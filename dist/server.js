// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@noble/hashes/_assert.js
var require__assert = __commonJS((exports) => {
  var number7 = function(n2) {
    if (!Number.isSafeInteger(n2) || n2 < 0)
      throw new Error(`Wrong positive integer: ${n2}`);
  };
  var bool = function(b3) {
    if (typeof b3 !== "boolean")
      throw new Error(`Expected boolean, not ${b3}`);
  };
  var isBytes = function(a2) {
    return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
  };
  var bytes2 = function(b3, ...lengths) {
    if (!isBytes(b3))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b3.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b3.length}`);
  };
  var hash7 = function(hash8) {
    if (typeof hash8 !== "function" || typeof hash8.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number7(hash8.outputLen);
    number7(hash8.blockLen);
  };
  var exists = function(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  };
  var output = function(out, instance) {
    bytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = undefined;
  exports.number = number7;
  exports.bool = bool;
  exports.bytes = bytes2;
  exports.hash = hash7;
  exports.exists = exists;
  exports.output = output;
  var assert = { number: number7, bool, bytes: bytes2, hash: hash7, exists, output };
  exports.default = assert;
});

// node_modules/@noble/hashes/_u64.js
var require__u64 = __commonJS((exports) => {
  var fromBig = function(n2, le = false) {
    if (le)
      return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
    return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
  };
  var split = function(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0;i < lst.length; i++) {
      const { h: h2, l: l2 } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h2, l2];
    }
    return [Ah, Al];
  };
  var add = function(Ah, Al, Bh, Bl) {
    const l2 = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l2 / 2 ** 32 | 0) | 0, l: l2 | 0 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = undefined;
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  exports.fromBig = fromBig;
  exports.split = split;
  var toBig = (h2, l2) => BigInt(h2 >>> 0) << _32n | BigInt(l2 >>> 0);
  exports.toBig = toBig;
  var shrSH = (h2, _l, s2) => h2 >>> s2;
  exports.shrSH = shrSH;
  var shrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
  exports.shrSL = shrSL;
  var rotrSH = (h2, l2, s2) => h2 >>> s2 | l2 << 32 - s2;
  exports.rotrSH = rotrSH;
  var rotrSL = (h2, l2, s2) => h2 << 32 - s2 | l2 >>> s2;
  exports.rotrSL = rotrSL;
  var rotrBH = (h2, l2, s2) => h2 << 64 - s2 | l2 >>> s2 - 32;
  exports.rotrBH = rotrBH;
  var rotrBL = (h2, l2, s2) => h2 >>> s2 - 32 | l2 << 64 - s2;
  exports.rotrBL = rotrBL;
  var rotr32H = (_h, l2) => l2;
  exports.rotr32H = rotr32H;
  var rotr32L = (h2, _l) => h2;
  exports.rotr32L = rotr32L;
  var rotlSH = (h2, l2, s2) => h2 << s2 | l2 >>> 32 - s2;
  exports.rotlSH = rotlSH;
  var rotlSL = (h2, l2, s2) => l2 << s2 | h2 >>> 32 - s2;
  exports.rotlSL = rotlSL;
  var rotlBH = (h2, l2, s2) => l2 << s2 - 32 | h2 >>> 64 - s2;
  exports.rotlBH = rotlBH;
  var rotlBL = (h2, l2, s2) => h2 << s2 - 32 | l2 >>> 64 - s2;
  exports.rotlBL = rotlBL;
  exports.add = add;
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  exports.add3L = add3L;
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  exports.add3H = add3H;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  exports.add4L = add4L;
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  exports.add4H = add4H;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  exports.add5L = add5L;
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  exports.add5H = add5H;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  exports.default = u64;
});

// node_modules/@noble/hashes/cryptoNode.js
var require_cryptoNode = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.crypto = undefined;
  var nc = import.meta.require("crypto");
  exports.crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS((exports) => {
  var isBytes = function(a2) {
    return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
  };
  var bytesToHex = function(bytes2) {
    if (!isBytes(bytes2))
      throw new Error("Uint8Array expected");
    let hex = "";
    for (let i = 0;i < bytes2.length; i++) {
      hex += hexes[bytes2[i]];
    }
    return hex;
  };
  var asciiToBase16 = function(char) {
    if (char >= asciis._0 && char <= asciis._9)
      return char - asciis._0;
    if (char >= asciis._A && char <= asciis._F)
      return char - (asciis._A - 10);
    if (char >= asciis._a && char <= asciis._f)
      return char - (asciis._a - 10);
    return;
  };
  var hexToBytes = function(hex) {
    if (typeof hex !== "string")
      throw new Error("hex string expected, got " + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2)
      throw new Error("padded hex string expected, got unpadded hex of length " + hl);
    const array5 = new Uint8Array(al);
    for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
      const n12 = asciiToBase16(hex.charCodeAt(hi));
      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
      if (n12 === undefined || n2 === undefined) {
        const char = hex[hi] + hex[hi + 1];
        throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
      }
      array5[ai] = n12 * 16 + n2;
    }
    return array5;
  };
  async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for (let i = 0;i < iters; i++) {
      cb(i);
      const diff = Date.now() - ts;
      if (diff >= 0 && diff < tick)
        continue;
      await (0, exports.nextTick)();
      ts += diff;
    }
  }
  var utf8ToBytes = function(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  };
  var toBytes = function(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!isBytes(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  };
  var concatBytes = function(...arrays) {
    let sum = 0;
    for (let i = 0;i < arrays.length; i++) {
      const a2 = arrays[i];
      if (!isBytes(a2))
        throw new Error("Uint8Array expected");
      sum += a2.length;
    }
    const res = new Uint8Array(sum);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const a2 = arrays[i];
      res.set(a2, pad);
      pad += a2.length;
    }
    return res;
  };
  var checkOpts = function(defaults, opts) {
    if (opts !== undefined && toStr.call(opts) !== "[object Object]")
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults, opts);
    return merged;
  };
  var wrapConstructor = function(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  };
  var wrapConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var wrapXOFConstructorWithOpts = function(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  };
  var randomBytes = function(bytesLength = 32) {
    if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
      return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
    }
    throw new Error("crypto.getRandomValues must be defined");
  };
  /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = undefined;
  var crypto_1 = require_cryptoNode();
  var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.u8 = u8;
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  exports.u32 = u32;
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  exports.createView = createView;
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  exports.rotr = rotr;
  exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!exports.isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
  exports.bytesToHex = bytesToHex;
  var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
  exports.hexToBytes = hexToBytes;
  var nextTick = async () => {
  };
  exports.nextTick = nextTick;
  exports.asyncLoop = asyncLoop;
  exports.utf8ToBytes = utf8ToBytes;
  exports.toBytes = toBytes;
  exports.concatBytes = concatBytes;

  class Hash3 {
    clone() {
      return this._cloneInto();
    }
  }
  exports.Hash = Hash3;
  var toStr = {}.toString;
  exports.checkOpts = checkOpts;
  exports.wrapConstructor = wrapConstructor;
  exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
  exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
  exports.randomBytes = randomBytes;
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS((exports) => {
  var keccakP = function(s2, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds;round < 24; round++) {
      for (let x = 0;x < 10; x++)
        B[x] = s2[x] ^ s2[x + 10] ^ s2[x + 20] ^ s2[x + 30] ^ s2[x + 40];
      for (let x = 0;x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B02 = B[idx0];
        const B12 = B[idx0 + 1];
        const Th = rotlH(B02, B12, 1) ^ B[idx1];
        const Tl = rotlL(B02, B12, 1) ^ B[idx1 + 1];
        for (let y2 = 0;y2 < 50; y2 += 10) {
          s2[x + y2] ^= Th;
          s2[x + y2 + 1] ^= Tl;
        }
      }
      let curH = s2[2];
      let curL = s2[3];
      for (let t = 0;t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s2[PI];
        curL = s2[PI + 1];
        s2[PI] = Th;
        s2[PI + 1] = Tl;
      }
      for (let y2 = 0;y2 < 50; y2 += 10) {
        for (let x = 0;x < 10; x++)
          B[x] = s2[y2 + x];
        for (let x = 0;x < 10; x++)
          s2[y2 + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s2[0] ^= SHA3_IOTA_H[round];
      s2[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = undefined;
  var _assert_js_1 = require__assert();
  var _u64_js_1 = require__u64();
  var utils_js_1 = require_utils();
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y2 = 0;round < 24; round++) {
    [x, y2] = [y2, (2 * x + 3 * y2) % 5];
    SHA3_PI.push(2 * (5 * y2 + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0;j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
  var rotlH = (h2, l2, s2) => s2 > 32 ? (0, _u64_js_1.rotlBH)(h2, l2, s2) : (0, _u64_js_1.rotlSH)(h2, l2, s2);
  var rotlL = (h2, l2, s2) => s2 > 32 ? (0, _u64_js_1.rotlBL)(h2, l2, s2) : (0, _u64_js_1.rotlSL)(h2, l2, s2);
  exports.keccakP = keccakP;

  class Keccak extends utils_js_1.Hash {
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      (0, _assert_js_1.number)(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = (0, utils_js_1.u32)(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      (0, _assert_js_1.exists)(this);
      const { blockLen, state } = this;
      data = (0, utils_js_1.toBytes)(data);
      const len = data.length;
      for (let pos = 0;pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0;i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      (0, _assert_js_1.exists)(this, false);
      (0, _assert_js_1.bytes)(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length;pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes2) {
      (0, _assert_js_1.number)(bytes2);
      return this.xofInto(new Uint8Array(bytes2));
    }
    digestInto(out) {
      (0, _assert_js_1.output)(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  }
  exports.Keccak = Keccak;
  var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
  exports.sha3_224 = gen(6, 144, 224 / 8);
  exports.sha3_256 = gen(6, 136, 256 / 8);
  exports.sha3_384 = gen(6, 104, 384 / 8);
  exports.sha3_512 = gen(6, 72, 512 / 8);
  exports.keccak_224 = gen(1, 144, 224 / 8);
  exports.keccak_256 = gen(1, 136, 256 / 8);
  exports.keccak_384 = gen(1, 104, 384 / 8);
  exports.keccak_512 = gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
  exports.shake128 = genShake(31, 168, 128 / 8);
  exports.shake256 = genShake(31, 136, 256 / 8);
});

// node_modules/@paralleldrive/cuid2/src/index.js
var require_src = __commonJS((exports, module) => {
  var bufToBigInt = function(buf) {
    let bits = 8n;
    let value15 = 0n;
    for (const i of buf.values()) {
      const bi = BigInt(i);
      value15 = (value15 << bits) + bi;
    }
    return value15;
  };
  var { sha3_512: sha3 } = require_sha3();
  var defaultLength = 24;
  var bigLength = 32;
  var createEntropy = (length = 4, random = Math.random) => {
    let entropy = "";
    while (entropy.length < length) {
      entropy = entropy + Math.floor(random() * 36).toString(36);
    }
    return entropy;
  };
  var hash7 = (input = "") => {
    return bufToBigInt(sha3(input)).toString(36).slice(1);
  };
  var alphabet = Array.from({ length: 26 }, (x, i) => String.fromCharCode(i + 97));
  var randomLetter = (random) => alphabet[Math.floor(random() * alphabet.length)];
  var createFingerprint = ({
    globalObj = typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : {},
    random = Math.random
  } = {}) => {
    const globals = Object.keys(globalObj).toString();
    const sourceString = globals.length ? globals + createEntropy(bigLength, random) : createEntropy(bigLength, random);
    return hash7(sourceString).substring(0, bigLength);
  };
  var createCounter = (count) => () => {
    return count++;
  };
  var initialCountMax = 476782367;
  var init = ({
    random = Math.random,
    counter = createCounter(Math.floor(random() * initialCountMax)),
    length = defaultLength,
    fingerprint = createFingerprint({ random })
  } = {}) => {
    return function cuid2() {
      const firstLetter = randomLetter(random);
      const time = Date.now().toString(36);
      const count = counter().toString(36);
      const salt = createEntropy(length, random);
      const hashInput = `${time + salt + count + fingerprint}`;
      return `${firstLetter + hash7(hashInput).substring(1, length)}`;
    };
  };
  var createId = init();
  var isCuid = (id, { minLength = 2, maxLength = bigLength } = {}) => {
    const length = id.length;
    const regex = /^[0-9a-z]+$/;
    try {
      if (typeof id === "string" && length >= minLength && length <= maxLength && regex.test(id))
        return true;
    } finally {
    }
    return false;
  };
  exports.getConstants = () => ({ defaultLength, bigLength });
  exports.init = init;
  exports.createId = createId;
  exports.bufToBigInt = bufToBigInt;
  exports.createCounter = createCounter;
  exports.createFingerprint = createFingerprint;
  exports.isCuid = isCuid;
});

// node_modules/@ioredis/commands/built/commands.json
var require_commands = __commonJS((exports, module) => {
  module.exports = {
    acl: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    append: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    asking: {
      arity: 1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    auth: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgrewriteaof: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgsave: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bitcount: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield_ro: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitop: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 2,
      keyStop: -1,
      step: 1
    },
    bitpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    blmove: {
      arity: 6,
      flags: [
        "write",
        "denyoom",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    blmpop: {
      arity: -5,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    blpop: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpop: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpoplpush: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    bzmpop: {
      arity: -5,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bzpopmax: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    bzpopmin: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    client: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    cluster: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    command: {
      arity: -1,
      flags: [
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    config: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    copy: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    dbsize: {
      arity: 1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    debug: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    decr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    decrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    del: {
      arity: -2,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    discard: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    dump: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    echo: {
      arity: 2,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    eval: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    eval_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    evalsha: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    evalsha_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exec: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "skip_slowlog"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exists: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    expire: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    expireat: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    expiretime: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    failover: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    fcall: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    fcall_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushall: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushdb: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    function: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    geoadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geodist: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geohash: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geopos: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius: {
      arity: -6,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius_ro: {
      arity: -6,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember_ro: {
      arity: -5,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearch: {
      arity: -7,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearchstore: {
      arity: -8,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    get: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getbit: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getdel: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getex: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getset: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hello: {
      arity: -1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    hexists: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hget: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hgetall: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrbyfloat: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hkeys: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmget: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hrandfield: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hsetnx: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hstrlen: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hvals: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrbyfloat: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    info: {
      arity: -1,
      flags: [
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    keys: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lastsave: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    latency: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lcs: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    lindex: {
      arity: 3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    linsert: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    llen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lmove: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    lmpop: {
      arity: -4,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lolwut: {
      arity: -1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrem: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lset: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    ltrim: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    memory: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    mget: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    migrate: {
      arity: -6,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 3,
      keyStop: 3,
      step: 1
    },
    module: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    monitor: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    move: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    mset: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    msetnx: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    multi: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    object: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    persist: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpire: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpireat: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpiretime: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfadd: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfcount: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfdebug: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "admin"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    pfmerge: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfselftest: {
      arity: 1,
      flags: [
        "admin"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    ping: {
      arity: -1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psetex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    psubscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psync: {
      arity: -3,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pttl: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    publish: {
      arity: 3,
      flags: [
        "pubsub",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pubsub: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    punsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    quit: {
      arity: -1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    randomkey: {
      arity: 1,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readonly: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readwrite: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rename: {
      arity: 3,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    renamenx: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    replconf: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    replicaof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    reset: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    restore: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    "restore-asking": {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "asking"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    role: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpoplpush: {
      arity: 3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    rpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sadd: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    save: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scan: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    script: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sdiff: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sdiffstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    select: {
      arity: 2,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    set: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setbit: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setnx: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setrange: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    shutdown: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale",
        "no_multi",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sinter: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sintercard: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sinterstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sismember: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    slaveof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    slowlog: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    smembers: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smismember: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smove: {
      arity: 4,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    sort: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sort_ro: {
      arity: -2,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    spop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    spublish: {
      arity: 3,
      flags: [
        "pubsub",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srandmember: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    ssubscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    strlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    subscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    substr: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sunion: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sunionstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sunsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    swapdb: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sync: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    time: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    touch: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    ttl: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    type: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    unlink: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    unsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    unwatch: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    wait: {
      arity: 3,
      flags: [
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    watch: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    xack: {
      arity: -4,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xautoclaim: {
      arity: -6,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xclaim: {
      arity: -6,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xgroup: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xinfo: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xpending: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xread: {
      arity: -4,
      flags: [
        "readonly",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xreadgroup: {
      arity: -7,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xsetid: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xtrim: {
      arity: -4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zadd: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zdiff: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zdiffstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zinter: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zintercard: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zinterstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zlexcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zmpop: {
      arity: -4,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zmscore: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmax: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmin: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrandmember: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangestore: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    zrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebylex: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyrank: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyscore: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscore: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zunion: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zunionstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    }
  };
});

// node_modules/@ioredis/commands/built/index.js
var require_built = __commonJS((exports) => {
  var exists2 = function(commandName) {
    return Boolean(commands_json_1.default[commandName]);
  };
  var hasFlag = function(commandName, flag) {
    if (!flags[commandName]) {
      throw new Error("Unknown command " + commandName);
    }
    return Boolean(flags[commandName][flag]);
  };
  var getKeyIndexes = function(commandName, args, options) {
    const command = commands_json_1.default[commandName];
    if (!command) {
      throw new Error("Unknown command " + commandName);
    }
    if (!Array.isArray(args)) {
      throw new Error("Expect args to be an array");
    }
    const keys = [];
    const parseExternalKey = Boolean(options && options.parseExternalKey);
    const takeDynamicKeys = (args2, startIndex) => {
      const keys2 = [];
      const keyStop = Number(args2[startIndex]);
      for (let i = 0;i < keyStop; i++) {
        keys2.push(i + startIndex + 1);
      }
      return keys2;
    };
    const takeKeyAfterToken = (args2, startIndex, token) => {
      for (let i = startIndex;i < args2.length - 1; i += 1) {
        if (String(args2[i]).toLowerCase() === token.toLowerCase()) {
          return i + 1;
        }
      }
      return null;
    };
    switch (commandName) {
      case "zunionstore":
      case "zinterstore":
      case "zdiffstore":
        keys.push(0, ...takeDynamicKeys(args, 1));
        break;
      case "eval":
      case "evalsha":
      case "eval_ro":
      case "evalsha_ro":
      case "fcall":
      case "fcall_ro":
      case "blmpop":
      case "bzmpop":
        keys.push(...takeDynamicKeys(args, 1));
        break;
      case "sintercard":
      case "lmpop":
      case "zunion":
      case "zinter":
      case "zmpop":
      case "zintercard":
      case "zdiff": {
        keys.push(...takeDynamicKeys(args, 0));
        break;
      }
      case "georadius": {
        keys.push(0);
        const storeKey = takeKeyAfterToken(args, 5, "STORE");
        if (storeKey)
          keys.push(storeKey);
        const distKey = takeKeyAfterToken(args, 5, "STOREDIST");
        if (distKey)
          keys.push(distKey);
        break;
      }
      case "georadiusbymember": {
        keys.push(0);
        const storeKey = takeKeyAfterToken(args, 4, "STORE");
        if (storeKey)
          keys.push(storeKey);
        const distKey = takeKeyAfterToken(args, 4, "STOREDIST");
        if (distKey)
          keys.push(distKey);
        break;
      }
      case "sort":
      case "sort_ro":
        keys.push(0);
        for (let i = 1;i < args.length - 1; i++) {
          let arg = args[i];
          if (typeof arg !== "string") {
            continue;
          }
          const directive = arg.toUpperCase();
          if (directive === "GET") {
            i += 1;
            arg = args[i];
            if (arg !== "#") {
              if (parseExternalKey) {
                keys.push([i, getExternalKeyNameLength(arg)]);
              } else {
                keys.push(i);
              }
            }
          } else if (directive === "BY") {
            i += 1;
            if (parseExternalKey) {
              keys.push([i, getExternalKeyNameLength(args[i])]);
            } else {
              keys.push(i);
            }
          } else if (directive === "STORE") {
            i += 1;
            keys.push(i);
          }
        }
        break;
      case "migrate":
        if (args[2] === "") {
          for (let i = 5;i < args.length - 1; i++) {
            const arg = args[i];
            if (typeof arg === "string" && arg.toUpperCase() === "KEYS") {
              for (let j = i + 1;j < args.length; j++) {
                keys.push(j);
              }
              break;
            }
          }
        } else {
          keys.push(2);
        }
        break;
      case "xreadgroup":
      case "xread":
        for (let i = commandName === "xread" ? 0 : 3;i < args.length - 1; i++) {
          if (String(args[i]).toUpperCase() === "STREAMS") {
            for (let j = i + 1;j <= i + (args.length - 1 - i) / 2; j++) {
              keys.push(j);
            }
            break;
          }
        }
        break;
      default:
        if (command.step > 0) {
          const keyStart = command.keyStart - 1;
          const keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
          for (let i = keyStart;i < keyStop; i += command.step) {
            keys.push(i);
          }
        }
        break;
    }
    return keys;
  };
  var getExternalKeyNameLength = function(key) {
    if (typeof key !== "string") {
      key = String(key);
    }
    const hashPos = key.indexOf("->");
    return hashPos === -1 ? key.length : hashPos;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getKeyIndexes = exports.hasFlag = exports.exists = exports.list = undefined;
  var commands_json_1 = __importDefault(require_commands());
  exports.list = Object.keys(commands_json_1.default);
  var flags = {};
  exports.list.forEach((commandName) => {
    flags[commandName] = commands_json_1.default[commandName].flags.reduce(function(flags2, flag) {
      flags2[flag] = true;
      return flags2;
    }, {});
  });
  exports.exists = exists2;
  exports.hasFlag = hasFlag;
  exports.getKeyIndexes = getKeyIndexes;
});

// node_modules/standard-as-callback/built/utils.js
var require_utils2 = __commonJS((exports) => {
  var tryCatcher = function(err, val) {
    try {
      const target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e2) {
      exports.errorObj.e = e2;
      return exports.errorObj;
    }
  };
  var tryCatch = function(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tryCatch = exports.errorObj = undefined;
  exports.errorObj = { e: {} };
  var tryCatchTarget;
  exports.tryCatch = tryCatch;
});

// node_modules/standard-as-callback/built/index.js
var require_built2 = __commonJS((exports) => {
  var throwLater = function(e2) {
    setTimeout(function() {
      throw e2;
    }, 0);
  };
  var asCallback = function(promise5, nodeback, options) {
    if (typeof nodeback === "function") {
      promise5.then((val) => {
        let ret;
        if (options !== undefined && Object(options).spread && Array.isArray(val)) {
          ret = utils_1.tryCatch(nodeback).apply(undefined, [null].concat(val));
        } else {
          ret = val === undefined ? utils_1.tryCatch(nodeback)(null) : utils_1.tryCatch(nodeback)(null, val);
        }
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      }, (cause) => {
        if (!cause) {
          const newReason = new Error(cause + "");
          Object.assign(newReason, { cause });
          cause = newReason;
        }
        const ret = utils_1.tryCatch(nodeback)(cause);
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      });
    }
    return promise5;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  exports.default = asCallback;
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS((exports, module) => {
  var RedisError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var ParserError = function(message, buffer2, offset) {
    assert(buffer2);
    assert.strictEqual(typeof offset, "number");
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
    this.offset = offset;
    this.buffer = buffer2;
  };
  var ReplyError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
  };
  var AbortError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var InterruptError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var assert = import.meta.require("assert");
  var util2 = import.meta.require("util");
  util2.inherits(RedisError, Error);
  Object.defineProperty(RedisError.prototype, "name", {
    value: "RedisError",
    configurable: true,
    writable: true
  });
  util2.inherits(ParserError, RedisError);
  Object.defineProperty(ParserError.prototype, "name", {
    value: "ParserError",
    configurable: true,
    writable: true
  });
  util2.inherits(ReplyError, RedisError);
  Object.defineProperty(ReplyError.prototype, "name", {
    value: "ReplyError",
    configurable: true,
    writable: true
  });
  util2.inherits(AbortError, RedisError);
  Object.defineProperty(AbortError.prototype, "name", {
    value: "AbortError",
    configurable: true,
    writable: true
  });
  util2.inherits(InterruptError, AbortError);
  Object.defineProperty(InterruptError.prototype, "name", {
    value: "InterruptError",
    configurable: true,
    writable: true
  });
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");

  class RedisError extends Error {
    get name() {
      return this.constructor.name;
    }
  }

  class ParserError extends RedisError {
    constructor(message, buffer2, offset) {
      assert(buffer2);
      assert.strictEqual(typeof offset, "number");
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer2;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class ReplyError extends RedisError {
    constructor(message) {
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message);
      Error.stackTraceLimit = tmp;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class AbortError extends RedisError {
    get name() {
      return this.constructor.name;
    }
  }

  class InterruptError extends AbortError {
    get name() {
      return this.constructor.name;
    }
  }
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS((exports, module) => {
  var Errors4 = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
  module.exports = Errors4;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p2 = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p2++] = char;
      } else if (char < 2048) {
        utf8[p2++] = char >> 6 | 192;
        utf8[p2++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p2++] = char >> 18 | 240;
        utf8[p2++] = char >> 12 & 63 | 128;
        utf8[p2++] = char >> 6 & 63 | 128;
        utf8[p2++] = char & 63 | 128;
      } else {
        utf8[p2++] = char >> 12 | 224;
        utf8[p2++] = char >> 6 & 63 | 128;
        utf8[p2++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate3 = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result2 = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result2 = lookup[(char ^ result2 >> 8) & 255] ^ result2 << 8;
    }
    return result2 & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate3(keys[0]);
    while (i < len) {
      if (generate3(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS((exports, module) => {
  var apply = function(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  };
  var baseTimes = function(n2, iteratee) {
    var index = -1, result2 = Array(n2);
    while (++index < n2) {
      result2[index] = iteratee(index);
    }
    return result2;
  };
  var arrayLikeKeys = function(value15, inherited) {
    var result2 = isArray(value15) || isArguments(value15) ? baseTimes(value15.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value15) {
      if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  };
  var assignInDefaults = function(objValue, srcValue, key, object13) {
    if (objValue === undefined || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object13, key)) {
      return srcValue;
    }
    return objValue;
  };
  var assignValue = function(object13, key, value15) {
    var objValue = object13[key];
    if (!(hasOwnProperty.call(object13, key) && eq2(objValue, value15)) || value15 === undefined && !(key in object13)) {
      object13[key] = value15;
    }
  };
  var baseKeysIn = function(object13) {
    if (!isObject(object13)) {
      return nativeKeysIn(object13);
    }
    var isProto = isPrototype(object13), result2 = [];
    for (var key in object13) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object13, key)))) {
        result2.push(key);
      }
    }
    return result2;
  };
  var baseRest = function(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array6 = Array(length);
      while (++index < length) {
        array6[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array6;
      return apply(func, this, otherArgs);
    };
  };
  var copyObject = function(source, props, object13, customizer) {
    object13 || (object13 = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined;
      assignValue(object13, key, newValue === undefined ? source[key] : newValue);
    }
    return object13;
  };
  var createAssigner = function(assigner) {
    return baseRest(function(object13, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard22 = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object13 = Object(object13);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object13, source, index, customizer);
        }
      }
      return object13;
    });
  };
  var isIndex = function(value15, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value15 == "number" || reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
  };
  var isIterateeCall = function(value15, index, object13) {
    if (!isObject(object13)) {
      return false;
    }
    var type75 = typeof index;
    if (type75 == "number" ? isArrayLike(object13) && isIndex(index, object13.length) : type75 == "string" && (index in object13)) {
      return eq2(object13[index], value15);
    }
    return false;
  };
  var isPrototype = function(value15) {
    var Ctor = value15 && value15.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value15 === proto;
  };
  var nativeKeysIn = function(object13) {
    var result2 = [];
    if (object13 != null) {
      for (var key in Object(object13)) {
        result2.push(key);
      }
    }
    return result2;
  };
  var eq2 = function(value15, other) {
    return value15 === other || value15 !== value15 && other !== other;
  };
  var isArguments = function(value15) {
    return isArrayLikeObject(value15) && hasOwnProperty.call(value15, "callee") && (!propertyIsEnumerable.call(value15, "callee") || objectToString.call(value15) == argsTag);
  };
  var isArrayLike = function(value15) {
    return value15 != null && isLength(value15.length) && !isFunction(value15);
  };
  var isArrayLikeObject = function(value15) {
    return isObjectLike(value15) && isArrayLike(value15);
  };
  var isFunction = function(value15) {
    var tag = isObject(value15) ? objectToString.call(value15) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value15) {
    return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value15) {
    var type75 = typeof value15;
    return !!value15 && (type75 == "object" || type75 == "function");
  };
  var isObjectLike = function(value15) {
    return !!value15 && typeof value15 == "object";
  };
  var keysIn = function(object13) {
    return isArrayLike(object13) ? arrayLikeKeys(object13, true) : baseKeysIn(object13);
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  var isArray = Array.isArray;
  var assignInWith = createAssigner(function(object13, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object13, customizer);
  });
  var defaults = baseRest(function(args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
  });
  module.exports = defaults;
});

// node_modules/lodash.isarguments/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var isArguments = function(value15) {
    return isArrayLikeObject(value15) && hasOwnProperty.call(value15, "callee") && (!propertyIsEnumerable.call(value15, "callee") || objectToString.call(value15) == argsTag);
  };
  var isArrayLike = function(value15) {
    return value15 != null && isLength(value15.length) && !isFunction(value15);
  };
  var isArrayLikeObject = function(value15) {
    return isObjectLike(value15) && isArrayLike(value15);
  };
  var isFunction = function(value15) {
    var tag = isObject(value15) ? objectToString.call(value15) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value15) {
    return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value15) {
    var type75 = typeof value15;
    return !!value15 && (type75 == "object" || type75 == "function");
  };
  var isObjectLike = function(value15) {
    return !!value15 && typeof value15 == "object";
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  module.exports = isArguments;
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash3 = __commonJS((exports) => {
  var noop3 = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArguments = exports.defaults = exports.noop = undefined;
  var defaults = require_lodash();
  exports.defaults = defaults;
  var isArguments = require_lodash2();
  exports.isArguments = isArguments;
  exports.noop = noop3;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse5 = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n2 = parseFloat(match[1]);
    var type75 = (match[2] || "ms").toLowerCase();
    switch (type75) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n2 * y2;
      case "weeks":
      case "week":
      case "w":
        return n2 * w;
      case "days":
      case "day":
      case "d":
        return n2 * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n2 * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n2 * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n2 * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n2;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return Math.round(ms / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms / s2) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d2) {
      return plural(ms, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural(ms, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural(ms, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural(ms, msAbs, s2, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n2, name) {
    var isPlural = msAbs >= n2 * 1.5;
    return Math.round(ms / n2) + " " + name + (isPlural ? "s" : "");
  };
  var s2 = 1000;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w = d2 * 7;
  var y2 = d2 * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type75 = typeof val;
    if (type75 === "string" && val.length > 0) {
      return parse5(val);
    } else if (type75 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env3) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env3).forEach((key) => {
      createDebug[key] = env3[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash7 = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash7 = (hash7 << 5) - hash7 + namespace.charCodeAt(i);
        hash7 |= 0;
      }
      return createDebug.colors[Math.abs(hash7) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v2) => {
          enableOverride = v2;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp4) {
      return regexp4.toString().substring(2, regexp4.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c2 = "color: " + this.color;
    args.splice(1, 0, c2, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c2);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error22) {
    }
  };
  var load = function() {
    let r2;
    try {
      r2 = exports.storage.getItem("debug");
    } catch (error22) {
    }
    if (!r2 && typeof process !== "undefined" && "env" in process) {
      r2 = process.env.DEBUG;
    }
    return r2;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error22) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v2) {
    try {
      return JSON.stringify(v2);
    } catch (error22) {
      return "[UnexpectedJSONParseError]: " + error22.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env3.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os2.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env3) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env3)) || env3.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env3) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env3.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env3.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env3) {
      const version3 = parseInt((env3.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env3.TERM_PROGRAM) {
        case "iTerm.app":
          return version3 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env3.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env3.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env3) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  };
  var os2 = import.meta.require("os");
  var tty = import.meta.require("tty");
  var hasFlag = require_has_flag();
  var { env: env3 } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env3) {
    if (env3.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env3.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env3.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env3.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c2 = this.color;
      const colorCode = "\x1B[3" + (c2 < 8 ? c2 : "8;5;" + c2);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util2.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init2 = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = import.meta.require("tty");
  var util2 = import.meta.require("util");
  exports.init = init2;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error22) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v2) {
    this.inspectOpts.colors = this.useColors;
    return util2.inspect(v2, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src2 = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS((exports) => {
  var getStringValue = function(v2) {
    if (v2 === null) {
      return;
    }
    switch (typeof v2) {
      case "boolean":
        return;
      case "number":
        return;
      case "object":
        if (Buffer.isBuffer(v2)) {
          return v2.toString("hex");
        }
        if (Array.isArray(v2)) {
          return v2.join(",");
        }
        try {
          return JSON.stringify(v2);
        } catch (e2) {
          return;
        }
      case "string":
        return v2;
    }
  };
  var genRedactedString = function(str, maxLen) {
    const { length } = str;
    return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
  };
  var genDebugFunction = function(namespace) {
    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);
    function wrappedDebug(...args) {
      if (!fn.enabled) {
        return;
      }
      for (let i = 1;i < args.length; i++) {
        const str = getStringValue(args[i]);
        if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
          args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
        }
      }
      return fn.apply(null, args);
    }
    Object.defineProperties(wrappedDebug, {
      namespace: {
        get() {
          return fn.namespace;
        }
      },
      enabled: {
        get() {
          return fn.enabled;
        }
      },
      destroy: {
        get() {
          return fn.destroy;
        }
      },
      log: {
        get() {
          return fn.log;
        },
        set(l2) {
          fn.log = l2;
        }
      }
    });
    return wrappedDebug;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = undefined;
  var debug_1 = require_src2();
  var MAX_ARGUMENT_LENGTH = 200;
  exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
  var NAMESPACE_PREFIX = "ioredis";
  exports.getStringValue = getStringValue;
  exports.genRedactedString = genRedactedString;
  exports.default = genDebugFunction;
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var RedisCloudCA = `-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP
JnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz
rmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E
QwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2
BDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3
TMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp
4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w
MB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w
DQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta
lbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6
Su8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ
uFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k
BpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp
Z4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx
CzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w
KwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN
MTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG
A1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy
bWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA
A4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv
Tq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4
VuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym
hjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W
P0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN
r0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw
hhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s
UzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u
P1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9
MjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT
t5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID
AQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy
LnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw
AYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G
A1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4
L2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB
hjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr
AP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW
vcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw
7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+
XoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc
AUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1
jQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh
/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z
zDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli
iF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43
iqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo
616pxqo=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz
TGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y
aXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC
VVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz
MS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1
G5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY
Dm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl
pp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT
ULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag
54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ
xeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC
JpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K
2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3
StsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI
SIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B
cS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL
yzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T
AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg
z5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu
rYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3
3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+
hSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ
D0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj
TY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l
FXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj
mcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf
ybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji
n8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F
UhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM
MSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv
YmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y
NTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu
IG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy
MDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf
8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD
BVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg
ofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK
dZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh
counQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu
jE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG
CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW
BBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj
move4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw
Mi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1
cmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w
K6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD
VR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC
AQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/
3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY
0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX
y+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3
15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5
ZgKnO/Fx2hBgTxhOTMYaD312kg==
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----`;
  var TLSProfiles = {
    RedisCloudFixed: { ca: RedisCloudCA },
    RedisCloudFlexible: { ca: RedisCloudCA }
  };
  exports.default = TLSProfiles;
});

// node_modules/ioredis/built/utils/index.js
var require_utils3 = __commonJS((exports) => {
  var convertBufferToString = function(value15, encoding) {
    if (value15 instanceof Buffer) {
      return value15.toString(encoding);
    }
    if (Array.isArray(value15)) {
      const length = value15.length;
      const res = Array(length);
      for (let i = 0;i < length; ++i) {
        res[i] = value15[i] instanceof Buffer && encoding === "utf8" ? value15[i].toString() : convertBufferToString(value15[i], encoding);
      }
      return res;
    }
    return value15;
  };
  var wrapMultiResult = function(arr) {
    if (!arr) {
      return null;
    }
    const result2 = [];
    const length = arr.length;
    for (let i = 0;i < length; ++i) {
      const item = arr[i];
      if (item instanceof Error) {
        result2.push([item]);
      } else {
        result2.push([null, item]);
      }
    }
    return result2;
  };
  var isInt = function(value15) {
    const x = parseFloat(value15);
    return !isNaN(value15) && (x | 0) === x;
  };
  var packObject = function(array6) {
    const result2 = {};
    const length = array6.length;
    for (let i = 1;i < length; i += 2) {
      result2[array6[i - 1]] = array6[i];
    }
    return result2;
  };
  var timeout = function(callback, timeout2) {
    let timer2 = null;
    const run = function() {
      if (timer2) {
        clearTimeout(timer2);
        timer2 = null;
        callback.apply(this, arguments);
      }
    };
    timer2 = setTimeout(run, timeout2, new Error("timeout"));
    return run;
  };
  var convertObjectToArray = function(obj) {
    const result2 = [];
    const keys = Object.keys(obj);
    for (let i = 0, l2 = keys.length;i < l2; i++) {
      result2.push(keys[i], obj[keys[i]]);
    }
    return result2;
  };
  var convertMapToArray = function(map3) {
    const result2 = [];
    let pos = 0;
    map3.forEach(function(value15, key) {
      result2[pos] = key;
      result2[pos + 1] = value15;
      pos += 2;
    });
    return result2;
  };
  var toArg = function(arg) {
    if (arg === null || typeof arg === "undefined") {
      return "";
    }
    return String(arg);
  };
  var optimizeErrorStack = function(error22, friendlyStack, filterPath) {
    const stacks = friendlyStack.split("\n");
    let lines = "";
    let i;
    for (i = 1;i < stacks.length; ++i) {
      if (stacks[i].indexOf(filterPath) === -1) {
        break;
      }
    }
    for (let j = i;j < stacks.length; ++j) {
      lines += "\n" + stacks[j];
    }
    if (error22.stack) {
      const pos = error22.stack.indexOf("\n");
      error22.stack = error22.stack.slice(0, pos) + lines;
    }
    return error22;
  };
  var parseURL = function(url) {
    if (isInt(url)) {
      return { port: url };
    }
    let parsed = (0, url_1.parse)(url, true, true);
    if (!parsed.slashes && url[0] !== "/") {
      url = "//" + url;
      parsed = (0, url_1.parse)(url, true, true);
    }
    const options = parsed.query || {};
    const result2 = {};
    if (parsed.auth) {
      const index = parsed.auth.indexOf(":");
      result2.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
      result2.password = index === -1 ? "" : parsed.auth.slice(index + 1);
    }
    if (parsed.pathname) {
      if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
        if (parsed.pathname.length > 1) {
          result2.db = parsed.pathname.slice(1);
        }
      } else {
        result2.path = parsed.pathname;
      }
    }
    if (parsed.host) {
      result2.host = parsed.hostname;
    }
    if (parsed.port) {
      result2.port = parsed.port;
    }
    if (typeof options.family === "string") {
      const intFamily = Number.parseInt(options.family, 10);
      if (!Number.isNaN(intFamily)) {
        result2.family = intFamily;
      }
    }
    (0, lodash_1.defaults)(result2, options);
    return result2;
  };
  var resolveTLSProfile = function(options) {
    let tls2 = options === null || options === undefined ? undefined : options.tls;
    if (typeof tls2 === "string")
      tls2 = { profile: tls2 };
    const profile = TLSProfiles_1.default[tls2 === null || tls2 === undefined ? undefined : tls2.profile];
    if (profile) {
      tls2 = Object.assign({}, profile, tls2);
      delete tls2.profile;
      options = Object.assign({}, options, { tls: tls2 });
    }
    return options;
  };
  var sample = function(array6, from = 0) {
    const length = array6.length;
    if (from >= length) {
      return null;
    }
    return array6[from + Math.floor(Math.random() * (length - from))];
  };
  var shuffle = function(array6) {
    let counter = array6.length;
    while (counter > 0) {
      const index = Math.floor(Math.random() * counter);
      counter--;
      [array6[counter], array6[index]] = [array6[index], array6[counter]];
    }
    return array6;
  };
  var zipMap = function(keys, values2) {
    const map3 = new Map;
    keys.forEach((key, index) => {
      map3.set(key, values2[index]);
    });
    return map3;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = undefined;
  var url_1 = import.meta.require("url");
  var lodash_1 = require_lodash3();
  Object.defineProperty(exports, "defaults", { enumerable: true, get: function() {
    return lodash_1.defaults;
  } });
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return lodash_1.noop;
  } });
  var debug_1 = require_debug();
  exports.Debug = debug_1.default;
  var TLSProfiles_1 = require_TLSProfiles();
  exports.convertBufferToString = convertBufferToString;
  exports.wrapMultiResult = wrapMultiResult;
  exports.isInt = isInt;
  exports.packObject = packObject;
  exports.timeout = timeout;
  exports.convertObjectToArray = convertObjectToArray;
  exports.convertMapToArray = convertMapToArray;
  exports.toArg = toArg;
  exports.optimizeErrorStack = optimizeErrorStack;
  exports.parseURL = parseURL;
  exports.resolveTLSProfile = resolveTLSProfile;
  exports.sample = sample;
  exports.shuffle = shuffle;
  exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
  exports.zipMap = zipMap;
});

// node_modules/ioredis/built/Command.js
var require_Command = __commonJS((exports) => {
  var __dirname = "/home/jeffsilva01/www/pizzashop-api/node_modules/ioredis/built";
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built2();
  var utils_1 = require_utils3();

  class Command {
    constructor(name, args = [], options = {}, callback) {
      this.name = name;
      this.inTransaction = false;
      this.isResolved = false;
      this.transformed = false;
      this.replyEncoding = options.replyEncoding;
      this.errorStack = options.errorStack;
      this.args = args.flat();
      this.callback = callback;
      this.initPromise();
      if (options.keyPrefix) {
        const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;
        let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;
        this._iterateKeys((key) => {
          if (key instanceof Buffer) {
            if (keyPrefixBuffer === null) {
              keyPrefixBuffer = Buffer.from(options.keyPrefix);
            }
            return Buffer.concat([keyPrefixBuffer, key]);
          } else if (isBufferKeyPrefix) {
            return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);
          }
          return options.keyPrefix + key;
        });
      }
      if (options.readOnly) {
        this.isReadOnly = true;
      }
    }
    static checkFlag(flagName, commandName) {
      return !!this.getFlagMap()[flagName][commandName];
    }
    static setArgumentTransformer(name, func) {
      this._transformer.argument[name] = func;
    }
    static setReplyTransformer(name, func) {
      this._transformer.reply[name] = func;
    }
    static getFlagMap() {
      if (!this.flagMap) {
        this.flagMap = Object.keys(Command.FLAGS).reduce((map3, flagName) => {
          map3[flagName] = {};
          Command.FLAGS[flagName].forEach((commandName) => {
            map3[flagName][commandName] = true;
          });
          return map3;
        }, {});
      }
      return this.flagMap;
    }
    getSlot() {
      if (typeof this.slot === "undefined") {
        const key = this.getKeys()[0];
        this.slot = key == null ? null : calculateSlot(key);
      }
      return this.slot;
    }
    getKeys() {
      return this._iterateKeys();
    }
    toWritable(_socket) {
      let result2;
      const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
      if (this.bufferMode) {
        const buffers = new MixedBuffers;
        buffers.push(commandStr);
        for (let i = 0;i < this.args.length; ++i) {
          const arg = this.args[i];
          if (arg instanceof Buffer) {
            if (arg.length === 0) {
              buffers.push("$0\r\n\r\n");
            } else {
              buffers.push("$" + arg.length + "\r\n");
              buffers.push(arg);
              buffers.push("\r\n");
            }
          } else {
            buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
          }
        }
        result2 = buffers.toBuffer();
      } else {
        result2 = commandStr;
        for (let i = 0;i < this.args.length; ++i) {
          const arg = this.args[i];
          result2 += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
        }
      }
      return result2;
    }
    stringifyArguments() {
      for (let i = 0;i < this.args.length; ++i) {
        const arg = this.args[i];
        if (typeof arg === "string") {
        } else if (arg instanceof Buffer) {
          this.bufferMode = true;
        } else {
          this.args[i] = (0, utils_1.toArg)(arg);
        }
      }
    }
    transformReply(result2) {
      if (this.replyEncoding) {
        result2 = (0, utils_1.convertBufferToString)(result2, this.replyEncoding);
      }
      const transformer = Command._transformer.reply[this.name];
      if (transformer) {
        result2 = transformer(result2);
      }
      return result2;
    }
    setTimeout(ms) {
      if (!this._commandTimeoutTimer) {
        this._commandTimeoutTimer = setTimeout(() => {
          if (!this.isResolved) {
            this.reject(new Error("Command timed out"));
          }
        }, ms);
      }
    }
    initPromise() {
      const promise5 = new Promise((resolve, reject) => {
        if (!this.transformed) {
          this.transformed = true;
          const transformer = Command._transformer.argument[this.name];
          if (transformer) {
            this.args = transformer(this.args);
          }
          this.stringifyArguments();
        }
        this.resolve = this._convertValue(resolve);
        if (this.errorStack) {
          this.reject = (err) => {
            reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));
          };
        } else {
          this.reject = reject;
        }
      });
      this.promise = (0, standard_as_callback_1.default)(promise5, this.callback);
    }
    _iterateKeys(transform7 = (key) => key) {
      if (typeof this.keys === "undefined") {
        this.keys = [];
        if ((0, commands_1.exists)(this.name)) {
          const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);
          for (const index of keyIndexes) {
            this.args[index] = transform7(this.args[index]);
            this.keys.push(this.args[index]);
          }
        }
      }
      return this.keys;
    }
    _convertValue(resolve) {
      return (value15) => {
        try {
          const existingTimer = this._commandTimeoutTimer;
          if (existingTimer) {
            clearTimeout(existingTimer);
            delete this._commandTimeoutTimer;
          }
          resolve(this.transformReply(value15));
          this.isResolved = true;
        } catch (err) {
          this.reject(err);
        }
        return this.promise;
      };
    }
  }
  exports.default = Command;
  Command.FLAGS = {
    VALID_IN_SUBSCRIBER_MODE: [
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "punsubscribe",
      "ssubscribe",
      "sunsubscribe",
      "ping",
      "quit"
    ],
    VALID_IN_MONITOR_MODE: ["monitor", "auth"],
    ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe", "ssubscribe"],
    EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe", "sunsubscribe"],
    WILL_DISCONNECT: ["quit"]
  };
  Command._transformer = {
    argument: {},
    reply: {}
  };
  var msetArgumentTransformer = function(args) {
    if (args.length === 1) {
      if (args[0] instanceof Map) {
        return (0, utils_1.convertMapToArray)(args[0]);
      }
      if (typeof args[0] === "object" && args[0] !== null) {
        return (0, utils_1.convertObjectToArray)(args[0]);
      }
    }
    return args;
  };
  var hsetArgumentTransformer = function(args) {
    if (args.length === 2) {
      if (args[1] instanceof Map) {
        return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));
      }
      if (typeof args[1] === "object" && args[1] !== null) {
        return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));
      }
    }
    return args;
  };
  Command.setArgumentTransformer("mset", msetArgumentTransformer);
  Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
  Command.setArgumentTransformer("hset", hsetArgumentTransformer);
  Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
  Command.setReplyTransformer("hgetall", function(result2) {
    if (Array.isArray(result2)) {
      const obj = {};
      for (let i = 0;i < result2.length; i += 2) {
        const key = result2[i];
        const value15 = result2[i + 1];
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value15,
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          obj[key] = value15;
        }
      }
      return obj;
    }
    return result2;
  });

  class MixedBuffers {
    constructor() {
      this.length = 0;
      this.items = [];
    }
    push(x) {
      this.length += Buffer.byteLength(x);
      this.items.push(x);
    }
    toBuffer() {
      const result2 = Buffer.allocUnsafe(this.length);
      let offset = 0;
      for (const item of this.items) {
        const length = Buffer.byteLength(item);
        Buffer.isBuffer(item) ? item.copy(result2, offset) : result2.write(item, offset, length);
        offset += length;
      }
      return result2;
    }
  }
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class ClusterAllFailedError extends redis_errors_1.RedisError {
    constructor(message, lastNodeError) {
      super(message);
      this.lastNodeError = lastNodeError;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = ClusterAllFailedError;
  ClusterAllFailedError.defaultMessage = "Failed to refresh slots cache.";
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = import.meta.require("stream");

  class ScanStream extends stream_1.Readable {
    constructor(opt) {
      super(opt);
      this.opt = opt;
      this._redisCursor = "0";
      this._redisDrained = false;
    }
    _read() {
      if (this._redisDrained) {
        this.push(null);
        return;
      }
      const args = [this._redisCursor];
      if (this.opt.key) {
        args.unshift(this.opt.key);
      }
      if (this.opt.match) {
        args.push("MATCH", this.opt.match);
      }
      if (this.opt.type) {
        args.push("TYPE", this.opt.type);
      }
      if (this.opt.count) {
        args.push("COUNT", String(this.opt.count));
      }
      this.opt.redis[this.opt.command](args, (err, res) => {
        if (err) {
          this.emit("error", err);
          return;
        }
        this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
        if (this._redisCursor === "0") {
          this._redisDrained = true;
        }
        this.push(res[1]);
      });
    }
    close() {
      this._redisDrained = true;
    }
  }
  exports.default = ScanStream;
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS((exports) => {
  var executeAutoPipeline = function(client, slotKey) {
    if (client._runningAutoPipelines.has(slotKey)) {
      return;
    }
    if (!client._autoPipelines.has(slotKey)) {
      return;
    }
    client._runningAutoPipelines.add(slotKey);
    const pipeline = client._autoPipelines.get(slotKey);
    client._autoPipelines.delete(slotKey);
    const callbacks = pipeline[exports.kCallbacks];
    pipeline[exports.kCallbacks] = null;
    pipeline.exec(function(err, results) {
      client._runningAutoPipelines.delete(slotKey);
      if (err) {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], err);
        }
      } else {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], ...results[i]);
        }
      }
      if (client._autoPipelines.has(slotKey)) {
        executeAutoPipeline(client, slotKey);
      }
    });
  };
  var shouldUseAutoPipelining = function(client, functionName, commandName) {
    return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
  };
  var getFirstValueInFlattenedArray = function(args) {
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        return arg;
      } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {
        if (arg.length === 0) {
          continue;
        }
        return arg[0];
      }
      const flattened = [arg].flat();
      if (flattened.length > 0) {
        return flattened[0];
      }
    }
    return;
  };
  var executeWithAutoPipelining = function(client, functionName, commandName, args, callback) {
    if (client.isCluster && !client.slots.length) {
      if (client.status === "wait")
        client.connect().catch(lodash_1.noop);
      return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
        client.delayUntilReady((err) => {
          if (err) {
            reject(err);
            return;
          }
          executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);
        });
      }), callback);
    }
    const prefix = client.options.keyPrefix || "";
    const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",") : "main";
    if (!client._autoPipelines.has(slotKey)) {
      const pipeline2 = client.pipeline();
      pipeline2[exports.kExec] = false;
      pipeline2[exports.kCallbacks] = [];
      client._autoPipelines.set(slotKey, pipeline2);
    }
    const pipeline = client._autoPipelines.get(slotKey);
    if (!pipeline[exports.kExec]) {
      pipeline[exports.kExec] = true;
      setImmediate(executeAutoPipeline, client, slotKey);
    }
    const autoPipelinePromise = new Promise(function(resolve, reject) {
      pipeline[exports.kCallbacks].push(function(err, value15) {
        if (err) {
          reject(err);
          return;
        }
        resolve(value15);
      });
      if (functionName === "call") {
        args.unshift(commandName);
      }
      pipeline[functionName](...args);
    });
    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = undefined;
  var lodash_1 = require_lodash3();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built2();
  exports.kExec = Symbol("exec");
  exports.kCallbacks = Symbol("callbacks");
  exports.notAllowedAutoPipelineCommands = [
    "auth",
    "info",
    "script",
    "quit",
    "cluster",
    "pipeline",
    "multi",
    "subscribe",
    "psubscribe",
    "unsubscribe",
    "unpsubscribe",
    "select"
  ];
  exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
  exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
  exports.executeWithAutoPipelining = executeWithAutoPipelining;
});

// node_modules/ioredis/built/Script.js
var require_Script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = import.meta.require("crypto");
  var Command_1 = require_Command();
  var standard_as_callback_1 = require_built2();

  class Script {
    constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
      this.lua = lua;
      this.numberOfKeys = numberOfKeys;
      this.keyPrefix = keyPrefix;
      this.readOnly = readOnly;
      this.sha = (0, crypto_1.createHash)("sha1").update(lua).digest("hex");
      const sha = this.sha;
      const socketHasScriptLoaded = new WeakSet;
      this.Command = class CustomScriptCommand extends Command_1.default {
        toWritable(socket) {
          const origReject = this.reject;
          this.reject = (err) => {
            if (err.message.indexOf("NOSCRIPT") !== -1) {
              socketHasScriptLoaded.delete(socket);
            }
            origReject.call(this, err);
          };
          if (!socketHasScriptLoaded.has(socket)) {
            socketHasScriptLoaded.add(socket);
            this.name = "eval";
            this.args[0] = lua;
          } else if (this.name === "eval") {
            this.name = "evalsha";
            this.args[0] = sha;
          }
          return super.toWritable(socket);
        }
      };
    }
    execute(container, args, options, callback) {
      if (typeof this.numberOfKeys === "number") {
        args.unshift(this.numberOfKeys);
      }
      if (this.keyPrefix) {
        options.keyPrefix = this.keyPrefix;
      }
      if (this.readOnly) {
        options.readOnly = true;
      }
      const evalsha = new this.Command("evalsha", [this.sha, ...args], options);
      evalsha.promise = evalsha.promise.catch((err) => {
        if (err.message.indexOf("NOSCRIPT") === -1) {
          throw err;
        }
        const resend = new this.Command("evalsha", [this.sha, ...args], options);
        const client = container.isPipeline ? container.redis : container;
        return client.sendCommand(resend);
      });
      (0, standard_as_callback_1.default)(evalsha.promise, callback);
      return container.sendCommand(evalsha);
    }
  }
  exports.default = Script;
});

// node_modules/ioredis/built/utils/Commander.js
var require_Commander = __commonJS((exports) => {
  var generateFunction = function(functionName, _commandName, _encoding) {
    if (typeof _encoding === "undefined") {
      _encoding = _commandName;
      _commandName = null;
    }
    return function(...args) {
      const commandName = _commandName || args.shift();
      let callback = args[args.length - 1];
      if (typeof callback === "function") {
        args.pop();
      } else {
        callback = undefined;
      }
      const options = {
        errorStack: this.options.showFriendlyErrorStack ? new Error : undefined,
        keyPrefix: this.options.keyPrefix,
        replyEncoding: _encoding
      };
      if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
        return this.sendCommand(new Command_1.default(commandName, args, options, callback));
      }
      return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);
    };
  };
  var generateScriptingFunction = function(functionName, commandName, script, encoding) {
    return function(...args) {
      const callback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
      const options = {
        replyEncoding: encoding
      };
      if (this.options.showFriendlyErrorStack) {
        options.errorStack = new Error;
      }
      if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
        return script.execute(this, args, options, callback);
      }
      return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var autoPipelining_1 = require_autoPipelining();
  var Command_1 = require_Command();
  var Script_1 = require_Script();

  class Commander {
    constructor() {
      this.options = {};
      this.scriptsSet = {};
      this.addedBuiltinSet = new Set;
    }
    getBuiltinCommands() {
      return commands.slice(0);
    }
    createBuiltinCommand(commandName) {
      return {
        string: generateFunction(null, commandName, "utf8"),
        buffer: generateFunction(null, commandName, null)
      };
    }
    addBuiltinCommand(commandName) {
      this.addedBuiltinSet.add(commandName);
      this[commandName] = generateFunction(commandName, commandName, "utf8");
      this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
    }
    defineCommand(name, definition) {
      const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
      this.scriptsSet[name] = script;
      this[name] = generateScriptingFunction(name, name, script, "utf8");
      this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
    }
    sendCommand(command, stream, node) {
      throw new Error('"sendCommand" is not implemented');
    }
  }
  var commands = commands_1.list.filter((command) => command !== "monitor");
  commands.push("sentinel");
  commands.forEach(function(commandName) {
    Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
    Commander.prototype[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
  });
  Commander.prototype.call = generateFunction("call", "utf8");
  Commander.prototype.callBuffer = generateFunction("callBuffer", null);
  Commander.prototype.send_command = Commander.prototype.call;
  exports.default = Commander;
});

// node_modules/ioredis/built/Pipeline.js
var require_Pipeline = __commonJS((exports) => {
  var generateMultiWithNodes = function(redis, keys) {
    const slot = calculateSlot(keys[0]);
    const target = redis._groupsBySlot[slot];
    for (let i = 1;i < keys.length; i++) {
      if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {
        return -1;
      }
    }
    return slot;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var calculateSlot = require_lib();
  var commands_1 = require_built();
  var standard_as_callback_1 = require_built2();
  var util_1 = import.meta.require("util");
  var Command_1 = require_Command();
  var utils_1 = require_utils3();
  var Commander_1 = require_Commander();

  class Pipeline extends Commander_1.default {
    constructor(redis) {
      super();
      this.redis = redis;
      this.isPipeline = true;
      this.replyPending = 0;
      this._queue = [];
      this._result = [];
      this._transactions = 0;
      this._shaToScript = {};
      this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
      this.options = redis.options;
      Object.keys(redis.scriptsSet).forEach((name) => {
        const script = redis.scriptsSet[name];
        this._shaToScript[script.sha] = script;
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      redis.addedBuiltinSet.forEach((name) => {
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      const _this = this;
      Object.defineProperty(this, "length", {
        get: function() {
          return _this._queue.length;
        }
      });
    }
    fillResult(value15, position) {
      if (this._queue[position].name === "exec" && Array.isArray(value15[1])) {
        const execLength = value15[1].length;
        for (let i = 0;i < execLength; i++) {
          if (value15[1][i] instanceof Error) {
            continue;
          }
          const cmd = this._queue[position - (execLength - i)];
          try {
            value15[1][i] = cmd.transformReply(value15[1][i]);
          } catch (err) {
            value15[1][i] = err;
          }
        }
      }
      this._result[position] = value15;
      if (--this.replyPending) {
        return;
      }
      if (this.isCluster) {
        let retriable = true;
        let commonError;
        for (let i = 0;i < this._result.length; ++i) {
          const error22 = this._result[i][0];
          const command = this._queue[i];
          if (error22) {
            if (command.name === "exec" && error22.message === "EXECABORT Transaction discarded because of previous errors.") {
              continue;
            }
            if (!commonError) {
              commonError = {
                name: error22.name,
                message: error22.message
              };
            } else if (commonError.name !== error22.name || commonError.message !== error22.message) {
              retriable = false;
              break;
            }
          } else if (!command.inTransaction) {
            const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
            if (!isReadOnly) {
              retriable = false;
              break;
            }
          }
        }
        if (commonError && retriable) {
          const _this = this;
          const errv = commonError.message.split(" ");
          const queue3 = this._queue;
          let inTransaction = false;
          this._queue = [];
          for (let i = 0;i < queue3.length; ++i) {
            if (errv[0] === "ASK" && !inTransaction && queue3[i].name !== "asking" && (!queue3[i - 1] || queue3[i - 1].name !== "asking")) {
              const asking = new Command_1.default("asking");
              asking.ignore = true;
              this.sendCommand(asking);
            }
            queue3[i].initPromise();
            this.sendCommand(queue3[i]);
            inTransaction = queue3[i].inTransaction;
          }
          let matched = true;
          if (typeof this.leftRedirections === "undefined") {
            this.leftRedirections = {};
          }
          const exec = function() {
            _this.exec();
          };
          const cluster = this.redis;
          cluster.handleError(commonError, this.leftRedirections, {
            moved: function(_slot, key) {
              _this.preferKey = key;
              cluster.slots[errv[1]] = [key];
              cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(";")];
              cluster.refreshSlotsCache();
              _this.exec();
            },
            ask: function(_slot, key) {
              _this.preferKey = key;
              _this.exec();
            },
            tryagain: exec,
            clusterDown: exec,
            connectionClosed: exec,
            maxRedirections: () => {
              matched = false;
            },
            defaults: () => {
              matched = false;
            }
          });
          if (matched) {
            return;
          }
        }
      }
      let ignoredCount = 0;
      for (let i = 0;i < this._queue.length - ignoredCount; ++i) {
        if (this._queue[i + ignoredCount].ignore) {
          ignoredCount += 1;
        }
        this._result[i] = this._result[i + ignoredCount];
      }
      this.resolve(this._result.slice(0, this._result.length - ignoredCount));
    }
    sendCommand(command) {
      if (this._transactions > 0) {
        command.inTransaction = true;
      }
      const position = this._queue.length;
      command.pipelineIndex = position;
      command.promise.then((result2) => {
        this.fillResult([null, result2], position);
      }).catch((error22) => {
        this.fillResult([error22], position);
      });
      this._queue.push(command);
      return this;
    }
    addBatch(commands) {
      let command, commandName, args;
      for (let i = 0;i < commands.length; ++i) {
        command = commands[i];
        commandName = command[0];
        args = command.slice(1);
        this[commandName].apply(this, args);
      }
      return this;
    }
  }
  exports.default = Pipeline;
  var multi = Pipeline.prototype.multi;
  Pipeline.prototype.multi = function() {
    this._transactions += 1;
    return multi.apply(this, arguments);
  };
  var execBuffer = Pipeline.prototype.execBuffer;
  Pipeline.prototype.execBuffer = (0, util_1.deprecate)(function() {
    if (this._transactions > 0) {
      this._transactions -= 1;
    }
    return execBuffer.apply(this, arguments);
  }, "Pipeline#execBuffer: Use Pipeline#exec instead");
  Pipeline.prototype.exec = function(callback) {
    if (this.isCluster && !this.redis.slots.length) {
      if (this.redis.status === "wait")
        this.redis.connect().catch(utils_1.noop);
      if (callback && !this.nodeifiedPromise) {
        this.nodeifiedPromise = true;
        (0, standard_as_callback_1.default)(this.promise, callback);
      }
      this.redis.delayUntilReady((err) => {
        if (err) {
          this.reject(err);
          return;
        }
        this.exec(callback);
      });
      return this.promise;
    }
    if (this._transactions > 0) {
      this._transactions -= 1;
      return execBuffer.apply(this, arguments);
    }
    if (!this.nodeifiedPromise) {
      this.nodeifiedPromise = true;
      (0, standard_as_callback_1.default)(this.promise, callback);
    }
    if (!this._queue.length) {
      this.resolve([]);
    }
    let pipelineSlot;
    if (this.isCluster) {
      const sampleKeys = [];
      for (let i = 0;i < this._queue.length; i++) {
        const keys = this._queue[i].getKeys();
        if (keys.length) {
          sampleKeys.push(keys[0]);
        }
        if (keys.length && calculateSlot.generateMulti(keys) < 0) {
          this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
          return this.promise;
        }
      }
      if (sampleKeys.length) {
        pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
        if (pipelineSlot < 0) {
          this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
          return this.promise;
        }
      } else {
        pipelineSlot = Math.random() * 16384 | 0;
      }
    }
    const _this = this;
    execPipeline();
    return this.promise;
    function execPipeline() {
      let writePending = _this.replyPending = _this._queue.length;
      let node;
      if (_this.isCluster) {
        node = {
          slot: pipelineSlot,
          redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
        };
      }
      let data = "";
      let buffers;
      const stream = {
        isPipeline: true,
        destination: _this.isCluster ? node : { redis: _this.redis },
        write(writable) {
          if (typeof writable !== "string") {
            if (!buffers) {
              buffers = [];
            }
            if (data) {
              buffers.push(Buffer.from(data, "utf8"));
              data = "";
            }
            buffers.push(writable);
          } else {
            data += writable;
          }
          if (!--writePending) {
            if (buffers) {
              if (data) {
                buffers.push(Buffer.from(data, "utf8"));
              }
              stream.destination.redis.stream.write(Buffer.concat(buffers));
            } else {
              stream.destination.redis.stream.write(data);
            }
            writePending = _this._queue.length;
            data = "";
            buffers = undefined;
          }
        }
      };
      for (let i = 0;i < _this._queue.length; ++i) {
        _this.redis.sendCommand(_this._queue[i], stream, node);
      }
      return _this.promise;
    }
  };
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS((exports) => {
  var addTransactionSupport = function(redis) {
    redis.pipeline = function(commands) {
      const pipeline = new Pipeline_1.default(this);
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      return pipeline;
    };
    const { multi } = redis;
    redis.multi = function(commands, options) {
      if (typeof options === "undefined" && !Array.isArray(commands)) {
        options = commands;
        commands = null;
      }
      if (options && options.pipeline === false) {
        return multi.call(this);
      }
      const pipeline = new Pipeline_1.default(this);
      pipeline.multi();
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      const exec2 = pipeline.exec;
      pipeline.exec = function(callback) {
        if (this.isCluster && !this.redis.slots.length) {
          if (this.redis.status === "wait")
            this.redis.connect().catch(utils_1.noop);
          return (0, standard_as_callback_1.default)(new Promise((resolve, reject) => {
            this.redis.delayUntilReady((err) => {
              if (err) {
                reject(err);
                return;
              }
              this.exec(pipeline).then(resolve, reject);
            });
          }), callback);
        }
        if (this._transactions > 0) {
          exec2.call(pipeline);
        }
        if (this.nodeifiedPromise) {
          return exec2.call(pipeline);
        }
        const promise5 = exec2.call(pipeline);
        return (0, standard_as_callback_1.default)(promise5.then(function(result2) {
          const execResult = result2[result2.length - 1];
          if (typeof execResult === "undefined") {
            throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
          }
          if (execResult[0]) {
            execResult[0].previousErrors = [];
            for (let i = 0;i < result2.length - 1; ++i) {
              if (result2[i][0]) {
                execResult[0].previousErrors.push(result2[i][0]);
              }
            }
            throw execResult[0];
          }
          return (0, utils_1.wrapMultiResult)(execResult[1]);
        }), callback);
      };
      const { execBuffer } = pipeline;
      pipeline.execBuffer = function(callback) {
        if (this._transactions > 0) {
          execBuffer.call(pipeline);
        }
        return pipeline.exec(callback);
      };
      return pipeline;
    };
    const { exec } = redis;
    redis.exec = function(callback) {
      return (0, standard_as_callback_1.default)(exec.call(this).then(function(results) {
        if (Array.isArray(results)) {
          results = (0, utils_1.wrapMultiResult)(results);
        }
        return results;
      }), callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addTransactionSupport = undefined;
  var utils_1 = require_utils3();
  var standard_as_callback_1 = require_built2();
  var Pipeline_1 = require_Pipeline();
  exports.addTransactionSupport = addTransactionSupport;
});

// node_modules/ioredis/built/utils/applyMixin.js
var require_applyMixin = __commonJS((exports) => {
  var applyMixin = function(derivedConstructor, mixinConstructor) {
    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {
      Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = applyMixin;
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CLUSTER_OPTIONS = undefined;
  var dns_1 = import.meta.require("dns");
  exports.DEFAULT_CLUSTER_OPTIONS = {
    clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),
    enableOfflineQueue: true,
    enableReadyCheck: true,
    scaleReads: "master",
    maxRedirections: 16,
    retryDelayOnMoved: 0,
    retryDelayOnFailover: 100,
    retryDelayOnClusterDown: 100,
    retryDelayOnTryAgain: 100,
    slotsRefreshTimeout: 1000,
    useSRVRecords: false,
    resolveSrv: dns_1.resolveSrv,
    dnsLookup: dns_1.lookup,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: []
  };
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS((exports) => {
  var getNodeKey = function(node) {
    node.port = node.port || 6379;
    node.host = node.host || "127.0.0.1";
    return node.host + ":" + node.port;
  };
  var nodeKeyToRedisOptions = function(nodeKey) {
    const portIndex = nodeKey.lastIndexOf(":");
    if (portIndex === -1) {
      throw new Error(`Invalid node key ${nodeKey}`);
    }
    return {
      host: nodeKey.slice(0, portIndex),
      port: Number(nodeKey.slice(portIndex + 1))
    };
  };
  var normalizeNodeOptions = function(nodes) {
    return nodes.map((node) => {
      const options = {};
      if (typeof node === "object") {
        Object.assign(options, node);
      } else if (typeof node === "string") {
        Object.assign(options, (0, utils_1.parseURL)(node));
      } else if (typeof node === "number") {
        options.port = node;
      } else {
        throw new Error("Invalid argument " + node);
      }
      if (typeof options.port === "string") {
        options.port = parseInt(options.port, 10);
      }
      delete options.db;
      if (!options.port) {
        options.port = 6379;
      }
      if (!options.host) {
        options.host = "127.0.0.1";
      }
      return (0, utils_1.resolveTLSProfile)(options);
    });
  };
  var getUniqueHostnamesFromOptions = function(nodes) {
    const uniqueHostsMap = {};
    nodes.forEach((node) => {
      uniqueHostsMap[node.host] = true;
    });
    return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));
  };
  var groupSrvRecords = function(records) {
    const recordsByPriority = {};
    for (const record4 of records) {
      if (!recordsByPriority.hasOwnProperty(record4.priority)) {
        recordsByPriority[record4.priority] = {
          totalWeight: record4.weight,
          records: [record4]
        };
      } else {
        recordsByPriority[record4.priority].totalWeight += record4.weight;
        recordsByPriority[record4.priority].records.push(record4);
      }
    }
    return recordsByPriority;
  };
  var weightSrvRecords = function(recordsGroup) {
    if (recordsGroup.records.length === 1) {
      recordsGroup.totalWeight = 0;
      return recordsGroup.records.shift();
    }
    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
    let total = 0;
    for (const [i, record4] of recordsGroup.records.entries()) {
      total += 1 + record4.weight;
      if (total > random) {
        recordsGroup.totalWeight -= record4.weight;
        recordsGroup.records.splice(i, 1);
        return record4;
      }
    }
  };
  var getConnectionName = function(component, nodeConnectionName) {
    const prefix = `ioredis-cluster(${component})`;
    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = undefined;
  var utils_1 = require_utils3();
  var net_1 = import.meta.require("net");
  exports.getNodeKey = getNodeKey;
  exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
  exports.normalizeNodeOptions = normalizeNodeOptions;
  exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
  exports.groupSrvRecords = groupSrvRecords;
  exports.weightSrvRecords = weightSrvRecords;
  exports.getConnectionName = getConnectionName;
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var utils_1 = require_utils3();
  var Redis_1 = require_Redis();
  var debug = (0, utils_1.Debug)("cluster:subscriber");

  class ClusterSubscriber {
    constructor(connectionPool, emitter) {
      this.connectionPool = connectionPool;
      this.emitter = emitter;
      this.started = false;
      this.subscriber = null;
      this.onSubscriberEnd = () => {
        if (!this.started) {
          debug("subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.");
          return;
        }
        debug("subscriber has disconnected, selecting a new one...");
        this.selectSubscriber();
      };
      this.connectionPool.on("-node", (_, key) => {
        if (!this.started || !this.subscriber) {
          return;
        }
        if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {
          debug("subscriber has left, selecting a new one...");
          this.selectSubscriber();
        }
      });
      this.connectionPool.on("+node", () => {
        if (!this.started || this.subscriber) {
          return;
        }
        debug("a new node is discovered and there is no subscriber, selecting a new one...");
        this.selectSubscriber();
      });
    }
    getInstance() {
      return this.subscriber;
    }
    start() {
      this.started = true;
      this.selectSubscriber();
      debug("started");
    }
    stop() {
      this.started = false;
      if (this.subscriber) {
        this.subscriber.disconnect();
        this.subscriber = null;
      }
      debug("stopped");
    }
    selectSubscriber() {
      const lastActiveSubscriber = this.lastActiveSubscriber;
      if (lastActiveSubscriber) {
        lastActiveSubscriber.off("end", this.onSubscriberEnd);
        lastActiveSubscriber.disconnect();
      }
      if (this.subscriber) {
        this.subscriber.off("end", this.onSubscriberEnd);
        this.subscriber.disconnect();
      }
      const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());
      if (!sampleNode) {
        debug("selecting subscriber failed since there is no node discovered in the cluster yet");
        this.subscriber = null;
        return;
      }
      const { options } = sampleNode;
      debug("selected a subscriber %s:%s", options.host, options.port);
      this.subscriber = new Redis_1.default({
        port: options.port,
        host: options.host,
        username: options.username,
        password: options.password,
        enableReadyCheck: true,
        connectionName: (0, util_1.getConnectionName)("subscriber", options.connectionName),
        lazyConnect: true,
        tls: options.tls,
        retryStrategy: null
      });
      this.subscriber.on("error", utils_1.noop);
      this.subscriber.once("end", this.onSubscriberEnd);
      const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };
      if (lastActiveSubscriber) {
        const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
        if (condition && condition.subscriber) {
          previousChannels.subscribe = condition.subscriber.channels("subscribe");
          previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
          previousChannels.ssubscribe = condition.subscriber.channels("ssubscribe");
        }
      }
      if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {
        let pending = 0;
        for (const type75 of ["subscribe", "psubscribe", "ssubscribe"]) {
          const channels = previousChannels[type75];
          if (channels.length) {
            pending += 1;
            debug("%s %d channels", type75, channels.length);
            this.subscriber[type75](channels).then(() => {
              if (!--pending) {
                this.lastActiveSubscriber = this.subscriber;
              }
            }).catch(() => {
              debug("failed to %s %d channels", type75, channels.length);
            });
          }
        }
      } else {
        this.lastActiveSubscriber = this.subscriber;
      }
      for (const event of [
        "message",
        "messageBuffer",
        "smessage",
        "smessageBuffer"
      ]) {
        this.subscriber.on(event, (arg1, arg2) => {
          this.emitter.emit(event, arg1, arg2);
        });
      }
      for (const event of ["pmessage", "pmessageBuffer"]) {
        this.subscriber.on(event, (arg1, arg2, arg3) => {
          this.emitter.emit(event, arg1, arg2, arg3);
        });
      }
    }
  }
  exports.default = ClusterSubscriber;
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = import.meta.require("events");
  var utils_1 = require_utils3();
  var util_1 = require_util();
  var Redis_1 = require_Redis();
  var debug = (0, utils_1.Debug)("cluster:connectionPool");

  class ConnectionPool extends events_1.EventEmitter {
    constructor(redisOptions) {
      super();
      this.redisOptions = redisOptions;
      this.nodes = {
        all: {},
        master: {},
        slave: {}
      };
      this.specifiedOptions = {};
    }
    getNodes(role = "all") {
      const nodes = this.nodes[role];
      return Object.keys(nodes).map((key) => nodes[key]);
    }
    getInstanceByKey(key) {
      return this.nodes.all[key];
    }
    getSampleInstance(role) {
      const keys = Object.keys(this.nodes[role]);
      const sampleKey = (0, utils_1.sample)(keys);
      return this.nodes[role][sampleKey];
    }
    findOrCreate(node, readOnly = false) {
      const key = (0, util_1.getNodeKey)(node);
      readOnly = Boolean(readOnly);
      if (this.specifiedOptions[key]) {
        Object.assign(node, this.specifiedOptions[key]);
      } else {
        this.specifiedOptions[key] = node;
      }
      let redis;
      if (this.nodes.all[key]) {
        redis = this.nodes.all[key];
        if (redis.options.readOnly !== readOnly) {
          redis.options.readOnly = readOnly;
          debug("Change role of %s to %s", key, readOnly ? "slave" : "master");
          redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
          if (readOnly) {
            delete this.nodes.master[key];
            this.nodes.slave[key] = redis;
          } else {
            delete this.nodes.slave[key];
            this.nodes.master[key] = redis;
          }
        }
      } else {
        debug("Connecting to %s as %s", key, readOnly ? "slave" : "master");
        redis = new Redis_1.default((0, utils_1.defaults)({
          retryStrategy: null,
          enableOfflineQueue: true,
          readOnly
        }, node, this.redisOptions, { lazyConnect: true }));
        this.nodes.all[key] = redis;
        this.nodes[readOnly ? "slave" : "master"][key] = redis;
        redis.once("end", () => {
          this.removeNode(key);
          this.emit("-node", redis, key);
          if (!Object.keys(this.nodes.all).length) {
            this.emit("drain");
          }
        });
        this.emit("+node", redis, key);
        redis.on("error", function(error22) {
          this.emit("nodeError", error22, key);
        });
      }
      return redis;
    }
    reset(nodes) {
      debug("Reset with %O", nodes);
      const newNodes = {};
      nodes.forEach((node) => {
        const key = (0, util_1.getNodeKey)(node);
        if (!(node.readOnly && newNodes[key])) {
          newNodes[key] = node;
        }
      });
      Object.keys(this.nodes.all).forEach((key) => {
        if (!newNodes[key]) {
          debug("Disconnect %s because the node does not hold any slot", key);
          this.nodes.all[key].disconnect();
          this.removeNode(key);
        }
      });
      Object.keys(newNodes).forEach((key) => {
        const node = newNodes[key];
        this.findOrCreate(node, node.readOnly);
      });
    }
    removeNode(key) {
      const { nodes } = this;
      if (nodes.all[key]) {
        debug("Remove %s from the pool", key);
        delete nodes.all[key];
      }
      delete nodes.master[key];
      delete nodes.slave[key];
    }
  }
  exports.default = ConnectionPool;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports, module) => {
  var Denque = function(array6, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array6)) {
      this._fromArray(array6);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  };
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return;
    var item = this._list[head];
    this._list[head] = undefined;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = undefined;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size2 = this.size();
    var len = this._list.length;
    if (i >= size2 || i < -size2)
      return;
    if (i < 0)
      i += size2;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size2 / 2) {
      for (k = index;k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size2 - 1 - index;k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size2 = this.size();
    var len = this._list.length;
    if (i >= size2 || i < -size2 || count < 1)
      return;
    if (i < 0)
      i += size2;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size2) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size2)
      count = size2 - i;
    var k;
    removed = new Array(count);
    for (k = 0;k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size2) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (i < size2 / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index;k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size2 - (count + index);k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var size2 = this.size();
    if (i < 0)
      i += size2;
    if (i > size2)
      return;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size2 || i < size2 / 2) {
        temp = new Array(i);
        for (k = 0;k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i;k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size2 - (i + count));
        var leng = temp.length;
        for (k = 0;k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size2) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0;k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array6) {
    var length = array6.length;
    var capacity = this._nextPowerOf2(length);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length;
    for (var i = 0;i < length; i++)
      this._list[i] = array6[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size2) {
    var src = this._list;
    var capacity = src.length;
    var length = this.length;
    size2 = size2 | length;
    if (size2 == length && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size2);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head;i < capacity; i++)
        dest[k++] = src[i];
      for (i = 0;i < this._tail; i++)
        dest[k++] = src[i];
    } else {
      for (i = this._head;i < this._tail; i++)
        dest[k++] = src[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log2 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log2 + 1;
    return Math.max(nextPow2, 4);
  };
  module.exports = Denque;
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils3();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("delayqueue");

  class DelayQueue {
    constructor() {
      this.queues = {};
      this.timeouts = {};
    }
    push(bucket, item, options) {
      const callback = options.callback || process.nextTick;
      if (!this.queues[bucket]) {
        this.queues[bucket] = new Deque;
      }
      const queue3 = this.queues[bucket];
      queue3.push(item);
      if (!this.timeouts[bucket]) {
        this.timeouts[bucket] = setTimeout(() => {
          callback(() => {
            this.timeouts[bucket] = null;
            this.execute(bucket);
          });
        }, options.timeout);
      }
    }
    execute(bucket) {
      const queue3 = this.queues[bucket];
      if (!queue3) {
        return;
      }
      const { length } = queue3;
      if (!length) {
        return;
      }
      debug("send %d commands in %s queue", length, bucket);
      this.queues[bucket] = null;
      while (queue3.length > 0) {
        queue3.shift()();
      }
    }
  }
  exports.default = DelayQueue;
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var events_1 = import.meta.require("events");
  var redis_errors_1 = require_redis_errors();
  var standard_as_callback_1 = require_built2();
  var Command_1 = require_Command();
  var ClusterAllFailedError_1 = require_ClusterAllFailedError();
  var Redis_1 = require_Redis();
  var ScanStream_1 = require_ScanStream();
  var transaction_1 = require_transaction();
  var utils_1 = require_utils3();
  var applyMixin_1 = require_applyMixin();
  var Commander_1 = require_Commander();
  var ClusterOptions_1 = require_ClusterOptions();
  var ClusterSubscriber_1 = require_ClusterSubscriber();
  var ConnectionPool_1 = require_ConnectionPool();
  var DelayQueue_1 = require_DelayQueue();
  var util_1 = require_util();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("cluster");
  var REJECT_OVERWRITTEN_COMMANDS = new WeakSet;

  class Cluster extends Commander_1.default {
    constructor(startupNodes, options = {}) {
      super();
      this.slots = [];
      this._groupsIds = {};
      this._groupsBySlot = Array(16384);
      this.isCluster = true;
      this.retryAttempts = 0;
      this.delayQueue = new DelayQueue_1.default;
      this.offlineQueue = new Deque;
      this.isRefreshing = false;
      this._autoPipelines = new Map;
      this._runningAutoPipelines = new Set;
      this._readyDelayedCallbacks = [];
      this.connectionEpoch = 0;
      events_1.EventEmitter.call(this);
      this.startupNodes = startupNodes;
      this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
      if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {
        this.options.keyPrefix = this.options.redisOptions.keyPrefix;
      }
      if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
        throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
      }
      this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
      this.connectionPool.on("-node", (redis, key) => {
        this.emit("-node", redis);
      });
      this.connectionPool.on("+node", (redis) => {
        this.emit("+node", redis);
      });
      this.connectionPool.on("drain", () => {
        this.setStatus("close");
      });
      this.connectionPool.on("nodeError", (error22, key) => {
        this.emit("node error", error22, key);
      });
      this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
      if (this.options.scripts) {
        Object.entries(this.options.scripts).forEach(([name, definition]) => {
          this.defineCommand(name, definition);
        });
      }
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch((err) => {
          debug("connecting failed: %s", err);
        });
      }
    }
    connect() {
      return new Promise((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        const epoch = ++this.connectionEpoch;
        this.setStatus("connecting");
        this.resolveStartupNodeHostnames().then((nodes) => {
          if (this.connectionEpoch !== epoch) {
            debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch, this.connectionEpoch);
            reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
            return;
          }
          if (this.status !== "connecting") {
            debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
            reject(new redis_errors_1.RedisError("Connection is aborted"));
            return;
          }
          this.connectionPool.reset(nodes);
          const readyHandler = () => {
            this.setStatus("ready");
            this.retryAttempts = 0;
            this.executeOfflineCommands();
            this.resetNodesRefreshInterval();
            resolve();
          };
          let closeListener = undefined;
          const refreshListener = () => {
            this.invokeReadyDelayedCallbacks(undefined);
            this.removeListener("close", closeListener);
            this.manuallyClosing = false;
            this.setStatus("connect");
            if (this.options.enableReadyCheck) {
              this.readyCheck((err, fail) => {
                if (err || fail) {
                  debug("Ready check failed (%s). Reconnecting...", err || fail);
                  if (this.status === "connect") {
                    this.disconnect(true);
                  }
                } else {
                  readyHandler();
                }
              });
            } else {
              readyHandler();
            }
          };
          closeListener = () => {
            const error22 = new Error("None of startup nodes is available");
            this.removeListener("refresh", refreshListener);
            this.invokeReadyDelayedCallbacks(error22);
            reject(error22);
          };
          this.once("refresh", refreshListener);
          this.once("close", closeListener);
          this.once("close", this.handleCloseEvent.bind(this));
          this.refreshSlotsCache((err) => {
            if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {
              Redis_1.default.prototype.silentEmit.call(this, "error", err);
              this.connectionPool.reset([]);
            }
          });
          this.subscriber.start();
        }).catch((err) => {
          this.setStatus("close");
          this.handleCloseEvent(err);
          this.invokeReadyDelayedCallbacks(err);
          reject(err);
        });
      });
    }
    disconnect(reconnect = false) {
      const status = this.status;
      this.setStatus("disconnecting");
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
        debug("Canceled reconnecting attempts");
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      if (status === "wait") {
        this.setStatus("close");
        this.handleCloseEvent();
      } else {
        this.connectionPool.reset([]);
      }
    }
    quit(callback) {
      const status = this.status;
      this.setStatus("disconnecting");
      this.manuallyClosing = true;
      if (this.reconnectTimeout) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      if (status === "wait") {
        const ret = (0, standard_as_callback_1.default)(Promise.resolve("OK"), callback);
        setImmediate(function() {
          this.setStatus("close");
          this.handleCloseEvent();
        }.bind(this));
        return ret;
      }
      return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {
        if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {
          return "OK";
        }
        throw err;
      }))).then(() => "OK"), callback);
    }
    duplicate(overrideStartupNodes = [], overrideOptions = {}) {
      const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
      const options = Object.assign({}, this.options, overrideOptions);
      return new Cluster(startupNodes, options);
    }
    nodes(role = "all") {
      if (role !== "all" && role !== "master" && role !== "slave") {
        throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
      }
      return this.connectionPool.getNodes(role);
    }
    delayUntilReady(callback) {
      this._readyDelayedCallbacks.push(callback);
    }
    get autoPipelineQueueSize() {
      let queued = 0;
      for (const pipeline of this._autoPipelines.values()) {
        queued += pipeline.length;
      }
      return queued;
    }
    refreshSlotsCache(callback) {
      if (this.isRefreshing) {
        if (callback) {
          process.nextTick(callback);
        }
        return;
      }
      this.isRefreshing = true;
      const _this = this;
      const wrapper = (error22) => {
        this.isRefreshing = false;
        if (callback) {
          callback(error22);
        }
      };
      const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());
      let lastNodeError = null;
      function tryNode(index) {
        if (index === nodes.length) {
          const error22 = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);
          return wrapper(error22);
        }
        const node = nodes[index];
        const key = `${node.options.host}:${node.options.port}`;
        debug("getting slot cache from %s", key);
        _this.getInfoFromNode(node, function(err) {
          switch (_this.status) {
            case "close":
            case "end":
              return wrapper(new Error("Cluster is disconnected."));
            case "disconnecting":
              return wrapper(new Error("Cluster is disconnecting."));
          }
          if (err) {
            _this.emit("node error", err, key);
            lastNodeError = err;
            tryNode(index + 1);
          } else {
            _this.emit("refresh");
            wrapper();
          }
        });
      }
      tryNode(0);
    }
    sendCommand(command, stream, node) {
      if (this.status === "wait") {
        this.connect().catch(utils_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      let to = this.options.scaleReads;
      if (to !== "master") {
        const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
        if (!isCommandReadOnly) {
          to = "master";
        }
      }
      let targetSlot = node ? node.slot : command.getSlot();
      const ttl = {};
      const _this = this;
      if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {
        REJECT_OVERWRITTEN_COMMANDS.add(command);
        const reject = command.reject;
        command.reject = function(err) {
          const partialTry = tryConnection.bind(null, true);
          _this.handleError(err, ttl, {
            moved: function(slot, key) {
              debug("command %s is moved to %s", command.name, key);
              targetSlot = Number(slot);
              if (_this.slots[slot]) {
                _this.slots[slot][0] = key;
              } else {
                _this.slots[slot] = [key];
              }
              _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
              _this.connectionPool.findOrCreate(_this.natMapper(key));
              tryConnection();
              debug("refreshing slot caches... (triggered by MOVED error)");
              _this.refreshSlotsCache();
            },
            ask: function(slot, key) {
              debug("command %s is required to ask %s:%s", command.name, key);
              const mapped20 = _this.natMapper(key);
              _this.connectionPool.findOrCreate(mapped20);
              tryConnection(false, `${mapped20.host}:${mapped20.port}`);
            },
            tryagain: partialTry,
            clusterDown: partialTry,
            connectionClosed: partialTry,
            maxRedirections: function(redirectionError) {
              reject.call(command, redirectionError);
            },
            defaults: function() {
              reject.call(command, err);
            }
          });
        };
      }
      tryConnection();
      function tryConnection(random, asking) {
        if (_this.status === "end") {
          command.reject(new redis_errors_1.AbortError("Cluster is ended."));
          return;
        }
        let redis;
        if (_this.status === "ready" || command.name === "cluster") {
          if (node && node.redis) {
            redis = node.redis;
          } else if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) || Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)) {
            redis = _this.subscriber.getInstance();
            if (!redis) {
              command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
              return;
            }
          } else {
            if (!random) {
              if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                const nodeKeys = _this.slots[targetSlot];
                if (typeof to === "function") {
                  const nodes = nodeKeys.map(function(key) {
                    return _this.connectionPool.getInstanceByKey(key);
                  });
                  redis = to(nodes, command);
                  if (Array.isArray(redis)) {
                    redis = (0, utils_1.sample)(redis);
                  }
                  if (!redis) {
                    redis = nodes[0];
                  }
                } else {
                  let key;
                  if (to === "all") {
                    key = (0, utils_1.sample)(nodeKeys);
                  } else if (to === "slave" && nodeKeys.length > 1) {
                    key = (0, utils_1.sample)(nodeKeys, 1);
                  } else {
                    key = nodeKeys[0];
                  }
                  redis = _this.connectionPool.getInstanceByKey(key);
                }
              }
              if (asking) {
                redis = _this.connectionPool.getInstanceByKey(asking);
                redis.asking();
              }
            }
            if (!redis) {
              redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
            }
          }
          if (node && !node.redis) {
            node.redis = redis;
          }
        }
        if (redis) {
          redis.sendCommand(command, stream);
        } else if (_this.options.enableOfflineQueue) {
          _this.offlineQueue.push({
            command,
            stream,
            node
          });
        } else {
          command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
        }
      }
      return command.promise;
    }
    sscanStream(key, options) {
      return this.createScanStream("sscan", { key, options });
    }
    sscanBufferStream(key, options) {
      return this.createScanStream("sscanBuffer", { key, options });
    }
    hscanStream(key, options) {
      return this.createScanStream("hscan", { key, options });
    }
    hscanBufferStream(key, options) {
      return this.createScanStream("hscanBuffer", { key, options });
    }
    zscanStream(key, options) {
      return this.createScanStream("zscan", { key, options });
    }
    zscanBufferStream(key, options) {
      return this.createScanStream("zscanBuffer", { key, options });
    }
    handleError(error22, ttl, handlers) {
      if (typeof ttl.value === "undefined") {
        ttl.value = this.options.maxRedirections;
      } else {
        ttl.value -= 1;
      }
      if (ttl.value <= 0) {
        handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error22));
        return;
      }
      const errv = error22.message.split(" ");
      if (errv[0] === "MOVED") {
        const timeout = this.options.retryDelayOnMoved;
        if (timeout && typeof timeout === "number") {
          this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
        } else {
          handlers.moved(errv[1], errv[2]);
        }
      } else if (errv[0] === "ASK") {
        handlers.ask(errv[1], errv[2]);
      } else if (errv[0] === "TRYAGAIN") {
        this.delayQueue.push("tryagain", handlers.tryagain, {
          timeout: this.options.retryDelayOnTryAgain
        });
      } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
        this.delayQueue.push("clusterdown", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnClusterDown,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else if (error22.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
        this.delayQueue.push("failover", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnFailover,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else {
        handlers.defaults();
      }
    }
    resetOfflineQueue() {
      this.offlineQueue = new Deque;
    }
    clearNodesRefreshInterval() {
      if (this.slotsTimer) {
        clearTimeout(this.slotsTimer);
        this.slotsTimer = null;
      }
    }
    resetNodesRefreshInterval() {
      if (this.slotsTimer || !this.options.slotsRefreshInterval) {
        return;
      }
      const nextRound = () => {
        this.slotsTimer = setTimeout(() => {
          debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
          this.refreshSlotsCache(() => {
            nextRound();
          });
        }, this.options.slotsRefreshInterval);
      };
      nextRound();
    }
    setStatus(status) {
      debug("status: %s -> %s", this.status || "[empty]", status);
      this.status = status;
      process.nextTick(() => {
        this.emit(status);
      });
    }
    handleCloseEvent(reason) {
      if (reason) {
        debug("closed because %s", reason);
      }
      let retryDelay;
      if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
        retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
      }
      if (typeof retryDelay === "number") {
        this.setStatus("reconnecting");
        this.reconnectTimeout = setTimeout(() => {
          this.reconnectTimeout = null;
          debug("Cluster is disconnected. Retrying after %dms", retryDelay);
          this.connect().catch(function(err) {
            debug("Got error %s when reconnecting. Ignoring...", err);
          });
        }, retryDelay);
      } else {
        this.setStatus("end");
        this.flushQueue(new Error("None of startup nodes is available"));
      }
    }
    flushQueue(error22) {
      let item;
      while (item = this.offlineQueue.shift()) {
        item.command.reject(error22);
      }
    }
    executeOfflineCommands() {
      if (this.offlineQueue.length) {
        debug("send %d commands in offline queue", this.offlineQueue.length);
        const offlineQueue = this.offlineQueue;
        this.resetOfflineQueue();
        let item;
        while (item = offlineQueue.shift()) {
          this.sendCommand(item.command, item.stream, item.node);
        }
      }
    }
    natMapper(nodeKey) {
      if (this.options.natMap && typeof this.options.natMap === "object") {
        const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
        const mapped20 = this.options.natMap[key];
        if (mapped20) {
          debug("NAT mapping %s -> %O", key, mapped20);
          return Object.assign({}, mapped20);
        }
      }
      return typeof nodeKey === "string" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;
    }
    getInfoFromNode(redis, callback) {
      if (!redis) {
        return callback(new Error("Node is disconnected"));
      }
      const duplicatedConnection = redis.duplicate({
        enableOfflineQueue: true,
        enableReadyCheck: false,
        retryStrategy: null,
        connectionName: (0, util_1.getConnectionName)("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
      });
      duplicatedConnection.on("error", utils_1.noop);
      duplicatedConnection.cluster("SLOTS", (0, utils_1.timeout)((err, result2) => {
        duplicatedConnection.disconnect();
        if (err) {
          return callback(err);
        }
        if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
          debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result2.length, this.status);
          callback();
          return;
        }
        const nodes = [];
        debug("cluster slots result count: %d", result2.length);
        for (let i = 0;i < result2.length; ++i) {
          const items = result2[i];
          const slotRangeStart = items[0];
          const slotRangeEnd = items[1];
          const keys = [];
          for (let j2 = 2;j2 < items.length; j2++) {
            if (!items[j2][0]) {
              continue;
            }
            const node = this.natMapper({
              host: items[j2][0],
              port: items[j2][1]
            });
            node.readOnly = j2 !== 2;
            nodes.push(node);
            keys.push(node.host + ":" + node.port);
          }
          debug("cluster slots result [%d]: slots %d~%d served by %s", i, slotRangeStart, slotRangeEnd, keys);
          for (let slot = slotRangeStart;slot <= slotRangeEnd; slot++) {
            this.slots[slot] = keys;
          }
        }
        this._groupsIds = Object.create(null);
        let j = 0;
        for (let i = 0;i < 16384; i++) {
          const target = (this.slots[i] || []).join(";");
          if (!target.length) {
            this._groupsBySlot[i] = undefined;
            continue;
          }
          if (!this._groupsIds[target]) {
            this._groupsIds[target] = ++j;
          }
          this._groupsBySlot[i] = this._groupsIds[target];
        }
        this.connectionPool.reset(nodes);
        callback();
      }, this.options.slotsRefreshTimeout));
    }
    invokeReadyDelayedCallbacks(err) {
      for (const c2 of this._readyDelayedCallbacks) {
        process.nextTick(c2, err);
      }
      this._readyDelayedCallbacks = [];
    }
    readyCheck(callback) {
      this.cluster("INFO", (err, res) => {
        if (err) {
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback();
        }
        let state;
        const lines = res.split("\r\n");
        for (let i = 0;i < lines.length; ++i) {
          const parts = lines[i].split(":");
          if (parts[0] === "cluster_state") {
            state = parts[1];
            break;
          }
        }
        if (state === "fail") {
          debug("cluster state not ok (%s)", state);
          callback(null, state);
        } else {
          callback();
        }
      });
    }
    resolveSrv(hostname) {
      return new Promise((resolve, reject) => {
        this.options.resolveSrv(hostname, (err, records) => {
          if (err) {
            return reject(err);
          }
          const self2 = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a2, b3) => parseInt(a2) - parseInt(b3));
          function tryFirstOne(err2) {
            if (!sortedKeys.length) {
              return reject(err2);
            }
            const key = sortedKeys[0], group = groupedRecords[key], record4 = (0, util_1.weightSrvRecords)(group);
            if (!group.records.length) {
              sortedKeys.shift();
            }
            self2.dnsLookup(record4.name).then((host) => resolve({
              host,
              port: record4.port
            }), tryFirstOne);
          }
          tryFirstOne();
        });
      });
    }
    dnsLookup(hostname) {
      return new Promise((resolve, reject) => {
        this.options.dnsLookup(hostname, (err, address) => {
          if (err) {
            debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
            reject(err);
          } else {
            debug("resolved hostname %s to IP %s", hostname, address);
            resolve(address);
          }
        });
      });
    }
    async resolveStartupNodeHostnames() {
      if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
        throw new Error("`startupNodes` should contain at least one node.");
      }
      const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);
      const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);
      if (hostnames.length === 0) {
        return startupNodes;
      }
      const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));
      const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);
      return startupNodes.map((node) => {
        const config = hostnameToConfig.get(node.host);
        if (!config) {
          return node;
        }
        if (this.options.useSRVRecords) {
          return Object.assign({}, node, config);
        }
        return Object.assign({}, node, { host: config });
      });
    }
    createScanStream(command, { key, options = {} }) {
      return new ScanStream_1.default({
        objectMode: true,
        key,
        redis: this,
        command,
        ...options
      });
    }
  }
  (0, applyMixin_1.default)(Cluster, events_1.EventEmitter);
  (0, transaction_1.addTransactionSupport)(Cluster.prototype);
  exports.default = Cluster;
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils3();
  var debug = (0, utils_1.Debug)("AbstractConnector");

  class AbstractConnector {
    constructor(disconnectTimeout) {
      this.connecting = false;
      this.disconnectTimeout = disconnectTimeout;
    }
    check(info) {
      return true;
    }
    disconnect() {
      this.connecting = false;
      if (this.stream) {
        const stream = this.stream;
        const timeout = setTimeout(() => {
          debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
          stream.destroy();
        }, this.disconnectTimeout);
        stream.on("close", () => clearTimeout(timeout));
        stream.end();
      }
    }
  }
  exports.default = AbstractConnector;
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var net_1 = import.meta.require("net");
  var tls_1 = import.meta.require("tls");
  var utils_1 = require_utils3();
  var AbstractConnector_1 = require_AbstractConnector();

  class StandaloneConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
    }
    connect(_) {
      const { options } = this;
      this.connecting = true;
      let connectionOptions;
      if ("path" in options && options.path) {
        connectionOptions = {
          path: options.path
        };
      } else {
        connectionOptions = {};
        if ("port" in options && options.port != null) {
          connectionOptions.port = options.port;
        }
        if ("host" in options && options.host != null) {
          connectionOptions.host = options.host;
        }
        if ("family" in options && options.family != null) {
          connectionOptions.family = options.family;
        }
      }
      if (options.tls) {
        Object.assign(connectionOptions, options.tls);
      }
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (!this.connecting) {
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            return;
          }
          try {
            if (options.tls) {
              this.stream = (0, tls_1.connect)(connectionOptions);
            } else {
              this.stream = (0, net_1.createConnection)(connectionOptions);
            }
          } catch (err) {
            reject(err);
            return;
          }
          this.stream.once("error", (err) => {
            this.firstError = err;
          });
          resolve(this.stream);
        });
      });
    }
  }
  exports.default = StandaloneConnector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS((exports) => {
  var isSentinelEql = function(a2, b3) {
    return (a2.host || "127.0.0.1") === (b3.host || "127.0.0.1") && (a2.port || 26379) === (b3.port || 26379);
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SentinelIterator {
    constructor(sentinels) {
      this.cursor = 0;
      this.sentinels = sentinels.slice(0);
    }
    next() {
      const done = this.cursor >= this.sentinels.length;
      return { done, value: done ? undefined : this.sentinels[this.cursor++] };
    }
    reset(moveCurrentEndpointToFirst) {
      if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
        this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
      }
      this.cursor = 0;
    }
    add(sentinel) {
      for (let i = 0;i < this.sentinels.length; i++) {
        if (isSentinelEql(sentinel, this.sentinels[i])) {
          return false;
        }
      }
      this.sentinels.push(sentinel);
      return true;
    }
    toString() {
      return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
    }
  }
  exports.default = SentinelIterator;
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FailoverDetector = undefined;
  var utils_1 = require_utils3();
  var debug = (0, utils_1.Debug)("FailoverDetector");
  var CHANNEL_NAME = "+switch-master";

  class FailoverDetector {
    constructor(connector, sentinels) {
      this.isDisconnected = false;
      this.connector = connector;
      this.sentinels = sentinels;
    }
    cleanup() {
      this.isDisconnected = true;
      for (const sentinel of this.sentinels) {
        sentinel.client.disconnect();
      }
    }
    async subscribe() {
      debug("Starting FailoverDetector");
      const promises = [];
      for (const sentinel of this.sentinels) {
        const promise5 = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
          debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
        });
        promises.push(promise5);
        sentinel.client.on("message", (channel) => {
          if (!this.isDisconnected && channel === CHANNEL_NAME) {
            this.disconnect();
          }
        });
      }
      await Promise.all(promises);
    }
    disconnect() {
      this.isDisconnected = true;
      debug("Failover detected, disconnecting");
      this.connector.disconnect();
    }
  }
  exports.FailoverDetector = FailoverDetector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS((exports) => {
  var selectPreferredSentinel = function(availableSlaves, preferredSlaves) {
    if (availableSlaves.length === 0) {
      return null;
    }
    let selectedSlave;
    if (typeof preferredSlaves === "function") {
      selectedSlave = preferredSlaves(availableSlaves);
    } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
      const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
      preferredSlavesArray.sort((a2, b3) => {
        if (!a2.prio) {
          a2.prio = 1;
        }
        if (!b3.prio) {
          b3.prio = 1;
        }
        if (a2.prio < b3.prio) {
          return -1;
        }
        if (a2.prio > b3.prio) {
          return 1;
        }
        return 0;
      });
      for (let p2 = 0;p2 < preferredSlavesArray.length; p2++) {
        for (let a2 = 0;a2 < availableSlaves.length; a2++) {
          const slave = availableSlaves[a2];
          if (slave.ip === preferredSlavesArray[p2].ip) {
            if (slave.port === preferredSlavesArray[p2].port) {
              selectedSlave = slave;
              break;
            }
          }
        }
        if (selectedSlave) {
          break;
        }
      }
    }
    if (!selectedSlave) {
      selectedSlave = (0, utils_1.sample)(availableSlaves);
    }
    return addressResponseToAddress(selectedSlave);
  };
  var addressResponseToAddress = function(input) {
    return { host: input.ip, port: Number(input.port) };
  };
  var noop3 = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SentinelIterator = undefined;
  var net_1 = import.meta.require("net");
  var utils_1 = require_utils3();
  var tls_1 = import.meta.require("tls");
  var SentinelIterator_1 = require_SentinelIterator();
  exports.SentinelIterator = SentinelIterator_1.default;
  var AbstractConnector_1 = require_AbstractConnector();
  var Redis_1 = require_Redis();
  var FailoverDetector_1 = require_FailoverDetector();
  var debug = (0, utils_1.Debug)("SentinelConnector");

  class SentinelConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
      this.emitter = null;
      this.failoverDetector = null;
      if (!this.options.sentinels.length) {
        throw new Error("Requires at least one sentinel to connect to.");
      }
      if (!this.options.name) {
        throw new Error("Requires the name of master.");
      }
      this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
    }
    check(info) {
      const roleMatches = !info.role || this.options.role === info.role;
      if (!roleMatches) {
        debug("role invalid, expected %s, but got %s", this.options.role, info.role);
        this.sentinelIterator.next();
        this.sentinelIterator.next();
        this.sentinelIterator.reset(true);
      }
      return roleMatches;
    }
    disconnect() {
      super.disconnect();
      if (this.failoverDetector) {
        this.failoverDetector.cleanup();
      }
    }
    connect(eventEmitter) {
      this.connecting = true;
      this.retryAttempts = 0;
      let lastError;
      const connectToNext = async () => {
        const endpoint = this.sentinelIterator.next();
        if (endpoint.done) {
          this.sentinelIterator.reset(false);
          const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
          let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
          if (lastError) {
            errorMsg += ` Last error: ${lastError.message}`;
          }
          debug(errorMsg);
          const error22 = new Error(errorMsg);
          if (typeof retryDelay === "number") {
            eventEmitter("error", error22);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return connectToNext();
          } else {
            throw error22;
          }
        }
        let resolved = null;
        let err = null;
        try {
          resolved = await this.resolve(endpoint.value);
        } catch (error22) {
          err = error22;
        }
        if (!this.connecting) {
          throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
        }
        const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
        if (resolved) {
          debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
          if (this.options.enableTLSForSentinelMode && this.options.tls) {
            Object.assign(resolved, this.options.tls);
            this.stream = (0, tls_1.connect)(resolved);
            this.stream.once("secureConnect", this.initFailoverDetector.bind(this));
          } else {
            this.stream = (0, net_1.createConnection)(resolved);
            this.stream.once("connect", this.initFailoverDetector.bind(this));
          }
          this.stream.once("error", (err2) => {
            this.firstError = err2;
          });
          return this.stream;
        } else {
          const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
          debug(errorMsg);
          eventEmitter("sentinelError", new Error(errorMsg));
          if (err) {
            lastError = err;
          }
          return connectToNext();
        }
      };
      return connectToNext();
    }
    async updateSentinels(client) {
      if (!this.options.updateSentinels) {
        return;
      }
      const result2 = await client.sentinel("sentinels", this.options.name);
      if (!Array.isArray(result2)) {
        return;
      }
      result2.map(utils_1.packObject).forEach((sentinel) => {
        const flags = sentinel.flags ? sentinel.flags.split(",") : [];
        if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
          const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
          if (this.sentinelIterator.add(endpoint)) {
            debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
          }
        }
      });
      debug("Updated internal sentinels: %s", this.sentinelIterator);
    }
    async resolveMaster(client) {
      const result2 = await client.sentinel("get-master-addr-by-name", this.options.name);
      await this.updateSentinels(client);
      return this.sentinelNatResolve(Array.isArray(result2) ? { host: result2[0], port: Number(result2[1]) } : null);
    }
    async resolveSlave(client) {
      const result2 = await client.sentinel("slaves", this.options.name);
      if (!Array.isArray(result2)) {
        return null;
      }
      const availableSlaves = result2.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
      return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
    }
    sentinelNatResolve(item) {
      if (!item || !this.options.natMap)
        return item;
      return this.options.natMap[`${item.host}:${item.port}`] || item;
    }
    connectToSentinel(endpoint, options) {
      const redis = new Redis_1.default({
        port: endpoint.port || 26379,
        host: endpoint.host,
        username: this.options.sentinelUsername || null,
        password: this.options.sentinelPassword || null,
        family: endpoint.family || ("path" in this.options && this.options.path ? undefined : this.options.family),
        tls: this.options.sentinelTLS,
        retryStrategy: null,
        enableReadyCheck: false,
        connectTimeout: this.options.connectTimeout,
        commandTimeout: this.options.sentinelCommandTimeout,
        ...options
      });
      return redis;
    }
    async resolve(endpoint) {
      const client = this.connectToSentinel(endpoint);
      client.on("error", noop3);
      try {
        if (this.options.role === "slave") {
          return await this.resolveSlave(client);
        } else {
          return await this.resolveMaster(client);
        }
      } finally {
        client.disconnect();
      }
    }
    async initFailoverDetector() {
      var _a;
      if (!this.options.failoverDetector) {
        return;
      }
      this.sentinelIterator.reset(true);
      const sentinels = [];
      while (sentinels.length < this.options.sentinelMaxConnections) {
        const { done, value: value15 } = this.sentinelIterator.next();
        if (done) {
          break;
        }
        const client = this.connectToSentinel(value15, {
          lazyConnect: true,
          retryStrategy: this.options.sentinelReconnectStrategy
        });
        client.on("reconnecting", () => {
          var _a2;
          (_a2 = this.emitter) === null || _a2 === undefined || _a2.emit("sentinelReconnecting");
        });
        sentinels.push({ address: value15, client });
      }
      this.sentinelIterator.reset(false);
      if (this.failoverDetector) {
        this.failoverDetector.cleanup();
      }
      this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
      await this.failoverDetector.subscribe();
      (_a = this.emitter) === null || _a === undefined || _a.emit("failoverSubscribed");
    }
  }
  exports.default = SentinelConnector;
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SentinelConnector = exports.StandaloneConnector = undefined;
  var StandaloneConnector_1 = require_StandaloneConnector();
  exports.StandaloneConnector = StandaloneConnector_1.default;
  var SentinelConnector_1 = require_SentinelConnector();
  exports.SentinelConnector = SentinelConnector_1.default;
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class MaxRetriesPerRequestError extends redis_errors_1.AbortError {
    constructor(maxRetriesPerRequest) {
      const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
      super(message);
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = MaxRetriesPerRequestError;
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MaxRetriesPerRequestError = undefined;
  var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
  exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var parseSimpleNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number7 = 0;
    var sign = 1;
    if (parser.buffer[offset] === 45) {
      sign = -1;
      offset++;
    }
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return sign * number7;
      }
      number7 = number7 * 10 + (c1 - 48);
    }
  };
  var parseStringNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number7 = 0;
    var res = "";
    if (parser.buffer[offset] === 45) {
      res += "-";
      offset++;
    }
    while (offset < length) {
      var c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        if (number7 !== 0) {
          res += number7;
        }
        return res;
      } else if (number7 > 429496728) {
        res += number7 * 10 + (c1 - 48);
        number7 = 0;
      } else if (c1 === 48 && number7 === 0) {
        res += 0;
      } else {
        number7 = number7 * 10 + (c1 - 48);
      }
    }
  };
  var parseSimpleString = function(parser) {
    const start = parser.offset;
    const buffer2 = parser.buffer;
    const length = buffer2.length - 1;
    var offset = start;
    while (offset < length) {
      if (buffer2[offset++] === 13) {
        parser.offset = offset + 1;
        if (parser.optionReturnBuffers === true) {
          return parser.buffer.slice(start, offset - 1);
        }
        return parser.buffer.toString("utf8", start, offset - 1);
      }
    }
  };
  var parseLength = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number7 = 0;
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return number7;
      }
      number7 = number7 * 10 + (c1 - 48);
    }
  };
  var parseInteger = function(parser) {
    if (parser.optionStringNumbers === true) {
      return parseStringNumbers(parser);
    }
    return parseSimpleNumbers(parser);
  };
  var parseBulkString = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const offset = parser.offset + length;
    if (offset + 2 > parser.buffer.length) {
      parser.bigStrSize = offset + 2;
      parser.totalChunkSize = parser.buffer.length;
      parser.bufferCache.push(parser.buffer);
      return;
    }
    const start = parser.offset;
    parser.offset = offset + 2;
    if (parser.optionReturnBuffers === true) {
      return parser.buffer.slice(start, offset);
    }
    return parser.buffer.toString("utf8", start, offset);
  };
  var parseError2 = function(parser) {
    var string7 = parseSimpleString(parser);
    if (string7 !== undefined) {
      if (parser.optionReturnBuffers === true) {
        string7 = string7.toString();
      }
      return new ReplyError(string7);
    }
  };
  var handleError = function(parser, type75) {
    const err = new ParserError("Protocol error, got " + JSON.stringify(String.fromCharCode(type75)) + " as reply type byte", JSON.stringify(parser.buffer), parser.offset);
    parser.buffer = null;
    parser.returnFatalError(err);
  };
  var parseArray = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const responses = new Array(length);
    return parseArrayElements(parser, responses, 0);
  };
  var pushArrayCache = function(parser, array6, pos) {
    parser.arrayCache.push(array6);
    parser.arrayPos.push(pos);
  };
  var parseArrayChunks = function(parser) {
    const tmp = parser.arrayCache.pop();
    var pos = parser.arrayPos.pop();
    if (parser.arrayCache.length) {
      const res = parseArrayChunks(parser);
      if (res === undefined) {
        pushArrayCache(parser, tmp, pos);
        return;
      }
      tmp[pos++] = res;
    }
    return parseArrayElements(parser, tmp, pos);
  };
  var parseArrayElements = function(parser, responses, i) {
    const bufferLength = parser.buffer.length;
    while (i < responses.length) {
      const offset = parser.offset;
      if (parser.offset >= bufferLength) {
        pushArrayCache(parser, responses, i);
        return;
      }
      const response = parseType(parser, parser.buffer[parser.offset++]);
      if (response === undefined) {
        if (!(parser.arrayCache.length || parser.bufferCache.length)) {
          parser.offset = offset;
        }
        pushArrayCache(parser, responses, i);
        return;
      }
      responses[i] = response;
      i++;
    }
    return responses;
  };
  var parseType = function(parser, type75) {
    switch (type75) {
      case 36:
        return parseBulkString(parser);
      case 43:
        return parseSimpleString(parser);
      case 42:
        return parseArray(parser);
      case 58:
        return parseInteger(parser);
      case 45:
        return parseError2(parser);
      default:
        return handleError(parser, type75);
    }
  };
  var decreaseBufferPool = function() {
    if (bufferPool.length > 50 * 1024) {
      if (counter === 1 || notDecreased > counter * 2) {
        const minSliceLen = Math.floor(bufferPool.length / 10);
        const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
        bufferOffset = 0;
        bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
      } else {
        notDecreased++;
        counter--;
      }
    } else {
      clearInterval(interval);
      counter = 0;
      notDecreased = 0;
      interval = null;
    }
  };
  var resizeBuffer = function(length) {
    if (bufferPool.length < length + bufferOffset) {
      const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
      if (bufferOffset > 1024 * 1024 * 111) {
        bufferOffset = 1024 * 1024 * 50;
      }
      bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
      bufferOffset = 0;
      counter++;
      if (interval === null) {
        interval = setInterval(decreaseBufferPool, 50);
      }
    }
  };
  var concatBulkString = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    var res = decoder.write(list[0].slice(oldOffset));
    for (var i = 1;i < chunks - 1; i++) {
      res += decoder.write(list[i]);
    }
    res += decoder.end(list[i].slice(0, offset - 2));
    return res;
  };
  var concatBulkBuffer = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    const length = parser.bigStrSize - oldOffset - 2;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].slice(oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    resizeBuffer(length);
    const start = bufferOffset;
    list[0].copy(bufferPool, start, oldOffset, list[0].length);
    bufferOffset += list[0].length - oldOffset;
    for (var i = 1;i < chunks - 1; i++) {
      list[i].copy(bufferPool, bufferOffset);
      bufferOffset += list[i].length;
    }
    list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
    bufferOffset += offset - 2;
    return bufferPool.slice(start, bufferOffset);
  };
  var Buffer2 = import.meta.require("buffer").Buffer;
  var StringDecoder = import.meta.require("string_decoder").StringDecoder;
  var decoder = new StringDecoder;
  var errors10 = require_redis_errors();
  var ReplyError = errors10.ReplyError;
  var ParserError = errors10.ParserError;
  var bufferPool = Buffer2.allocUnsafe(32 * 1024);
  var bufferOffset = 0;
  var interval = null;
  var counter = 0;
  var notDecreased = 0;

  class JavascriptRedisParser {
    constructor(options) {
      if (!options) {
        throw new TypeError("Options are mandatory.");
      }
      if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
        throw new TypeError("The returnReply and returnError options have to be functions.");
      }
      this.setReturnBuffers(!!options.returnBuffers);
      this.setStringNumbers(!!options.stringNumbers);
      this.returnError = options.returnError;
      this.returnFatalError = options.returnFatalError || options.returnError;
      this.returnReply = options.returnReply;
      this.reset();
    }
    reset() {
      this.offset = 0;
      this.buffer = null;
      this.bigStrSize = 0;
      this.totalChunkSize = 0;
      this.bufferCache = [];
      this.arrayCache = [];
      this.arrayPos = [];
    }
    setReturnBuffers(returnBuffers) {
      if (typeof returnBuffers !== "boolean") {
        throw new TypeError("The returnBuffers argument has to be a boolean");
      }
      this.optionReturnBuffers = returnBuffers;
    }
    setStringNumbers(stringNumbers) {
      if (typeof stringNumbers !== "boolean") {
        throw new TypeError("The stringNumbers argument has to be a boolean");
      }
      this.optionStringNumbers = stringNumbers;
    }
    execute(buffer2) {
      if (this.buffer === null) {
        this.buffer = buffer2;
        this.offset = 0;
      } else if (this.bigStrSize === 0) {
        const oldLength = this.buffer.length;
        const remainingLength = oldLength - this.offset;
        const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer2.length);
        this.buffer.copy(newBuffer, 0, this.offset, oldLength);
        buffer2.copy(newBuffer, remainingLength, 0, buffer2.length);
        this.buffer = newBuffer;
        this.offset = 0;
        if (this.arrayCache.length) {
          const arr = parseArrayChunks(this);
          if (arr === undefined) {
            return;
          }
          this.returnReply(arr);
        }
      } else if (this.totalChunkSize + buffer2.length >= this.bigStrSize) {
        this.bufferCache.push(buffer2);
        var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
        this.bigStrSize = 0;
        this.bufferCache = [];
        this.buffer = buffer2;
        if (this.arrayCache.length) {
          this.arrayCache[0][this.arrayPos[0]++] = tmp;
          tmp = parseArrayChunks(this);
          if (tmp === undefined) {
            return;
          }
        }
        this.returnReply(tmp);
      } else {
        this.bufferCache.push(buffer2);
        this.totalChunkSize += buffer2.length;
        return;
      }
      while (this.offset < this.buffer.length) {
        const offset = this.offset;
        const type75 = this.buffer[this.offset++];
        const response = parseType(this, type75);
        if (response === undefined) {
          if (!(this.arrayCache.length || this.bufferCache.length)) {
            this.offset = offset;
          }
          return;
        }
        if (type75 === 45) {
          this.returnError(response);
        } else {
          this.returnReply(response);
        }
      }
      this.buffer = null;
    }
  }
  module.exports = JavascriptRedisParser;
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS((exports) => {
  var mapSet = function(set2) {
    if (set2 === "unsubscribe") {
      return "subscribe";
    }
    if (set2 === "punsubscribe") {
      return "psubscribe";
    }
    if (set2 === "sunsubscribe") {
      return "ssubscribe";
    }
    return set2;
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SubscriptionSet {
    constructor() {
      this.set = {
        subscribe: {},
        psubscribe: {},
        ssubscribe: {}
      };
    }
    add(set2, channel) {
      this.set[mapSet(set2)][channel] = true;
    }
    del(set2, channel) {
      delete this.set[mapSet(set2)][channel];
    }
    channels(set2) {
      return Object.keys(this.set[mapSet(set2)]);
    }
    isEmpty() {
      return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0 && this.channels("ssubscribe").length === 0;
    }
  }
  exports.default = SubscriptionSet;
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS((exports) => {
  var fillSubCommand = function(command, count) {
    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
    remainingReplies -= 1;
    if (remainingReplies <= 0) {
      command.resolve(count);
      remainingRepliesMap.delete(command);
      return true;
    }
    remainingRepliesMap.set(command, remainingReplies);
    return false;
  };
  var fillUnsubCommand = function(command, count) {
    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
    if (remainingReplies === 0) {
      if (Number(count) === 0) {
        remainingRepliesMap.delete(command);
        command.resolve(count);
        return true;
      }
      return false;
    }
    remainingReplies -= 1;
    if (remainingReplies <= 0) {
      command.resolve(count);
      return true;
    }
    remainingRepliesMap.set(command, remainingReplies);
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Command_1 = require_Command();
  var utils_1 = require_utils3();
  var RedisParser = require_parser();
  var SubscriptionSet_1 = require_SubscriptionSet();
  var debug = (0, utils_1.Debug)("dataHandler");

  class DataHandler {
    constructor(redis, parserOptions) {
      this.redis = redis;
      const parser = new RedisParser({
        stringNumbers: parserOptions.stringNumbers,
        returnBuffers: true,
        returnError: (err) => {
          this.returnError(err);
        },
        returnFatalError: (err) => {
          this.returnFatalError(err);
        },
        returnReply: (reply) => {
          this.returnReply(reply);
        }
      });
      redis.stream.on("data", (data) => {
        parser.execute(data);
      });
    }
    returnFatalError(err) {
      err.message += ". Please report this.";
      this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
    }
    returnError(err) {
      const item = this.shiftCommand(err);
      if (!item) {
        return;
      }
      err.command = {
        name: item.command.name,
        args: item.command.args
      };
      this.redis.handleReconnection(err, item);
    }
    returnReply(reply) {
      if (this.handleMonitorReply(reply)) {
        return;
      }
      if (this.handleSubscriberReply(reply)) {
        return;
      }
      const item = this.shiftCommand(reply);
      if (!item) {
        return;
      }
      if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
        this.redis.condition.subscriber = new SubscriptionSet_1.default;
        this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
        if (!fillSubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else if (Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
        if (!fillUnsubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else {
        item.command.resolve(reply);
      }
    }
    handleSubscriberReply(reply) {
      if (!this.redis.condition.subscriber) {
        return false;
      }
      const replyType = Array.isArray(reply) ? reply[0].toString() : null;
      debug('receive reply "%s" in subscriber mode', replyType);
      switch (replyType) {
        case "message":
          if (this.redis.listeners("message").length > 0) {
            this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
          }
          this.redis.emit("messageBuffer", reply[1], reply[2]);
          break;
        case "pmessage": {
          const pattern3 = reply[1].toString();
          if (this.redis.listeners("pmessage").length > 0) {
            this.redis.emit("pmessage", pattern3, reply[2].toString(), reply[3].toString());
          }
          this.redis.emit("pmessageBuffer", pattern3, reply[2], reply[3]);
          break;
        }
        case "smessage": {
          if (this.redis.listeners("smessage").length > 0) {
            this.redis.emit("smessage", reply[1].toString(), reply[2] ? reply[2].toString() : "");
          }
          this.redis.emit("smessageBuffer", reply[1], reply[2]);
          break;
        }
        case "ssubscribe":
        case "subscribe":
        case "psubscribe": {
          const channel = reply[1].toString();
          this.redis.condition.subscriber.add(replyType, channel);
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        case "sunsubscribe":
        case "unsubscribe":
        case "punsubscribe": {
          const channel = reply[1] ? reply[1].toString() : null;
          if (channel) {
            this.redis.condition.subscriber.del(replyType, channel);
          }
          const count = reply[2];
          if (Number(count) === 0) {
            this.redis.condition.subscriber = false;
          }
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillUnsubCommand(item.command, count)) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        default: {
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          item.command.resolve(reply);
        }
      }
      return true;
    }
    handleMonitorReply(reply) {
      if (this.redis.status !== "monitoring") {
        return false;
      }
      const replyStr = reply.toString();
      if (replyStr === "OK") {
        return false;
      }
      const len = replyStr.indexOf(" ");
      const timestamp2 = replyStr.slice(0, len);
      const argIndex = replyStr.indexOf('"');
      const args = replyStr.slice(argIndex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
      const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(" ");
      this.redis.emit("monitor", timestamp2, args, dbAndSource[1], dbAndSource[0]);
      return true;
    }
    shiftCommand(reply) {
      const item = this.redis.commandQueue.shift();
      if (!item) {
        const message = "Command queue state error. If you can reproduce this, please report it.";
        const error22 = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
        this.redis.emit("error", error22);
        return null;
      }
      return item;
    }
  }
  exports.default = DataHandler;
  var remainingRepliesMap = new WeakMap;
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS((exports) => {
  var connectHandler = function(self2) {
    return function() {
      self2.setStatus("connect");
      self2.resetCommandQueue();
      let flushed = false;
      const { connectionEpoch } = self2;
      if (self2.condition.auth) {
        self2.auth(self2.condition.auth, function(err) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (err.message.indexOf("no password is set") !== -1) {
              console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
            } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
              console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
            } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
              console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
            } else {
              flushed = true;
              self2.recoverFromFatalError(err, err);
            }
          }
        });
      }
      if (self2.condition.select) {
        self2.select(self2.condition.select).catch((err) => {
          self2.silentEmit("error", err);
        });
      }
      if (!self2.options.enableReadyCheck) {
        exports.readyHandler(self2)();
      }
      new DataHandler_1.default(self2, {
        stringNumbers: self2.options.stringNumbers
      });
      if (self2.options.enableReadyCheck) {
        self2._readyCheck(function(err, info) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (!flushed) {
              self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
            }
          } else {
            if (self2.connector.check(info)) {
              exports.readyHandler(self2)();
            } else {
              self2.disconnect(true);
            }
          }
        });
      }
    };
  };
  var abortError = function(command) {
    const err = new redis_errors_1.AbortError("Command aborted due to connection close");
    err.command = {
      name: command.name,
      args: command.args
    };
    return err;
  };
  var abortIncompletePipelines = function(commandQueue) {
    var _a;
    let expectedIndex = 0;
    for (let i = 0;i < commandQueue.length; ) {
      const command = (_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
      const pipelineIndex = command.pipelineIndex;
      if (pipelineIndex === undefined || pipelineIndex === 0) {
        expectedIndex = 0;
      }
      if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        continue;
      }
      i++;
    }
  };
  var abortTransactionFragments = function(commandQueue) {
    var _a;
    for (let i = 0;i < commandQueue.length; ) {
      const command = (_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
      if (command.name === "multi") {
        break;
      }
      if (command.name === "exec") {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        break;
      }
      if (command.inTransaction) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
      } else {
        i++;
      }
    }
  };
  var closeHandler = function(self2) {
    return function() {
      const prevStatus = self2.status;
      self2.setStatus("close");
      if (self2.commandQueue.length) {
        abortIncompletePipelines(self2.commandQueue);
      }
      if (self2.offlineQueue.length) {
        abortTransactionFragments(self2.offlineQueue);
      }
      if (prevStatus === "ready") {
        if (!self2.prevCondition) {
          self2.prevCondition = self2.condition;
        }
        if (self2.commandQueue.length) {
          self2.prevCommandQueue = self2.commandQueue;
        }
      }
      if (self2.manuallyClosing) {
        self2.manuallyClosing = false;
        debug("skip reconnecting since the connection is manually closed.");
        return close();
      }
      if (typeof self2.options.retryStrategy !== "function") {
        debug("skip reconnecting because `retryStrategy` is not a function");
        return close();
      }
      const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
      if (typeof retryDelay !== "number") {
        debug("skip reconnecting because `retryStrategy` doesn't return a number");
        return close();
      }
      debug("reconnect in %sms", retryDelay);
      self2.setStatus("reconnecting", retryDelay);
      self2.reconnectTimeout = setTimeout(function() {
        self2.reconnectTimeout = null;
        self2.connect().catch(utils_1.noop);
      }, retryDelay);
      const { maxRetriesPerRequest } = self2.options;
      if (typeof maxRetriesPerRequest === "number") {
        if (maxRetriesPerRequest < 0) {
          debug("maxRetriesPerRequest is negative, ignoring...");
        } else {
          const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
          if (remainder === 0) {
            debug("reach maxRetriesPerRequest limitation, flushing command queue...");
            self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
          }
        }
      }
    };
    function close() {
      self2.setStatus("end");
      self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
    }
  };
  var errorHandler = function(self2) {
    return function(error22) {
      debug("error: %s", error22);
      self2.silentEmit("error", error22);
    };
  };
  var readyHandler = function(self2) {
    return function() {
      self2.setStatus("ready");
      self2.retryAttempts = 0;
      if (self2.options.monitor) {
        self2.call("monitor").then(() => self2.setStatus("monitoring"), (error22) => self2.emit("error", error22));
        const { sendCommand } = self2;
        self2.sendCommand = function(command) {
          if (Command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
            return sendCommand.call(self2, command);
          }
          command.reject(new Error("Connection is in monitoring mode, can't process commands."));
          return command.promise;
        };
        self2.once("close", function() {
          delete self2.sendCommand;
        });
        return;
      }
      const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
      if (self2.options.connectionName) {
        debug("set the connection name [%s]", self2.options.connectionName);
        self2.client("setname", self2.options.connectionName).catch(utils_1.noop);
      }
      if (self2.options.readOnly) {
        debug("set the connection to readonly mode");
        self2.readonly().catch(utils_1.noop);
      }
      if (self2.prevCondition) {
        const condition = self2.prevCondition;
        self2.prevCondition = null;
        if (condition.subscriber && self2.options.autoResubscribe) {
          if (self2.condition.select !== finalSelect) {
            debug("connect to db [%d]", finalSelect);
            self2.select(finalSelect);
          }
          const subscribeChannels = condition.subscriber.channels("subscribe");
          if (subscribeChannels.length) {
            debug("subscribe %d channels", subscribeChannels.length);
            self2.subscribe(subscribeChannels);
          }
          const psubscribeChannels = condition.subscriber.channels("psubscribe");
          if (psubscribeChannels.length) {
            debug("psubscribe %d channels", psubscribeChannels.length);
            self2.psubscribe(psubscribeChannels);
          }
          const ssubscribeChannels = condition.subscriber.channels("ssubscribe");
          if (ssubscribeChannels.length) {
            debug("ssubscribe %d channels", ssubscribeChannels.length);
            self2.ssubscribe(ssubscribeChannels);
          }
        }
      }
      if (self2.prevCommandQueue) {
        if (self2.options.autoResendUnfulfilledCommands) {
          debug("resend %d unfulfilled commands", self2.prevCommandQueue.length);
          while (self2.prevCommandQueue.length > 0) {
            const item = self2.prevCommandQueue.shift();
            if (item.select !== self2.condition.select && item.command.name !== "select") {
              self2.select(item.select);
            }
            self2.sendCommand(item.command, item.stream);
          }
        } else {
          self2.prevCommandQueue = null;
        }
      }
      if (self2.offlineQueue.length) {
        debug("send %d commands in offline queue", self2.offlineQueue.length);
        const offlineQueue = self2.offlineQueue;
        self2.resetOfflineQueue();
        while (offlineQueue.length > 0) {
          const item = offlineQueue.shift();
          if (item.select !== self2.condition.select && item.command.name !== "select") {
            self2.select(item.select);
          }
          self2.sendCommand(item.command, item.stream);
        }
      }
      if (self2.condition.select !== finalSelect) {
        debug("connect to db [%d]", finalSelect);
        self2.select(finalSelect);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = undefined;
  var redis_errors_1 = require_redis_errors();
  var Command_1 = require_Command();
  var errors_1 = require_errors();
  var utils_1 = require_utils3();
  var DataHandler_1 = require_DataHandler();
  var debug = (0, utils_1.Debug)("connection");
  exports.connectHandler = connectHandler;
  exports.closeHandler = closeHandler;
  exports.errorHandler = errorHandler;
  exports.readyHandler = readyHandler;
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_REDIS_OPTIONS = undefined;
  exports.DEFAULT_REDIS_OPTIONS = {
    port: 6379,
    host: "localhost",
    family: 4,
    connectTimeout: 1e4,
    disconnectTimeout: 2000,
    retryStrategy: function(times) {
      return Math.min(times * 50, 2000);
    },
    keepAlive: 0,
    noDelay: true,
    connectionName: null,
    sentinels: null,
    name: null,
    role: "master",
    sentinelRetryStrategy: function(times) {
      return Math.min(times * 10, 1000);
    },
    sentinelReconnectStrategy: function() {
      return 60000;
    },
    natMap: null,
    enableTLSForSentinelMode: false,
    updateSentinels: true,
    failoverDetector: false,
    username: null,
    password: null,
    db: 0,
    enableOfflineQueue: true,
    enableReadyCheck: true,
    autoResubscribe: true,
    autoResendUnfulfilledCommands: true,
    lazyConnect: false,
    keyPrefix: "",
    reconnectOnError: null,
    readOnly: false,
    stringNumbers: false,
    maxRetriesPerRequest: 20,
    maxLoadingRetryTime: 1e4,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: [],
    sentinelMaxConnections: 10
  };
});

// node_modules/ioredis/built/Redis.js
var require_Redis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var events_1 = import.meta.require("events");
  var standard_as_callback_1 = require_built2();
  var cluster_1 = require_cluster();
  var Command_1 = require_Command();
  var connectors_1 = require_connectors();
  var SentinelConnector_1 = require_SentinelConnector();
  var eventHandler = require_event_handler();
  var RedisOptions_1 = require_RedisOptions();
  var ScanStream_1 = require_ScanStream();
  var transaction_1 = require_transaction();
  var utils_1 = require_utils3();
  var applyMixin_1 = require_applyMixin();
  var Commander_1 = require_Commander();
  var lodash_1 = require_lodash3();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("redis");

  class Redis extends Commander_1.default {
    constructor(arg1, arg2, arg3) {
      super();
      this.status = "wait";
      this.isCluster = false;
      this.reconnectTimeout = null;
      this.connectionEpoch = 0;
      this.retryAttempts = 0;
      this.manuallyClosing = false;
      this._autoPipelines = new Map;
      this._runningAutoPipelines = new Set;
      this.parseOptions(arg1, arg2, arg3);
      events_1.EventEmitter.call(this);
      this.resetCommandQueue();
      this.resetOfflineQueue();
      if (this.options.Connector) {
        this.connector = new this.options.Connector(this.options);
      } else if (this.options.sentinels) {
        const sentinelConnector = new SentinelConnector_1.default(this.options);
        sentinelConnector.emitter = this;
        this.connector = sentinelConnector;
      } else {
        this.connector = new connectors_1.StandaloneConnector(this.options);
      }
      if (this.options.scripts) {
        Object.entries(this.options.scripts).forEach(([name, definition]) => {
          this.defineCommand(name, definition);
        });
      }
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch(lodash_1.noop);
      }
    }
    static createClient(...args) {
      return new Redis(...args);
    }
    get autoPipelineQueueSize() {
      let queued = 0;
      for (const pipeline of this._autoPipelines.values()) {
        queued += pipeline.length;
      }
      return queued;
    }
    connect(callback) {
      const promise5 = new Promise((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        this.connectionEpoch += 1;
        this.setStatus("connecting");
        const { options } = this;
        this.condition = {
          select: options.db,
          auth: options.username ? [options.username, options.password] : options.password,
          subscriber: false
        };
        const _this = this;
        (0, standard_as_callback_1.default)(this.connector.connect(function(type75, err) {
          _this.silentEmit(type75, err);
        }), function(err, stream) {
          if (err) {
            _this.flushQueue(err);
            _this.silentEmit("error", err);
            reject(err);
            _this.setStatus("end");
            return;
          }
          let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
          if ("sentinels" in options && options.sentinels && !options.enableTLSForSentinelMode) {
            CONNECT_EVENT = "connect";
          }
          _this.stream = stream;
          if (options.noDelay) {
            stream.setNoDelay(true);
          }
          if (typeof options.keepAlive === "number") {
            if (stream.connecting) {
              stream.once(CONNECT_EVENT, () => {
                stream.setKeepAlive(true, options.keepAlive);
              });
            } else {
              stream.setKeepAlive(true, options.keepAlive);
            }
          }
          if (stream.connecting) {
            stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
            if (options.connectTimeout) {
              let connectTimeoutCleared = false;
              stream.setTimeout(options.connectTimeout, function() {
                if (connectTimeoutCleared) {
                  return;
                }
                stream.setTimeout(0);
                stream.destroy();
                const err2 = new Error("connect ETIMEDOUT");
                err2.errorno = "ETIMEDOUT";
                err2.code = "ETIMEDOUT";
                err2.syscall = "connect";
                eventHandler.errorHandler(_this)(err2);
              });
              stream.once(CONNECT_EVENT, function() {
                connectTimeoutCleared = true;
                stream.setTimeout(0);
              });
            }
          } else if (stream.destroyed) {
            const firstError = _this.connector.firstError;
            if (firstError) {
              process.nextTick(() => {
                eventHandler.errorHandler(_this)(firstError);
              });
            }
            process.nextTick(eventHandler.closeHandler(_this));
          } else {
            process.nextTick(eventHandler.connectHandler(_this));
          }
          if (!stream.destroyed) {
            stream.once("error", eventHandler.errorHandler(_this));
            stream.once("close", eventHandler.closeHandler(_this));
          }
          const connectionReadyHandler = function() {
            _this.removeListener("close", connectionCloseHandler);
            resolve();
          };
          var connectionCloseHandler = function() {
            _this.removeListener("ready", connectionReadyHandler);
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          };
          _this.once("ready", connectionReadyHandler);
          _this.once("close", connectionCloseHandler);
        });
      });
      return (0, standard_as_callback_1.default)(promise5, callback);
    }
    disconnect(reconnect = false) {
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      if (this.status === "wait") {
        eventHandler.closeHandler(this)();
      } else {
        this.connector.disconnect();
      }
    }
    end() {
      this.disconnect();
    }
    duplicate(override) {
      return new Redis({ ...this.options, ...override });
    }
    get mode() {
      var _a;
      return this.options.monitor ? "monitor" : ((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber) ? "subscriber" : "normal";
    }
    monitor(callback) {
      const monitorInstance = this.duplicate({
        monitor: true,
        lazyConnect: false
      });
      return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
        monitorInstance.once("error", reject);
        monitorInstance.once("monitoring", function() {
          resolve(monitorInstance);
        });
      }), callback);
    }
    sendCommand(command, stream) {
      var _a, _b;
      if (this.status === "wait") {
        this.connect().catch(lodash_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      if (((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber) && !Command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)) {
        command.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
        return command.promise;
      }
      if (typeof this.options.commandTimeout === "number") {
        command.setTimeout(this.options.commandTimeout);
      }
      let writable = this.status === "ready" || !stream && this.status === "connect" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "loading");
      if (!this.stream) {
        writable = false;
      } else if (!this.stream.writable) {
        writable = false;
      } else if (this.stream._writableState && this.stream._writableState.ended) {
        writable = false;
      }
      if (!writable) {
        if (!this.options.enableOfflineQueue) {
          command.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
          return command.promise;
        }
        if (command.name === "quit" && this.offlineQueue.length === 0) {
          this.disconnect();
          command.resolve(Buffer.from("OK"));
          return command.promise;
        }
        if (debug.enabled) {
          debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
        }
        this.offlineQueue.push({
          command,
          stream,
          select: this.condition.select
        });
      } else {
        if (debug.enabled) {
          debug("write command[%s]: %d -> %s(%o)", this._getDescription(), (_b = this.condition) === null || _b === undefined ? undefined : _b.select, command.name, command.args);
        }
        if (stream) {
          if ("isPipeline" in stream && stream.isPipeline) {
            stream.write(command.toWritable(stream.destination.redis.stream));
          } else {
            stream.write(command.toWritable(stream));
          }
        } else {
          this.stream.write(command.toWritable(this.stream));
        }
        this.commandQueue.push({
          command,
          stream,
          select: this.condition.select
        });
        if (Command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
          this.manuallyClosing = true;
        }
      }
      if (command.name === "select" && (0, utils_1.isInt)(command.args[0])) {
        const db4 = parseInt(command.args[0], 10);
        if (this.condition.select !== db4) {
          this.condition.select = db4;
          this.emit("select", db4);
          debug("switch to db [%d]", this.condition.select);
        }
      }
      return command.promise;
    }
    scanStream(options) {
      return this.createScanStream("scan", { options });
    }
    scanBufferStream(options) {
      return this.createScanStream("scanBuffer", { options });
    }
    sscanStream(key, options) {
      return this.createScanStream("sscan", { key, options });
    }
    sscanBufferStream(key, options) {
      return this.createScanStream("sscanBuffer", { key, options });
    }
    hscanStream(key, options) {
      return this.createScanStream("hscan", { key, options });
    }
    hscanBufferStream(key, options) {
      return this.createScanStream("hscanBuffer", { key, options });
    }
    zscanStream(key, options) {
      return this.createScanStream("zscan", { key, options });
    }
    zscanBufferStream(key, options) {
      return this.createScanStream("zscanBuffer", { key, options });
    }
    silentEmit(eventName, arg) {
      let error22;
      if (eventName === "error") {
        error22 = arg;
        if (this.status === "end") {
          return;
        }
        if (this.manuallyClosing) {
          if (error22 instanceof Error && (error22.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || error22.syscall === "connect" || error22.syscall === "read")) {
            return;
          }
        }
      }
      if (this.listeners(eventName).length > 0) {
        return this.emit.apply(this, arguments);
      }
      if (error22 && error22 instanceof Error) {
        console.error("[ioredis] Unhandled error event:", error22.stack);
      }
      return false;
    }
    recoverFromFatalError(_commandError, err, options) {
      this.flushQueue(err, options);
      this.silentEmit("error", err);
      this.disconnect(true);
    }
    handleReconnection(err, item) {
      var _a;
      let needReconnect = false;
      if (this.options.reconnectOnError) {
        needReconnect = this.options.reconnectOnError(err);
      }
      switch (needReconnect) {
        case 1:
        case true:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          item.command.reject(err);
          break;
        case 2:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          if (((_a = this.condition) === null || _a === undefined ? undefined : _a.select) !== item.select && item.command.name !== "select") {
            this.select(item.select);
          }
          this.sendCommand(item.command);
          break;
        default:
          item.command.reject(err);
      }
    }
    _getDescription() {
      let description;
      if ("path" in this.options && this.options.path) {
        description = this.options.path;
      } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
        description = this.stream.remoteAddress + ":" + this.stream.remotePort;
      } else if ("host" in this.options && this.options.host) {
        description = this.options.host + ":" + this.options.port;
      } else {
        description = "";
      }
      if (this.options.connectionName) {
        description += ` (${this.options.connectionName})`;
      }
      return description;
    }
    resetCommandQueue() {
      this.commandQueue = new Deque;
    }
    resetOfflineQueue() {
      this.offlineQueue = new Deque;
    }
    parseOptions(...args) {
      const options = {};
      let isTls = false;
      for (let i = 0;i < args.length; ++i) {
        const arg = args[i];
        if (arg === null || typeof arg === "undefined") {
          continue;
        }
        if (typeof arg === "object") {
          (0, lodash_1.defaults)(options, arg);
        } else if (typeof arg === "string") {
          (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));
          if (arg.startsWith("rediss://")) {
            isTls = true;
          }
        } else if (typeof arg === "number") {
          options.port = arg;
        } else {
          throw new Error("Invalid argument " + arg);
        }
      }
      if (isTls) {
        (0, lodash_1.defaults)(options, { tls: true });
      }
      (0, lodash_1.defaults)(options, Redis.defaultOptions);
      if (typeof options.port === "string") {
        options.port = parseInt(options.port, 10);
      }
      if (typeof options.db === "string") {
        options.db = parseInt(options.db, 10);
      }
      this.options = (0, utils_1.resolveTLSProfile)(options);
    }
    setStatus(status, arg) {
      if (debug.enabled) {
        debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
      }
      this.status = status;
      process.nextTick(this.emit.bind(this, status, arg));
    }
    createScanStream(command, { key, options = {} }) {
      return new ScanStream_1.default({
        objectMode: true,
        key,
        redis: this,
        command,
        ...options
      });
    }
    flushQueue(error22, options) {
      options = (0, lodash_1.defaults)({}, options, {
        offlineQueue: true,
        commandQueue: true
      });
      let item;
      if (options.offlineQueue) {
        while (item = this.offlineQueue.shift()) {
          item.command.reject(error22);
        }
      }
      if (options.commandQueue) {
        if (this.commandQueue.length > 0) {
          if (this.stream) {
            this.stream.removeAllListeners("data");
          }
          while (item = this.commandQueue.shift()) {
            item.command.reject(error22);
          }
        }
      }
    }
    _readyCheck(callback) {
      const _this = this;
      this.info(function(err, res) {
        if (err) {
          if (err.message && err.message.includes("NOPERM")) {
            console.warn(`Skipping the ready check because INFO command fails: "${err.message}". You can disable ready check with "enableReadyCheck". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);
            return callback(null, {});
          }
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback(null, res);
        }
        const info = {};
        const lines = res.split("\r\n");
        for (let i = 0;i < lines.length; ++i) {
          const [fieldName, ...fieldValueParts] = lines[i].split(":");
          const fieldValue = fieldValueParts.join(":");
          if (fieldValue) {
            info[fieldName] = fieldValue;
          }
        }
        if (!info.loading || info.loading === "0") {
          callback(null, info);
        } else {
          const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
          const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
          debug("Redis server still loading, trying again in " + retryTime + "ms");
          setTimeout(function() {
            _this._readyCheck(callback);
          }, retryTime);
        }
      }).catch(lodash_1.noop);
    }
  }
  Redis.Cluster = cluster_1.default;
  Redis.Command = Command_1.default;
  Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
  (0, applyMixin_1.default)(Redis, events_1.EventEmitter);
  (0, transaction_1.addTransactionSupport)(Redis.prototype);
  exports.default = Redis;
});

// node_modules/ioredis/built/index.js
var require_built3 = __commonJS((exports, module) => {
  var print = function(err, reply) {
    if (err) {
      console.log("Error: " + err);
    } else {
      console.log("Reply: " + reply);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports.default = undefined;
  exports = module.exports = require_Redis().default;
  var Redis_1 = require_Redis();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return Redis_1.default;
  } });
  var Redis_2 = require_Redis();
  Object.defineProperty(exports, "Redis", { enumerable: true, get: function() {
    return Redis_2.default;
  } });
  var cluster_1 = require_cluster();
  Object.defineProperty(exports, "Cluster", { enumerable: true, get: function() {
    return cluster_1.default;
  } });
  var Command_1 = require_Command();
  Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
    return Command_1.default;
  } });
  var ScanStream_1 = require_ScanStream();
  Object.defineProperty(exports, "ScanStream", { enumerable: true, get: function() {
    return ScanStream_1.default;
  } });
  var Pipeline_1 = require_Pipeline();
  Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
    return Pipeline_1.default;
  } });
  var AbstractConnector_1 = require_AbstractConnector();
  Object.defineProperty(exports, "AbstractConnector", { enumerable: true, get: function() {
    return AbstractConnector_1.default;
  } });
  var SentinelConnector_1 = require_SentinelConnector();
  Object.defineProperty(exports, "SentinelConnector", { enumerable: true, get: function() {
    return SentinelConnector_1.default;
  } });
  Object.defineProperty(exports, "SentinelIterator", { enumerable: true, get: function() {
    return SentinelConnector_1.SentinelIterator;
  } });
  exports.ReplyError = require_redis_errors().ReplyError;
  Object.defineProperty(exports, "Promise", {
    get() {
      console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
      return Promise;
    },
    set(_lib) {
      console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
    }
  });
  exports.print = print;
});

// node_modules/lodash/lodash.js
var require_lodash4 = __commonJS((exports, module) => {
  (function() {
    var undefined6;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types4 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types4) {
          return types4;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e2) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array6, setter, iteratee, accumulator) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      while (++index < length) {
        var value15 = array6[index];
        setter(accumulator, value15, iteratee(value15), array6);
      }
      return accumulator;
    }
    function arrayEach(array6, iteratee) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      while (++index < length) {
        if (iteratee(array6[index], index, array6) === false) {
          break;
        }
      }
      return array6;
    }
    function arrayEachRight(array6, iteratee) {
      var length = array6 == null ? 0 : array6.length;
      while (length--) {
        if (iteratee(array6[length], length, array6) === false) {
          break;
        }
      }
      return array6;
    }
    function arrayEvery(array6, predicate) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      while (++index < length) {
        if (!predicate(array6[index], index, array6)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array6, predicate) {
      var index = -1, length = array6 == null ? 0 : array6.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value15 = array6[index];
        if (predicate(value15, index, array6)) {
          result2[resIndex++] = value15;
        }
      }
      return result2;
    }
    function arrayIncludes(array6, value15) {
      var length = array6 == null ? 0 : array6.length;
      return !!length && baseIndexOf(array6, value15, 0) > -1;
    }
    function arrayIncludesWith(array6, value15, comparator) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      while (++index < length) {
        if (comparator(value15, array6[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array6, iteratee) {
      var index = -1, length = array6 == null ? 0 : array6.length, result2 = Array(length);
      while (++index < length) {
        result2[index] = iteratee(array6[index], index, array6);
      }
      return result2;
    }
    function arrayPush(array6, values2) {
      var index = -1, length = values2.length, offset = array6.length;
      while (++index < length) {
        array6[offset + index] = values2[index];
      }
      return array6;
    }
    function arrayReduce(array6, iteratee, accumulator, initAccum) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      if (initAccum && length) {
        accumulator = array6[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array6[index], index, array6);
      }
      return accumulator;
    }
    function arrayReduceRight(array6, iteratee, accumulator, initAccum) {
      var length = array6 == null ? 0 : array6.length;
      if (initAccum && length) {
        accumulator = array6[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array6[length], length, array6);
      }
      return accumulator;
    }
    function arraySome(array6, predicate) {
      var index = -1, length = array6 == null ? 0 : array6.length;
      while (++index < length) {
        if (predicate(array6[index], index, array6)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string7) {
      return string7.split("");
    }
    function asciiWords(string7) {
      return string7.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result2;
      eachFunc(collection, function(value15, key, collection2) {
        if (predicate(value15, key, collection2)) {
          result2 = key;
          return false;
        }
      });
      return result2;
    }
    function baseFindIndex(array6, predicate, fromIndex, fromRight) {
      var length = array6.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array6[index], index, array6)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array6, value15, fromIndex) {
      return value15 === value15 ? strictIndexOf(array6, value15, fromIndex) : baseFindIndex(array6, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array6, value15, fromIndex, comparator) {
      var index = fromIndex - 1, length = array6.length;
      while (++index < length) {
        if (comparator(array6[index], value15)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value15) {
      return value15 !== value15;
    }
    function baseMean(array6, iteratee) {
      var length = array6 == null ? 0 : array6.length;
      return length ? baseSum(array6, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object13) {
        return object13 == null ? undefined6 : object13[key];
      };
    }
    function basePropertyOf(object13) {
      return function(key) {
        return object13 == null ? undefined6 : object13[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value15, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value15) : iteratee(accumulator, value15, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array6, comparer) {
      var length = array6.length;
      array6.sort(comparer);
      while (length--) {
        array6[length] = array6[length].value;
      }
      return array6;
    }
    function baseSum(array6, iteratee) {
      var result2, index = -1, length = array6.length;
      while (++index < length) {
        var current = iteratee(array6[index]);
        if (current !== undefined6) {
          result2 = result2 === undefined6 ? current : result2 + current;
        }
      }
      return result2;
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result2 = Array(n2);
      while (++index < n2) {
        result2[index] = iteratee(index);
      }
      return result2;
    }
    function baseToPairs(object13, props) {
      return arrayMap(props, function(key) {
        return [key, object13[key]];
      });
    }
    function baseTrim(string7) {
      return string7 ? string7.slice(0, trimmedEndIndex(string7) + 1).replace(reTrimStart, "") : string7;
    }
    function baseUnary(func) {
      return function(value15) {
        return func(value15);
      };
    }
    function baseValues(object13, props) {
      return arrayMap(props, function(key) {
        return object13[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array6, placeholder) {
      var length = array6.length, result2 = 0;
      while (length--) {
        if (array6[length] === placeholder) {
          ++result2;
        }
      }
      return result2;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object13, key) {
      return object13 == null ? undefined6 : object13[key];
    }
    function hasUnicode(string7) {
      return reHasUnicode.test(string7);
    }
    function hasUnicodeWord(string7) {
      return reHasUnicodeWord.test(string7);
    }
    function iteratorToArray(iterator5) {
      var data, result2 = [];
      while (!(data = iterator5.next()).done) {
        result2.push(data.value);
      }
      return result2;
    }
    function mapToArray(map3) {
      var index = -1, result2 = Array(map3.size);
      map3.forEach(function(value15, key) {
        result2[++index] = [key, value15];
      });
      return result2;
    }
    function overArg(func, transform7) {
      return function(arg) {
        return func(transform7(arg));
      };
    }
    function replaceHolders(array6, placeholder) {
      var index = -1, length = array6.length, resIndex = 0, result2 = [];
      while (++index < length) {
        var value15 = array6[index];
        if (value15 === placeholder || value15 === PLACEHOLDER) {
          array6[index] = PLACEHOLDER;
          result2[resIndex++] = index;
        }
      }
      return result2;
    }
    function setToArray(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value15) {
        result2[++index] = value15;
      });
      return result2;
    }
    function setToPairs(set2) {
      var index = -1, result2 = Array(set2.size);
      set2.forEach(function(value15) {
        result2[++index] = [value15, value15];
      });
      return result2;
    }
    function strictIndexOf(array6, value15, fromIndex) {
      var index = fromIndex - 1, length = array6.length;
      while (++index < length) {
        if (array6[index] === value15) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array6, value15, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array6[index] === value15) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string7) {
      return hasUnicode(string7) ? unicodeSize(string7) : asciiSize(string7);
    }
    function stringToArray(string7) {
      return hasUnicode(string7) ? unicodeToArray(string7) : asciiToArray(string7);
    }
    function trimmedEndIndex(string7) {
      var index = string7.length;
      while (index-- && reWhitespace.test(string7.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string7) {
      var result2 = reUnicode.lastIndex = 0;
      while (reUnicode.test(string7)) {
        ++result2;
      }
      return result2;
    }
    function unicodeToArray(string7) {
      return string7.match(reUnicode) || [];
    }
    function unicodeWords(string7) {
      return string7.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var { Array: Array3, Date: Date3, Error: Error2, Function: Function3, Math: Math2, Object: Object3, RegExp: RegExp3, String: String3, TypeError: TypeError2 } = context;
      var arrayProto = Array3.prototype, funcProto = Function3.prototype, objectProto = Object3.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object3);
      var oldDash = root._;
      var reIsNative = RegExp3("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context.Buffer : undefined6, Symbol3 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined6, getPrototype = overArg(Object3.getPrototypeOf, Object3), objectCreate = Object3.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol3 ? Symbol3.isConcatSpreadable : undefined6, symIterator = Symbol3 ? Symbol3.iterator : undefined6, symToStringTag = Symbol3 ? Symbol3.toStringTag : undefined6;
      var defineProperty = function() {
        try {
          var func = getNative(Object3, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e2) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date3 && Date3.now !== root.Date.now && Date3.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var { ceil: nativeCeil, floor: nativeFloor } = Math2, nativeGetSymbols = Object3.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined6, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object3.keys, Object3), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date3.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise3 = getNative(context, "Promise"), Set5 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object3, "create");
      var metaMap = WeakMap2 && new WeakMap2;
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise3), setCtorString = toSource(Set5), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol3 ? Symbol3.prototype : undefined6, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined6, symbolToString = symbolProto ? symbolProto.toString : undefined6;
      function lodash(value15) {
        if (isObjectLike(value15) && !isArray(value15) && !(value15 instanceof LazyWrapper)) {
          if (value15 instanceof LodashWrapper) {
            return value15;
          }
          if (hasOwnProperty.call(value15, "__wrapped__")) {
            return wrapperClone(value15);
          }
        }
        return new LodashWrapper(value15);
      }
      var baseCreate = function() {
        function object13() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object13.prototype = proto;
          var result3 = new object13;
          object13.prototype = undefined6;
          return result3;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value15, chainAll) {
        this.__wrapped__ = value15;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined6;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value15) {
        this.__wrapped__ = value15;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result3 = new LazyWrapper(this.__wrapped__);
        result3.__actions__ = copyArray(this.__actions__);
        result3.__dir__ = this.__dir__;
        result3.__filtered__ = this.__filtered__;
        result3.__iteratees__ = copyArray(this.__iteratees__);
        result3.__takeCount__ = this.__takeCount__;
        result3.__views__ = copyArray(this.__views__);
        return result3;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result3 = new LazyWrapper(this);
          result3.__dir__ = -1;
          result3.__filtered__ = true;
        } else {
          result3 = this.clone();
          result3.__dir__ *= -1;
        }
        return result3;
      }
      function lazyValue() {
        var array6 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array6), isRight = dir < 0, arrLength = isArr ? array6.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array6, this.__actions__);
        }
        var result3 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value15 = array6[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type75 = data.type, computed = iteratee2(value15);
              if (type75 == LAZY_MAP_FLAG) {
                value15 = computed;
              } else if (!computed) {
                if (type75 == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result3[resIndex++] = value15;
          }
        return result3;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash3(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result3 = this.has(key) && delete this.__data__[key];
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result3 = data[key];
          return result3 === HASH_UNDEFINED ? undefined6 : result3;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined6;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined6 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value15) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value15 === undefined6 ? HASH_UNDEFINED : value15;
        return this;
      }
      Hash3.prototype.clear = hashClear;
      Hash3.prototype["delete"] = hashDelete;
      Hash3.prototype.get = hashGet;
      Hash3.prototype.has = hashHas;
      Hash3.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined6 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value15) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value15]);
        } else {
          data[index][1] = value15;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash3,
          map: new (Map2 || ListCache),
          string: new Hash3
        };
      }
      function mapCacheDelete(key) {
        var result3 = getMapData(this, key)["delete"](key);
        this.size -= result3 ? 1 : 0;
        return result3;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value15) {
        var data = getMapData(this, key), size3 = data.size;
        data.set(key, value15);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values3) {
        var index = -1, length = values3 == null ? 0 : values3.length;
        this.__data__ = new MapCache;
        while (++index < length) {
          this.add(values3[index]);
        }
      }
      function setCacheAdd(value15) {
        this.__data__.set(value15, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value15) {
        return this.__data__.has(value15);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache;
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result3 = data["delete"](key);
        this.size = data.size;
        return result3;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value15) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value15]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value15);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value15, inherited) {
        var isArr = isArray(value15), isArg = !isArr && isArguments(value15), isBuff = !isArr && !isArg && isBuffer(value15), isType = !isArr && !isArg && !isBuff && isTypedArray(value15), skipIndexes = isArr || isArg || isBuff || isType, result3 = skipIndexes ? baseTimes(value15.length, String3) : [], length = result3.length;
        for (var key in value15) {
          if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function arraySample(array6) {
        var length = array6.length;
        return length ? array6[baseRandom(0, length - 1)] : undefined6;
      }
      function arraySampleSize(array6, n2) {
        return shuffleSelf(copyArray(array6), baseClamp(n2, 0, array6.length));
      }
      function arrayShuffle(array6) {
        return shuffleSelf(copyArray(array6));
      }
      function assignMergeValue(object13, key, value15) {
        if (value15 !== undefined6 && !eq2(object13[key], value15) || value15 === undefined6 && !(key in object13)) {
          baseAssignValue(object13, key, value15);
        }
      }
      function assignValue(object13, key, value15) {
        var objValue = object13[key];
        if (!(hasOwnProperty.call(object13, key) && eq2(objValue, value15)) || value15 === undefined6 && !(key in object13)) {
          baseAssignValue(object13, key, value15);
        }
      }
      function assocIndexOf(array6, key) {
        var length = array6.length;
        while (length--) {
          if (eq2(array6[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value15, key, collection2) {
          setter(accumulator, value15, iteratee2(value15), collection2);
        });
        return accumulator;
      }
      function baseAssign(object13, source) {
        return object13 && copyObject(source, keys(source), object13);
      }
      function baseAssignIn(object13, source) {
        return object13 && copyObject(source, keysIn(source), object13);
      }
      function baseAssignValue(object13, key, value15) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object13, key, {
            configurable: true,
            enumerable: true,
            value: value15,
            writable: true
          });
        } else {
          object13[key] = value15;
        }
      }
      function baseAt(object13, paths) {
        var index = -1, length = paths.length, result3 = Array3(length), skip = object13 == null;
        while (++index < length) {
          result3[index] = skip ? undefined6 : get(object13, paths[index]);
        }
        return result3;
      }
      function baseClamp(number7, lower, upper) {
        if (number7 === number7) {
          if (upper !== undefined6) {
            number7 = number7 <= upper ? number7 : upper;
          }
          if (lower !== undefined6) {
            number7 = number7 >= lower ? number7 : lower;
          }
        }
        return number7;
      }
      function baseClone(value15, bitmask, customizer, key, object13, stack) {
        var result3, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result3 = object13 ? customizer(value15, key, object13, stack) : customizer(value15);
        }
        if (result3 !== undefined6) {
          return result3;
        }
        if (!isObject(value15)) {
          return value15;
        }
        var isArr = isArray(value15);
        if (isArr) {
          result3 = initCloneArray(value15);
          if (!isDeep) {
            return copyArray(value15, result3);
          }
        } else {
          var tag = getTag(value15), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value15)) {
            return cloneBuffer(value15, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object13) {
            result3 = isFlat || isFunc ? {} : initCloneObject(value15);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value15, baseAssignIn(result3, value15)) : copySymbols(value15, baseAssign(result3, value15));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object13 ? value15 : {};
            }
            result3 = initCloneByTag(value15, tag, isDeep);
          }
        }
        stack || (stack = new Stack);
        var stacked = stack.get(value15);
        if (stacked) {
          return stacked;
        }
        stack.set(value15, result3);
        if (isSet(value15)) {
          value15.forEach(function(subValue) {
            result3.add(baseClone(subValue, bitmask, customizer, subValue, value15, stack));
          });
        } else if (isMap(value15)) {
          value15.forEach(function(subValue, key2) {
            result3.set(key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined6 : keysFunc(value15);
        arrayEach(props || value15, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value15[key2];
          }
          assignValue(result3, key2, baseClone(subValue, bitmask, customizer, key2, value15, stack));
        });
        return result3;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object13) {
          return baseConformsTo(object13, source, props);
        };
      }
      function baseConformsTo(object13, source, props) {
        var length = props.length;
        if (object13 == null) {
          return !length;
        }
        object13 = Object3(object13);
        while (length--) {
          var key = props[length], predicate = source[key], value15 = object13[key];
          if (value15 === undefined6 && !(key in object13) || !predicate(value15)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined6, args);
        }, wait);
      }
      function baseDifference(array6, values3, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array6.length, result3 = [], valuesLength = values3.length;
        if (!length) {
          return result3;
        }
        if (iteratee2) {
          values3 = arrayMap(values3, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values3.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values3 = new SetCache(values3);
        }
        outer:
          while (++index < length) {
            var value15 = array6[index], computed = iteratee2 == null ? value15 : iteratee2(value15);
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values3[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result3.push(value15);
            } else if (!includes2(values3, computed, comparator)) {
              result3.push(value15);
            }
          }
        return result3;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result3 = true;
        baseEach(collection, function(value15, index, collection2) {
          result3 = !!predicate(value15, index, collection2);
          return result3;
        });
        return result3;
      }
      function baseExtremum(array6, iteratee2, comparator) {
        var index = -1, length = array6.length;
        while (++index < length) {
          var value15 = array6[index], current = iteratee2(value15);
          if (current != null && (computed === undefined6 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result3 = value15;
          }
        }
        return result3;
      }
      function baseFill(array6, value15, start, end) {
        var length = array6.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined6 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array6[start++] = value15;
        }
        return array6;
      }
      function baseFilter(collection, predicate) {
        var result3 = [];
        baseEach(collection, function(value15, index, collection2) {
          if (predicate(value15, index, collection2)) {
            result3.push(value15);
          }
        });
        return result3;
      }
      function baseFlatten(array6, depth, predicate, isStrict, result3) {
        var index = -1, length = array6.length;
        predicate || (predicate = isFlattenable);
        result3 || (result3 = []);
        while (++index < length) {
          var value15 = array6[index];
          if (depth > 0 && predicate(value15)) {
            if (depth > 1) {
              baseFlatten(value15, depth - 1, predicate, isStrict, result3);
            } else {
              arrayPush(result3, value15);
            }
          } else if (!isStrict) {
            result3[result3.length] = value15;
          }
        }
        return result3;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object13, iteratee2) {
        return object13 && baseFor(object13, iteratee2, keys);
      }
      function baseForOwnRight(object13, iteratee2) {
        return object13 && baseForRight(object13, iteratee2, keys);
      }
      function baseFunctions(object13, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object13[key]);
        });
      }
      function baseGet(object13, path) {
        path = castPath(path, object13);
        var index = 0, length = path.length;
        while (object13 != null && index < length) {
          object13 = object13[toKey(path[index++])];
        }
        return index && index == length ? object13 : undefined6;
      }
      function baseGetAllKeys(object13, keysFunc, symbolsFunc) {
        var result3 = keysFunc(object13);
        return isArray(object13) ? result3 : arrayPush(result3, symbolsFunc(object13));
      }
      function baseGetTag(value15) {
        if (value15 == null) {
          return value15 === undefined6 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object3(value15) ? getRawTag(value15) : objectToString(value15);
      }
      function baseGt(value15, other) {
        return value15 > other;
      }
      function baseHas(object13, key) {
        return object13 != null && hasOwnProperty.call(object13, key);
      }
      function baseHasIn(object13, key) {
        return object13 != null && key in Object3(object13);
      }
      function baseInRange(number7, start, end) {
        return number7 >= nativeMin(start, end) && number7 < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array3(othLength), maxLength = Infinity, result3 = [];
        while (othIndex--) {
          var array6 = arrays[othIndex];
          if (othIndex && iteratee2) {
            array6 = arrayMap(array6, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array6.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array6.length >= 120) ? new SetCache(othIndex && array6) : undefined6;
        }
        array6 = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result3.length < maxLength) {
            var value15 = array6[index], computed = iteratee2 ? iteratee2(value15) : value15;
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result3, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result3.push(value15);
            }
          }
        return result3;
      }
      function baseInverter(object13, setter, iteratee2, accumulator) {
        baseForOwn(object13, function(value15, key, object14) {
          setter(accumulator, iteratee2(value15), key, object14);
        });
        return accumulator;
      }
      function baseInvoke(object13, path, args) {
        path = castPath(path, object13);
        object13 = parent(object13, path);
        var func = object13 == null ? object13 : object13[toKey(last(path))];
        return func == null ? undefined6 : apply(func, object13, args);
      }
      function baseIsArguments(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == argsTag;
      }
      function baseIsArrayBuffer(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == arrayBufferTag;
      }
      function baseIsDate(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == dateTag;
      }
      function baseIsEqual(value15, other, bitmask, customizer, stack) {
        if (value15 === other) {
          return true;
        }
        if (value15 == null || other == null || !isObjectLike(value15) && !isObjectLike(other)) {
          return value15 !== value15 && other !== other;
        }
        return baseIsEqualDeep(value15, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object13, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object13), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object13), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object13)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack);
          return objIsArr || isTypedArray(object13) ? equalArrays(object13, other, bitmask, customizer, equalFunc, stack) : equalByTag(object13, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object13, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object13.value() : object13, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack);
        return equalObjects(object13, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value15) {
        return isObjectLike(value15) && getTag(value15) == mapTag;
      }
      function baseIsMatch(object13, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object13 == null) {
          return !length;
        }
        object13 = Object3(object13);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object13[data[0]] : !(data[0] in object13)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object13[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined6 && !(key in object13)) {
              return false;
            }
          } else {
            var stack = new Stack;
            if (customizer) {
              var result3 = customizer(objValue, srcValue, key, object13, source, stack);
            }
            if (!(result3 === undefined6 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result3)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value15) {
        if (!isObject(value15) || isMasked(value15)) {
          return false;
        }
        var pattern3 = isFunction(value15) ? reIsNative : reIsHostCtor;
        return pattern3.test(toSource(value15));
      }
      function baseIsRegExp(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == regexpTag;
      }
      function baseIsSet(value15) {
        return isObjectLike(value15) && getTag(value15) == setTag;
      }
      function baseIsTypedArray(value15) {
        return isObjectLike(value15) && isLength(value15.length) && !!typedArrayTags[baseGetTag(value15)];
      }
      function baseIteratee(value15) {
        if (typeof value15 == "function") {
          return value15;
        }
        if (value15 == null) {
          return identity;
        }
        if (typeof value15 == "object") {
          return isArray(value15) ? baseMatchesProperty(value15[0], value15[1]) : baseMatches(value15);
        }
        return property(value15);
      }
      function baseKeys(object13) {
        if (!isPrototype(object13)) {
          return nativeKeys(object13);
        }
        var result3 = [];
        for (var key in Object3(object13)) {
          if (hasOwnProperty.call(object13, key) && key != "constructor") {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseKeysIn(object13) {
        if (!isObject(object13)) {
          return nativeKeysIn(object13);
        }
        var isProto = isPrototype(object13), result3 = [];
        for (var key in object13) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object13, key)))) {
            result3.push(key);
          }
        }
        return result3;
      }
      function baseLt(value15, other) {
        return value15 < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result3 = isArrayLike(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value15, key, collection2) {
          result3[++index] = iteratee2(value15, key, collection2);
        });
        return result3;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object13) {
          return object13 === source || baseIsMatch(object13, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object13) {
          var objValue = get(object13, path);
          return objValue === undefined6 && objValue === srcValue ? hasIn(object13, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object13, source, srcIndex, customizer, stack) {
        if (object13 === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack);
          if (isObject(srcValue)) {
            baseMergeDeep(object13, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object13, key), srcValue, key + "", object13, source, stack) : undefined6;
            if (newValue === undefined6) {
              newValue = srcValue;
            }
            assignMergeValue(object13, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object13, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object13, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object13, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object13, source, stack) : undefined6;
        var isCommon = newValue === undefined6;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object13, key, newValue);
      }
      function baseNth(array6, n2) {
        var length = array6.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array6[n2] : undefined6;
      }
      function baseOrderBy(collection, iteratees, orders6) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value15) {
                return baseGet(value15, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result3 = baseMap(collection, function(value15, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value15);
          });
          return { criteria, index: ++index, value: value15 };
        });
        return baseSortBy(result3, function(object13, other) {
          return compareMultiple(object13, other, orders6);
        });
      }
      function basePick(object13, paths) {
        return basePickBy(object13, paths, function(value15, path) {
          return hasIn(object13, path);
        });
      }
      function basePickBy(object13, paths, predicate) {
        var index = -1, length = paths.length, result3 = {};
        while (++index < length) {
          var path = paths[index], value15 = baseGet(object13, path);
          if (predicate(value15, path)) {
            baseSet(result3, castPath(path, object13), value15);
          }
        }
        return result3;
      }
      function basePropertyDeep(path) {
        return function(object13) {
          return baseGet(object13, path);
        };
      }
      function basePullAll(array6, values3, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values3.length, seen = array6;
        if (array6 === values3) {
          values3 = copyArray(values3);
        }
        if (iteratee2) {
          seen = arrayMap(array6, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value15 = values3[index], computed = iteratee2 ? iteratee2(value15) : value15;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array6) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array6, fromIndex, 1);
          }
        }
        return array6;
      }
      function basePullAt(array6, indexes) {
        var length = array6 ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array6, index, 1);
            } else {
              baseUnset(array6, index);
            }
          }
        }
        return array6;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result3 = Array3(length);
        while (length--) {
          result3[fromRight ? length : ++index] = start;
          start += step;
        }
        return result3;
      }
      function baseRepeat(string7, n2) {
        var result3 = "";
        if (!string7 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result3;
        }
        do {
          if (n2 % 2) {
            result3 += string7;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string7 += string7;
          }
        } while (n2);
        return result3;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values2(collection));
      }
      function baseSampleSize(collection, n2) {
        var array6 = values2(collection);
        return shuffleSelf(array6, baseClamp(n2, 0, array6.length));
      }
      function baseSet(object13, path, value15, customizer) {
        if (!isObject(object13)) {
          return object13;
        }
        path = castPath(path, object13);
        var index = -1, length = path.length, lastIndex = length - 1, nested = object13;
        while (nested != null && ++index < length) {
          var key = toKey(path[index]), newValue = value15;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object13;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined6;
            if (newValue === undefined6) {
              newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object13;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string7) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string7),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values2(collection));
      }
      function baseSlice(array6, start, end) {
        var index = -1, length = array6.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result3 = Array3(length);
        while (++index < length) {
          result3[index] = array6[index + start];
        }
        return result3;
      }
      function baseSome(collection, predicate) {
        var result3;
        baseEach(collection, function(value15, index, collection2) {
          result3 = predicate(value15, index, collection2);
          return !result3;
        });
        return !!result3;
      }
      function baseSortedIndex(array6, value15, retHighest) {
        var low = 0, high = array6 == null ? low : array6.length;
        if (typeof value15 == "number" && value15 === value15 && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array6[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value15 : computed < value15)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array6, value15, identity, retHighest);
      }
      function baseSortedIndexBy(array6, value15, iteratee2, retHighest) {
        var low = 0, high = array6 == null ? 0 : array6.length;
        if (high === 0) {
          return 0;
        }
        value15 = iteratee2(value15);
        var valIsNaN = value15 !== value15, valIsNull = value15 === null, valIsSymbol = isSymbol(value15), valIsUndefined = value15 === undefined6;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array6[mid]), othIsDefined = computed !== undefined6, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value15 : computed < value15;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array6, iteratee2) {
        var index = -1, length = array6.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value15 = array6[index], computed = iteratee2 ? iteratee2(value15) : value15;
          if (!index || !eq2(computed, seen)) {
            var seen = computed;
            result3[resIndex++] = value15 === 0 ? 0 : value15;
          }
        }
        return result3;
      }
      function baseToNumber(value15) {
        if (typeof value15 == "number") {
          return value15;
        }
        if (isSymbol(value15)) {
          return NAN;
        }
        return +value15;
      }
      function baseToString(value15) {
        if (typeof value15 == "string") {
          return value15;
        }
        if (isArray(value15)) {
          return arrayMap(value15, baseToString) + "";
        }
        if (isSymbol(value15)) {
          return symbolToString ? symbolToString.call(value15) : "";
        }
        var result3 = value15 + "";
        return result3 == "0" && 1 / value15 == -INFINITY ? "-0" : result3;
      }
      function baseUniq(array6, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array6.length, isCommon = true, result3 = [], seen = result3;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array6);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache;
        } else {
          seen = iteratee2 ? [] : result3;
        }
        outer:
          while (++index < length) {
            var value15 = array6[index], computed = iteratee2 ? iteratee2(value15) : value15;
            value15 = comparator || value15 !== 0 ? value15 : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result3.push(value15);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result3) {
                seen.push(computed);
              }
              result3.push(value15);
            }
          }
        return result3;
      }
      function baseUnset(object13, path) {
        path = castPath(path, object13);
        object13 = parent(object13, path);
        return object13 == null || delete object13[toKey(last(path))];
      }
      function baseUpdate(object13, path, updater, customizer) {
        return baseSet(object13, path, updater(baseGet(object13, path)), customizer);
      }
      function baseWhile(array6, predicate, isDrop, fromRight) {
        var length = array6.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array6[index], index, array6)) {
        }
        return isDrop ? baseSlice(array6, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array6, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value15, actions) {
        var result3 = value15;
        if (result3 instanceof LazyWrapper) {
          result3 = result3.value();
        }
        return arrayReduce(actions, function(result4, action) {
          return action.func.apply(action.thisArg, arrayPush([result4], action.args));
        }, result3);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result3 = Array3(length);
        while (++index < length) {
          var array6 = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result3[index] = baseDifference(result3[index] || array6, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result3, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values3, assignFunc) {
        var index = -1, length = props.length, valsLength = values3.length, result3 = {};
        while (++index < length) {
          var value15 = index < valsLength ? values3[index] : undefined6;
          assignFunc(result3, props[index], value15);
        }
        return result3;
      }
      function castArrayLikeObject(value15) {
        return isArrayLikeObject(value15) ? value15 : [];
      }
      function castFunction(value15) {
        return typeof value15 == "function" ? value15 : identity;
      }
      function castPath(value15, object13) {
        if (isArray(value15)) {
          return value15;
        }
        return isKey(value15, object13) ? [value15] : stringToPath(toString(value15));
      }
      var castRest = baseRest;
      function castSlice(array6, start, end) {
        var length = array6.length;
        end = end === undefined6 ? length : end;
        return !start && end >= length ? array6 : baseSlice(array6, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result3 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result3);
        return result3;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result3 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array3(result3).set(new Uint8Array3(arrayBuffer));
        return result3;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp4) {
        var result3 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
        result3.lastIndex = regexp4.lastIndex;
        return result3;
      }
      function cloneSymbol(symbol5) {
        return symbolValueOf ? Object3(symbolValueOf.call(symbol5)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value15, other) {
        if (value15 !== other) {
          var valIsDefined = value15 !== undefined6, valIsNull = value15 === null, valIsReflexive = value15 === value15, valIsSymbol = isSymbol(value15);
          var othIsDefined = other !== undefined6, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value15 > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value15 < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object13, other, orders6) {
        var index = -1, objCriteria = object13.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders6.length;
        while (++index < length) {
          var result3 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result3) {
            if (index >= ordersLength) {
              return result3;
            }
            var order = orders6[index];
            return result3 * (order == "desc" ? -1 : 1);
          }
        }
        return object13.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array3(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result3[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result3[leftIndex++] = args[argsIndex++];
        }
        return result3;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result3 = Array3(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result3[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result3[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result3[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result3;
      }
      function copyArray(source, array6) {
        var index = -1, length = source.length;
        array6 || (array6 = Array3(length));
        while (++index < length) {
          array6[index] = source[index];
        }
        return array6;
      }
      function copyObject(source, props, object13, customizer) {
        var isNew = !object13;
        object13 || (object13 = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined6;
          if (newValue === undefined6) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object13, key, newValue);
          } else {
            assignValue(object13, key, newValue);
          }
        }
        return object13;
      }
      function copySymbols(source, object13) {
        return copyObject(source, getSymbols(source), object13);
      }
      function copySymbolsIn(source, object13) {
        return copyObject(source, getSymbolsIn(source), object13);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object13, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined6, guard22 = length > 2 ? sources[2] : undefined6;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined6;
          if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
            customizer = length < 3 ? undefined6 : customizer;
            length = 1;
          }
          object13 = Object3(object13);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object13, source, index, customizer);
            }
          }
          return object13;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object3(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object13, iteratee2, keysFunc) {
          var index = -1, iterable = Object3(object13), props = keysFunc(object13), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object13;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string7) {
          string7 = toString(string7);
          var strSymbols = hasUnicode(string7) ? stringToArray(string7) : undefined6;
          var chr = strSymbols ? strSymbols[0] : string7.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string7.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string7) {
          return arrayReduce(words(deburr(string7).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor;
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result3 = Ctor.apply(thisBinding, args);
          return isObject(result3) ? result3 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined6, args, holders, undefined6, undefined6, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object3(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined6;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined6;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value15 = args[0];
            if (wrapper && args.length == 1 && isArray(value15)) {
              return wrapper.plant(value15).value();
            }
            var index2 = 0, result3 = length ? funcs[index2].apply(this, args) : value15;
            while (++index2 < length) {
              result3 = funcs[index2].call(this, result3);
            }
            return result3;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined6 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array3(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object13, iteratee2) {
          return baseInverter(object13, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value15, other) {
          var result3;
          if (value15 === undefined6 && other === undefined6) {
            return defaultValue;
          }
          if (value15 !== undefined6) {
            result3 = value15;
          }
          if (other !== undefined6) {
            if (result3 === undefined6) {
              return other;
            }
            if (typeof value15 == "string" || typeof other == "string") {
              value15 = baseToString(value15);
              other = baseToString(other);
            } else {
              value15 = baseToNumber(value15);
              other = baseToNumber(other);
            }
            result3 = operator(value15, other);
          }
          return result3;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined6 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result3 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result3), 0, length).join("") : result3.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array3(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined6;
          }
          start = toFinite(start);
          if (end === undefined6) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined6 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value15, other) {
          if (!(typeof value15 == "string" && typeof other == "string")) {
            value15 = toNumber(value15);
            other = toNumber(other);
          }
          return operator(value15, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined6, newHoldersRight = isCurry ? undefined6 : holders, newPartials = isCurry ? partials : undefined6, newPartialsRight = isCurry ? undefined6 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result3 = wrapFunc.apply(undefined6, newData);
        if (isLaziable(func)) {
          setData(result3, newData);
        }
        result3.placeholder = placeholder;
        return setWrapToString(result3, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number7, precision) {
          number7 = toNumber(number7);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number7)) {
            var pair = (toString(number7) + "e").split("e"), value15 = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value15) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number7);
        };
      }
      var createSet = !(Set5 && 1 / setToArray(new Set5([, -0]))[1] == INFINITY) ? noop3 : function(values3) {
        return new Set5(values3);
      };
      function createToPairs(keysFunc) {
        return function(object13) {
          var tag = getTag(object13);
          if (tag == mapTag) {
            return mapToArray(object13);
          }
          if (tag == setTag) {
            return setToPairs(object13);
          }
          return baseToPairs(object13, keysFunc(object13));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined6;
        }
        ary2 = ary2 === undefined6 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined6 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined6;
        }
        var data = isBindKey ? undefined6 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined6 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result3 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result3 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result3 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result3 = createHybrid.apply(undefined6, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result3, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object13) {
        if (objValue === undefined6 || eq2(objValue, objectProto[key]) && !hasOwnProperty.call(object13, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object13, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined6, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value15) {
        return isPlainObject(value15) ? undefined6 : value15;
      }
      function equalArrays(array6, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array6.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array6);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array6;
        }
        var index = -1, result3 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined6;
        stack.set(array6, other);
        stack.set(other, array6);
        while (++index < arrLength) {
          var arrValue = array6[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array6, stack) : customizer(arrValue, othValue, index, array6, other, stack);
          }
          if (compared !== undefined6) {
            if (compared) {
              continue;
            }
            result3 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result3 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result3 = false;
            break;
          }
        }
        stack["delete"](array6);
        stack["delete"](other);
        return result3;
      }
      function equalByTag(object13, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object13.byteLength != other.byteLength || object13.byteOffset != other.byteOffset) {
              return false;
            }
            object13 = object13.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object13.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object13), new Uint8Array3(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq2(+object13, +other);
          case errorTag:
            return object13.name == other.name && object13.message == other.message;
          case regexpTag:
          case stringTag:
            return object13 == other + "";
          case mapTag:
            var convert4 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert4 || (convert4 = setToArray);
            if (object13.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object13);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object13, other);
            var result3 = equalArrays(convert4(object13), convert4(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object13);
            return result3;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object13) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object13, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object13), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object13);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object13;
        }
        var result3 = true;
        stack.set(object13, other);
        stack.set(other, object13);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object13[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object13, stack) : customizer(objValue, othValue, key, object13, other, stack);
          }
          if (!(compared === undefined6 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result3 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result3 && !skipCtor) {
          var objCtor = object13.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && (("constructor" in object13) && ("constructor" in other)) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result3 = false;
          }
        }
        stack["delete"](object13);
        stack["delete"](other);
        return result3;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined6, flatten), func + "");
      }
      function getAllKeys(object13) {
        return baseGetAllKeys(object13, keys, getSymbols);
      }
      function getAllKeysIn(object13) {
        return baseGetAllKeys(object13, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop3 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result3 = func.name + "", array6 = realNames[result3], length = hasOwnProperty.call(realNames, result3) ? array6.length : 0;
        while (length--) {
          var data = array6[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result3;
      }
      function getHolder(func) {
        var object13 = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object13.placeholder;
      }
      function getIteratee() {
        var result3 = lodash.iteratee || iteratee;
        result3 = result3 === iteratee ? baseIteratee : result3;
        return arguments.length ? result3(arguments[0], arguments[1]) : result3;
      }
      function getMapData(map4, key) {
        var data = map4.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object13) {
        var result3 = keys(object13), length = result3.length;
        while (length--) {
          var key = result3[length], value15 = object13[key];
          result3[length] = [key, value15, isStrictComparable(value15)];
        }
        return result3;
      }
      function getNative(object13, key) {
        var value15 = getValue(object13, key);
        return baseIsNative(value15) ? value15 : undefined6;
      }
      function getRawTag(value15) {
        var isOwn = hasOwnProperty.call(value15, symToStringTag), tag = value15[symToStringTag];
        try {
          value15[symToStringTag] = undefined6;
          var unmasked = true;
        } catch (e2) {
        }
        var result3 = nativeObjectToString.call(value15);
        if (unmasked) {
          if (isOwn) {
            value15[symToStringTag] = tag;
          } else {
            delete value15[symToStringTag];
          }
        }
        return result3;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object13) {
        if (object13 == null) {
          return [];
        }
        object13 = Object3(object13);
        return arrayFilter(nativeGetSymbols(object13), function(symbol5) {
          return propertyIsEnumerable.call(object13, symbol5);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object13) {
        var result3 = [];
        while (object13) {
          arrayPush(result3, getSymbols(object13));
          object13 = getPrototype(object13);
        }
        return result3;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
        getTag = function(value15) {
          var result3 = baseGetTag(value15), Ctor = result3 == objectTag ? value15.constructor : undefined6, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result3;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size3 = data.size;
          switch (data.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax(start, end - size3);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object13, path, hasFunc) {
        path = castPath(path, object13);
        var index = -1, length = path.length, result3 = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result3 = object13 != null && hasFunc(object13, key))) {
            break;
          }
          object13 = object13[key];
        }
        if (result3 || ++index != length) {
          return result3;
        }
        length = object13 == null ? 0 : object13.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object13) || isArguments(object13));
      }
      function initCloneArray(array6) {
        var length = array6.length, result3 = new array6.constructor(length);
        if (length && typeof array6[0] == "string" && hasOwnProperty.call(array6, "index")) {
          result3.index = array6.index;
          result3.input = array6.input;
        }
        return result3;
      }
      function initCloneObject(object13) {
        return typeof object13.constructor == "function" && !isPrototype(object13) ? baseCreate(getPrototype(object13)) : {};
      }
      function initCloneByTag(object13, tag, isDeep) {
        var Ctor = object13.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object13);
          case boolTag:
          case dateTag:
            return new Ctor(+object13);
          case dataViewTag:
            return cloneDataView(object13, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object13, isDeep);
          case mapTag:
            return new Ctor;
          case numberTag:
          case stringTag:
            return new Ctor(object13);
          case regexpTag:
            return cloneRegExp(object13);
          case setTag:
            return new Ctor;
          case symbolTag:
            return cloneSymbol(object13);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value15) {
        return isArray(value15) || isArguments(value15) || !!(spreadableSymbol && value15 && value15[spreadableSymbol]);
      }
      function isIndex(value15, length) {
        var type75 = typeof value15;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type75 == "number" || type75 != "symbol" && reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
      }
      function isIterateeCall(value15, index, object13) {
        if (!isObject(object13)) {
          return false;
        }
        var type75 = typeof index;
        if (type75 == "number" ? isArrayLike(object13) && isIndex(index, object13.length) : type75 == "string" && (index in object13)) {
          return eq2(object13[index], value15);
        }
        return false;
      }
      function isKey(value15, object13) {
        if (isArray(value15)) {
          return false;
        }
        var type75 = typeof value15;
        if (type75 == "number" || type75 == "symbol" || type75 == "boolean" || value15 == null || isSymbol(value15)) {
          return true;
        }
        return reIsPlainProp.test(value15) || !reIsDeepProp.test(value15) || object13 != null && value15 in Object3(object13);
      }
      function isKeyable(value15) {
        var type75 = typeof value15;
        return type75 == "string" || type75 == "number" || type75 == "symbol" || type75 == "boolean" ? value15 !== "__proto__" : value15 === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value15) {
        var Ctor = value15 && value15.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value15 === proto;
      }
      function isStrictComparable(value15) {
        return value15 === value15 && !isObject(value15);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object13) {
          if (object13 == null) {
            return false;
          }
          return object13[key] === srcValue && (srcValue !== undefined6 || (key in Object3(object13)));
        };
      }
      function memoizeCapped(func) {
        var result3 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result3.cache;
        return result3;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value15 = source[3];
        if (value15) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value15, source[4]) : value15;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value15 = source[5];
        if (value15) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value15, source[6]) : value15;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value15 = source[7];
        if (value15) {
          data[7] = value15;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object13) {
        var result3 = [];
        if (object13 != null) {
          for (var key in Object3(object13)) {
            result3.push(key);
          }
        }
        return result3;
      }
      function objectToString(value15) {
        return nativeObjectToString.call(value15);
      }
      function overRest(func, start, transform8) {
        start = nativeMax(start === undefined6 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array6 = Array3(length);
          while (++index < length) {
            array6[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array3(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform8(array6);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object13, path) {
        return path.length < 2 ? object13 : baseGet(object13, baseSlice(path, 0, -1));
      }
      function reorder(array6, indexes) {
        var arrLength = array6.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array6);
        while (length--) {
          var index = indexes[length];
          array6[length] = isIndex(index, arrLength) ? oldArray[index] : undefined6;
        }
        return array6;
      }
      function safeGet(object13, key) {
        if (key === "constructor" && typeof object13[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object13[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined6, arguments);
        };
      }
      function shuffleSelf(array6, size3) {
        var index = -1, length = array6.length, lastIndex = length - 1;
        size3 = size3 === undefined6 ? length : size3;
        while (++index < size3) {
          var rand = baseRandom(index, lastIndex), value15 = array6[rand];
          array6[rand] = array6[index];
          array6[index] = value15;
        }
        array6.length = size3;
        return array6;
      }
      var stringToPath = memoizeCapped(function(string7) {
        var result3 = [];
        if (string7.charCodeAt(0) === 46) {
          result3.push("");
        }
        string7.replace(rePropName, function(match, number7, quote, subString) {
          result3.push(quote ? subString.replace(reEscapeChar, "$1") : number7 || match);
        });
        return result3;
      });
      function toKey(value15) {
        if (typeof value15 == "string" || isSymbol(value15)) {
          return value15;
        }
        var result3 = value15 + "";
        return result3 == "0" && 1 / value15 == -INFINITY ? "-0" : result3;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e2) {
          }
          try {
            return func + "";
          } catch (e2) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value15 = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value15)) {
            details.push(value15);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result3 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result3.__actions__ = copyArray(wrapper.__actions__);
        result3.__index__ = wrapper.__index__;
        result3.__values__ = wrapper.__values__;
        return result3;
      }
      function chunk(array6, size3, guard22) {
        if (guard22 ? isIterateeCall(array6, size3, guard22) : size3 === undefined6) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger(size3), 0);
        }
        var length = array6 == null ? 0 : array6.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result3 = Array3(nativeCeil(length / size3));
        while (index < length) {
          result3[resIndex++] = baseSlice(array6, index, index += size3);
        }
        return result3;
      }
      function compact(array6) {
        var index = -1, length = array6 == null ? 0 : array6.length, resIndex = 0, result3 = [];
        while (++index < length) {
          var value15 = array6[index];
          if (value15) {
            result3[resIndex++] = value15;
          }
        }
        return result3;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array3(length - 1), array6 = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array6) ? copyArray(array6) : [array6], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array6, values3) {
        return isArrayLikeObject(array6) ? baseDifference(array6, baseFlatten(values3, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array6, values3) {
        var iteratee2 = last(values3);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return isArrayLikeObject(array6) ? baseDifference(array6, baseFlatten(values3, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array6, values3) {
        var comparator = last(values3);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined6;
        }
        return isArrayLikeObject(array6) ? baseDifference(array6, baseFlatten(values3, 1, isArrayLikeObject, true), undefined6, comparator) : [];
      });
      function drop(array6, n2, guard22) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        n2 = guard22 || n2 === undefined6 ? 1 : toInteger(n2);
        return baseSlice(array6, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array6, n2, guard22) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        n2 = guard22 || n2 === undefined6 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array6, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array6, predicate) {
        return array6 && array6.length ? baseWhile(array6, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array6, predicate) {
        return array6 && array6.length ? baseWhile(array6, getIteratee(predicate, 3), true) : [];
      }
      function fill(array6, value15, start, end) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array6, value15, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array6, value15, start, end);
      }
      function findIndex(array6, predicate, fromIndex) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array6, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array6, predicate, fromIndex) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined6) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array6, getIteratee(predicate, 3), index, true);
      }
      function flatten(array6) {
        var length = array6 == null ? 0 : array6.length;
        return length ? baseFlatten(array6, 1) : [];
      }
      function flattenDeep(array6) {
        var length = array6 == null ? 0 : array6.length;
        return length ? baseFlatten(array6, INFINITY) : [];
      }
      function flattenDepth(array6, depth) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined6 ? 1 : toInteger(depth);
        return baseFlatten(array6, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result3 = {};
        while (++index < length) {
          var pair = pairs[index];
          result3[pair[0]] = pair[1];
        }
        return result3;
      }
      function head(array6) {
        return array6 && array6.length ? array6[0] : undefined6;
      }
      function indexOf(array6, value15, fromIndex) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array6, value15, index);
      }
      function initial(array6) {
        var length = array6 == null ? 0 : array6.length;
        return length ? baseSlice(array6, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped20 = arrayMap(arrays, castArrayLikeObject);
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped20 = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped20)) {
          iteratee2 = undefined6;
        } else {
          mapped20.pop();
        }
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped20 = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        if (comparator) {
          mapped20.pop();
        }
        return mapped20.length && mapped20[0] === arrays[0] ? baseIntersection(mapped20, undefined6, comparator) : [];
      });
      function join(array6, separator) {
        return array6 == null ? "" : nativeJoin.call(array6, separator);
      }
      function last(array6) {
        var length = array6 == null ? 0 : array6.length;
        return length ? array6[length - 1] : undefined6;
      }
      function lastIndexOf(array6, value15, fromIndex) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined6) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value15 === value15 ? strictLastIndexOf(array6, value15, index) : baseFindIndex(array6, baseIsNaN, index, true);
      }
      function nth(array6, n2) {
        return array6 && array6.length ? baseNth(array6, toInteger(n2)) : undefined6;
      }
      var pull = baseRest(pullAll);
      function pullAll(array6, values3) {
        return array6 && array6.length && values3 && values3.length ? basePullAll(array6, values3) : array6;
      }
      function pullAllBy(array6, values3, iteratee2) {
        return array6 && array6.length && values3 && values3.length ? basePullAll(array6, values3, getIteratee(iteratee2, 2)) : array6;
      }
      function pullAllWith(array6, values3, comparator) {
        return array6 && array6.length && values3 && values3.length ? basePullAll(array6, values3, undefined6, comparator) : array6;
      }
      var pullAt = flatRest(function(array6, indexes) {
        var length = array6 == null ? 0 : array6.length, result3 = baseAt(array6, indexes);
        basePullAt(array6, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result3;
      });
      function remove(array6, predicate) {
        var result3 = [];
        if (!(array6 && array6.length)) {
          return result3;
        }
        var index = -1, indexes = [], length = array6.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value15 = array6[index];
          if (predicate(value15, index, array6)) {
            result3.push(value15);
            indexes.push(index);
          }
        }
        basePullAt(array6, indexes);
        return result3;
      }
      function reverse(array6) {
        return array6 == null ? array6 : nativeReverse.call(array6);
      }
      function slice(array6, start, end) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array6, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined6 ? length : toInteger(end);
        }
        return baseSlice(array6, start, end);
      }
      function sortedIndex(array6, value15) {
        return baseSortedIndex(array6, value15);
      }
      function sortedIndexBy(array6, value15, iteratee2) {
        return baseSortedIndexBy(array6, value15, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array6, value15) {
        var length = array6 == null ? 0 : array6.length;
        if (length) {
          var index = baseSortedIndex(array6, value15);
          if (index < length && eq2(array6[index], value15)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array6, value15) {
        return baseSortedIndex(array6, value15, true);
      }
      function sortedLastIndexBy(array6, value15, iteratee2) {
        return baseSortedIndexBy(array6, value15, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array6, value15) {
        var length = array6 == null ? 0 : array6.length;
        if (length) {
          var index = baseSortedIndex(array6, value15, true) - 1;
          if (eq2(array6[index], value15)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array6) {
        return array6 && array6.length ? baseSortedUniq(array6) : [];
      }
      function sortedUniqBy(array6, iteratee2) {
        return array6 && array6.length ? baseSortedUniq(array6, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array6) {
        var length = array6 == null ? 0 : array6.length;
        return length ? baseSlice(array6, 1, length) : [];
      }
      function take(array6, n2, guard22) {
        if (!(array6 && array6.length)) {
          return [];
        }
        n2 = guard22 || n2 === undefined6 ? 1 : toInteger(n2);
        return baseSlice(array6, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array6, n2, guard22) {
        var length = array6 == null ? 0 : array6.length;
        if (!length) {
          return [];
        }
        n2 = guard22 || n2 === undefined6 ? 1 : toInteger(n2);
        n2 = length - n2;
        return baseSlice(array6, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array6, predicate) {
        return array6 && array6.length ? baseWhile(array6, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array6, predicate) {
        return array6 && array6.length ? baseWhile(array6, getIteratee(predicate, 3)) : [];
      }
      var union23 = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined6, comparator);
      });
      function uniq(array6) {
        return array6 && array6.length ? baseUniq(array6) : [];
      }
      function uniqBy(array6, iteratee2) {
        return array6 && array6.length ? baseUniq(array6, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array6, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return array6 && array6.length ? baseUniq(array6, undefined6, comparator) : [];
      }
      function unzip(array6) {
        if (!(array6 && array6.length)) {
          return [];
        }
        var length = 0;
        array6 = arrayFilter(array6, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array6, baseProperty(index));
        });
      }
      function unzipWith(array6, iteratee2) {
        if (!(array6 && array6.length)) {
          return [];
        }
        var result3 = unzip(array6);
        if (iteratee2 == null) {
          return result3;
        }
        return arrayMap(result3, function(group) {
          return apply(iteratee2, undefined6, group);
        });
      }
      var without = baseRest(function(array6, values3) {
        return isArrayLikeObject(array6) ? baseDifference(array6, values3) : [];
      });
      var xor2 = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined6;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined6;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined6, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values3) {
        return baseZipObject(props || [], values3 || [], assignValue);
      }
      function zipObjectDeep(props, values3) {
        return baseZipObject(props || [], values3 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined6;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined6;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value15) {
        var result3 = lodash(value15);
        result3.__chain__ = true;
        return result3;
      }
      function tap(value15, interceptor) {
        interceptor(value15);
        return value15;
      }
      function thru(value15, interceptor) {
        return interceptor(value15);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value15 = this.__wrapped__, interceptor = function(object13) {
          return baseAt(object13, paths);
        };
        if (length > 1 || this.__actions__.length || !(value15 instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value15 = value15.slice(start, +start + (length ? 1 : 0));
        value15.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined6
        });
        return new LodashWrapper(value15, this.__chain__).thru(function(array6) {
          if (length && !array6.length) {
            array6.push(undefined6);
          }
          return array6;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined6) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value15 = done ? undefined6 : this.__values__[this.__index__++];
        return { done, value: value15 };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value15) {
        var result3, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone14 = wrapperClone(parent2);
          clone14.__index__ = 0;
          clone14.__values__ = undefined6;
          if (result3) {
            previous.__wrapped__ = clone14;
          } else {
            result3 = clone14;
          }
          var previous = clone14;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value15;
        return result3;
      }
      function wrapperReverse() {
        var value15 = this.__wrapped__;
        if (value15 instanceof LazyWrapper) {
          var wrapped = value15;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined6
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result3, value15, key) {
        if (hasOwnProperty.call(result3, key)) {
          ++result3[key];
        } else {
          baseAssignValue(result3, key, 1);
        }
      });
      function every(collection, predicate, guard22) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard22 && isIterateeCall(collection, predicate, guard22)) {
          predicate = undefined6;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map3(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined6 ? 1 : toInteger(depth);
        return baseFlatten(map3(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result3, value15, key) {
        if (hasOwnProperty.call(result3, key)) {
          result3[key].push(value15);
        } else {
          baseAssignValue(result3, key, [value15]);
        }
      });
      function includes(collection, value15, fromIndex, guard22) {
        collection = isArrayLike(collection) ? collection : values2(collection);
        fromIndex = fromIndex && !guard22 ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value15, fromIndex) > -1 : !!length && baseIndexOf(collection, value15, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result3 = isArrayLike(collection) ? Array3(collection.length) : [];
        baseEach(collection, function(value15) {
          result3[++index] = isFunc ? apply(path, value15, args) : baseInvoke(value15, path, args);
        });
        return result3;
      });
      var keyBy = createAggregator(function(result3, value15, key) {
        baseAssignValue(result3, key, value15);
      });
      function map3(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders6, guard22) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders6 = guard22 ? undefined6 : orders6;
        if (!isArray(orders6)) {
          orders6 = orders6 == null ? [] : [orders6];
        }
        return baseOrderBy(collection, iteratees, orders6);
      }
      var partition = createAggregator(function(result3, value15, key) {
        result3[key ? 0 : 1].push(value15);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard22) {
        if (guard22 ? isIterateeCall(collection, n2, guard22) : n2 === undefined6) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard22) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard22 && isIterateeCall(collection, predicate, guard22)) {
          predicate = undefined6;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard22) {
        n2 = guard22 ? undefined6 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined6, undefined6, undefined6, undefined6, n2);
      }
      function before(n2, func) {
        var result3;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger(n2);
        return function() {
          if (--n2 > 0) {
            result3 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined6;
          }
          return result3;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object13, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object13, partials, holders);
      });
      function curry(func, arity, guard22) {
        arity = guard22 ? undefined6 : arity;
        var result3 = createWrap(func, WRAP_CURRY_FLAG, undefined6, undefined6, undefined6, undefined6, undefined6, arity);
        result3.placeholder = curry.placeholder;
        return result3;
      }
      function curryRight(func, arity, guard22) {
        arity = guard22 ? undefined6 : arity;
        var result3 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined6, undefined6, undefined6, undefined6, undefined6, arity);
        result3.placeholder = curryRight.placeholder;
        return result3;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result3, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined6;
          lastInvokeTime = time;
          result3 = func.apply(thisArg, args);
          return result3;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result3;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined6 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined6;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined6;
          return result3;
        }
        function cancel() {
          if (timerId !== undefined6) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined6;
        }
        function flush() {
          return timerId === undefined6 ? result3 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined6) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined6) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result3;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result3 = func.apply(this, args);
          memoized.cache = cache.set(key, result3) || cache;
          return result3;
        };
        memoized.cache = new (memoize.Cache || MapCache);
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial5 = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial5));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined6, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined6, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined6, undefined6, undefined6, indexes);
      });
      function rest4(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined6 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array6 = args[start], otherArgs = castSlice(args, 0, start);
          if (array6) {
            arrayPush(otherArgs, array6);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value15, wrapper) {
        return partial5(castFunction(wrapper), value15);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value15 = arguments[0];
        return isArray(value15) ? value15 : [value15];
      }
      function clone13(value15) {
        return baseClone(value15, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseClone(value15, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value15) {
        return baseClone(value15, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseClone(value15, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object13, source) {
        return source == null || baseConformsTo(object13, source, keys(source));
      }
      function eq2(value15, other) {
        return value15 === other || value15 !== value15 && other !== other;
      }
      var gt2 = createRelationalOperation(baseGt);
      var gte2 = createRelationalOperation(function(value15, other) {
        return value15 >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value15) {
        return isObjectLike(value15) && hasOwnProperty.call(value15, "callee") && !propertyIsEnumerable.call(value15, "callee");
      };
      var isArray = Array3.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value15) {
        return value15 != null && isLength(value15.length) && !isFunction(value15);
      }
      function isArrayLikeObject(value15) {
        return isObjectLike(value15) && isArrayLike(value15);
      }
      function isBoolean(value15) {
        return value15 === true || value15 === false || isObjectLike(value15) && baseGetTag(value15) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value15) {
        return isObjectLike(value15) && value15.nodeType === 1 && !isPlainObject(value15);
      }
      function isEmpty(value15) {
        if (value15 == null) {
          return true;
        }
        if (isArrayLike(value15) && (isArray(value15) || typeof value15 == "string" || typeof value15.splice == "function" || isBuffer(value15) || isTypedArray(value15) || isArguments(value15))) {
          return !value15.length;
        }
        var tag = getTag(value15);
        if (tag == mapTag || tag == setTag) {
          return !value15.size;
        }
        if (isPrototype(value15)) {
          return !baseKeys(value15).length;
        }
        for (var key in value15) {
          if (hasOwnProperty.call(value15, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value15, other) {
        return baseIsEqual(value15, other);
      }
      function isEqualWith(value15, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        var result3 = customizer ? customizer(value15, other) : undefined6;
        return result3 === undefined6 ? baseIsEqual(value15, other, undefined6, customizer) : !!result3;
      }
      function isError(value15) {
        if (!isObjectLike(value15)) {
          return false;
        }
        var tag = baseGetTag(value15);
        return tag == errorTag || tag == domExcTag || typeof value15.message == "string" && typeof value15.name == "string" && !isPlainObject(value15);
      }
      function isFinite2(value15) {
        return typeof value15 == "number" && nativeIsFinite(value15);
      }
      function isFunction(value15) {
        if (!isObject(value15)) {
          return false;
        }
        var tag = baseGetTag(value15);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value15) {
        return typeof value15 == "number" && value15 == toInteger(value15);
      }
      function isLength(value15) {
        return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
      }
      function isObject(value15) {
        var type75 = typeof value15;
        return value15 != null && (type75 == "object" || type75 == "function");
      }
      function isObjectLike(value15) {
        return value15 != null && typeof value15 == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object13, source) {
        return object13 === source || baseIsMatch(object13, source, getMatchData(source));
      }
      function isMatchWith(object13, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return baseIsMatch(object13, source, getMatchData(source), customizer);
      }
      function isNaN2(value15) {
        return isNumber(value15) && value15 != +value15;
      }
      function isNative(value15) {
        if (isMaskable(value15)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value15);
      }
      function isNull2(value15) {
        return value15 === null;
      }
      function isNil(value15) {
        return value15 == null;
      }
      function isNumber(value15) {
        return typeof value15 == "number" || isObjectLike(value15) && baseGetTag(value15) == numberTag;
      }
      function isPlainObject(value15) {
        if (!isObjectLike(value15) || baseGetTag(value15) != objectTag) {
          return false;
        }
        var proto = getPrototype(value15);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value15) {
        return isInteger(value15) && value15 >= -MAX_SAFE_INTEGER && value15 <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value15) {
        return typeof value15 == "string" || !isArray(value15) && isObjectLike(value15) && baseGetTag(value15) == stringTag;
      }
      function isSymbol(value15) {
        return typeof value15 == "symbol" || isObjectLike(value15) && baseGetTag(value15) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value15) {
        return value15 === undefined6;
      }
      function isWeakMap(value15) {
        return isObjectLike(value15) && getTag(value15) == weakMapTag;
      }
      function isWeakSet(value15) {
        return isObjectLike(value15) && baseGetTag(value15) == weakSetTag;
      }
      var lt2 = createRelationalOperation(baseLt);
      var lte2 = createRelationalOperation(function(value15, other) {
        return value15 <= other;
      });
      function toArray(value15) {
        if (!value15) {
          return [];
        }
        if (isArrayLike(value15)) {
          return isString(value15) ? stringToArray(value15) : copyArray(value15);
        }
        if (symIterator && value15[symIterator]) {
          return iteratorToArray(value15[symIterator]());
        }
        var tag = getTag(value15), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values2;
        return func(value15);
      }
      function toFinite(value15) {
        if (!value15) {
          return value15 === 0 ? value15 : 0;
        }
        value15 = toNumber(value15);
        if (value15 === INFINITY || value15 === -INFINITY) {
          var sign = value15 < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value15 === value15 ? value15 : 0;
      }
      function toInteger(value15) {
        var result3 = toFinite(value15), remainder = result3 % 1;
        return result3 === result3 ? remainder ? result3 - remainder : result3 : 0;
      }
      function toLength(value15) {
        return value15 ? baseClamp(toInteger(value15), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value15) {
        if (typeof value15 == "number") {
          return value15;
        }
        if (isSymbol(value15)) {
          return NAN;
        }
        if (isObject(value15)) {
          var other = typeof value15.valueOf == "function" ? value15.valueOf() : value15;
          value15 = isObject(other) ? other + "" : other;
        }
        if (typeof value15 != "string") {
          return value15 === 0 ? value15 : +value15;
        }
        value15 = baseTrim(value15);
        var isBinary = reIsBinary.test(value15);
        return isBinary || reIsOctal.test(value15) ? freeParseInt(value15.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value15) ? NAN : +value15;
      }
      function toPlainObject(value15) {
        return copyObject(value15, keysIn(value15));
      }
      function toSafeInteger(value15) {
        return value15 ? baseClamp(toInteger(value15), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value15 === 0 ? value15 : 0;
      }
      function toString(value15) {
        return value15 == null ? "" : baseToString(value15);
      }
      var assign = createAssigner(function(object13, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object13);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object13, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object13, source) {
        copyObject(source, keysIn(source), object13);
      });
      var assignInWith = createAssigner(function(object13, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object13, customizer);
      });
      var assignWith = createAssigner(function(object13, source, srcIndex, customizer) {
        copyObject(source, keys(source), object13, customizer);
      });
      var at = flatRest(baseAt);
      function create5(prototype, properties) {
        var result3 = baseCreate(prototype);
        return properties == null ? result3 : baseAssign(result3, properties);
      }
      var defaults = baseRest(function(object13, sources) {
        object13 = Object3(object13);
        var index = -1;
        var length = sources.length;
        var guard22 = length > 2 ? sources[2] : undefined6;
        if (guard22 && isIterateeCall(sources[0], sources[1], guard22)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value15 = object13[key];
            if (value15 === undefined6 || eq2(value15, objectProto[key]) && !hasOwnProperty.call(object13, key)) {
              object13[key] = source[key];
            }
          }
        }
        return object13;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined6, customDefaultsMerge);
        return apply(mergeWith, undefined6, args);
      });
      function findKey(object13, predicate) {
        return baseFindKey(object13, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object13, predicate) {
        return baseFindKey(object13, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object13, iteratee2) {
        return object13 == null ? object13 : baseFor(object13, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object13, iteratee2) {
        return object13 == null ? object13 : baseForRight(object13, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object13, iteratee2) {
        return object13 && baseForOwn(object13, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object13, iteratee2) {
        return object13 && baseForOwnRight(object13, getIteratee(iteratee2, 3));
      }
      function functions(object13) {
        return object13 == null ? [] : baseFunctions(object13, keys(object13));
      }
      function functionsIn(object13) {
        return object13 == null ? [] : baseFunctions(object13, keysIn(object13));
      }
      function get(object13, path, defaultValue) {
        var result3 = object13 == null ? undefined6 : baseGet(object13, path);
        return result3 === undefined6 ? defaultValue : result3;
      }
      function has2(object13, path) {
        return object13 != null && hasPath(object13, path, baseHas);
      }
      function hasIn(object13, path) {
        return object13 != null && hasPath(object13, path, baseHasIn);
      }
      var invert = createInverter(function(result3, value15, key) {
        if (value15 != null && typeof value15.toString != "function") {
          value15 = nativeObjectToString.call(value15);
        }
        result3[value15] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result3, value15, key) {
        if (value15 != null && typeof value15.toString != "function") {
          value15 = nativeObjectToString.call(value15);
        }
        if (hasOwnProperty.call(result3, value15)) {
          result3[value15].push(key);
        } else {
          result3[value15] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object13) {
        return isArrayLike(object13) ? arrayLikeKeys(object13) : baseKeys(object13);
      }
      function keysIn(object13) {
        return isArrayLike(object13) ? arrayLikeKeys(object13, true) : baseKeysIn(object13);
      }
      function mapKeys(object13, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object13, function(value15, key, object14) {
          baseAssignValue(result3, iteratee2(value15, key, object14), value15);
        });
        return result3;
      }
      function mapValues(object13, iteratee2) {
        var result3 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object13, function(value15, key, object14) {
          baseAssignValue(result3, key, iteratee2(value15, key, object14));
        });
        return result3;
      }
      var merge = createAssigner(function(object13, source, srcIndex) {
        baseMerge(object13, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object13, source, srcIndex, customizer) {
        baseMerge(object13, source, srcIndex, customizer);
      });
      var omit6 = flatRest(function(object13, paths) {
        var result3 = {};
        if (object13 == null) {
          return result3;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object13);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object13, getAllKeysIn(object13), result3);
        if (isDeep) {
          result3 = baseClone(result3, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result3, paths[length]);
        }
        return result3;
      });
      function omitBy(object13, predicate) {
        return pickBy(object13, negate(getIteratee(predicate)));
      }
      var pick6 = flatRest(function(object13, paths) {
        return object13 == null ? {} : basePick(object13, paths);
      });
      function pickBy(object13, predicate) {
        if (object13 == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object13), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object13, props, function(value15, path) {
          return predicate(value15, path[0]);
        });
      }
      function result2(object13, path, defaultValue) {
        path = castPath(path, object13);
        var index = -1, length = path.length;
        if (!length) {
          length = 1;
          object13 = undefined6;
        }
        while (++index < length) {
          var value15 = object13 == null ? undefined6 : object13[toKey(path[index])];
          if (value15 === undefined6) {
            index = length;
            value15 = defaultValue;
          }
          object13 = isFunction(value15) ? value15.call(object13) : value15;
        }
        return object13;
      }
      function set2(object13, path, value15) {
        return object13 == null ? object13 : baseSet(object13, path, value15);
      }
      function setWith(object13, path, value15, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return object13 == null ? object13 : baseSet(object13, path, value15, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform7(object13, iteratee2, accumulator) {
        var isArr = isArray(object13), isArrLike = isArr || isBuffer(object13) || isTypedArray(object13);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object13 && object13.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor : [];
          } else if (isObject(object13)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object13)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object13, function(value15, index, object14) {
          return iteratee2(accumulator, value15, index, object14);
        });
        return accumulator;
      }
      function unset(object13, path) {
        return object13 == null ? true : baseUnset(object13, path);
      }
      function update(object13, path, updater) {
        return object13 == null ? object13 : baseUpdate(object13, path, castFunction(updater));
      }
      function updateWith(object13, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined6;
        return object13 == null ? object13 : baseUpdate(object13, path, castFunction(updater), customizer);
      }
      function values2(object13) {
        return object13 == null ? [] : baseValues(object13, keys(object13));
      }
      function valuesIn(object13) {
        return object13 == null ? [] : baseValues(object13, keysIn(object13));
      }
      function clamp(number7, lower, upper) {
        if (upper === undefined6) {
          upper = lower;
          lower = undefined6;
        }
        if (upper !== undefined6) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined6) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number7), lower, upper);
      }
      function inRange(number7, start, end) {
        start = toFinite(start);
        if (end === undefined6) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number7 = toNumber(number7);
        return baseInRange(number7, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined6;
        }
        if (floating === undefined6) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined6;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined6;
          }
        }
        if (lower === undefined6 && upper === undefined6) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined6) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result3, word, index) {
        word = word.toLowerCase();
        return result3 + (index ? capitalize2(word) : word);
      });
      function capitalize2(string7) {
        return upperFirst(toString(string7).toLowerCase());
      }
      function deburr(string7) {
        string7 = toString(string7);
        return string7 && string7.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string7, target, position) {
        string7 = toString(string7);
        target = baseToString(target);
        var length = string7.length;
        position = position === undefined6 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string7.slice(position, end) == target;
      }
      function escape2(string7) {
        string7 = toString(string7);
        return string7 && reHasUnescapedHtml.test(string7) ? string7.replace(reUnescapedHtml, escapeHtmlChar) : string7;
      }
      function escapeRegExp(string7) {
        string7 = toString(string7);
        return string7 && reHasRegExpChar.test(string7) ? string7.replace(reRegExpChar, "\\$&") : string7;
      }
      var kebabCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        if (!length || strLength >= length) {
          return string7;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string7 + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        return length && strLength < length ? string7 + createPadding(length - strLength, chars) : string7;
      }
      function padStart(string7, length, chars) {
        string7 = toString(string7);
        length = toInteger(length);
        var strLength = length ? stringSize(string7) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string7 : string7;
      }
      function parseInt2(string7, radix, guard22) {
        if (guard22 || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string7).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string7, n2, guard22) {
        if (guard22 ? isIterateeCall(string7, n2, guard22) : n2 === undefined6) {
          n2 = 1;
        } else {
          n2 = toInteger(n2);
        }
        return baseRepeat(toString(string7), n2);
      }
      function replace() {
        var args = arguments, string7 = toString(args[0]);
        return args.length < 3 ? string7 : string7.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string7, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string7, separator, limit)) {
          separator = limit = undefined6;
        }
        limit = limit === undefined6 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string7 = toString(string7);
        if (string7 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string7)) {
            return castSlice(stringToArray(string7), 0, limit);
          }
        }
        return string7.split(separator, limit);
      }
      var startCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string7, target, position) {
        string7 = toString(string7);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string7.length);
        target = baseToString(target);
        return string7.slice(position, position + target.length) == target;
      }
      function template(string7, options, guard22) {
        var settings = lodash.templateSettings;
        if (guard22 && isIterateeCall(string7, options, guard22)) {
          options = undefined6;
        }
        string7 = toString(string7);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp3((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string7.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string7.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result3 = attempt(function() {
          return Function3(importsKeys, sourceURL + "return " + source).apply(undefined6, importsValues);
        });
        result3.source = source;
        if (isError(result3)) {
          throw result3;
        }
        return result3;
      }
      function toLower(value15) {
        return toString(value15).toLowerCase();
      }
      function toUpper(value15) {
        return toString(value15).toUpperCase();
      }
      function trim(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return baseTrim(string7);
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return string7.slice(0, trimmedEndIndex(string7) + 1);
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string7, chars, guard22) {
        string7 = toString(string7);
        if (string7 && (guard22 || chars === undefined6)) {
          return string7.replace(reTrimStart, "");
        }
        if (!string7 || !(chars = baseToString(chars))) {
          return string7;
        }
        var strSymbols = stringToArray(string7), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string7, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string7 = toString(string7);
        var strLength = string7.length;
        if (hasUnicode(string7)) {
          var strSymbols = stringToArray(string7);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string7;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result3 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string7.slice(0, end);
        if (separator === undefined6) {
          return result3 + omission;
        }
        if (strSymbols) {
          end += result3.length - end;
        }
        if (isRegExp(separator)) {
          if (string7.slice(end).search(separator)) {
            var match, substring = result3;
            if (!separator.global) {
              separator = RegExp3(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result3 = result3.slice(0, newEnd === undefined6 ? end : newEnd);
          }
        } else if (string7.indexOf(baseToString(separator), end) != end) {
          var index = result3.lastIndexOf(separator);
          if (index > -1) {
            result3 = result3.slice(0, index);
          }
        }
        return result3 + omission;
      }
      function unescape2(string7) {
        string7 = toString(string7);
        return string7 && reHasEscapedHtml.test(string7) ? string7.replace(reEscapedHtml, unescapeHtmlChar) : string7;
      }
      var upperCase = createCompounder(function(result3, word, index) {
        return result3 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string7, pattern3, guard22) {
        string7 = toString(string7);
        pattern3 = guard22 ? undefined6 : pattern3;
        if (pattern3 === undefined6) {
          return hasUnicodeWord(string7) ? unicodeWords(string7) : asciiWords(string7);
        }
        return string7.match(pattern3) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined6, args);
        } catch (e2) {
          return isError(e2) ? e2 : new Error2(e2);
        }
      });
      var bindAll = flatRest(function(object13, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object13, key, bind(object13[key], object13));
        });
        return object13;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value15) {
        return function() {
          return value15;
        };
      }
      function defaultTo(value15, defaultValue) {
        return value15 == null || value15 !== value15 ? defaultValue : value15;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value15) {
        return value15;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object13) {
          return baseInvoke(object13, path, args);
        };
      });
      var methodOf = baseRest(function(object13, args) {
        return function(path) {
          return baseInvoke(object13, path, args);
        };
      });
      function mixin(object13, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object13;
          object13 = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && ("chain" in options)) || !!options.chain, isFunc = isFunction(object13);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object13[methodName] = func;
          if (isFunc) {
            object13.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result3 = object13(this.__wrapped__), actions = result3.__actions__ = copyArray(this.__actions__);
                actions.push({ func, args: arguments, thisArg: object13 });
                result3.__chain__ = chainAll;
                return result3;
              }
              return func.apply(object13, arrayPush([this.value()], arguments));
            };
          }
        });
        return object13;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop3() {
      }
      function nthArg(n2) {
        n2 = toInteger(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object13) {
        return function(path) {
          return object13 == null ? undefined6 : baseGet(object13, path);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result3 = baseTimes(length, iteratee2);
        while (++index < n2) {
          iteratee2(index);
        }
        return result3;
      }
      function toPath(value15) {
        if (isArray(value15)) {
          return arrayMap(value15, toKey);
        }
        return isSymbol(value15) ? [value15] : copyArray(stringToPath(toString(value15)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array6) {
        return array6 && array6.length ? baseExtremum(array6, identity, baseGt) : undefined6;
      }
      function maxBy(array6, iteratee2) {
        return array6 && array6.length ? baseExtremum(array6, getIteratee(iteratee2, 2), baseGt) : undefined6;
      }
      function mean(array6) {
        return baseMean(array6, identity);
      }
      function meanBy(array6, iteratee2) {
        return baseMean(array6, getIteratee(iteratee2, 2));
      }
      function min(array6) {
        return array6 && array6.length ? baseExtremum(array6, identity, baseLt) : undefined6;
      }
      function minBy(array6, iteratee2) {
        return array6 && array6.length ? baseExtremum(array6, getIteratee(iteratee2, 2), baseLt) : undefined6;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array6) {
        return array6 && array6.length ? baseSum(array6, identity) : 0;
      }
      function sumBy(array6, iteratee2) {
        return array6 && array6.length ? baseSum(array6, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create5;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map3;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit6;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial5;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick6;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest4;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set2;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform7;
      lodash.unary = unary;
      lodash.union = union23;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values2;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor2;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize2;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone13;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq2;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt2;
      lodash.gte = gte2;
      lodash.has = has2;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull2;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt2;
      lodash.lte = lte2;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop3;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result2;
      lodash.round = round;
      lodash.runInContext = runInContext;
      lodash.sample = sample;
      lodash.size = size2;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { chain: false });
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined6 ? 1 : nativeMax(toInteger(n2), 0);
          var result3 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result3.__filtered__) {
            result3.__takeCount__ = nativeMin(n2, result3.__takeCount__);
          } else {
            result3.__views__.push({
              size: nativeMin(n2, MAX_ARRAY_LENGTH),
              type: methodName + (result3.__dir__ < 0 ? "Right" : "")
            });
          }
          return result3;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type75 = index + 1, isFilter = type75 == LAZY_FILTER_FLAG || type75 == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result3 = this.clone();
          result3.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type: type75
          });
          result3.__filtered__ = result3.__filtered__ || isFilter;
          return result3;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value15) {
          return baseInvoke(value15, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result3 = this;
        if (result3.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result3);
        }
        if (start < 0) {
          result3 = result3.takeRight(-start);
        } else if (start) {
          result3 = result3.drop(start);
        }
        if (end !== undefined6) {
          end = toInteger(end);
          result3 = end < 0 ? result3.dropRight(-end) : result3.take(end - start);
        }
        return result3;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value15 = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value15 instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value15);
          var interceptor = function(value16) {
            var result4 = lodashFunc.apply(lodash, arrayPush([value16], args));
            return isTaker && chainAll ? result4[0] : result4;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value15 = onlyLazy ? value15 : new LazyWrapper(this);
            var result3 = func.apply(value15, args);
            result3.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined6 });
            return new LodashWrapper(result3, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result3 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result3.value()[0] : result3.value() : result3;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value15 = this.value();
            return func.apply(isArray(value15) ? value15 : [], args);
          }
          return this[chainName](function(value16) {
            return func.apply(isArray(value16) ? value16 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ name: methodName, func: lodashFunc });
        }
      });
      realNames[createHybrid(undefined6, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined6
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports);
});

// node_modules/bull/lib/utils.js
var require_utils4 = __commonJS((exports, module) => {
  var tryCatch = function(fn, ctx, args) {
    try {
      return fn.apply(ctx, args);
    } catch (e2) {
      errorObject.value = e2;
      return errorObject;
    }
  };
  var isRedisReady = function(client) {
    return new Promise((resolve, reject) => {
      if (client.status === "ready") {
        resolve();
      } else {
        let handleReady = function() {
          client.removeListener("end", handleEnd);
          client.removeListener("error", handleError);
          resolve();
        }, handleError = function(err) {
          lastError = err;
        }, handleEnd = function() {
          client.removeListener("ready", handleReady);
          client.removeListener("error", handleError);
          reject(lastError);
        };
        let lastError;
        client.once("ready", handleReady);
        client.on("error", handleError);
        client.once("end", handleEnd);
      }
    });
  };
  var errorObject = { value: null };
  exports.errorObject = errorObject;
  exports.tryCatch = tryCatch;
  exports.isRedisReady = isRedisReady;
  exports.emitSafe = function(emitter, event, ...args) {
    try {
      return emitter.emit(event, ...args);
    } catch (err) {
      try {
        return emitter.emit("error", err);
      } catch (err2) {
        console.error(err2);
      }
    }
  };
  exports.MetricsTime = {
    ONE_MINUTE: 1,
    FIVE_MINUTES: 5,
    FIFTEEN_MINUTES: 15,
    THIRTY_MINUTES: 30,
    ONE_HOUR: 60,
    ONE_WEEK: 60 * 24 * 7,
    TWO_WEEKS: 60 * 24 * 7 * 2,
    ONE_MONTH: 60 * 24 * 7 * 2 * 4
  };
});

// node_modules/node-gyp-build-optional-packages/index.js
var require_node_gyp_build_optional_packages = __commonJS((exports, module) => {
  var load = function(dir) {
    if (typeof __webpack_require__ === "function")
      return __non_webpack_require__(load.path(dir));
    else
      return import.meta.require(load.path(dir));
  };
  var readdirSync = function(dir) {
    try {
      return fs2.readdirSync(dir);
    } catch (err) {
      return [];
    }
  };
  var getFirst = function(dir, filter) {
    var files = readdirSync(dir).filter(filter);
    return files[0] && path.join(dir, files[0]);
  };
  var matchBuild = function(name) {
    return /\.node$/.test(name);
  };
  var parseTuple = function(name) {
    var arr = name.split("-");
    if (arr.length !== 2)
      return;
    var platform2 = arr[0];
    var architectures = arr[1].split("+");
    if (!platform2)
      return;
    if (!architectures.length)
      return;
    if (!architectures.every(Boolean))
      return;
    return { name, platform: platform2, architectures };
  };
  var matchTuple = function(platform2, arch2) {
    return function(tuple8) {
      if (tuple8 == null)
        return false;
      if (tuple8.platform !== platform2)
        return false;
      return tuple8.architectures.includes(arch2);
    };
  };
  var compareTuples = function(a2, b3) {
    return a2.architectures.length - b3.architectures.length;
  };
  var parseTags = function(file) {
    var arr = file.split(".");
    var extension = arr.pop();
    var tags = { file, specificity: 0 };
    if (extension !== "node")
      return;
    for (var i = 0;i < arr.length; i++) {
      var tag = arr[i];
      if (tag === "node" || tag === "electron" || tag === "node-webkit") {
        tags.runtime = tag;
      } else if (tag === "napi") {
        tags.napi = true;
      } else if (tag.slice(0, 3) === "abi") {
        tags.abi = tag.slice(3);
      } else if (tag.slice(0, 2) === "uv") {
        tags.uv = tag.slice(2);
      } else if (tag.slice(0, 4) === "armv") {
        tags.armv = tag.slice(4);
      } else if (tag === "glibc" || tag === "musl") {
        tags.libc = tag;
      } else {
        continue;
      }
      tags.specificity++;
    }
    return tags;
  };
  var matchTags = function(runtime2, abi2) {
    return function(tags) {
      if (tags == null)
        return false;
      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
        return false;
      if (tags.abi !== abi2 && !tags.napi)
        return false;
      if (tags.uv && tags.uv !== uv)
        return false;
      if (tags.armv && tags.armv !== armv)
        return false;
      if (tags.libc && tags.libc !== libc)
        return false;
      return true;
    };
  };
  var runtimeAgnostic = function(tags) {
    return tags.runtime === "node" && tags.napi;
  };
  var compareTags = function(runtime2) {
    return function(a2, b3) {
      if (a2.runtime !== b3.runtime) {
        return a2.runtime === runtime2 ? -1 : 1;
      } else if (a2.abi !== b3.abi) {
        return a2.abi ? -1 : 1;
      } else if (a2.specificity !== b3.specificity) {
        return a2.specificity > b3.specificity ? -1 : 1;
      } else {
        return 0;
      }
    };
  };
  var isElectron = function() {
    if (process.versions && process.versions.electron)
      return true;
    if (process.env.ELECTRON_RUN_AS_NODE)
      return true;
    return typeof window !== "undefined" && window.process && window.process.type === "renderer";
  };
  var isAlpine = function(platform2) {
    return platform2 === "linux" && fs2.existsSync("/etc/alpine-release");
  };
  var fs2 = import.meta.require("fs");
  var path = import.meta.require("path");
  var url = import.meta.require("url");
  var vars = process.config && process.config.variables || {};
  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
  var versions = process.versions;
  var abi = versions.modules;
  if (versions.deno || process.isBun) {
    abi = "unsupported";
  }
  var runtime = isElectron() ? "electron" : "node";
  var arch = process.arch;
  var platform = process.platform;
  var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
  var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
  var uv = (versions.uv || "").split(".")[0];
  module.exports = load;
  load.path = function(dir) {
    dir = path.resolve(dir || ".");
    var packageName;
    try {
      if (typeof __webpack_require__ === "function")
        packageName = __non_webpack_require__(path.join(dir, "package.json")).name;
      else
        packageName = import.meta.require(path.join(dir, "package.json")).name;
      var varName = packageName.toUpperCase().replace(/-/g, "_") + "_PREBUILD";
      if (process.env[varName])
        dir = process.env[varName];
    } catch (err) {
    }
    if (!prebuildsOnly) {
      var release = getFirst(path.join(dir, "build/Release"), matchBuild);
      if (release)
        return release;
      var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
      if (debug)
        return debug;
    }
    var prebuild = resolve(dir);
    if (prebuild)
      return prebuild;
    var nearby = resolve(path.dirname(process.execPath));
    if (nearby)
      return nearby;
    var platformPackage = (packageName[0] == "@" ? "" : "@" + packageName + "/") + packageName + "-" + platform + "-" + arch;
    try {
      var prebuildPackage = path.dirname(import.meta.require("module").createRequire(url.pathToFileURL(path.join(dir, "package.json"))).resolve(platformPackage));
      return resolveFile(prebuildPackage);
    } catch (error22) {
    }
    var target = [
      "platform=" + platform,
      "arch=" + arch,
      "runtime=" + runtime,
      "abi=" + abi,
      "uv=" + uv,
      armv ? "armv=" + armv : "",
      "libc=" + libc,
      "node=" + process.versions.node,
      process.versions.electron ? "electron=" + process.versions.electron : "",
      typeof __webpack_require__ === "function" ? "webpack=true" : ""
    ].filter(Boolean).join(" ");
    throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + " and package: " + platformPackage + "\n");
    function resolve(dir2) {
      var tuples2 = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
      var tuple8 = tuples2.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
      if (!tuple8)
        return;
      return resolveFile(path.join(dir2, "prebuilds", tuple8.name));
    }
    function resolveFile(prebuilds) {
      var parsed = readdirSync(prebuilds).map(parseTags);
      var candidates = parsed.filter(matchTags(runtime, abi));
      var winner = candidates.sort(compareTags(runtime))[0];
      if (winner)
        return path.join(prebuilds, winner.file);
    }
  };
  load.parseTags = parseTags;
  load.matchTags = matchTags;
  load.compareTags = compareTags;
  load.parseTuple = parseTuple;
  load.matchTuple = matchTuple;
  load.compareTuples = compareTuples;
});

// node_modules/msgpackr-extract/index.js
var require_msgpackr_extract = __commonJS((exports, module) => {
  var __dirname = "/home/jeffsilva01/www/pizzashop-api/node_modules/msgpackr-extract";
  module.exports = require_node_gyp_build_optional_packages()(__dirname);
});

// node_modules/msgpackr/dist/node.cjs
var require_node2 = __commonJS((exports) => {
  var checkedRead = function(options) {
    try {
      if (!currentUnpackr.trusted && !sequentialMode) {
        let sharedLength = currentStructures.sharedLength || 0;
        if (sharedLength < currentStructures.length)
          currentStructures.length = sharedLength;
      }
      let result2;
      if (currentUnpackr.randomAccessStructure && src[position$1] < 64 && src[position$1] >= 32 && readStruct$1) {
        result2 = readStruct$1(src, position$1, srcEnd, currentUnpackr);
        src = null;
        if (!(options && options.lazy) && result2)
          result2 = result2.toJSON();
        position$1 = srcEnd;
      } else
        result2 = read();
      if (bundledStrings$1) {
        position$1 = bundledStrings$1.postBundlePosition;
        bundledStrings$1 = null;
      }
      if (sequentialMode)
        currentStructures.restoreStructures = null;
      if (position$1 == srcEnd) {
        if (currentStructures && currentStructures.restoreStructures)
          restoreStructures();
        currentStructures = null;
        src = null;
        if (referenceMap)
          referenceMap = null;
      } else if (position$1 > srcEnd) {
        throw new Error("Unexpected end of MessagePack data");
      } else if (!sequentialMode) {
        let jsonView;
        try {
          jsonView = JSON.stringify(result2, (_, value15) => typeof value15 === "bigint" ? `${value15}n` : value15).slice(0, 100);
        } catch (error22) {
          jsonView = "(JSON view not available " + error22 + ")";
        }
        throw new Error("Data read, but end of buffer not reached " + jsonView);
      }
      return result2;
    } catch (error22) {
      if (currentStructures && currentStructures.restoreStructures)
        restoreStructures();
      clearSource();
      if (error22 instanceof RangeError || error22.message.startsWith("Unexpected end of buffer") || position$1 > srcEnd) {
        error22.incomplete = true;
      }
      throw error22;
    }
  };
  var restoreStructures = function() {
    for (let id in currentStructures.restoreStructures) {
      currentStructures[id] = currentStructures.restoreStructures[id];
    }
    currentStructures.restoreStructures = null;
  };
  var read = function() {
    let token = src[position$1++];
    if (token < 160) {
      if (token < 128) {
        if (token < 64)
          return token;
        else {
          let structure = currentStructures[token & 63] || currentUnpackr.getStructures && loadStructures()[token & 63];
          if (structure) {
            if (!structure.read) {
              structure.read = createStructureReader(structure, token & 63);
            }
            return structure.read();
          } else
            return token;
        }
      } else if (token < 144) {
        token -= 128;
        if (currentUnpackr.mapsAsObjects) {
          let object13 = {};
          for (let i = 0;i < token; i++) {
            let key = readKey();
            if (key === "__proto__")
              key = "__proto_";
            object13[key] = read();
          }
          return object13;
        } else {
          let map3 = new Map;
          for (let i = 0;i < token; i++) {
            map3.set(read(), read());
          }
          return map3;
        }
      } else {
        token -= 144;
        let array6 = new Array(token);
        for (let i = 0;i < token; i++) {
          array6[i] = read();
        }
        if (currentUnpackr.freezeData)
          return Object.freeze(array6);
        return array6;
      }
    } else if (token < 192) {
      let length = token - 160;
      if (srcStringEnd >= position$1) {
        return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);
      }
      if (srcStringEnd == 0 && srcEnd < 140) {
        let string7 = length < 16 ? shortStringInJS(length) : longStringInJS(length);
        if (string7 != null)
          return string7;
      }
      return readFixedString(length);
    } else {
      let value15;
      switch (token) {
        case 192:
          return null;
        case 193:
          if (bundledStrings$1) {
            value15 = read();
            if (value15 > 0)
              return bundledStrings$1[1].slice(bundledStrings$1.position1, bundledStrings$1.position1 += value15);
            else
              return bundledStrings$1[0].slice(bundledStrings$1.position0, bundledStrings$1.position0 -= value15);
          }
          return C12;
        case 194:
          return false;
        case 195:
          return true;
        case 196:
          value15 = src[position$1++];
          if (value15 === undefined)
            throw new Error("Unexpected end of buffer");
          return readBin(value15);
        case 197:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          return readBin(value15);
        case 198:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          return readBin(value15);
        case 199:
          return readExt(src[position$1++]);
        case 200:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          return readExt(value15);
        case 201:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          return readExt(value15);
        case 202:
          value15 = dataView.getFloat32(position$1);
          if (currentUnpackr.useFloat32 > 2) {
            let multiplier = mult10[(src[position$1] & 127) << 1 | src[position$1 + 1] >> 7];
            position$1 += 4;
            return (multiplier * value15 + (value15 > 0 ? 0.5 : -0.5) >> 0) / multiplier;
          }
          position$1 += 4;
          return value15;
        case 203:
          value15 = dataView.getFloat64(position$1);
          position$1 += 8;
          return value15;
        case 204:
          return src[position$1++];
        case 205:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          return value15;
        case 206:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          return value15;
        case 207:
          if (currentUnpackr.int64AsType === "number") {
            value15 = dataView.getUint32(position$1) * 4294967296;
            value15 += dataView.getUint32(position$1 + 4);
          } else if (currentUnpackr.int64AsType === "string") {
            value15 = dataView.getBigUint64(position$1).toString();
          } else if (currentUnpackr.int64AsType === "auto") {
            value15 = dataView.getBigUint64(position$1);
            if (value15 <= BigInt(2) << BigInt(52))
              value15 = Number(value15);
          } else
            value15 = dataView.getBigUint64(position$1);
          position$1 += 8;
          return value15;
        case 208:
          return dataView.getInt8(position$1++);
        case 209:
          value15 = dataView.getInt16(position$1);
          position$1 += 2;
          return value15;
        case 210:
          value15 = dataView.getInt32(position$1);
          position$1 += 4;
          return value15;
        case 211:
          if (currentUnpackr.int64AsType === "number") {
            value15 = dataView.getInt32(position$1) * 4294967296;
            value15 += dataView.getUint32(position$1 + 4);
          } else if (currentUnpackr.int64AsType === "string") {
            value15 = dataView.getBigInt64(position$1).toString();
          } else if (currentUnpackr.int64AsType === "auto") {
            value15 = dataView.getBigInt64(position$1);
            if (value15 >= BigInt(-2) << BigInt(52) && value15 <= BigInt(2) << BigInt(52))
              value15 = Number(value15);
          } else
            value15 = dataView.getBigInt64(position$1);
          position$1 += 8;
          return value15;
        case 212:
          value15 = src[position$1++];
          if (value15 == 114) {
            return recordDefinition(src[position$1++] & 63);
          } else {
            let extension = currentExtensions[value15];
            if (extension) {
              if (extension.read) {
                position$1++;
                return extension.read(read());
              } else if (extension.noBuffer) {
                position$1++;
                return extension();
              } else
                return extension(src.subarray(position$1, ++position$1));
            } else
              throw new Error("Unknown extension " + value15);
          }
        case 213:
          value15 = src[position$1];
          if (value15 == 114) {
            position$1++;
            return recordDefinition(src[position$1++] & 63, src[position$1++]);
          } else
            return readExt(2);
        case 214:
          return readExt(4);
        case 215:
          return readExt(8);
        case 216:
          return readExt(16);
        case 217:
          value15 = src[position$1++];
          if (srcStringEnd >= position$1) {
            return srcString.slice(position$1 - srcStringStart, (position$1 += value15) - srcStringStart);
          }
          return readString8(value15);
        case 218:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          if (srcStringEnd >= position$1) {
            return srcString.slice(position$1 - srcStringStart, (position$1 += value15) - srcStringStart);
          }
          return readString16(value15);
        case 219:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          if (srcStringEnd >= position$1) {
            return srcString.slice(position$1 - srcStringStart, (position$1 += value15) - srcStringStart);
          }
          return readString32(value15);
        case 220:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          return readArray(value15);
        case 221:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          return readArray(value15);
        case 222:
          value15 = dataView.getUint16(position$1);
          position$1 += 2;
          return readMap(value15);
        case 223:
          value15 = dataView.getUint32(position$1);
          position$1 += 4;
          return readMap(value15);
        default:
          if (token >= 224)
            return token - 256;
          if (token === undefined) {
            let error22 = new Error("Unexpected end of MessagePack data");
            error22.incomplete = true;
            throw error22;
          }
          throw new Error("Unknown MessagePack token " + token);
      }
    }
  };
  var createStructureReader = function(structure, firstId) {
    function readObject() {
      if (readObject.count++ > inlineObjectReadThreshold) {
        let readObject2 = structure.read = new Function("r", "return function(){return " + (currentUnpackr.freezeData ? "Object.freeze" : "") + "({" + structure.map((key) => key === "__proto__" ? "__proto_:r()" : validName.test(key) ? key + ":r()" : "[" + JSON.stringify(key) + "]:r()").join(",") + "})}")(read);
        if (structure.highByte === 0)
          structure.read = createSecondByteReader(firstId, structure.read);
        return readObject2();
      }
      let object13 = {};
      for (let i = 0, l2 = structure.length;i < l2; i++) {
        let key = structure[i];
        if (key === "__proto__")
          key = "__proto_";
        object13[key] = read();
      }
      if (currentUnpackr.freezeData)
        return Object.freeze(object13);
      return object13;
    }
    readObject.count = 0;
    if (structure.highByte === 0) {
      return createSecondByteReader(firstId, readObject);
    }
    return readObject;
  };
  var loadStructures = function() {
    let loadedStructures = saveState$1(() => {
      src = null;
      return currentUnpackr.getStructures();
    });
    return currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures);
  };
  var setExtractor = function(extractStrings) {
    exports.isNativeAccelerationEnabled = true;
    readFixedString = readString2(1);
    readString8 = readString2(2);
    readString16 = readString2(3);
    readString32 = readString2(5);
    function readString2(headerLength) {
      return function readString(length) {
        let string7 = strings[stringPosition++];
        if (string7 == null) {
          if (bundledStrings$1)
            return readStringJS(length);
          let byteOffset = src.byteOffset;
          let extraction = extractStrings(position$1 - headerLength + byteOffset, srcEnd + byteOffset, src.buffer);
          if (typeof extraction == "string") {
            string7 = extraction;
            strings = EMPTY_ARRAY;
          } else {
            strings = extraction;
            stringPosition = 1;
            srcStringEnd = 1;
            string7 = strings[0];
            if (string7 === undefined)
              throw new Error("Unexpected end of buffer");
          }
        }
        let srcStringLength = string7.length;
        if (srcStringLength <= length) {
          position$1 += length;
          return string7;
        }
        srcString = string7;
        srcStringStart = position$1;
        srcStringEnd = position$1 + srcStringLength;
        position$1 += length;
        return string7.slice(0, length);
      };
    }
  };
  var readStringJS = function(length) {
    let result2;
    if (length < 16) {
      if (result2 = shortStringInJS(length))
        return result2;
    }
    if (length > 64 && decoder)
      return decoder.decode(src.subarray(position$1, position$1 += length));
    const end = position$1 + length;
    const units = [];
    result2 = "";
    while (position$1 < end) {
      const byte1 = src[position$1++];
      if ((byte1 & 128) === 0) {
        units.push(byte1);
      } else if ((byte1 & 224) === 192) {
        const byte2 = src[position$1++] & 63;
        units.push((byte1 & 31) << 6 | byte2);
      } else if ((byte1 & 240) === 224) {
        const byte2 = src[position$1++] & 63;
        const byte3 = src[position$1++] & 63;
        units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
      } else if ((byte1 & 248) === 240) {
        const byte2 = src[position$1++] & 63;
        const byte3 = src[position$1++] & 63;
        const byte4 = src[position$1++] & 63;
        let unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (unit > 65535) {
          unit -= 65536;
          units.push(unit >>> 10 & 1023 | 55296);
          unit = 56320 | unit & 1023;
        }
        units.push(unit);
      } else {
        units.push(byte1);
      }
      if (units.length >= 4096) {
        result2 += fromCharCode.apply(String, units);
        units.length = 0;
      }
    }
    if (units.length > 0) {
      result2 += fromCharCode.apply(String, units);
    }
    return result2;
  };
  var readString = function(source, start, length) {
    let existingSrc = src;
    src = source;
    position$1 = start;
    try {
      return readStringJS(length);
    } finally {
      src = existingSrc;
    }
  };
  var readArray = function(length) {
    let array6 = new Array(length);
    for (let i = 0;i < length; i++) {
      array6[i] = read();
    }
    if (currentUnpackr.freezeData)
      return Object.freeze(array6);
    return array6;
  };
  var readMap = function(length) {
    if (currentUnpackr.mapsAsObjects) {
      let object13 = {};
      for (let i = 0;i < length; i++) {
        let key = readKey();
        if (key === "__proto__")
          key = "__proto_";
        object13[key] = read();
      }
      return object13;
    } else {
      let map3 = new Map;
      for (let i = 0;i < length; i++) {
        map3.set(read(), read());
      }
      return map3;
    }
  };
  var longStringInJS = function(length) {
    let start = position$1;
    let bytes2 = new Array(length);
    for (let i = 0;i < length; i++) {
      const byte = src[position$1++];
      if ((byte & 128) > 0) {
        position$1 = start;
        return;
      }
      bytes2[i] = byte;
    }
    return fromCharCode.apply(String, bytes2);
  };
  var shortStringInJS = function(length) {
    if (length < 4) {
      if (length < 2) {
        if (length === 0)
          return "";
        else {
          let a2 = src[position$1++];
          if ((a2 & 128) > 1) {
            position$1 -= 1;
            return;
          }
          return fromCharCode(a2);
        }
      } else {
        let a2 = src[position$1++];
        let b3 = src[position$1++];
        if ((a2 & 128) > 0 || (b3 & 128) > 0) {
          position$1 -= 2;
          return;
        }
        if (length < 3)
          return fromCharCode(a2, b3);
        let c2 = src[position$1++];
        if ((c2 & 128) > 0) {
          position$1 -= 3;
          return;
        }
        return fromCharCode(a2, b3, c2);
      }
    } else {
      let a2 = src[position$1++];
      let b3 = src[position$1++];
      let c2 = src[position$1++];
      let d2 = src[position$1++];
      if ((a2 & 128) > 0 || (b3 & 128) > 0 || (c2 & 128) > 0 || (d2 & 128) > 0) {
        position$1 -= 4;
        return;
      }
      if (length < 6) {
        if (length === 4)
          return fromCharCode(a2, b3, c2, d2);
        else {
          let e2 = src[position$1++];
          if ((e2 & 128) > 0) {
            position$1 -= 5;
            return;
          }
          return fromCharCode(a2, b3, c2, d2, e2);
        }
      } else if (length < 8) {
        let e2 = src[position$1++];
        let f = src[position$1++];
        if ((e2 & 128) > 0 || (f & 128) > 0) {
          position$1 -= 6;
          return;
        }
        if (length < 7)
          return fromCharCode(a2, b3, c2, d2, e2, f);
        let g = src[position$1++];
        if ((g & 128) > 0) {
          position$1 -= 7;
          return;
        }
        return fromCharCode(a2, b3, c2, d2, e2, f, g);
      } else {
        let e2 = src[position$1++];
        let f = src[position$1++];
        let g = src[position$1++];
        let h2 = src[position$1++];
        if ((e2 & 128) > 0 || (f & 128) > 0 || (g & 128) > 0 || (h2 & 128) > 0) {
          position$1 -= 8;
          return;
        }
        if (length < 10) {
          if (length === 8)
            return fromCharCode(a2, b3, c2, d2, e2, f, g, h2);
          else {
            let i = src[position$1++];
            if ((i & 128) > 0) {
              position$1 -= 9;
              return;
            }
            return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i);
          }
        } else if (length < 12) {
          let i = src[position$1++];
          let j = src[position$1++];
          if ((i & 128) > 0 || (j & 128) > 0) {
            position$1 -= 10;
            return;
          }
          if (length < 11)
            return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j);
          let k = src[position$1++];
          if ((k & 128) > 0) {
            position$1 -= 11;
            return;
          }
          return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j, k);
        } else {
          let i = src[position$1++];
          let j = src[position$1++];
          let k = src[position$1++];
          let l2 = src[position$1++];
          if ((i & 128) > 0 || (j & 128) > 0 || (k & 128) > 0 || (l2 & 128) > 0) {
            position$1 -= 12;
            return;
          }
          if (length < 14) {
            if (length === 12)
              return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j, k, l2);
            else {
              let m2 = src[position$1++];
              if ((m2 & 128) > 0) {
                position$1 -= 13;
                return;
              }
              return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j, k, l2, m2);
            }
          } else {
            let m2 = src[position$1++];
            let n2 = src[position$1++];
            if ((m2 & 128) > 0 || (n2 & 128) > 0) {
              position$1 -= 14;
              return;
            }
            if (length < 15)
              return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j, k, l2, m2, n2);
            let o2 = src[position$1++];
            if ((o2 & 128) > 0) {
              position$1 -= 15;
              return;
            }
            return fromCharCode(a2, b3, c2, d2, e2, f, g, h2, i, j, k, l2, m2, n2, o2);
          }
        }
      }
    }
  };
  var readOnlyJSString = function() {
    let token = src[position$1++];
    let length;
    if (token < 192) {
      length = token - 160;
    } else {
      switch (token) {
        case 217:
          length = src[position$1++];
          break;
        case 218:
          length = dataView.getUint16(position$1);
          position$1 += 2;
          break;
        case 219:
          length = dataView.getUint32(position$1);
          position$1 += 4;
          break;
        default:
          throw new Error("Expected string");
      }
    }
    return readStringJS(length);
  };
  var readBin = function(length) {
    return currentUnpackr.copyBuffers ? Uint8Array.prototype.slice.call(src, position$1, position$1 += length) : src.subarray(position$1, position$1 += length);
  };
  var readExt = function(length) {
    let type75 = src[position$1++];
    if (currentExtensions[type75]) {
      let end;
      return currentExtensions[type75](src.subarray(position$1, end = position$1 += length), (readPosition) => {
        position$1 = readPosition;
        try {
          return read();
        } finally {
          position$1 = end;
        }
      });
    } else
      throw new Error("Unknown extension type " + type75);
  };
  var readKey = function() {
    let length = src[position$1++];
    if (length >= 160 && length < 192) {
      length = length - 160;
      if (srcStringEnd >= position$1)
        return srcString.slice(position$1 - srcStringStart, (position$1 += length) - srcStringStart);
      else if (!(srcStringEnd == 0 && srcEnd < 180))
        return readFixedString(length);
    } else {
      position$1--;
      return asSafeString(read());
    }
    let key = (length << 5 ^ (length > 1 ? dataView.getUint16(position$1) : length > 0 ? src[position$1] : 0)) & 4095;
    let entry = keyCache[key];
    let checkPosition = position$1;
    let end = position$1 + length - 3;
    let chunk;
    let i = 0;
    if (entry && entry.bytes == length) {
      while (checkPosition < end) {
        chunk = dataView.getUint32(checkPosition);
        if (chunk != entry[i++]) {
          checkPosition = 1879048192;
          break;
        }
        checkPosition += 4;
      }
      end += 3;
      while (checkPosition < end) {
        chunk = src[checkPosition++];
        if (chunk != entry[i++]) {
          checkPosition = 1879048192;
          break;
        }
      }
      if (checkPosition === end) {
        position$1 = checkPosition;
        return entry.string;
      }
      end -= 3;
      checkPosition = position$1;
    }
    entry = [];
    keyCache[key] = entry;
    entry.bytes = length;
    while (checkPosition < end) {
      chunk = dataView.getUint32(checkPosition);
      entry.push(chunk);
      checkPosition += 4;
    }
    end += 3;
    while (checkPosition < end) {
      chunk = src[checkPosition++];
      entry.push(chunk);
    }
    let string7 = length < 16 ? shortStringInJS(length) : longStringInJS(length);
    if (string7 != null)
      return entry.string = string7;
    return entry.string = readFixedString(length);
  };
  var asSafeString = function(property) {
    if (typeof property === "string")
      return property;
    if (typeof property === "number")
      return property.toString();
    throw new Error("Invalid property type for record", typeof property);
  };
  var saveState$1 = function(callback) {
    if (onSaveState)
      onSaveState();
    let savedSrcEnd = srcEnd;
    let savedPosition = position$1;
    let savedStringPosition = stringPosition;
    let savedSrcStringStart = srcStringStart;
    let savedSrcStringEnd = srcStringEnd;
    let savedSrcString = srcString;
    let savedStrings = strings;
    let savedReferenceMap = referenceMap;
    let savedBundledStrings = bundledStrings$1;
    let savedSrc = new Uint8Array(src.slice(0, srcEnd));
    let savedStructures = currentStructures;
    let savedStructuresContents = currentStructures.slice(0, currentStructures.length);
    let savedPackr = currentUnpackr;
    let savedSequentialMode = sequentialMode;
    let value15 = callback();
    srcEnd = savedSrcEnd;
    position$1 = savedPosition;
    stringPosition = savedStringPosition;
    srcStringStart = savedSrcStringStart;
    srcStringEnd = savedSrcStringEnd;
    srcString = savedSrcString;
    strings = savedStrings;
    referenceMap = savedReferenceMap;
    bundledStrings$1 = savedBundledStrings;
    src = savedSrc;
    sequentialMode = savedSequentialMode;
    currentStructures = savedStructures;
    currentStructures.splice(0, currentStructures.length, ...savedStructuresContents);
    currentUnpackr = savedPackr;
    dataView = new DataView(src.buffer, src.byteOffset, src.byteLength);
    return value15;
  };
  var clearSource = function() {
    src = null;
    referenceMap = null;
    currentStructures = null;
  };
  var addExtension$1 = function(extension) {
    if (extension.unpack)
      currentExtensions[extension.type] = extension.unpack;
    else
      currentExtensions[extension.type] = extension;
  };
  var roundFloat32 = function(float32Number) {
    f32Array[0] = float32Number;
    let multiplier = mult10[(u8Array[3] & 127) << 1 | u8Array[2] >> 7];
    return (multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5) >> 0) / multiplier;
  };
  var setReadStruct = function(updatedReadStruct, loadedStructs, saveState2) {
    readStruct$1 = updatedReadStruct;
    onLoadedStructures$1 = loadedStructs;
    onSaveState = saveState2;
  };
  var writeExtBuffer = function(typedArray, type75, allocateForWrite, encode3) {
    let length = typedArray.byteLength;
    if (length + 1 < 256) {
      var { target: target2, position: position2 } = allocateForWrite(4 + length);
      target2[position2++] = 199;
      target2[position2++] = length + 1;
    } else if (length + 1 < 65536) {
      var { target: target2, position: position2 } = allocateForWrite(5 + length);
      target2[position2++] = 200;
      target2[position2++] = length + 1 >> 8;
      target2[position2++] = length + 1 & 255;
    } else {
      var { target: target2, position: position2, targetView: targetView2 } = allocateForWrite(7 + length);
      target2[position2++] = 201;
      targetView2.setUint32(position2, length + 1);
      position2 += 4;
    }
    target2[position2++] = 116;
    target2[position2++] = type75;
    target2.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position2);
  };
  var writeBuffer = function(buffer2, allocateForWrite) {
    let length = buffer2.byteLength;
    var target2, position2;
    if (length < 256) {
      var { target: target2, position: position2 } = allocateForWrite(length + 2);
      target2[position2++] = 196;
      target2[position2++] = length;
    } else if (length < 65536) {
      var { target: target2, position: position2 } = allocateForWrite(length + 3);
      target2[position2++] = 197;
      target2[position2++] = length >> 8;
      target2[position2++] = length & 255;
    } else {
      var { target: target2, position: position2, targetView: targetView2 } = allocateForWrite(length + 5);
      target2[position2++] = 198;
      targetView2.setUint32(position2, length);
      position2 += 4;
    }
    target2.set(buffer2, position2);
  };
  var writeExtensionData = function(result2, target2, position2, type75) {
    let length = result2.length;
    switch (length) {
      case 1:
        target2[position2++] = 212;
        break;
      case 2:
        target2[position2++] = 213;
        break;
      case 4:
        target2[position2++] = 214;
        break;
      case 8:
        target2[position2++] = 215;
        break;
      case 16:
        target2[position2++] = 216;
        break;
      default:
        if (length < 256) {
          target2[position2++] = 199;
          target2[position2++] = length;
        } else if (length < 65536) {
          target2[position2++] = 200;
          target2[position2++] = length >> 8;
          target2[position2++] = length & 255;
        } else {
          target2[position2++] = 201;
          target2[position2++] = length >> 24;
          target2[position2++] = length >> 16 & 255;
          target2[position2++] = length >> 8 & 255;
          target2[position2++] = length & 255;
        }
    }
    target2[position2++] = type75;
    target2.set(result2, position2);
    position2 += length;
    return position2;
  };
  var insertIds = function(serialized, idsToInsert) {
    let nextId;
    let distanceToMove = idsToInsert.length * 6;
    let lastEnd = serialized.length - distanceToMove;
    while (nextId = idsToInsert.pop()) {
      let offset = nextId.offset;
      let id = nextId.id;
      serialized.copyWithin(offset + distanceToMove, offset, lastEnd);
      distanceToMove -= 6;
      let position2 = offset + distanceToMove;
      serialized[position2++] = 214;
      serialized[position2++] = 105;
      serialized[position2++] = id >> 24;
      serialized[position2++] = id >> 16 & 255;
      serialized[position2++] = id >> 8 & 255;
      serialized[position2++] = id & 255;
      lastEnd = offset;
    }
    return serialized;
  };
  var writeBundles = function(start, pack2, incrementPosition) {
    if (bundledStrings.length > 0) {
      targetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start);
      bundledStrings.stringsPosition = position - start;
      let writeStrings = bundledStrings;
      bundledStrings = null;
      pack2(writeStrings[0]);
      pack2(writeStrings[1]);
    }
  };
  var addExtension = function(extension) {
    if (extension.Class) {
      if (!extension.pack && !extension.write)
        throw new Error("Extension has no pack or write function");
      if (extension.pack && !extension.type)
        throw new Error("Extension has no type (numeric code to identify the extension)");
      extensionClasses.unshift(extension.Class);
      extensions.unshift(extension);
    }
    addExtension$1(extension);
  };
  var prepareStructures$1 = function(structures, packr) {
    structures.isCompatible = (existingStructures) => {
      let compatible = !existingStructures || (packr.lastNamedStructuresLength || 0) === existingStructures.length;
      if (!compatible)
        packr._mergeStructures(existingStructures);
      return compatible;
    };
    return structures;
  };
  var setWriteStructSlots = function(writeSlots, makeStructures) {
    writeStructSlots = writeSlots;
    prepareStructures$1 = makeStructures;
  };
  var writeStruct = function(object13, target2, encodingStart, position2, structures, makeRoom, pack2, packr) {
    let typedStructs = packr.typedStructs || (packr.typedStructs = []);
    let targetView2 = target2.dataView;
    let refsStartPosition = (typedStructs.lastStringStart || 100) + position2;
    let safeEnd2 = target2.length - 10;
    let start = position2;
    if (position2 > safeEnd2) {
      target2 = makeRoom(position2);
      targetView2 = target2.dataView;
      position2 -= encodingStart;
      start -= encodingStart;
      refsStartPosition -= encodingStart;
      encodingStart = 0;
      safeEnd2 = target2.length - 10;
    }
    let refOffset, refPosition = refsStartPosition;
    let transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));
    let nextId = typedStructs.nextId || typedStructs.length;
    let headerSize = nextId < 15 ? 1 : nextId < 240 ? 2 : nextId < 61440 ? 3 : nextId < 15728640 ? 4 : 0;
    if (headerSize === 0)
      return 0;
    position2 += headerSize;
    let queuedReferences = [];
    let usedAscii0;
    let keyIndex = 0;
    for (let key in object13) {
      let value15 = object13[key];
      let nextTransition = transition[key];
      if (!nextTransition) {
        transition[key] = nextTransition = {
          key,
          parent: transition,
          enumerationOffset: 0,
          ascii0: null,
          ascii8: null,
          num8: null,
          string16: null,
          object16: null,
          num32: null,
          float64: null,
          date64: null
        };
      }
      if (position2 > safeEnd2) {
        target2 = makeRoom(position2);
        targetView2 = target2.dataView;
        position2 -= encodingStart;
        start -= encodingStart;
        refsStartPosition -= encodingStart;
        refPosition -= encodingStart;
        encodingStart = 0;
        safeEnd2 = target2.length - 10;
      }
      switch (typeof value15) {
        case "number":
          let number7 = value15;
          if (nextId < 200 || !nextTransition.num64) {
            if (number7 >> 0 === number7 && number7 < 536870912 && number7 > -520093696) {
              if (number7 < 246 && number7 >= 0 && (nextTransition.num8 && !(nextId > 200 && nextTransition.num32) || number7 < 32 && !nextTransition.num32)) {
                transition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);
                target2[position2++] = number7;
              } else {
                transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);
                targetView2.setUint32(position2, number7, true);
                position2 += 4;
              }
              break;
            } else if (number7 < 4294967296 && number7 >= -2147483648) {
              targetView2.setFloat32(position2, number7, true);
              if (float32Headers[target2[position2 + 3] >>> 5]) {
                let xShifted;
                if ((xShifted = number7 * mult10[(target2[position2 + 3] & 127) << 1 | target2[position2 + 2] >> 7]) >> 0 === xShifted) {
                  transition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);
                  position2 += 4;
                  break;
                }
              }
            }
          }
          transition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);
          targetView2.setFloat64(position2, number7, true);
          position2 += 8;
          break;
        case "string":
          let strLength = value15.length;
          refOffset = refPosition - refsStartPosition;
          if ((strLength << 2) + refPosition > safeEnd2) {
            target2 = makeRoom((strLength << 2) + refPosition);
            targetView2 = target2.dataView;
            position2 -= encodingStart;
            start -= encodingStart;
            refsStartPosition -= encodingStart;
            refPosition -= encodingStart;
            encodingStart = 0;
            safeEnd2 = target2.length - 10;
          }
          if (strLength > 65280 + refOffset >> 2) {
            queuedReferences.push(key, value15, position2 - start);
            break;
          }
          let isNotAscii;
          let strStart = refPosition;
          if (strLength < 64) {
            let i, c1, c2;
            for (i = 0;i < strLength; i++) {
              c1 = value15.charCodeAt(i);
              if (c1 < 128) {
                target2[refPosition++] = c1;
              } else if (c1 < 2048) {
                isNotAscii = true;
                target2[refPosition++] = c1 >> 6 | 192;
                target2[refPosition++] = c1 & 63 | 128;
              } else if ((c1 & 64512) === 55296 && ((c2 = value15.charCodeAt(i + 1)) & 64512) === 56320) {
                isNotAscii = true;
                c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                i++;
                target2[refPosition++] = c1 >> 18 | 240;
                target2[refPosition++] = c1 >> 12 & 63 | 128;
                target2[refPosition++] = c1 >> 6 & 63 | 128;
                target2[refPosition++] = c1 & 63 | 128;
              } else {
                isNotAscii = true;
                target2[refPosition++] = c1 >> 12 | 224;
                target2[refPosition++] = c1 >> 6 & 63 | 128;
                target2[refPosition++] = c1 & 63 | 128;
              }
            }
          } else {
            refPosition += encodeUtf8(target2, value15, refPosition);
            isNotAscii = refPosition - strStart > strLength;
          }
          if (refOffset < 160 || refOffset < 246 && (nextTransition.ascii8 || nextTransition.string8)) {
            if (isNotAscii) {
              if (!(transition = nextTransition.string8)) {
                if (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {
                  transition.__type = UTF8;
                  nextTransition.ascii8 = null;
                  nextTransition.string8 = transition;
                  pack2(null, 0, true);
                } else {
                  transition = createTypeTransition(nextTransition, UTF8, 1);
                }
              }
            } else if (refOffset === 0 && !usedAscii0) {
              usedAscii0 = true;
              transition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);
              break;
            } else if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))
              transition = createTypeTransition(nextTransition, ASCII, 1);
            target2[position2++] = refOffset;
          } else {
            transition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);
            targetView2.setUint16(position2, refOffset, true);
            position2 += 2;
          }
          break;
        case "object":
          if (value15) {
            if (value15.constructor === Date) {
              transition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);
              targetView2.setFloat64(position2, value15.getTime(), true);
              position2 += 8;
            } else {
              queuedReferences.push(key, value15, keyIndex);
            }
            break;
          } else {
            nextTransition = anyType2(nextTransition, position2, targetView2, -10);
            if (nextTransition) {
              transition = nextTransition;
              position2 = updatedPosition;
            } else
              queuedReferences.push(key, value15, keyIndex);
          }
          break;
        case "boolean":
          transition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);
          target2[position2++] = value15 ? 249 : 248;
          break;
        case "undefined":
          nextTransition = anyType2(nextTransition, position2, targetView2, -9);
          if (nextTransition) {
            transition = nextTransition;
            position2 = updatedPosition;
          } else
            queuedReferences.push(key, value15, keyIndex);
          break;
        default:
          queuedReferences.push(key, value15, keyIndex);
      }
      keyIndex++;
    }
    for (let i = 0, l2 = queuedReferences.length;i < l2; ) {
      let key = queuedReferences[i++];
      let value15 = queuedReferences[i++];
      let propertyIndex = queuedReferences[i++];
      let nextTransition = transition[key];
      if (!nextTransition) {
        transition[key] = nextTransition = {
          key,
          parent: transition,
          enumerationOffset: propertyIndex - keyIndex,
          ascii0: null,
          ascii8: null,
          num8: null,
          string16: null,
          object16: null,
          num32: null,
          float64: null
        };
      }
      let newPosition;
      if (value15) {
        let size2;
        refOffset = refPosition - refsStartPosition;
        if (refOffset < 65280) {
          transition = nextTransition.object16;
          if (transition)
            size2 = 2;
          else if (transition = nextTransition.object32)
            size2 = 4;
          else {
            transition = createTypeTransition(nextTransition, OBJECT_DATA, 2);
            size2 = 2;
          }
        } else {
          transition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);
          size2 = 4;
        }
        newPosition = pack2(value15, refPosition);
        if (typeof newPosition === "object") {
          refPosition = newPosition.position;
          targetView2 = newPosition.targetView;
          target2 = newPosition.target;
          refsStartPosition -= encodingStart;
          position2 -= encodingStart;
          start -= encodingStart;
          encodingStart = 0;
        } else
          refPosition = newPosition;
        if (size2 === 2) {
          targetView2.setUint16(position2, refOffset, true);
          position2 += 2;
        } else {
          targetView2.setUint32(position2, refOffset, true);
          position2 += 4;
        }
      } else {
        transition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);
        targetView2.setInt16(position2, value15 === null ? -10 : -9, true);
        position2 += 2;
      }
      keyIndex++;
    }
    let recordId = transition[RECORD_SYMBOL];
    if (recordId == null) {
      recordId = packr.typedStructs.length;
      let structure = [];
      let nextTransition = transition;
      let key, type75;
      while ((type75 = nextTransition.__type) !== undefined) {
        let size2 = nextTransition.__size;
        nextTransition = nextTransition.__parent;
        key = nextTransition.key;
        let property = [type75, size2, key];
        if (nextTransition.enumerationOffset)
          property.push(nextTransition.enumerationOffset);
        structure.push(property);
        nextTransition = nextTransition.parent;
      }
      structure.reverse();
      transition[RECORD_SYMBOL] = recordId;
      packr.typedStructs[recordId] = structure;
      pack2(null, 0, true);
    }
    switch (headerSize) {
      case 1:
        if (recordId >= 16)
          return 0;
        target2[start] = recordId + 32;
        break;
      case 2:
        if (recordId >= 256)
          return 0;
        target2[start] = 56;
        target2[start + 1] = recordId;
        break;
      case 3:
        if (recordId >= 65536)
          return 0;
        target2[start] = 57;
        targetView2.setUint16(start + 1, recordId, true);
        break;
      case 4:
        if (recordId >= 16777216)
          return 0;
        targetView2.setUint32(start, (recordId << 8) + 58, true);
        break;
    }
    if (position2 < refsStartPosition) {
      if (refsStartPosition === refPosition)
        return position2;
      target2.copyWithin(position2, refsStartPosition, refPosition);
      refPosition += position2 - refsStartPosition;
      typedStructs.lastStringStart = position2 - start;
    } else if (position2 > refsStartPosition) {
      if (refsStartPosition === refPosition)
        return position2;
      typedStructs.lastStringStart = position2 - start;
      return writeStruct(object13, target2, encodingStart, start, structures, makeRoom, pack2, packr);
    }
    return refPosition;
  };
  var anyType2 = function(transition, position2, targetView2, value15) {
    let nextTransition;
    if (nextTransition = transition.ascii8 || transition.num8) {
      targetView2.setInt8(position2, value15, true);
      updatedPosition = position2 + 1;
      return nextTransition;
    }
    if (nextTransition = transition.string16 || transition.object16) {
      targetView2.setInt16(position2, value15, true);
      updatedPosition = position2 + 2;
      return nextTransition;
    }
    if (nextTransition = transition.num32) {
      targetView2.setUint32(position2, 3758096640 + value15, true);
      updatedPosition = position2 + 4;
      return nextTransition;
    }
    if (nextTransition = transition.num64) {
      targetView2.setFloat64(position2, NaN, true);
      targetView2.setInt8(position2, value15);
      updatedPosition = position2 + 8;
      return nextTransition;
    }
    updatedPosition = position2;
    return;
  };
  var createTypeTransition = function(transition, type75, size2) {
    let typeName = TYPE_NAMES[type75] + (size2 << 3);
    let newTransition = transition[typeName] || (transition[typeName] = Object.create(null));
    newTransition.__type = type75;
    newTransition.__size = size2;
    newTransition.__parent = transition;
    return newTransition;
  };
  var onLoadedStructures = function(sharedData) {
    if (!(sharedData instanceof Map))
      return sharedData;
    let typed = sharedData.get("typed") || [];
    if (Object.isFrozen(typed))
      typed = typed.map((structure) => structure.slice(0));
    let named = sharedData.get("named");
    let transitions = Object.create(null);
    for (let i = 0, l2 = typed.length;i < l2; i++) {
      let structure = typed[i];
      let transition = transitions;
      for (let [type75, size2, key] of structure) {
        let nextTransition = transition[key];
        if (!nextTransition) {
          transition[key] = nextTransition = {
            key,
            parent: transition,
            enumerationOffset: 0,
            ascii0: null,
            ascii8: null,
            num8: null,
            string16: null,
            object16: null,
            num32: null,
            float64: null,
            date64: null
          };
        }
        transition = createTypeTransition(nextTransition, type75, size2);
      }
      transition[RECORD_SYMBOL] = i;
    }
    typed.transitions = transitions;
    this.typedStructs = typed;
    this.lastTypedStructuresLength = typed.length;
    return named;
  };
  var readStruct = function(src2, position2, srcEnd2, unpackr) {
    let recordId = src2[position2++] - 32;
    if (recordId >= 24) {
      switch (recordId) {
        case 24:
          recordId = src2[position2++];
          break;
        case 25:
          recordId = src2[position2++] + (src2[position2++] << 8);
          break;
        case 26:
          recordId = src2[position2++] + (src2[position2++] << 8) + (src2[position2++] << 16);
          break;
        case 27:
          recordId = src2[position2++] + (src2[position2++] << 8) + (src2[position2++] << 16) + (src2[position2++] << 24);
          break;
      }
    }
    let structure = unpackr.typedStructs && unpackr.typedStructs[recordId];
    if (!structure) {
      src2 = Uint8Array.prototype.slice.call(src2, position2, srcEnd2);
      srcEnd2 -= position2;
      position2 = 0;
      unpackr._mergeStructures(unpackr.getStructures());
      if (!unpackr.typedStructs)
        throw new Error("Could not find any shared typed structures");
      unpackr.lastTypedStructuresLength = unpackr.typedStructs.length;
      structure = unpackr.typedStructs[recordId];
      if (!structure)
        throw new Error("Could not find typed structure " + recordId);
    }
    var construct = structure.construct;
    if (!construct) {
      construct = structure.construct = function LazyObject() {
      };
      var prototype = construct.prototype;
      let properties = [];
      let currentOffset = 0;
      let lastRefProperty;
      for (let i = 0, l2 = structure.length;i < l2; i++) {
        let definition = structure[i];
        let [type75, size2, key, enumerationOffset] = definition;
        if (key === "__proto__")
          key = "__proto_";
        let property = {
          key,
          offset: currentOffset
        };
        if (enumerationOffset)
          properties.splice(i + enumerationOffset, 0, property);
        else
          properties.push(property);
        let getRef;
        switch (size2) {
          case 0:
            getRef = () => 0;
            break;
          case 1:
            getRef = (source, position3) => {
              let ref4 = source.bytes[position3 + property.offset];
              return ref4 >= 246 ? toConstant(ref4) : ref4;
            };
            break;
          case 2:
            getRef = (source, position3) => {
              let src3 = source.bytes;
              let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
              let ref4 = dataView2.getUint16(position3 + property.offset, true);
              return ref4 >= 65280 ? toConstant(ref4 & 255) : ref4;
            };
            break;
          case 4:
            getRef = (source, position3) => {
              let src3 = source.bytes;
              let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
              let ref4 = dataView2.getUint32(position3 + property.offset, true);
              return ref4 >= 4294967040 ? toConstant(ref4 & 255) : ref4;
            };
            break;
        }
        property.getRef = getRef;
        currentOffset += size2;
        let get;
        switch (type75) {
          case ASCII:
            if (lastRefProperty && !lastRefProperty.next)
              lastRefProperty.next = property;
            lastRefProperty = property;
            property.multiGetCount = 0;
            get = function(source) {
              let src3 = source.bytes;
              let position3 = source.position;
              let refStart = currentOffset + position3;
              let ref4 = getRef(source, position3);
              if (typeof ref4 !== "number")
                return ref4;
              let end, next = property.next;
              while (next) {
                end = next.getRef(source, position3);
                if (typeof end === "number")
                  break;
                else
                  end = null;
                next = next.next;
              }
              if (end == null)
                end = source.bytesEnd - refStart;
              if (source.srcString) {
                return source.srcString.slice(ref4, end);
              }
              return readString(src3, ref4 + refStart, end - ref4);
            };
            break;
          case UTF8:
          case OBJECT_DATA:
            if (lastRefProperty && !lastRefProperty.next)
              lastRefProperty.next = property;
            lastRefProperty = property;
            get = function(source) {
              let position3 = source.position;
              let refStart = currentOffset + position3;
              let ref4 = getRef(source, position3);
              if (typeof ref4 !== "number")
                return ref4;
              let src3 = source.bytes;
              let end, next = property.next;
              while (next) {
                end = next.getRef(source, position3);
                if (typeof end === "number")
                  break;
                else
                  end = null;
                next = next.next;
              }
              if (end == null)
                end = source.bytesEnd - refStart;
              if (type75 === UTF8) {
                return src3.toString("utf8", ref4 + refStart, end + refStart);
              } else {
                currentSource = source;
                try {
                  return unpackr.unpack(src3, { start: ref4 + refStart, end: end + refStart });
                } finally {
                  currentSource = null;
                }
              }
            };
            break;
          case NUMBER:
            switch (size2) {
              case 4:
                get = function(source) {
                  let src3 = source.bytes;
                  let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
                  let position3 = source.position + property.offset;
                  let value15 = dataView2.getInt32(position3, true);
                  if (value15 < 536870912) {
                    if (value15 > -520093696)
                      return value15;
                    if (value15 > -536870912)
                      return toConstant(value15 & 255);
                  }
                  let fValue = dataView2.getFloat32(position3, true);
                  let multiplier = mult10[(src3[position3 + 3] & 127) << 1 | src3[position3 + 2] >> 7];
                  return (multiplier * fValue + (fValue > 0 ? 0.5 : -0.5) >> 0) / multiplier;
                };
                break;
              case 8:
                get = function(source) {
                  let src3 = source.bytes;
                  let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
                  let value15 = dataView2.getFloat64(source.position + property.offset, true);
                  if (isNaN(value15)) {
                    let byte = src3[source.position + property.offset];
                    if (byte >= 246)
                      return toConstant(byte);
                  }
                  return value15;
                };
                break;
              case 1:
                get = function(source) {
                  let src3 = source.bytes;
                  let value15 = src3[source.position + property.offset];
                  return value15 < 246 ? value15 : toConstant(value15);
                };
                break;
            }
            break;
          case DATE:
            get = function(source) {
              let src3 = source.bytes;
              let dataView2 = src3.dataView || (src3.dataView = new DataView(src3.buffer, src3.byteOffset, src3.byteLength));
              return new Date(dataView2.getFloat64(source.position + property.offset, true));
            };
            break;
        }
        property.get = get;
      }
      if (evalSupported) {
        let objectLiteralProperties = [];
        let args = [];
        let i = 0;
        let hasInheritedProperties;
        for (let property of properties) {
          if (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {
            hasInheritedProperties = true;
            continue;
          }
          Object.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });
          let valueFunction = "v" + i++;
          args.push(valueFunction);
          objectLiteralProperties.push("[" + JSON.stringify(property.key) + "]:" + valueFunction + "(s)");
        }
        if (hasInheritedProperties) {
          objectLiteralProperties.push("__proto__:this");
        }
        let toObject = new Function(...args, "return function(s){return{" + objectLiteralProperties.join(",") + "}}").apply(null, properties.map((prop) => prop.get));
        Object.defineProperty(prototype, "toJSON", {
          value(omitUnderscoredProperties) {
            return toObject.call(this, this[sourceSymbol]);
          }
        });
      } else {
        Object.defineProperty(prototype, "toJSON", {
          value(omitUnderscoredProperties) {
            let resolved = {};
            for (let i = 0, l2 = properties.length;i < l2; i++) {
              let key = properties[i].key;
              resolved[key] = this[key];
            }
            return resolved;
          }
        });
      }
    }
    var instance = new construct;
    instance[sourceSymbol] = {
      bytes: src2,
      position: position2,
      srcString: "",
      bytesEnd: srcEnd2
    };
    return instance;
  };
  var toConstant = function(code) {
    switch (code) {
      case 246:
        return null;
      case 247:
        return;
      case 248:
        return false;
      case 249:
        return true;
    }
    throw new Error("Unknown constant");
  };
  var withSource = function(get) {
    return function() {
      return get(this[sourceSymbol]);
    };
  };
  var saveState = function() {
    if (currentSource) {
      currentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);
      currentSource.position = 0;
      currentSource.bytesEnd = currentSource.bytes.length;
    }
  };
  var prepareStructures = function(structures, packr) {
    if (packr.typedStructs) {
      let structMap = new Map;
      structMap.set("named", structures);
      structMap.set("typed", packr.typedStructs);
      structures = structMap;
    }
    let lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;
    structures.isCompatible = (existing) => {
      let compatible = true;
      if (existing instanceof Map) {
        let named = existing.get("named") || [];
        if (named.length !== (packr.lastNamedStructuresLength || 0))
          compatible = false;
        let typed = existing.get("typed") || [];
        if (typed.length !== lastTypedStructuresLength)
          compatible = false;
      } else if (existing instanceof Array || Array.isArray(existing)) {
        if (existing.length !== (packr.lastNamedStructuresLength || 0))
          compatible = false;
      }
      if (!compatible)
        packr._mergeStructures(existing);
      return compatible;
    };
    packr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;
    return structures;
  };
  var packIter = function(objectIterator, options = {}) {
    if (!objectIterator || typeof objectIterator !== "object") {
      throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");
    } else if (typeof objectIterator[Symbol.iterator] === "function") {
      return packIterSync(objectIterator, options);
    } else if (typeof objectIterator.then === "function" || typeof objectIterator[Symbol.asyncIterator] === "function") {
      return packIterAsync(objectIterator, options);
    } else {
      throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise");
    }
  };
  function* packIterSync(objectIterator, options) {
    const packr = new Packr(options);
    for (const value15 of objectIterator) {
      yield packr.pack(value15);
    }
  }
  async function* packIterAsync(objectIterator, options) {
    const packr = new Packr(options);
    for await (const value15 of objectIterator) {
      yield packr.pack(value15);
    }
  }
  var unpackIter = function(bufferIterator, options = {}) {
    if (!bufferIterator || typeof bufferIterator !== "object") {
      throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");
    }
    const unpackr = new Unpackr(options);
    let incomplete;
    const parser = (chunk) => {
      let yields;
      if (incomplete) {
        chunk = Buffer.concat([incomplete, chunk]);
        incomplete = undefined;
      }
      try {
        yields = unpackr.unpackMultiple(chunk);
      } catch (err) {
        if (err.incomplete) {
          incomplete = chunk.slice(err.lastPosition);
          yields = err.values;
        } else {
          throw err;
        }
      }
      return yields;
    };
    if (typeof bufferIterator[Symbol.iterator] === "function") {
      return function* iter() {
        for (const value15 of bufferIterator) {
          yield* parser(value15);
        }
      }();
    } else if (typeof bufferIterator[Symbol.asyncIterator] === "function") {
      return async function* iter() {
        for await (const value15 of bufferIterator) {
          yield* parser(value15);
        }
      }();
    }
  };
  var __filename = "/home/jeffsilva01/www/pizzashop-api/node_modules/msgpackr/dist/node.cjs";
  var stream = import.meta.require("stream");
  var module$1 = import.meta.require("module");
  var decoder;
  try {
    decoder = new TextDecoder;
  } catch (error22) {
  }
  var src;
  var srcEnd;
  var position$1 = 0;
  var EMPTY_ARRAY = [];
  var strings = EMPTY_ARRAY;
  var stringPosition = 0;
  var currentUnpackr = {};
  var currentStructures;
  var srcString;
  var srcStringStart = 0;
  var srcStringEnd = 0;
  var bundledStrings$1;
  var referenceMap;
  var currentExtensions = [];
  var dataView;
  var defaultOptions = {
    useRecords: false,
    mapsAsObjects: true
  };

  class C1Type {
  }
  var C12 = new C1Type;
  C12.name = "MessagePack 0xC1";
  var sequentialMode = false;
  var inlineObjectReadThreshold = 2;
  var readStruct$1;
  var onLoadedStructures$1;
  var onSaveState;
  try {
    new Function("");
  } catch (error22) {
    inlineObjectReadThreshold = Infinity;
  }

  class Unpackr {
    constructor(options) {
      if (options) {
        if (options.useRecords === false && options.mapsAsObjects === undefined)
          options.mapsAsObjects = true;
        if (options.sequential && options.trusted !== false) {
          options.trusted = true;
          if (!options.structures && options.useRecords != false) {
            options.structures = [];
            if (!options.maxSharedStructures)
              options.maxSharedStructures = 0;
          }
        }
        if (options.structures)
          options.structures.sharedLength = options.structures.length;
        else if (options.getStructures) {
          (options.structures = []).uninitialized = true;
          options.structures.sharedLength = 0;
        }
        if (options.int64AsNumber) {
          options.int64AsType = "number";
        }
      }
      Object.assign(this, options);
    }
    unpack(source, options) {
      if (src) {
        return saveState$1(() => {
          clearSource();
          return this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options);
        });
      }
      if (!source.buffer && source.constructor === ArrayBuffer)
        source = typeof Buffer !== "undefined" ? Buffer.from(source) : new Uint8Array(source);
      if (typeof options === "object") {
        srcEnd = options.end || source.length;
        position$1 = options.start || 0;
      } else {
        position$1 = 0;
        srcEnd = options > -1 ? options : source.length;
      }
      stringPosition = 0;
      srcStringEnd = 0;
      srcString = null;
      strings = EMPTY_ARRAY;
      bundledStrings$1 = null;
      src = source;
      try {
        dataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength));
      } catch (error22) {
        src = null;
        if (source instanceof Uint8Array)
          throw error22;
        throw new Error("Source must be a Uint8Array or Buffer but was a " + (source && typeof source == "object" ? source.constructor.name : typeof source));
      }
      if (this instanceof Unpackr) {
        currentUnpackr = this;
        if (this.structures) {
          currentStructures = this.structures;
          return checkedRead(options);
        } else if (!currentStructures || currentStructures.length > 0) {
          currentStructures = [];
        }
      } else {
        currentUnpackr = defaultOptions;
        if (!currentStructures || currentStructures.length > 0)
          currentStructures = [];
      }
      return checkedRead(options);
    }
    unpackMultiple(source, forEach) {
      let values2, lastPosition = 0;
      try {
        sequentialMode = true;
        let size2 = source.length;
        let value15 = this ? this.unpack(source, size2) : defaultUnpackr.unpack(source, size2);
        if (forEach) {
          if (forEach(value15, lastPosition, position$1) === false)
            return;
          while (position$1 < size2) {
            lastPosition = position$1;
            if (forEach(checkedRead(), lastPosition, position$1) === false) {
              return;
            }
          }
        } else {
          values2 = [value15];
          while (position$1 < size2) {
            lastPosition = position$1;
            values2.push(checkedRead());
          }
          return values2;
        }
      } catch (error22) {
        error22.lastPosition = lastPosition;
        error22.values = values2;
        throw error22;
      } finally {
        sequentialMode = false;
        clearSource();
      }
    }
    _mergeStructures(loadedStructures, existingStructures) {
      if (onLoadedStructures$1)
        loadedStructures = onLoadedStructures$1.call(this, loadedStructures);
      loadedStructures = loadedStructures || [];
      if (Object.isFrozen(loadedStructures))
        loadedStructures = loadedStructures.map((structure) => structure.slice(0));
      for (let i = 0, l2 = loadedStructures.length;i < l2; i++) {
        let structure = loadedStructures[i];
        if (structure) {
          structure.isShared = true;
          if (i >= 32)
            structure.highByte = i - 32 >> 5;
        }
      }
      loadedStructures.sharedLength = loadedStructures.length;
      for (let id in existingStructures || []) {
        if (id >= 0) {
          let structure = loadedStructures[id];
          let existing = existingStructures[id];
          if (existing) {
            if (structure)
              (loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure;
            loadedStructures[id] = existing;
          }
        }
      }
      return this.structures = loadedStructures;
    }
    decode(source, options) {
      return this.unpack(source, options);
    }
  }
  var validName = /^[a-zA-Z_$][a-zA-Z\d_$]*$/;
  var createSecondByteReader = (firstId, read0) => {
    return function() {
      let highByte = src[position$1++];
      if (highByte === 0)
        return read0();
      let id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5);
      let structure = currentStructures[id] || loadStructures()[id];
      if (!structure) {
        throw new Error("Record id is not defined for " + id);
      }
      if (!structure.read)
        structure.read = createStructureReader(structure, firstId);
      return structure.read();
    };
  };
  var readFixedString = readStringJS;
  var readString8 = readStringJS;
  var readString16 = readStringJS;
  var readString32 = readStringJS;
  exports.isNativeAccelerationEnabled = false;
  var fromCharCode = String.fromCharCode;
  var keyCache = new Array(4096);
  var recordDefinition = (id, highByte) => {
    let structure = read().map(asSafeString);
    let firstByte = id;
    if (highByte !== undefined) {
      id = id < 32 ? -((highByte << 5) + id) : (highByte << 5) + id;
      structure.highByte = highByte;
    }
    let existingStructure = currentStructures[id];
    if (existingStructure && (existingStructure.isShared || sequentialMode)) {
      (currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure;
    }
    currentStructures[id] = structure;
    structure.read = createStructureReader(structure, firstByte);
    return structure.read();
  };
  currentExtensions[0] = () => {
  };
  currentExtensions[0].noBuffer = true;
  currentExtensions[66] = (data) => {
    let length = data.length;
    let value15 = BigInt(data[0] & 128 ? data[0] - 256 : data[0]);
    for (let i = 1;i < length; i++) {
      value15 <<= 8n;
      value15 += BigInt(data[i]);
    }
    return value15;
  };
  var errors10 = { Error, TypeError, ReferenceError };
  currentExtensions[101] = () => {
    let data = read();
    return (errors10[data[0]] || Error)(data[1]);
  };
  currentExtensions[105] = (data) => {
    if (currentUnpackr.structuredClone === false)
      throw new Error("Structured clone extension is disabled");
    let id = dataView.getUint32(position$1 - 4);
    if (!referenceMap)
      referenceMap = new Map;
    let token = src[position$1];
    let target2;
    if (token >= 144 && token < 160 || token == 220 || token == 221)
      target2 = [];
    else
      target2 = {};
    let refEntry = { target: target2 };
    referenceMap.set(id, refEntry);
    let targetProperties = read();
    if (refEntry.used)
      return Object.assign(target2, targetProperties);
    refEntry.target = targetProperties;
    return targetProperties;
  };
  currentExtensions[112] = (data) => {
    if (currentUnpackr.structuredClone === false)
      throw new Error("Structured clone extension is disabled");
    let id = dataView.getUint32(position$1 - 4);
    let refEntry = referenceMap.get(id);
    refEntry.used = true;
    return refEntry.target;
  };
  currentExtensions[115] = () => new Set(read());
  var typedArrays = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map((type75) => type75 + "Array");
  var glbl = typeof globalThis === "object" ? globalThis : window;
  currentExtensions[116] = (data) => {
    let typeCode = data[0];
    let typedArrayName = typedArrays[typeCode];
    if (!typedArrayName)
      throw new Error("Could not find typed array for code " + typeCode);
    return new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer);
  };
  currentExtensions[120] = () => {
    let data = read();
    return new RegExp(data[0], data[1]);
  };
  var TEMP_BUNDLE = [];
  currentExtensions[98] = (data) => {
    let dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3];
    let dataPosition = position$1;
    position$1 += dataSize - data.length;
    bundledStrings$1 = TEMP_BUNDLE;
    bundledStrings$1 = [readOnlyJSString(), readOnlyJSString()];
    bundledStrings$1.position0 = 0;
    bundledStrings$1.position1 = 0;
    bundledStrings$1.postBundlePosition = position$1;
    position$1 = dataPosition;
    return read();
  };
  currentExtensions[255] = (data) => {
    if (data.length == 4)
      return new Date((data[0] * 16777216 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000);
    else if (data.length == 8)
      return new Date(((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1e6 + ((data[3] & 3) * 4294967296 + data[4] * 16777216 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000);
    else if (data.length == 12)
      return new Date(((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1e6 + ((data[4] & 128 ? -281474976710656 : 0) + data[6] * 1099511627776 + data[7] * 4294967296 + data[8] * 16777216 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000);
    else
      return new Date("invalid");
  };
  var mult10 = new Array(147);
  for (let i = 0;i < 256; i++) {
    mult10[i] = +("1e" + Math.floor(45.15 - i * 0.30103));
  }
  var Decoder = Unpackr;
  var defaultUnpackr = new Unpackr({ useRecords: false });
  var unpack = defaultUnpackr.unpack;
  var unpackMultiple = defaultUnpackr.unpackMultiple;
  var decode2 = defaultUnpackr.unpack;
  var FLOAT32_OPTIONS = {
    NEVER: 0,
    ALWAYS: 1,
    DECIMAL_ROUND: 3,
    DECIMAL_FIT: 4
  };
  var f32Array = new Float32Array(1);
  var u8Array = new Uint8Array(f32Array.buffer, 0, 4);
  var textEncoder$1;
  try {
    textEncoder$1 = new TextEncoder;
  } catch (error22) {
  }
  var extensions;
  var extensionClasses;
  var hasNodeBuffer$1 = typeof Buffer !== "undefined";
  var ByteArrayAllocate = hasNodeBuffer$1 ? function(length) {
    return Buffer.allocUnsafeSlow(length);
  } : Uint8Array;
  var ByteArray = hasNodeBuffer$1 ? Buffer : Uint8Array;
  var MAX_BUFFER_SIZE = hasNodeBuffer$1 ? 4294967296 : 2144337920;
  var target;
  var keysTarget;
  var targetView;
  var position = 0;
  var safeEnd;
  var bundledStrings = null;
  var writeStructSlots;
  var MAX_BUNDLE_SIZE = 21760;
  var hasNonLatin = /[\u0080-\uFFFF]/;
  var RECORD_SYMBOL = Symbol("record-id");

  class Packr extends Unpackr {
    constructor(options) {
      super(options);
      this.offset = 0;
      let start;
      let hasSharedUpdate;
      let structures;
      let referenceMap2;
      let encodeUtf82 = ByteArray.prototype.utf8Write ? function(string7, position2) {
        return target.utf8Write(string7, position2, 4294967295);
      } : textEncoder$1 && textEncoder$1.encodeInto ? function(string7, position2) {
        return textEncoder$1.encodeInto(string7, target.subarray(position2)).written;
      } : false;
      let packr = this;
      if (!options)
        options = {};
      let isSequential = options && options.sequential;
      let hasSharedStructures = options.structures || options.saveStructures;
      let maxSharedStructures = options.maxSharedStructures;
      if (maxSharedStructures == null)
        maxSharedStructures = hasSharedStructures ? 32 : 0;
      if (maxSharedStructures > 8160)
        throw new Error("Maximum maxSharedStructure is 8160");
      if (options.structuredClone && options.moreTypes == undefined) {
        this.moreTypes = true;
      }
      let maxOwnStructures = options.maxOwnStructures;
      if (maxOwnStructures == null)
        maxOwnStructures = hasSharedStructures ? 32 : 64;
      if (!this.structures && options.useRecords != false)
        this.structures = [];
      let useTwoByteRecords = maxSharedStructures > 32 || maxOwnStructures + maxSharedStructures > 64;
      let sharedLimitId = maxSharedStructures + 64;
      let maxStructureId = maxSharedStructures + maxOwnStructures + 64;
      if (maxStructureId > 8256) {
        throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");
      }
      let recordIdsToRemove = [];
      let transitionsCount = 0;
      let serializationsSinceTransitionRebuild = 0;
      this.pack = this.encode = function(value15, encodeOptions) {
        if (!target) {
          target = new ByteArrayAllocate(8192);
          targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192));
          position = 0;
        }
        safeEnd = target.length - 10;
        if (safeEnd - position < 2048) {
          target = new ByteArrayAllocate(target.length);
          targetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length));
          safeEnd = target.length - 10;
          position = 0;
        } else
          position = position + 7 & 2147483640;
        start = position;
        if (encodeOptions & RESERVE_START_SPACE)
          position += encodeOptions & 255;
        referenceMap2 = packr.structuredClone ? new Map : null;
        if (packr.bundleStrings && typeof value15 !== "string") {
          bundledStrings = [];
          bundledStrings.size = Infinity;
        } else
          bundledStrings = null;
        structures = packr.structures;
        if (structures) {
          if (structures.uninitialized)
            structures = packr._mergeStructures(packr.getStructures());
          let sharedLength = structures.sharedLength || 0;
          if (sharedLength > maxSharedStructures) {
            throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + structures.sharedLength);
          }
          if (!structures.transitions) {
            structures.transitions = Object.create(null);
            for (let i = 0;i < sharedLength; i++) {
              let keys = structures[i];
              if (!keys)
                continue;
              let nextTransition, transition = structures.transitions;
              for (let j = 0, l2 = keys.length;j < l2; j++) {
                let key = keys[j];
                nextTransition = transition[key];
                if (!nextTransition) {
                  nextTransition = transition[key] = Object.create(null);
                }
                transition = nextTransition;
              }
              transition[RECORD_SYMBOL] = i + 64;
            }
            this.lastNamedStructuresLength = sharedLength;
          }
          if (!isSequential) {
            structures.nextId = sharedLength + 64;
          }
        }
        if (hasSharedUpdate)
          hasSharedUpdate = false;
        let encodingError;
        try {
          if (packr.randomAccessStructure && value15 && value15.constructor && value15.constructor === Object)
            writeStruct2(value15);
          else
            pack2(value15);
          let lastBundle = bundledStrings;
          if (bundledStrings)
            writeBundles(start, pack2, 0);
          if (referenceMap2 && referenceMap2.idsToInsert) {
            let idsToInsert = referenceMap2.idsToInsert.sort((a2, b3) => a2.offset > b3.offset ? 1 : -1);
            let i = idsToInsert.length;
            let incrementPosition = -1;
            while (lastBundle && i > 0) {
              let insertionPoint = idsToInsert[--i].offset + start;
              if (insertionPoint < lastBundle.stringsPosition + start && incrementPosition === -1)
                incrementPosition = 0;
              if (insertionPoint > lastBundle.position + start) {
                if (incrementPosition >= 0)
                  incrementPosition += 6;
              } else {
                if (incrementPosition >= 0) {
                  targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);
                  incrementPosition = -1;
                }
                lastBundle = lastBundle.previous;
                i++;
              }
            }
            if (incrementPosition >= 0 && lastBundle) {
              targetView.setUint32(lastBundle.position + start, targetView.getUint32(lastBundle.position + start) + incrementPosition);
            }
            position += idsToInsert.length * 6;
            if (position > safeEnd)
              makeRoom(position);
            packr.offset = position;
            let serialized = insertIds(target.subarray(start, position), idsToInsert);
            referenceMap2 = null;
            return serialized;
          }
          packr.offset = position;
          if (encodeOptions & REUSE_BUFFER_MODE) {
            target.start = start;
            target.end = position;
            return target;
          }
          return target.subarray(start, position);
        } catch (error22) {
          encodingError = error22;
          throw error22;
        } finally {
          if (structures) {
            resetStructures();
            if (hasSharedUpdate && packr.saveStructures) {
              let sharedLength = structures.sharedLength || 0;
              let returnBuffer = target.subarray(start, position);
              let newSharedData = prepareStructures$1(structures, packr);
              if (!encodingError) {
                if (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {
                  return packr.pack(value15, encodeOptions);
                }
                packr.lastNamedStructuresLength = sharedLength;
                return returnBuffer;
              }
            }
          }
          if (encodeOptions & RESET_BUFFER_MODE)
            position = start;
        }
      };
      const resetStructures = () => {
        if (serializationsSinceTransitionRebuild < 10)
          serializationsSinceTransitionRebuild++;
        let sharedLength = structures.sharedLength || 0;
        if (structures.length > sharedLength && !isSequential)
          structures.length = sharedLength;
        if (transitionsCount > 1e4) {
          structures.transitions = null;
          serializationsSinceTransitionRebuild = 0;
          transitionsCount = 0;
          if (recordIdsToRemove.length > 0)
            recordIdsToRemove = [];
        } else if (recordIdsToRemove.length > 0 && !isSequential) {
          for (let i = 0, l2 = recordIdsToRemove.length;i < l2; i++) {
            recordIdsToRemove[i][RECORD_SYMBOL] = 0;
          }
          recordIdsToRemove = [];
        }
      };
      const packArray = (value15) => {
        var length = value15.length;
        if (length < 16) {
          target[position++] = 144 | length;
        } else if (length < 65536) {
          target[position++] = 220;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          target[position++] = 221;
          targetView.setUint32(position, length);
          position += 4;
        }
        for (let i = 0;i < length; i++) {
          pack2(value15[i]);
        }
      };
      const pack2 = (value15) => {
        if (position > safeEnd)
          target = makeRoom(position);
        var type75 = typeof value15;
        var length;
        if (type75 === "string") {
          let strLength = value15.length;
          if (bundledStrings && strLength >= 4 && strLength < 4096) {
            if ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {
              let extStart;
              let maxBytes2 = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10;
              if (position + maxBytes2 > safeEnd)
                target = makeRoom(position + maxBytes2);
              let lastBundle;
              if (bundledStrings.position) {
                lastBundle = bundledStrings;
                target[position] = 200;
                position += 3;
                target[position++] = 98;
                extStart = position - start;
                position += 4;
                writeBundles(start, pack2, 0);
                targetView.setUint16(extStart + start - 3, position - start - extStart);
              } else {
                target[position++] = 214;
                target[position++] = 98;
                extStart = position - start;
                position += 4;
              }
              bundledStrings = ["", ""];
              bundledStrings.previous = lastBundle;
              bundledStrings.size = 0;
              bundledStrings.position = extStart;
            }
            let twoByte = hasNonLatin.test(value15);
            bundledStrings[twoByte ? 0 : 1] += value15;
            target[position++] = 193;
            pack2(twoByte ? -strLength : strLength);
            return;
          }
          let headerSize;
          if (strLength < 32) {
            headerSize = 1;
          } else if (strLength < 256) {
            headerSize = 2;
          } else if (strLength < 65536) {
            headerSize = 3;
          } else {
            headerSize = 5;
          }
          let maxBytes = strLength * 3;
          if (position + maxBytes > safeEnd)
            target = makeRoom(position + maxBytes);
          if (strLength < 64 || !encodeUtf82) {
            let i, c1, c2, strPosition = position + headerSize;
            for (i = 0;i < strLength; i++) {
              c1 = value15.charCodeAt(i);
              if (c1 < 128) {
                target[strPosition++] = c1;
              } else if (c1 < 2048) {
                target[strPosition++] = c1 >> 6 | 192;
                target[strPosition++] = c1 & 63 | 128;
              } else if ((c1 & 64512) === 55296 && ((c2 = value15.charCodeAt(i + 1)) & 64512) === 56320) {
                c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
                i++;
                target[strPosition++] = c1 >> 18 | 240;
                target[strPosition++] = c1 >> 12 & 63 | 128;
                target[strPosition++] = c1 >> 6 & 63 | 128;
                target[strPosition++] = c1 & 63 | 128;
              } else {
                target[strPosition++] = c1 >> 12 | 224;
                target[strPosition++] = c1 >> 6 & 63 | 128;
                target[strPosition++] = c1 & 63 | 128;
              }
            }
            length = strPosition - position - headerSize;
          } else {
            length = encodeUtf82(value15, position + headerSize);
          }
          if (length < 32) {
            target[position++] = 160 | length;
          } else if (length < 256) {
            if (headerSize < 2) {
              target.copyWithin(position + 2, position + 1, position + 1 + length);
            }
            target[position++] = 217;
            target[position++] = length;
          } else if (length < 65536) {
            if (headerSize < 3) {
              target.copyWithin(position + 3, position + 2, position + 2 + length);
            }
            target[position++] = 218;
            target[position++] = length >> 8;
            target[position++] = length & 255;
          } else {
            if (headerSize < 5) {
              target.copyWithin(position + 5, position + 3, position + 3 + length);
            }
            target[position++] = 219;
            targetView.setUint32(position, length);
            position += 4;
          }
          position += length;
        } else if (type75 === "number") {
          if (value15 >>> 0 === value15) {
            if (value15 < 32 || value15 < 128 && this.useRecords === false || value15 < 64 && !this.randomAccessStructure) {
              target[position++] = value15;
            } else if (value15 < 256) {
              target[position++] = 204;
              target[position++] = value15;
            } else if (value15 < 65536) {
              target[position++] = 205;
              target[position++] = value15 >> 8;
              target[position++] = value15 & 255;
            } else {
              target[position++] = 206;
              targetView.setUint32(position, value15);
              position += 4;
            }
          } else if (value15 >> 0 === value15) {
            if (value15 >= -32) {
              target[position++] = 256 + value15;
            } else if (value15 >= -128) {
              target[position++] = 208;
              target[position++] = value15 + 256;
            } else if (value15 >= -32768) {
              target[position++] = 209;
              targetView.setInt16(position, value15);
              position += 2;
            } else {
              target[position++] = 210;
              targetView.setInt32(position, value15);
              position += 4;
            }
          } else {
            let useFloat32;
            if ((useFloat32 = this.useFloat32) > 0 && value15 < 4294967296 && value15 >= -2147483648) {
              target[position++] = 202;
              targetView.setFloat32(position, value15);
              let xShifted;
              if (useFloat32 < 4 || (xShifted = value15 * mult10[(target[position] & 127) << 1 | target[position + 1] >> 7]) >> 0 === xShifted) {
                position += 4;
                return;
              } else
                position--;
            }
            target[position++] = 203;
            targetView.setFloat64(position, value15);
            position += 8;
          }
        } else if (type75 === "object" || type75 === "function") {
          if (!value15)
            target[position++] = 192;
          else {
            if (referenceMap2) {
              let referee = referenceMap2.get(value15);
              if (referee) {
                if (!referee.id) {
                  let idsToInsert = referenceMap2.idsToInsert || (referenceMap2.idsToInsert = []);
                  referee.id = idsToInsert.push(referee);
                }
                target[position++] = 214;
                target[position++] = 112;
                targetView.setUint32(position, referee.id);
                position += 4;
                return;
              } else
                referenceMap2.set(value15, { offset: position - start });
            }
            let constructor5 = value15.constructor;
            if (constructor5 === Object) {
              writeObject(value15, true);
            } else if (constructor5 === Array) {
              packArray(value15);
            } else if (constructor5 === Map) {
              if (this.mapAsEmptyObject)
                target[position++] = 128;
              else {
                length = value15.size;
                if (length < 16) {
                  target[position++] = 128 | length;
                } else if (length < 65536) {
                  target[position++] = 222;
                  target[position++] = length >> 8;
                  target[position++] = length & 255;
                } else {
                  target[position++] = 223;
                  targetView.setUint32(position, length);
                  position += 4;
                }
                for (let [key, entryValue] of value15) {
                  pack2(key);
                  pack2(entryValue);
                }
              }
            } else {
              for (let i = 0, l2 = extensions.length;i < l2; i++) {
                let extensionClass = extensionClasses[i];
                if (value15 instanceof extensionClass) {
                  let extension = extensions[i];
                  if (extension.write) {
                    if (extension.type) {
                      target[position++] = 212;
                      target[position++] = extension.type;
                      target[position++] = 0;
                    }
                    let writeResult = extension.write.call(this, value15);
                    if (writeResult === value15) {
                      if (Array.isArray(value15)) {
                        packArray(value15);
                      } else {
                        writeObject(value15);
                      }
                    } else {
                      pack2(writeResult);
                    }
                    return;
                  }
                  let currentTarget = target;
                  let currentTargetView = targetView;
                  let currentPosition = position;
                  target = null;
                  let result2;
                  try {
                    result2 = extension.pack.call(this, value15, (size2) => {
                      target = currentTarget;
                      currentTarget = null;
                      position += size2;
                      if (position > safeEnd)
                        makeRoom(position);
                      return {
                        target,
                        targetView,
                        position: position - size2
                      };
                    }, pack2);
                  } finally {
                    if (currentTarget) {
                      target = currentTarget;
                      targetView = currentTargetView;
                      position = currentPosition;
                      safeEnd = target.length - 10;
                    }
                  }
                  if (result2) {
                    if (result2.length + position > safeEnd)
                      makeRoom(result2.length + position);
                    position = writeExtensionData(result2, target, position, extension.type);
                  }
                  return;
                }
              }
              if (Array.isArray(value15)) {
                packArray(value15);
              } else {
                if (value15.toJSON) {
                  const json2 = value15.toJSON();
                  if (json2 !== value15)
                    return pack2(json2);
                }
                if (type75 === "function")
                  return pack2(this.writeFunction && this.writeFunction(value15));
                writeObject(value15, !value15.hasOwnProperty);
              }
            }
          }
        } else if (type75 === "boolean") {
          target[position++] = value15 ? 195 : 194;
        } else if (type75 === "bigint") {
          if (value15 < BigInt(1) << BigInt(63) && value15 >= -(BigInt(1) << BigInt(63))) {
            target[position++] = 211;
            targetView.setBigInt64(position, value15);
          } else if (value15 < BigInt(1) << BigInt(64) && value15 > 0) {
            target[position++] = 207;
            targetView.setBigUint64(position, value15);
          } else {
            if (this.largeBigIntToFloat) {
              target[position++] = 203;
              targetView.setFloat64(position, Number(value15));
            } else if (this.useBigIntExtension && value15 < 2n ** 1023n && value15 > -(2n ** 1023n)) {
              target[position++] = 199;
              position++;
              target[position++] = 66;
              let bytes2 = [];
              let alignedSign;
              do {
                let byte = value15 & 0xffn;
                alignedSign = (byte & 0x80n) === (value15 < 0n ? 0x80n : 0n);
                bytes2.push(byte);
                value15 >>= 8n;
              } while (!((value15 === 0n || value15 === -1n) && alignedSign));
              target[position - 2] = bytes2.length;
              for (let i = bytes2.length;i > 0; ) {
                target[position++] = Number(bytes2[--i]);
              }
              return;
            } else {
              throw new RangeError(value15 + " was too large to fit in MessagePack 64-bit integer format, use useBigIntExtension or set largeBigIntToFloat to convert to float-64");
            }
          }
          position += 8;
        } else if (type75 === "undefined") {
          if (this.encodeUndefinedAsNil)
            target[position++] = 192;
          else {
            target[position++] = 212;
            target[position++] = 0;
            target[position++] = 0;
          }
        } else {
          throw new Error("Unknown type: " + type75);
        }
      };
      const writePlainObject = this.variableMapSize || this.coercibleKeyAsNumber ? (object13) => {
        let keys = Object.keys(object13);
        let length = keys.length;
        if (length < 16) {
          target[position++] = 128 | length;
        } else if (length < 65536) {
          target[position++] = 222;
          target[position++] = length >> 8;
          target[position++] = length & 255;
        } else {
          target[position++] = 223;
          targetView.setUint32(position, length);
          position += 4;
        }
        let key;
        if (this.coercibleKeyAsNumber) {
          for (let i = 0;i < length; i++) {
            key = keys[i];
            let num = Number(key);
            pack2(isNaN(num) ? key : num);
            pack2(object13[key]);
          }
        } else {
          for (let i = 0;i < length; i++) {
            pack2(key = keys[i]);
            pack2(object13[key]);
          }
        }
      } : (object13, safePrototype) => {
        target[position++] = 222;
        let objectOffset = position - start;
        position += 2;
        let size2 = 0;
        for (let key in object13) {
          if (safePrototype || object13.hasOwnProperty(key)) {
            pack2(key);
            pack2(object13[key]);
            size2++;
          }
        }
        target[objectOffset++ + start] = size2 >> 8;
        target[objectOffset + start] = size2 & 255;
      };
      const writeRecord = this.useRecords === false ? writePlainObject : options.progressiveRecords && !useTwoByteRecords ? (object13, safePrototype) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
        let objectOffset = position++ - start;
        let wroteKeys;
        for (let key in object13) {
          if (safePrototype || object13.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (nextTransition)
              transition = nextTransition;
            else {
              let keys = Object.keys(object13);
              let lastTransition = transition;
              transition = structures.transitions;
              let newTransitions = 0;
              for (let i = 0, l2 = keys.length;i < l2; i++) {
                let key2 = keys[i];
                nextTransition = transition[key2];
                if (!nextTransition) {
                  nextTransition = transition[key2] = Object.create(null);
                  newTransitions++;
                }
                transition = nextTransition;
              }
              if (objectOffset + start + 1 == position) {
                position--;
                newRecord(transition, keys, newTransitions);
              } else
                insertNewRecord(transition, keys, objectOffset, newTransitions);
              wroteKeys = true;
              transition = lastTransition[key];
            }
            pack2(object13[key]);
          }
        }
        if (!wroteKeys) {
          let recordId = transition[RECORD_SYMBOL];
          if (recordId)
            target[objectOffset + start] = recordId;
          else
            insertNewRecord(transition, Object.keys(object13), objectOffset, 0);
        }
      } : (object13, safePrototype) => {
        let nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null));
        let newTransitions = 0;
        for (let key in object13)
          if (safePrototype || object13.hasOwnProperty(key)) {
            nextTransition = transition[key];
            if (!nextTransition) {
              nextTransition = transition[key] = Object.create(null);
              newTransitions++;
            }
            transition = nextTransition;
          }
        let recordId = transition[RECORD_SYMBOL];
        if (recordId) {
          if (recordId >= 96 && useTwoByteRecords) {
            target[position++] = ((recordId -= 96) & 31) + 96;
            target[position++] = recordId >> 5;
          } else
            target[position++] = recordId;
        } else {
          newRecord(transition, transition.__keys__ || Object.keys(object13), newTransitions);
        }
        for (let key in object13)
          if (safePrototype || object13.hasOwnProperty(key)) {
            pack2(object13[key]);
          }
      };
      const checkUseRecords = typeof this.useRecords == "function" && this.useRecords;
      const writeObject = checkUseRecords ? (object13, safePrototype) => {
        checkUseRecords(object13) ? writeRecord(object13, safePrototype) : writePlainObject(object13, safePrototype);
      } : writeRecord;
      const makeRoom = (end) => {
        let newSize;
        if (end > 16777216) {
          if (end - start > MAX_BUFFER_SIZE)
            throw new Error("Packed buffer would be larger than maximum buffer size");
          newSize = Math.min(MAX_BUFFER_SIZE, Math.round(Math.max((end - start) * (end > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096);
        } else
          newSize = (Math.max(end - start << 2, target.length - 1) >> 12) + 1 << 12;
        let newBuffer = new ByteArrayAllocate(newSize);
        targetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize));
        end = Math.min(end, target.length);
        if (target.copy)
          target.copy(newBuffer, 0, start, end);
        else
          newBuffer.set(target.slice(start, end));
        position -= start;
        start = 0;
        safeEnd = newBuffer.length - 10;
        return target = newBuffer;
      };
      const newRecord = (transition, keys, newTransitions) => {
        let recordId = structures.nextId;
        if (!recordId)
          recordId = 64;
        if (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {
          recordId = structures.nextOwnId;
          if (!(recordId < maxStructureId))
            recordId = sharedLimitId;
          structures.nextOwnId = recordId + 1;
        } else {
          if (recordId >= maxStructureId)
            recordId = sharedLimitId;
          structures.nextId = recordId + 1;
        }
        let highByte = keys.highByte = recordId >= 96 && useTwoByteRecords ? recordId - 96 >> 5 : -1;
        transition[RECORD_SYMBOL] = recordId;
        transition.__keys__ = keys;
        structures[recordId - 64] = keys;
        if (recordId < sharedLimitId) {
          keys.isShared = true;
          structures.sharedLength = recordId - 63;
          hasSharedUpdate = true;
          if (highByte >= 0) {
            target[position++] = (recordId & 31) + 96;
            target[position++] = highByte;
          } else {
            target[position++] = recordId;
          }
        } else {
          if (highByte >= 0) {
            target[position++] = 213;
            target[position++] = 114;
            target[position++] = (recordId & 31) + 96;
            target[position++] = highByte;
          } else {
            target[position++] = 212;
            target[position++] = 114;
            target[position++] = recordId;
          }
          if (newTransitions)
            transitionsCount += serializationsSinceTransitionRebuild * newTransitions;
          if (recordIdsToRemove.length >= maxOwnStructures)
            recordIdsToRemove.shift()[RECORD_SYMBOL] = 0;
          recordIdsToRemove.push(transition);
          pack2(keys);
        }
      };
      const insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {
        let mainTarget = target;
        let mainPosition = position;
        let mainSafeEnd = safeEnd;
        let mainStart = start;
        target = keysTarget;
        position = 0;
        start = 0;
        if (!target)
          keysTarget = target = new ByteArrayAllocate(8192);
        safeEnd = target.length - 10;
        newRecord(transition, keys, newTransitions);
        keysTarget = target;
        let keysPosition = position;
        target = mainTarget;
        position = mainPosition;
        safeEnd = mainSafeEnd;
        start = mainStart;
        if (keysPosition > 1) {
          let newEnd = position + keysPosition - 1;
          if (newEnd > safeEnd)
            makeRoom(newEnd);
          let insertionPosition = insertionOffset + start;
          target.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position);
          target.set(keysTarget.slice(0, keysPosition), insertionPosition);
          position = newEnd;
        } else {
          target[insertionOffset + start] = keysTarget[0];
        }
      };
      const writeStruct2 = (object13, safePrototype) => {
        let newPosition = writeStructSlots(object13, target, start, position, structures, makeRoom, (value15, newPosition2, notifySharedUpdate) => {
          if (notifySharedUpdate)
            return hasSharedUpdate = true;
          position = newPosition2;
          let startTarget = target;
          pack2(value15);
          resetStructures();
          if (startTarget !== target) {
            return { position, targetView, target };
          }
          return position;
        }, this);
        if (newPosition === 0)
          return writeObject(object13, true);
        position = newPosition;
      };
    }
    useBuffer(buffer2) {
      target = buffer2;
      targetView = new DataView(target.buffer, target.byteOffset, target.byteLength);
      position = 0;
    }
    clearSharedData() {
      if (this.structures)
        this.structures = [];
      if (this.typedStructs)
        this.typedStructs = [];
    }
  }
  extensionClasses = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, C1Type];
  extensions = [{
    pack(date5, allocateForWrite, pack2) {
      let seconds = date5.getTime() / 1000;
      if ((this.useTimestamp32 || date5.getMilliseconds() === 0) && seconds >= 0 && seconds < 4294967296) {
        let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(6);
        target2[position2++] = 214;
        target2[position2++] = 255;
        targetView2.setUint32(position2, seconds);
      } else if (seconds > 0 && seconds < 4294967296) {
        let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(10);
        target2[position2++] = 215;
        target2[position2++] = 255;
        targetView2.setUint32(position2, date5.getMilliseconds() * 4000000 + (seconds / 1000 / 4294967296 >> 0));
        targetView2.setUint32(position2 + 4, seconds);
      } else if (isNaN(seconds)) {
        if (this.onInvalidDate) {
          allocateForWrite(0);
          return pack2(this.onInvalidDate());
        }
        let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(3);
        target2[position2++] = 212;
        target2[position2++] = 255;
        target2[position2++] = 255;
      } else {
        let { target: target2, targetView: targetView2, position: position2 } = allocateForWrite(15);
        target2[position2++] = 199;
        target2[position2++] = 12;
        target2[position2++] = 255;
        targetView2.setUint32(position2, date5.getMilliseconds() * 1e6);
        targetView2.setBigInt64(position2 + 4, BigInt(Math.floor(seconds)));
      }
    }
  }, {
    pack(set2, allocateForWrite, pack2) {
      if (this.setAsEmptyObject) {
        allocateForWrite(0);
        return pack2({});
      }
      let array6 = Array.from(set2);
      let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
      if (this.moreTypes) {
        target2[position2++] = 212;
        target2[position2++] = 115;
        target2[position2++] = 0;
      }
      pack2(array6);
    }
  }, {
    pack(error22, allocateForWrite, pack2) {
      let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
      if (this.moreTypes) {
        target2[position2++] = 212;
        target2[position2++] = 101;
        target2[position2++] = 0;
      }
      pack2([error22.name, error22.message]);
    }
  }, {
    pack(regex, allocateForWrite, pack2) {
      let { target: target2, position: position2 } = allocateForWrite(this.moreTypes ? 3 : 0);
      if (this.moreTypes) {
        target2[position2++] = 212;
        target2[position2++] = 120;
        target2[position2++] = 0;
      }
      pack2([regex.source, regex.flags]);
    }
  }, {
    pack(arrayBuffer, allocateForWrite) {
      if (this.moreTypes)
        writeExtBuffer(arrayBuffer, 16, allocateForWrite);
      else
        writeBuffer(hasNodeBuffer$1 ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite);
    }
  }, {
    pack(typedArray, allocateForWrite) {
      let constructor5 = typedArray.constructor;
      if (constructor5 !== ByteArray && this.moreTypes)
        writeExtBuffer(typedArray, typedArrays.indexOf(constructor5.name), allocateForWrite);
      else
        writeBuffer(typedArray, allocateForWrite);
    }
  }, {
    pack(c1, allocateForWrite) {
      let { target: target2, position: position2 } = allocateForWrite(1);
      target2[position2] = 193;
    }
  }];
  var defaultPackr = new Packr({ useRecords: false });
  var pack = defaultPackr.pack;
  var encode2 = defaultPackr.pack;
  var Encoder = Packr;
  var { NEVER: NEVER2, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS;
  var REUSE_BUFFER_MODE = 512;
  var RESET_BUFFER_MODE = 1024;
  var RESERVE_START_SPACE = 2048;
  var ASCII = 3;
  var NUMBER = 0;
  var UTF8 = 2;
  var OBJECT_DATA = 1;
  var DATE = 16;
  var TYPE_NAMES = ["num", "object", "string", "ascii"];
  TYPE_NAMES[DATE] = "date";
  var float32Headers = [false, true, true, false, false, true, true, false];
  var evalSupported;
  try {
    new Function("");
    evalSupported = true;
  } catch (error22) {
  }
  var updatedPosition;
  var hasNodeBuffer = typeof Buffer !== "undefined";
  var textEncoder;
  var currentSource;
  try {
    textEncoder = new TextEncoder;
  } catch (error22) {
  }
  var encodeUtf8 = hasNodeBuffer ? function(target2, string7, position2) {
    return target2.utf8Write(string7, position2, 4294967295);
  } : textEncoder && textEncoder.encodeInto ? function(target2, string7, position2) {
    return textEncoder.encodeInto(string7, target2.subarray(position2)).written;
  } : false;
  setWriteStructSlots(writeStruct, prepareStructures);
  var sourceSymbol = Symbol.for("source");
  setReadStruct(readStruct, onLoadedStructures, saveState);

  class PackrStream extends stream.Transform {
    constructor(options) {
      if (!options)
        options = {};
      options.writableObjectMode = true;
      super(options);
      options.sequential = true;
      this.packr = options.packr || new Packr(options);
    }
    _transform(value15, encoding, callback) {
      this.push(this.packr.pack(value15));
      callback();
    }
  }

  class UnpackrStream extends stream.Transform {
    constructor(options) {
      if (!options)
        options = {};
      options.objectMode = true;
      super(options);
      options.structures = [];
      this.unpackr = options.unpackr || new Unpackr(options);
    }
    _transform(chunk, encoding, callback) {
      if (this.incompleteBuffer) {
        chunk = Buffer.concat([this.incompleteBuffer, chunk]);
        this.incompleteBuffer = null;
      }
      let values2;
      try {
        values2 = this.unpackr.unpackMultiple(chunk);
      } catch (error22) {
        if (error22.incomplete) {
          this.incompleteBuffer = chunk.slice(error22.lastPosition);
          values2 = error22.values;
        } else
          throw error22;
      } finally {
        for (let value15 of values2 || []) {
          if (value15 === null)
            value15 = this.getNullValue();
          this.push(value15);
        }
      }
      if (callback)
        callback();
    }
    getNullValue() {
      return Symbol.for(null);
    }
  }
  var decodeIter = unpackIter;
  var encodeIter = packIter;
  var useRecords = false;
  var mapsAsObjects = true;
  var nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === "true";
  if (!nativeAccelerationDisabled) {
    let extractor;
    try {
      if (typeof import.meta.require == "function")
        extractor = require_msgpackr_extract();
      else
        extractor = module$1.createRequire(typeof document === "undefined" ? new (import.meta.require("url")).URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("node.cjs", document.baseURI).href)("msgpackr-extract");
      if (extractor)
        setExtractor(extractor.extractStrings);
    } catch (error22) {
    }
  }
  exports.ALWAYS = ALWAYS;
  exports.C1 = C12;
  exports.DECIMAL_FIT = DECIMAL_FIT;
  exports.DECIMAL_ROUND = DECIMAL_ROUND;
  exports.Decoder = Decoder;
  exports.DecoderStream = UnpackrStream;
  exports.Encoder = Encoder;
  exports.EncoderStream = PackrStream;
  exports.FLOAT32_OPTIONS = FLOAT32_OPTIONS;
  exports.NEVER = NEVER2;
  exports.Packr = Packr;
  exports.PackrStream = PackrStream;
  exports.Unpackr = Unpackr;
  exports.UnpackrStream = UnpackrStream;
  exports.addExtension = addExtension;
  exports.clearSource = clearSource;
  exports.decode = decode2;
  exports.decodeIter = decodeIter;
  exports.encode = encode2;
  exports.encodeIter = encodeIter;
  exports.mapsAsObjects = mapsAsObjects;
  exports.pack = pack;
  exports.roundFloat32 = roundFloat32;
  exports.unpack = unpack;
  exports.unpackMultiple = unpackMultiple;
  exports.useRecords = useRecords;
});

// node_modules/bull/lib/scripts.js
var require_scripts = __commonJS((exports, module) => {
  var array2obj = function(arr) {
    const obj = {};
    for (let i = 0;i < arr.length; i += 2) {
      obj[arr[i]] = arr[i + 1];
    }
    return obj;
  };
  var raw2jobData = function(raw2) {
    if (raw2) {
      const jobData = raw2[0];
      if (jobData.length) {
        const job = array2obj(jobData);
        return [job, raw2[1]];
      }
    }
    return [];
  };
  var _ = require_lodash4();
  var msgpackr = require_node2();
  var packer = new msgpackr.Packr({
    useRecords: false,
    encodeUndefinedAsNil: true
  });
  var pack = packer.pack;
  var scripts = {
    isJobInList(client, listKey, jobId) {
      return client.isJobInList([listKey, jobId]).then((result2) => {
        return result2 === 1;
      });
    },
    addJob(client, queue3, job, opts) {
      const queueKeys = queue3.keys;
      let keys = [
        queueKeys.wait,
        queueKeys.paused,
        queueKeys["meta-paused"],
        queueKeys.id,
        queueKeys.delayed,
        queueKeys.priority
      ];
      const args = [
        queueKeys[""],
        _.isUndefined(opts.customJobId) ? "" : opts.customJobId,
        job.name,
        job.data,
        job.opts,
        job.timestamp,
        job.delay,
        job.delay ? job.timestamp + job.delay : 0,
        opts.priority || 0,
        opts.lifo ? "RPUSH" : "LPUSH",
        queue3.token
      ];
      keys = keys.concat(args);
      return client.addJob(keys);
    },
    pause(queue3, pause) {
      let src = "wait", dst = "paused";
      if (!pause) {
        src = "paused";
        dst = "wait";
      }
      const keys = _.map([src, dst, "meta-paused", pause ? "paused" : "resumed", "meta"], (name) => {
        return queue3.toKey(name);
      });
      return queue3.client.pause(keys.concat([pause ? "paused" : "resumed"]));
    },
    moveToActive(queue3, jobId) {
      const queueKeys = queue3.keys;
      const keys = [queueKeys.wait, queueKeys.active, queueKeys.priority];
      keys[3] = keys[1] + "@" + queue3.token;
      keys[4] = queueKeys.stalled;
      keys[5] = queueKeys.limiter;
      keys[6] = queueKeys.delayed;
      keys[7] = queueKeys.drained;
      const args = [
        queueKeys[""],
        queue3.token,
        queue3.settings.lockDuration,
        Date.now(),
        jobId
      ];
      if (queue3.limiter) {
        args.push(queue3.limiter.max, queue3.limiter.duration, !!queue3.limiter.bounceBack);
        queue3.limiter.groupKey && args.push(true);
      }
      return queue3.client.moveToActive(keys.concat(args)).then(raw2jobData);
    },
    updateProgress(job, progress) {
      const queue3 = job.queue;
      const keys = [job.id, "progress"].map((name) => {
        return queue3.toKey(name);
      });
      const progressJson = JSON.stringify(progress);
      return queue3.client.updateProgress(keys, [
        progressJson,
        JSON.stringify({ jobId: job.id, progress })
      ]).then(() => {
        queue3.emit("progress", job, progress);
      });
    },
    retryJobsArgs(queue3, count) {
      const keys = [
        queue3.toKey(""),
        queue3.toKey("failed"),
        queue3.toKey("wait"),
        queue3.toKey("meta-paused"),
        queue3.toKey("paused")
      ];
      const args = [count];
      return keys.concat(args);
    },
    async retryJobs(queue3, count = 1000) {
      const client = await queue3.client;
      const args = this.retryJobsArgs(queue3, count);
      return client.retryJobs(args);
    },
    moveToFinishedArgs(job, val, propVal, shouldRemove, target, ignoreLock, notFetch) {
      const queue3 = job.queue;
      const queueKeys = queue3.keys;
      const metricsKey = queue3.toKey(`metrics:${target}`);
      const keys = [
        queueKeys.active,
        queueKeys[target],
        queue3.toKey(job.id),
        queueKeys.wait,
        queueKeys.priority,
        queueKeys.active + "@" + queue3.token,
        queueKeys.delayed,
        queueKeys.stalled,
        metricsKey
      ];
      const keepJobs = pack(typeof shouldRemove === "object" ? shouldRemove : typeof shouldRemove === "number" ? { count: shouldRemove } : { count: shouldRemove ? 0 : -1 });
      const args = [
        job.id,
        job.finishedOn,
        propVal,
        _.isUndefined(val) ? "null" : val,
        ignoreLock ? "0" : queue3.token,
        keepJobs,
        JSON.stringify({ jobId: job.id, val }),
        notFetch || queue3.paused || queue3.closing || queue3.limiter ? 0 : 1,
        queueKeys[""],
        queue3.settings.lockDuration,
        queue3.token,
        queue3.metrics && queue3.metrics.maxDataPoints
      ];
      return keys.concat(args);
    },
    moveToFinished(job, val, propVal, shouldRemove, target, ignoreLock, notFetch = false) {
      const args = scripts.moveToFinishedArgs(job, val, propVal, shouldRemove, target, ignoreLock, notFetch, job.queue.toKey(""));
      return job.queue.client.moveToFinished(args).then((result2) => {
        if (result2 < 0) {
          throw scripts.finishedErrors(result2, job.id, "finished");
        } else if (result2) {
          return raw2jobData(result2);
        }
        return 0;
      });
    },
    finishedErrors(code, jobId, command) {
      switch (code) {
        case -1:
          return new Error("Missing key for job " + jobId + " " + command);
        case -2:
          return new Error("Missing lock for job " + jobId + " " + command);
      }
    },
    moveToCompleted(job, returnvalue, removeOnComplete, ignoreLock, notFetch = false) {
      return scripts.moveToFinished(job, returnvalue, "returnvalue", removeOnComplete, "completed", ignoreLock, notFetch);
    },
    moveToFailedArgs(job, failedReason, removeOnFailed, ignoreLock) {
      return scripts.moveToFinishedArgs(job, failedReason, "failedReason", removeOnFailed, "failed", ignoreLock, true);
    },
    moveToFailed(job, failedReason, removeOnFailed, ignoreLock) {
      const args = scripts.moveToFailedArgs(job, failedReason, removeOnFailed, ignoreLock);
      return scripts.moveToFinished(args);
    },
    isFinished(job) {
      const keys = _.map(["completed", "failed"], (key) => {
        return job.queue.toKey(key);
      });
      return job.queue.client.isFinished(keys.concat([job.id]));
    },
    moveToDelayedArgs(queue3, jobId, timestamp2, ignoreLock) {
      timestamp2 = _.isUndefined(timestamp2) ? 0 : timestamp2;
      timestamp2 = +timestamp2 || 0;
      timestamp2 = timestamp2 < 0 ? 0 : timestamp2;
      if (timestamp2 > 0) {
        timestamp2 = timestamp2 * 4096 + (jobId & 4095);
      }
      const keys = _.map(["active", "delayed", jobId], (name) => {
        return queue3.toKey(name);
      });
      return keys.concat([
        JSON.stringify(timestamp2),
        jobId,
        ignoreLock ? "0" : queue3.token
      ]);
    },
    moveToDelayed(queue3, jobId, timestamp2, ignoreLock) {
      const args = scripts.moveToDelayedArgs(queue3, jobId, timestamp2, ignoreLock);
      return queue3.client.moveToDelayed(args).then((result2) => {
        switch (result2) {
          case -1:
            throw new Error("Missing Job " + jobId + " when trying to move from active to delayed");
          case -2:
            throw new Error("Job " + jobId + " was locked when trying to move from active to delayed");
        }
      });
    },
    remove(queue3, jobId) {
      const keys = [
        queue3.keys.active,
        queue3.keys.wait,
        queue3.keys.delayed,
        queue3.keys.paused,
        queue3.keys.completed,
        queue3.keys.failed,
        queue3.keys.priority,
        queue3.toKey(jobId),
        queue3.toKey(`${jobId}:logs`),
        queue3.keys.limiter
      ];
      return queue3.client.removeJob(keys.concat([jobId, queue3.token]));
    },
    async removeWithPattern(queue3, pattern3) {
      const keys = [
        queue3.keys.active,
        queue3.keys.wait,
        queue3.keys.delayed,
        queue3.keys.paused,
        queue3.keys.completed,
        queue3.keys.failed,
        queue3.keys.priority,
        queue3.keys.limiter
      ];
      const allRemoved = [];
      let cursor = "0", removed;
      do {
        [cursor, removed] = await queue3.client.removeJobs(keys.concat([queue3.toKey(""), pattern3, cursor]));
        allRemoved.push.apply(allRemoved, removed);
      } while (cursor !== "0");
      return allRemoved;
    },
    extendLock(queue3, jobId, duration) {
      return queue3.client.extendLock([
        queue3.toKey(jobId) + ":lock",
        queue3.keys.stalled,
        queue3.token,
        duration,
        jobId
      ]);
    },
    releaseLock(queue3, jobId) {
      return queue3.client.releaseLock([
        queue3.toKey(jobId) + ":lock",
        queue3.token
      ]);
    },
    takeLock(queue3, job) {
      return queue3.client.takeLock([
        job.lockKey(),
        queue3.token,
        queue3.settings.lockDuration
      ]);
    },
    updateDelaySet(queue3, delayedTimestamp) {
      const keys = [
        queue3.keys.delayed,
        queue3.keys.active,
        queue3.keys.wait,
        queue3.keys.priority,
        queue3.keys.paused,
        queue3.keys["meta-paused"]
      ];
      const args = [queue3.toKey(""), delayedTimestamp, queue3.token];
      return queue3.client.updateDelaySet(keys.concat(args));
    },
    promote(queue3, jobId) {
      const keys = [
        queue3.keys.delayed,
        queue3.keys.wait,
        queue3.keys.paused,
        queue3.keys.priority
      ];
      const args = [queue3.toKey(""), jobId, queue3.token];
      return queue3.client.promote(keys.concat(args));
    },
    moveUnlockedJobsToWait(queue3) {
      const keys = [
        queue3.keys.stalled,
        queue3.keys.wait,
        queue3.keys.active,
        queue3.keys.failed,
        queue3.keys["stalled-check"],
        queue3.keys["meta-paused"],
        queue3.keys.paused
      ];
      const args = [
        queue3.settings.maxStalledCount,
        queue3.toKey(""),
        Date.now(),
        queue3.settings.stalledInterval
      ];
      return queue3.client.moveStalledJobsToWait(keys.concat(args));
    },
    cleanJobsInSet(queue3, set2, ts, limit) {
      return queue3.client.cleanJobsInSet([
        queue3.toKey(set2),
        queue3.toKey("priority"),
        queue3.keys.limiter,
        queue3.toKey(""),
        ts,
        limit || 0,
        set2
      ]);
    },
    retryJobArgs(job, ignoreLock) {
      const queue3 = job.queue;
      const jobId = job.id;
      const keys = _.map(["active", "wait", jobId, "meta-paused", "paused"], (name) => {
        return queue3.toKey(name);
      });
      const pushCmd = (job.opts.lifo ? "R" : "L") + "PUSH";
      return keys.concat([pushCmd, jobId, ignoreLock ? "0" : job.queue.token]);
    },
    reprocessJob(job, options) {
      const queue3 = job.queue;
      const keys = [
        queue3.toKey(job.id),
        queue3.toKey(job.id) + ":lock",
        queue3.toKey(options.state),
        queue3.toKey("wait"),
        queue3.toKey("meta-paused"),
        queue3.toKey("paused")
      ];
      const args = [
        job.id,
        (job.opts.lifo ? "R" : "L") + "PUSH",
        queue3.token,
        Date.now()
      ];
      return queue3.client.reprocessJob(keys.concat(args));
    },
    obliterate(queue3, opts) {
      const client = queue3.client;
      const keys = [queue3.keys["meta-paused"], queue3.toKey("")];
      const args = [opts.count, opts.force ? "force" : null];
      return client.obliterate(keys.concat(args)).then((result2) => {
        if (result2 < 0) {
          switch (result2) {
            case -1:
              throw new Error("Cannot obliterate non-paused queue");
            case -2:
              throw new Error("Cannot obliterate queue with active jobs");
          }
        }
        return result2;
      });
    }
  };
  module.exports = scripts;
});

// node_modules/bull/lib/errors.js
var require_errors2 = __commonJS((exports, module) => {
  exports.Messages = {
    RETRY_JOB_NOT_EXIST: "Couldn't retry job: The job doesn't exist",
    RETRY_JOB_IS_LOCKED: "Couldn't retry job: The job is locked",
    RETRY_JOB_NOT_FAILED: "Couldn't retry job: The job has been already retried or has not failed",
    MISSING_REDIS_OPTS: `Using a redis instance with enableReadyCheck or maxRetriesPerRequest for bclient/subscriber is not permitted.
  see https://github.com/OptimalBits/bull/issues/1873
  `
  };
});

// node_modules/bull/lib/backoffs.js
var require_backoffs = __commonJS((exports, module) => {
  var lookupStrategy = function(backoff2, customStrategies) {
    if (backoff2.type in customStrategies) {
      return customStrategies[backoff2.type];
    } else if (backoff2.type in builtinStrategies) {
      return builtinStrategies[backoff2.type](backoff2.delay);
    } else {
      throw new Error("Unknown backoff strategy " + backoff2.type + ". If a custom backoff strategy is used, specify it when the queue is created.");
    }
  };
  var _ = require_lodash4();
  var builtinStrategies = {
    fixed(delay) {
      return function() {
        return delay;
      };
    },
    exponential(delay) {
      return function(attemptsMade) {
        return Math.round((Math.pow(2, attemptsMade) - 1) * delay);
      };
    }
  };
  module.exports = {
    normalize(backoff2) {
      if (_.isFinite(backoff2)) {
        return {
          type: "fixed",
          delay: backoff2
        };
      } else if (backoff2) {
        return backoff2;
      }
    },
    calculate(backoff2, attemptsMade, customStrategies, err, strategyOptions) {
      if (backoff2) {
        const strategy = lookupStrategy(backoff2, customStrategies, strategyOptions);
        return strategy(attemptsMade, err, strategyOptions);
      }
    }
  };
});

// node_modules/bull/lib/job.js
var require_job = __commonJS((exports, module) => {
  var setDefaultOpts = function(opts) {
    const _opts = Object.assign({}, opts);
    _opts.attempts = typeof _opts.attempts == "undefined" ? 1 : _opts.attempts;
    _opts.delay = typeof _opts.delay == "undefined" ? 0 : Number(_opts.delay);
    _opts.timestamp = typeof _opts.timestamp == "undefined" ? Date.now() : _opts.timestamp;
    _opts.attempts = parseInt(_opts.attempts);
    _opts.backoff = backoffs.normalize(_opts.backoff);
    return _opts;
  };
  var addJob = function(queue3, client, job) {
    const opts = job.opts;
    const jobData = job.toData();
    return scripts.addJob(client, queue3, jobData, {
      lifo: opts.lifo,
      customJobId: opts.jobId,
      priority: opts.priority
    });
  };
  var getTraces = function(stacktrace) {
    const _traces = utils8.tryCatch(JSON.parse, JSON, [stacktrace]);
    if (_traces === utils8.errorObject || !(_traces instanceof Array)) {
      return [];
    } else {
      return _traces;
    }
  };
  var getReturnValue = function(_value) {
    const value15 = utils8.tryCatch(JSON.parse, JSON, [_value]);
    if (value15 !== utils8.errorObject) {
      return value15;
    } else {
      debuglog("corrupted returnvalue: " + _value, value15);
    }
  };
  var _ = require_lodash4();
  var utils8 = require_utils4();
  var scripts = require_scripts();
  var debuglog = import.meta.require("util").debuglog("bull");
  var errors10 = require_errors2();
  var backoffs = require_backoffs();
  var FINISHED_WATCHDOG = 5000;
  var DEFAULT_JOB_NAME = "__default__";
  var jobFields = [
    "opts",
    "name",
    "id",
    "progress",
    "delay",
    "timestamp",
    "finishedOn",
    "processedOn",
    "retriedOn",
    "failedReason",
    "attemptsMade",
    "stacktrace",
    "returnvalue"
  ];
  var Job = function(queue3, name, data, opts) {
    if (typeof name !== "string") {
      opts = data;
      data = name;
      name = DEFAULT_JOB_NAME;
    }
    this.opts = setDefaultOpts(opts);
    this.name = name;
    this.queue = queue3;
    this.data = data;
    this._progress = 0;
    this.delay = this.opts.delay < 0 ? 0 : this.opts.delay;
    this.timestamp = this.opts.timestamp;
    this.stacktrace = [];
    this.returnvalue = null;
    this.attemptsMade = 0;
    this.toKey = _.bind(queue3.toKey, queue3);
  };
  Job.DEFAULT_JOB_NAME = DEFAULT_JOB_NAME;
  Job.create = function(queue3, name, data, opts) {
    const job = new Job(queue3, name, data, opts);
    return queue3.isReady().then(() => {
      return addJob(queue3, queue3.client, job);
    }).then((jobId) => {
      job.id = jobId;
      debuglog("Job added", jobId);
      return job;
    });
  };
  Job.createBulk = function(queue3, jobs) {
    jobs = jobs.map((job) => new Job(queue3, job.name, job.data, job.opts));
    return queue3.isReady().then(() => {
      const multi = queue3.client.multi();
      for (const job of jobs) {
        addJob(queue3, multi, job);
      }
      return multi.exec();
    }).then((res) => {
      res.forEach((res2, index) => {
        jobs[index].id = res2[1];
        debuglog("Job added", res2[1]);
      });
      return jobs;
    });
  };
  Job.fromId = async function(queue3, jobId, opts) {
    if (!jobId) {
      return Promise.resolve();
    }
    const jobKey = queue3.toKey(jobId);
    let rawJob;
    if (opts && opts.excludeData) {
      rawJob = _.zipObject(jobFields, await queue3.client.hmget(jobKey, jobFields));
    } else {
      rawJob = await queue3.client.hgetall(jobKey);
    }
    return _.isEmpty(rawJob) ? null : Job.fromJSON(queue3, rawJob, jobId);
  };
  Job.remove = async function(queue3, pattern3) {
    await queue3.isReady();
    const removed = await scripts.removeWithPattern(queue3, pattern3);
    removed.forEach((jobId) => queue3.emit("removed", jobId));
  };
  Job.prototype.progress = function(progress) {
    if (_.isUndefined(progress)) {
      return this._progress;
    }
    this._progress = progress;
    return scripts.updateProgress(this, progress);
  };
  Job.prototype.update = function(data) {
    this.data = data;
    return this.queue.client.hset(this.queue.toKey(this.id), "data", JSON.stringify(data));
  };
  Job.prototype.toJSON = function() {
    const opts = Object.assign({}, this.opts);
    return {
      id: this.id,
      name: this.name,
      data: this.data || {},
      opts,
      progress: this._progress,
      delay: this.delay,
      timestamp: this.timestamp,
      attemptsMade: this.attemptsMade,
      failedReason: this.failedReason,
      stacktrace: this.stacktrace || null,
      returnvalue: this.returnvalue || null,
      finishedOn: this.finishedOn || null,
      processedOn: this.processedOn || null
    };
  };
  Job.prototype.toData = function() {
    const json2 = this.toJSON();
    json2.data = JSON.stringify(json2.data);
    json2.opts = JSON.stringify(json2.opts);
    json2.stacktrace = JSON.stringify(json2.stacktrace);
    json2.failedReason = JSON.stringify(json2.failedReason);
    json2.returnvalue = JSON.stringify(json2.returnvalue);
    return json2;
  };
  Job.prototype.lockKey = function() {
    return this.toKey(this.id) + ":lock";
  };
  Job.prototype.takeLock = function() {
    return scripts.takeLock(this.queue, this).then((lock) => {
      return lock || false;
    });
  };
  Job.prototype.releaseLock = function() {
    return scripts.releaseLock(this.queue, this.id).then((unlocked) => {
      if (unlocked != 1) {
        throw new Error("Could not release lock for job " + this.id);
      }
    });
  };
  Job.prototype.extendLock = function(duration) {
    return scripts.extendLock(this.queue, this.id, duration);
  };
  Job.prototype.moveToCompleted = function(returnValue, ignoreLock, notFetch = false) {
    return this.queue.isReady().then(() => {
      this.returnvalue = returnValue || 0;
      returnValue = utils8.tryCatch(JSON.stringify, JSON, [returnValue]);
      if (returnValue === utils8.errorObject) {
        const err = utils8.errorObject.value;
        return Promise.reject(err);
      }
      this.finishedOn = Date.now();
      return scripts.moveToCompleted(this, returnValue, this.opts.removeOnComplete, ignoreLock, notFetch);
    });
  };
  Job.prototype.discard = function() {
    this._discarded = true;
  };
  Job.prototype.moveToFailed = async function(err, ignoreLock) {
    err = err || { message: "Unknown reason" };
    this.failedReason = err.message;
    await this.queue.isReady();
    let command;
    const multi = this.queue.client.multi();
    this._saveAttempt(multi, err);
    let moveToFailed = false;
    if (this.attemptsMade < this.opts.attempts && !this._discarded) {
      const delay = await backoffs.calculate(this.opts.backoff, this.attemptsMade, this.queue.settings.backoffStrategies, err, _.get(this, "opts.backoff.options", null));
      if (delay === -1) {
        moveToFailed = true;
      } else if (delay) {
        const args = scripts.moveToDelayedArgs(this.queue, this.id, Date.now() + delay, ignoreLock);
        multi.moveToDelayed(args);
        command = "delayed";
      } else {
        multi.retryJob(scripts.retryJobArgs(this, ignoreLock));
        command = "retry";
      }
    } else {
      moveToFailed = true;
    }
    if (moveToFailed) {
      this.finishedOn = Date.now();
      const args = scripts.moveToFailedArgs(this, err.message, this.opts.removeOnFail, ignoreLock);
      multi.moveToFinished(args);
      command = "failed";
    }
    const results = await multi.exec();
    const code = _.last(results)[1];
    if (code < 0) {
      throw scripts.finishedErrors(code, this.id, command);
    }
  };
  Job.prototype.moveToDelayed = function(timestamp2, ignoreLock) {
    return scripts.moveToDelayed(this.queue, this.id, timestamp2, ignoreLock);
  };
  Job.prototype.promote = function() {
    const queue3 = this.queue;
    const jobId = this.id;
    return queue3.isReady().then(() => scripts.promote(queue3, jobId).then((result2) => {
      if (result2 === -1) {
        throw new Error("Job " + jobId + " is not in a delayed state");
      }
    }));
  };
  Job.prototype.retry = function() {
    return this.queue.isReady().then(() => {
      this.failedReason = null;
      this.finishedOn = null;
      this.processedOn = null;
      this.retriedOn = Date.now();
      return scripts.reprocessJob(this, { state: "failed" }).then((result2) => {
        if (result2 === 1) {
          return;
        } else if (result2 === 0) {
          throw new Error(errors10.Messages.RETRY_JOB_NOT_EXIST);
        } else if (result2 === -1) {
          throw new Error(errors10.Messages.RETRY_JOB_IS_LOCKED);
        } else if (result2 === -2) {
          throw new Error(errors10.Messages.RETRY_JOB_NOT_FAILED);
        }
      });
    });
  };
  Job.prototype.log = function(logRow) {
    const logsKey = this.toKey(this.id) + ":logs";
    return this.queue.client.rpush(logsKey, logRow);
  };
  Job.prototype.isCompleted = function() {
    return this._isDone("completed");
  };
  Job.prototype.isFailed = function() {
    return this._isDone("failed");
  };
  Job.prototype.isDelayed = function() {
    return this._isDone("delayed");
  };
  Job.prototype.isActive = function() {
    return this._isInList("active");
  };
  Job.prototype.isWaiting = function() {
    return this._isInList("wait");
  };
  Job.prototype.isPaused = function() {
    return this._isInList("paused");
  };
  Job.prototype.isStuck = function() {
    return this.getState().then((state) => {
      return state === "stuck";
    });
  };
  Job.prototype.isDiscarded = function() {
    return this._discarded;
  };
  Job.prototype.getState = function() {
    const fns = [
      { fn: "isCompleted", state: "completed" },
      { fn: "isFailed", state: "failed" },
      { fn: "isDelayed", state: "delayed" },
      { fn: "isActive", state: "active" },
      { fn: "isWaiting", state: "waiting" },
      { fn: "isPaused", state: "paused" }
    ];
    return fns.reduce((result2, fn) => {
      return result2.then((state) => {
        if (state) {
          return state;
        }
        return this[fn.fn]().then((result3) => {
          return result3 ? fn.state : null;
        });
      });
    }, Promise.resolve()).then((result2) => {
      return result2 ? result2 : "stuck";
    });
  };
  Job.prototype.remove = function() {
    const queue3 = this.queue;
    const job = this;
    return queue3.isReady().then(() => {
      return scripts.remove(queue3, job.id).then((removed) => {
        if (removed) {
          queue3.emit("removed", job);
        } else {
          throw new Error("Could not remove job " + job.id);
        }
      });
    });
  };
  Job.prototype.finished = async function() {
    await Promise.all([
      this.queue._registerEvent("global:completed"),
      this.queue._registerEvent("global:failed")
    ]);
    await this.queue.isReady();
    const status = await scripts.isFinished(this);
    const finished = status > 0;
    if (finished) {
      const job = await Job.fromId(this.queue, this.id);
      if (status == 2) {
        throw new Error(job.failedReason);
      } else {
        return job.returnvalue;
      }
    } else {
      return new Promise((resolve, reject) => {
        const onCompleted = (jobId, resultValue) => {
          if (String(jobId) === String(this.id)) {
            let result2 = undefined;
            try {
              if (typeof resultValue === "string") {
                result2 = JSON.parse(resultValue);
              }
            } catch (err) {
              debuglog("corrupted resultValue: " + resultValue, err);
            }
            resolve(result2);
            removeListeners();
          }
        };
        const onFailed = (jobId, failedReason) => {
          if (String(jobId) === String(this.id)) {
            reject(new Error(failedReason));
            removeListeners();
          }
        };
        this.queue.on("global:completed", onCompleted);
        this.queue.on("global:failed", onFailed);
        const removeListeners = () => {
          clearInterval(interval);
          this.queue.removeListener("global:completed", onCompleted);
          this.queue.removeListener("global:failed", onFailed);
        };
        const interval = setInterval(() => {
          if (this._isQueueClosing()) {
            removeListeners();
            reject(new Error("cannot check if job is finished in a closing queue."));
          } else {
            scripts.isFinished(this).then((status2) => {
              const finished2 = status2 > 0;
              if (finished2) {
                Job.fromId(this.queue, this.id).then((job) => {
                  removeListeners();
                  if (status2 == 2) {
                    reject(new Error(job.failedReason));
                  } else {
                    resolve(job.returnvalue);
                  }
                });
              }
            });
          }
        }, FINISHED_WATCHDOG);
      });
    }
  };
  Job.prototype._isQueueClosing = function() {
    return this.queue.closing;
  };
  Job.prototype._isDone = function(list) {
    return this.queue.client.zscore(this.queue.toKey(list), this.id).then((score) => {
      return score !== null;
    });
  };
  Job.prototype._isInList = function(list) {
    return scripts.isJobInList(this.queue.client, this.queue.toKey(list), this.id);
  };
  Job.prototype._saveAttempt = function(multi, err) {
    this.attemptsMade++;
    const params = {
      attemptsMade: this.attemptsMade
    };
    if (this.opts.stackTraceLimit) {
      this.stacktrace = this.stacktrace.slice(0, this.opts.stackTraceLimit - 1);
    }
    this.stacktrace.push(err.stack);
    params.stacktrace = JSON.stringify(this.stacktrace);
    params.failedReason = err.message;
    multi.hmset(this.queue.toKey(this.id), params);
  };
  Job.fromJSON = function(queue3, json2, jobId) {
    const opts = JSON.parse(json2.opts || "{}");
    const data = opts.preventParsingData ? json2.data : JSON.parse(json2.data || "{}");
    const job = new Job(queue3, json2.name || Job.DEFAULT_JOB_NAME, data, opts);
    job.id = json2.id || jobId;
    try {
      job._progress = JSON.parse(json2.progress || 0);
    } catch (err) {
      console.error(`Error parsing progress ${json2.progress} with ${err.message}`);
    }
    job.delay = parseInt(json2.delay);
    job.timestamp = parseInt(json2.timestamp);
    if (json2.finishedOn) {
      job.finishedOn = parseInt(json2.finishedOn);
    }
    if (json2.processedOn) {
      job.processedOn = parseInt(json2.processedOn);
    }
    if (json2.retriedOn) {
      job.retriedOn = parseInt(json2.retriedOn);
    }
    job.failedReason = json2.failedReason;
    job.attemptsMade = parseInt(json2.attemptsMade || 0);
    job.stacktrace = getTraces(json2.stacktrace);
    if (typeof json2.returnvalue === "string") {
      job.returnvalue = getReturnValue(json2.returnvalue);
    }
    return job;
  };
  module.exports = Job;
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var rng = function() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = rng;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  exports.default = _default;
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var validate = function(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _regex = _interopRequireDefault(require_regex());
  var _default = validate;
  exports.default = _default;
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringify2 = function(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var byteToHex = [];
  for (let i = 0;i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  var _default = stringify2;
  exports.default = _default;
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v12 = function(options, buf, offset) {
    let i = buf && offset || 0;
    const b3 = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;
    if (node == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node == null) {
        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== undefined ? options.msecs : Date.now();
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 12219292800000;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b3[i++] = tl >>> 24 & 255;
    b3[i++] = tl >>> 16 & 255;
    b3[i++] = tl >>> 8 & 255;
    b3[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b3[i++] = tmh >>> 8 & 255;
    b3[i++] = tmh & 255;
    b3[i++] = tmh >>> 24 & 15 | 16;
    b3[i++] = tmh >>> 16 & 255;
    b3[i++] = clockseq >>> 8 | 128;
    b3[i++] = clockseq & 255;
    for (let n2 = 0;n2 < 6; ++n2) {
      b3[i + n2] = node[n2];
    }
    return buf || (0, _stringify.default)(b3);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _nodeId;
  var _clockseq;
  var _lastMSecs = 0;
  var _lastNSecs = 0;
  var _default = v12;
  exports.default = _default;
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var parse5 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v2;
    const arr = new Uint8Array(16);
    arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v2 >>> 16 & 255;
    arr[2] = v2 >>> 8 & 255;
    arr[3] = v2 & 255;
    arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v2 & 255;
    arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v2 & 255;
    arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v2 & 255;
    arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v2 / 4294967296 & 255;
    arr[12] = v2 >>> 24 & 255;
    arr[13] = v2 >>> 16 & 255;
    arr[14] = v2 >>> 8 & 255;
    arr[15] = v2 & 255;
    return arr;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = parse5;
  exports.default = _default;
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var stringToBytes = function(str) {
    str = unescape(encodeURIComponent(str));
    const bytes2 = [];
    for (let i = 0;i < str.length; ++i) {
      bytes2.push(str.charCodeAt(i));
    }
    return bytes2;
  };
  var _default = function(name, version3, hashfunc) {
    function generateUUID(value15, namespace, buf, offset) {
      if (typeof value15 === "string") {
        value15 = stringToBytes(value15);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes2 = new Uint8Array(16 + value15.length);
      bytes2.set(namespace);
      bytes2.set(value15, namespace.length);
      bytes2 = hashfunc(bytes2);
      bytes2[6] = bytes2[6] & 15 | version3;
      bytes2[8] = bytes2[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0;i < 16; ++i) {
          buf[offset + i] = bytes2[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes2);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = _default;
  exports.URL = exports.DNS = undefined;
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
  var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  exports.DNS = DNS;
  var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  exports.URL = URL2;
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var md52 = function(bytes2) {
    if (Array.isArray(bytes2)) {
      bytes2 = Buffer.from(bytes2);
    } else if (typeof bytes2 === "string") {
      bytes2 = Buffer.from(bytes2, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes2).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = md52;
  exports.default = _default;
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _md = _interopRequireDefault(require_md5());
  var v3 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3;
  exports.default = _default;
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var v4 = function(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0;i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _rng = _interopRequireDefault(require_rng());
  var _stringify = _interopRequireDefault(require_stringify());
  var _default = v4;
  exports.default = _default;
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var sha1 = function(bytes2) {
    if (Array.isArray(bytes2)) {
      bytes2 = Buffer.from(bytes2);
    } else if (typeof bytes2 === "string") {
      bytes2 = Buffer.from(bytes2, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes2).digest();
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _crypto = _interopRequireDefault(import.meta.require("crypto"));
  var _default = sha1;
  exports.default = _default;
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _v = _interopRequireDefault(require_v35());
  var _sha = _interopRequireDefault(require_sha1());
  var v5 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5;
  exports.default = _default;
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _default = "00000000-0000-0000-0000-000000000000";
  exports.default = _default;
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  var version3 = function(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = undefined;
  var _validate = _interopRequireDefault(require_validate());
  var _default = version3;
  exports.default = _default;
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS((exports) => {
  var _interopRequireDefault = function(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  };
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "v1", {
    enumerable: true,
    get: function() {
      return _v.default;
    }
  });
  Object.defineProperty(exports, "v3", {
    enumerable: true,
    get: function() {
      return _v2.default;
    }
  });
  Object.defineProperty(exports, "v4", {
    enumerable: true,
    get: function() {
      return _v3.default;
    }
  });
  Object.defineProperty(exports, "v5", {
    enumerable: true,
    get: function() {
      return _v4.default;
    }
  });
  Object.defineProperty(exports, "NIL", {
    enumerable: true,
    get: function() {
      return _nil.default;
    }
  });
  Object.defineProperty(exports, "version", {
    enumerable: true,
    get: function() {
      return _version.default;
    }
  });
  Object.defineProperty(exports, "validate", {
    enumerable: true,
    get: function() {
      return _validate.default;
    }
  });
  Object.defineProperty(exports, "stringify", {
    enumerable: true,
    get: function() {
      return _stringify.default;
    }
  });
  Object.defineProperty(exports, "parse", {
    enumerable: true,
    get: function() {
      return _parse.default;
    }
  });
  var _v = _interopRequireDefault(require_v1());
  var _v2 = _interopRequireDefault(require_v3());
  var _v3 = _interopRequireDefault(require_v4());
  var _v4 = _interopRequireDefault(require_v5());
  var _nil = _interopRequireDefault(require_nil());
  var _version = _interopRequireDefault(require_version());
  var _validate = _interopRequireDefault(require_validate());
  var _stringify = _interopRequireDefault(require_stringify());
  var _parse = _interopRequireDefault(require_parse());
});

// node_modules/bull/lib/timer-manager.js
var require_timer_manager = __commonJS((exports, module) => {
  var TimerManager = function() {
    this.idle = true;
    this.listeners = [];
    this.timers = {};
  };
  var _ = require_lodash4();
  var uuid = require_dist();
  TimerManager.prototype.set = function(name, delay, fn) {
    const id = uuid.v4();
    const timer2 = setTimeout((timerInstance, timeoutId) => {
      timerInstance.clear(timeoutId);
      try {
        fn();
      } catch (err) {
        console.error(err);
      }
    }, delay, this, id);
    this.timers[id] = {
      name,
      timer: timer2
    };
    this.idle = false;
    return id;
  };
  TimerManager.prototype.clear = function(id) {
    const timers = this.timers;
    const timer2 = timers[id];
    if (!timer2) {
      return;
    }
    clearTimeout(timer2.timer);
    delete timers[id];
    if (!this.idle && _.size(timers) === 0) {
      while (this.listeners.length) {
        this.listeners.pop()();
      }
      this.idle = true;
    }
  };
  TimerManager.prototype.clearAll = function() {
    _.each(this.timers, (timer2, id) => {
      this.clear(id);
    });
  };
  TimerManager.prototype.whenIdle = function() {
    return new Promise((resolve) => {
      if (this.idle) {
        resolve();
      } else {
        this.listeners.unshift(resolve);
      }
    });
  };
  module.exports = TimerManager;
});

// node_modules/bull/lib/p-timeout.js
var require_p_timeout = __commonJS((exports, module) => {
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  exports.TimeoutError = TimeoutError;
  exports.pTimeout = function pTimeout(promise5, milliseconds, fallback, options) {
    let timer2;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || Math.sign(milliseconds) !== 1) {
        throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${milliseconds}\``);
      }
      if (milliseconds === Number.POSITIVE_INFINITY) {
        resolve(promise5);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      timer2 = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error22) {
            reject(error22);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise5.cancel === "function") {
          promise5.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise5);
        } catch (error22) {
          reject(error22);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer2);
        }
      })();
    });
    cancelablePromise["clear"] = () => {
      clearTimeout(timer2);
      timer2 = undefined;
    };
    return cancelablePromise;
  };
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS((exports, module) => {
  var SEMVER_SPEC_VERSION = "2.0.0";
  var MAX_LENGTH = 256;
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
  var MAX_SAFE_COMPONENT_LENGTH = 16;
  var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
  var RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
  ];
  module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
  };
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS((exports, module) => {
  var debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
  };
  module.exports = debug;
});

// node_modules/semver/internal/re.js
var require_re = __commonJS((exports, module) => {
  var {
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_LENGTH
  } = require_constants();
  var debug = require_debug2();
  exports = module.exports = {};
  var re = exports.re = [];
  var safeRe = exports.safeRe = [];
  var src = exports.src = [];
  var t = exports.t = {};
  var R = 0;
  var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
  var safeRegexReplacements = [
    ["\\s", 1],
    ["\\d", MAX_LENGTH],
    [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
  ];
  var makeSafeRegex = (value15) => {
    for (const [token, max] of safeRegexReplacements) {
      value15 = value15.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value15;
  };
  var createToken = (name, value15, isGlobal) => {
    const safe = makeSafeRegex(value15);
    const index = R++;
    debug(name, index, value15);
    t[name] = index;
    src[index] = value15;
    re[index] = new RegExp(value15, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
  };
  createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
  createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
  createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
  createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
  createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
  createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
  createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
  createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
  createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
  createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
  createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
  createToken("FULL", `^${src[t.FULLPLAIN]}\$`);
  createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
  createToken("LOOSE", `^${src[t.LOOSEPLAIN]}\$`);
  createToken("GTLT", "((?:<|>)?=?)");
  createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
  createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
  createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
  createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}\$`);
  createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
  createToken("COERCE", `${src[t.COERCEPLAIN]}(?:\$|[^\\d])`);
  createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:\$|[^\\d])`);
  createToken("COERCERTL", src[t.COERCE], true);
  createToken("COERCERTLFULL", src[t.COERCEFULL], true);
  createToken("LONETILDE", "(?:~>?)");
  createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
  exports.tildeTrimReplace = "$1~";
  createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}\$`);
  createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("LONECARET", "(?:\\^)");
  createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
  exports.caretTrimReplace = "$1^";
  createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}\$`);
  createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}\$`);
  createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})\$|^\$`);
  createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})\$|^\$`);
  createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
  exports.comparatorTrimReplace = "$1$2$3";
  createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*\$`);
  createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*\$`);
  createToken("STAR", "(<|>)?=?\\s*\\*");
  createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
  createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS((exports, module) => {
  var looseOption = Object.freeze({ loose: true });
  var emptyOpts = Object.freeze({});
  var parseOptions2 = (options) => {
    if (!options) {
      return emptyOpts;
    }
    if (typeof options !== "object") {
      return looseOption;
    }
    return options;
  };
  module.exports = parseOptions2;
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS((exports, module) => {
  var numeric = /^[0-9]+$/;
  var compareIdentifiers = (a2, b3) => {
    const anum = numeric.test(a2);
    const bnum = numeric.test(b3);
    if (anum && bnum) {
      a2 = +a2;
      b3 = +b3;
    }
    return a2 === b3 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b3 ? -1 : 1;
  };
  var rcompareIdentifiers = (a2, b3) => compareIdentifiers(b3, a2);
  module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
  };
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS((exports, module) => {
  var debug = require_debug2();
  var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
  var { safeRe: re, t } = require_re();
  var parseOptions2 = require_parse_options();
  var { compareIdentifiers } = require_identifiers();

  class SemVer {
    constructor(version3, options) {
      options = parseOptions2(options);
      if (version3 instanceof SemVer) {
        if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
          return version3;
        } else {
          version3 = version3.version;
        }
      } else if (typeof version3 !== "string") {
        throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
      }
      if (version3.length > MAX_LENGTH) {
        throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
      }
      debug("SemVer", version3, options);
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      const m2 = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m2) {
        throw new TypeError(`Invalid Version: ${version3}`);
      }
      this.raw = version3;
      this.major = +m2[1];
      this.minor = +m2[2];
      this.patch = +m2[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m2[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m2[4].split(".").map((id) => {
          if (/^[0-9]+$/.test(id)) {
            const num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m2[5] ? m2[5].split(".") : [];
      this.format();
    }
    format() {
      this.version = `${this.major}.${this.minor}.${this.patch}`;
      if (this.prerelease.length) {
        this.version += `-${this.prerelease.join(".")}`;
      }
      return this.version;
    }
    toString() {
      return this.version;
    }
    compare(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        if (typeof other === "string" && other === this.version) {
          return 0;
        }
        other = new SemVer(other, this.options);
      }
      if (other.version === this.version) {
        return 0;
      }
      return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      let i = 0;
      do {
        const a2 = this.prerelease[i];
        const b3 = other.prerelease[i];
        debug("prerelease compare", i, a2, b3);
        if (a2 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a2 === undefined) {
          return -1;
        } else if (a2 === b3) {
          continue;
        } else {
          return compareIdentifiers(a2, b3);
        }
      } while (++i);
    }
    compareBuild(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      let i = 0;
      do {
        const a2 = this.build[i];
        const b3 = other.build[i];
        debug("prerelease compare", i, a2, b3);
        if (a2 === undefined && b3 === undefined) {
          return 0;
        } else if (b3 === undefined) {
          return 1;
        } else if (a2 === undefined) {
          return -1;
        } else if (a2 === b3) {
          continue;
        } else {
          return compareIdentifiers(a2, b3);
        }
      } while (++i);
    }
    inc(release, identifier, identifierBase) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier, identifierBase);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier, identifierBase);
          this.inc("pre", identifier, identifierBase);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier, identifierBase);
          }
          this.inc("pre", identifier, identifierBase);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre": {
          const base = Number(identifierBase) ? 1 : 0;
          if (!identifier && identifierBase === false) {
            throw new Error("invalid increment argument: identifier is empty");
          }
          if (this.prerelease.length === 0) {
            this.prerelease = [base];
          } else {
            let i = this.prerelease.length;
            while (--i >= 0) {
              if (typeof this.prerelease[i] === "number") {
                this.prerelease[i]++;
                i = -2;
              }
            }
            if (i === -1) {
              if (identifier === this.prerelease.join(".") && identifierBase === false) {
                throw new Error("invalid increment argument: identifier already exists");
              }
              this.prerelease.push(base);
            }
          }
          if (identifier) {
            let prerelease = [identifier, base];
            if (identifierBase === false) {
              prerelease = [identifier];
            }
            if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = prerelease;
              }
            } else {
              this.prerelease = prerelease;
            }
          }
          break;
        }
        default:
          throw new Error(`invalid increment argument: ${release}`);
      }
      this.raw = this.format();
      if (this.build.length) {
        this.raw += `+${this.build.join(".")}`;
      }
      return this;
    }
  }
  module.exports = SemVer;
});

// node_modules/semver/functions/parse.js
var require_parse2 = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse5 = (version3, options, throwErrors = false) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    try {
      return new SemVer(version3, options);
    } catch (er) {
      if (!throwErrors) {
        return null;
      }
      throw er;
    }
  };
  module.exports = parse5;
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS((exports, module) => {
  var parse5 = require_parse2();
  var valid = (version3, options) => {
    const v2 = parse5(version3, options);
    return v2 ? v2.version : null;
  };
  module.exports = valid;
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS((exports, module) => {
  var parse5 = require_parse2();
  var clean4 = (version3, options) => {
    const s2 = parse5(version3.trim().replace(/^[=v]+/, ""), options);
    return s2 ? s2.version : null;
  };
  module.exports = clean4;
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var inc = (version3, release, options, identifier, identifierBase) => {
    if (typeof options === "string") {
      identifierBase = identifier;
      identifier = options;
      options = undefined;
    }
    try {
      return new SemVer(version3 instanceof SemVer ? version3.version : version3, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
      return null;
    }
  };
  module.exports = inc;
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS((exports, module) => {
  var parse5 = require_parse2();
  var diff = (version1, version22) => {
    const v12 = parse5(version1, null, true);
    const v2 = parse5(version22, null, true);
    const comparison = v12.compare(v2);
    if (comparison === 0) {
      return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v12 : v2;
    const lowVersion = v1Higher ? v2 : v12;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
      if (!lowVersion.patch && !lowVersion.minor) {
        return "major";
      }
      if (highVersion.patch) {
        return "patch";
      }
      if (highVersion.minor) {
        return "minor";
      }
      return "major";
    }
    const prefix = highHasPre ? "pre" : "";
    if (v12.major !== v2.major) {
      return prefix + "major";
    }
    if (v12.minor !== v2.minor) {
      return prefix + "minor";
    }
    if (v12.patch !== v2.patch) {
      return prefix + "patch";
    }
    return "prerelease";
  };
  module.exports = diff;
});

// node_modules/semver/functions/major.js
var require_major = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var major = (a2, loose) => new SemVer(a2, loose).major;
  module.exports = major;
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var minor = (a2, loose) => new SemVer(a2, loose).minor;
  module.exports = minor;
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var patch = (a2, loose) => new SemVer(a2, loose).patch;
  module.exports = patch;
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS((exports, module) => {
  var parse5 = require_parse2();
  var prerelease = (version3, options) => {
    const parsed = parse5(version3, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
  };
  module.exports = prerelease;
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compare = (a2, b3, loose) => new SemVer(a2, loose).compare(new SemVer(b3, loose));
  module.exports = compare;
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS((exports, module) => {
  var compare = require_compare();
  var rcompare = (a2, b3, loose) => compare(b3, a2, loose);
  module.exports = rcompare;
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS((exports, module) => {
  var compare = require_compare();
  var compareLoose = (a2, b3) => compare(a2, b3, true);
  module.exports = compareLoose;
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var compareBuild = (a2, b3, loose) => {
    const versionA = new SemVer(a2, loose);
    const versionB = new SemVer(b3, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
  };
  module.exports = compareBuild;
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var sort = (list, loose) => list.sort((a2, b3) => compareBuild(a2, b3, loose));
  module.exports = sort;
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS((exports, module) => {
  var compareBuild = require_compare_build();
  var rsort = (list, loose) => list.sort((a2, b3) => compareBuild(b3, a2, loose));
  module.exports = rsort;
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS((exports, module) => {
  var compare = require_compare();
  var gt2 = (a2, b3, loose) => compare(a2, b3, loose) > 0;
  module.exports = gt2;
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS((exports, module) => {
  var compare = require_compare();
  var lt2 = (a2, b3, loose) => compare(a2, b3, loose) < 0;
  module.exports = lt2;
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS((exports, module) => {
  var compare = require_compare();
  var eq2 = (a2, b3, loose) => compare(a2, b3, loose) === 0;
  module.exports = eq2;
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS((exports, module) => {
  var compare = require_compare();
  var neq = (a2, b3, loose) => compare(a2, b3, loose) !== 0;
  module.exports = neq;
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS((exports, module) => {
  var compare = require_compare();
  var gte2 = (a2, b3, loose) => compare(a2, b3, loose) >= 0;
  module.exports = gte2;
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS((exports, module) => {
  var compare = require_compare();
  var lte2 = (a2, b3, loose) => compare(a2, b3, loose) <= 0;
  module.exports = lte2;
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS((exports, module) => {
  var eq2 = require_eq();
  var neq = require_neq();
  var gt2 = require_gt();
  var gte2 = require_gte();
  var lt2 = require_lt();
  var lte2 = require_lte();
  var cmp = (a2, op, b3, loose) => {
    switch (op) {
      case "===":
        if (typeof a2 === "object") {
          a2 = a2.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a2 === b3;
      case "!==":
        if (typeof a2 === "object") {
          a2 = a2.version;
        }
        if (typeof b3 === "object") {
          b3 = b3.version;
        }
        return a2 !== b3;
      case "":
      case "=":
      case "==":
        return eq2(a2, b3, loose);
      case "!=":
        return neq(a2, b3, loose);
      case ">":
        return gt2(a2, b3, loose);
      case ">=":
        return gte2(a2, b3, loose);
      case "<":
        return lt2(a2, b3, loose);
      case "<=":
        return lte2(a2, b3, loose);
      default:
        throw new TypeError(`Invalid operator: ${op}`);
    }
  };
  module.exports = cmp;
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var parse5 = require_parse2();
  var { safeRe: re, t } = require_re();
  var coerce2 = (version3, options) => {
    if (version3 instanceof SemVer) {
      return version3;
    }
    if (typeof version3 === "number") {
      version3 = String(version3);
    }
    if (typeof version3 !== "string") {
      return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
      match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
      const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
      let next;
      while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
        if (!match || next.index + next[0].length !== match.index + match[0].length) {
          match = next;
        }
        coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
      }
      coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
      return null;
    }
    const major = match[2];
    const minor = match[3] || "0";
    const patch = match[4] || "0";
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
    return parse5(`${major}.${minor}.${patch}${prerelease}${build}`, options);
  };
  module.exports = coerce2;
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS((exports, module) => {
  module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function* () {
      for (let walker = this.head;walker; walker = walker.next) {
        yield walker.value;
      }
    };
  };
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS((exports, module) => {
  var Yallist = function(list) {
    var self2 = this;
    if (!(self2 instanceof Yallist)) {
      self2 = new Yallist;
    }
    self2.tail = null;
    self2.head = null;
    self2.length = 0;
    if (list && typeof list.forEach === "function") {
      list.forEach(function(item) {
        self2.push(item);
      });
    } else if (arguments.length > 0) {
      for (var i = 0, l2 = arguments.length;i < l2; i++) {
        self2.push(arguments[i]);
      }
    }
    return self2;
  };
  var insert = function(self2, node, value15) {
    var inserted = node === self2.head ? new Node(value15, null, node, self2) : new Node(value15, node, node.next, self2);
    if (inserted.next === null) {
      self2.tail = inserted;
    }
    if (inserted.prev === null) {
      self2.head = inserted;
    }
    self2.length++;
    return inserted;
  };
  var push = function(self2, item) {
    self2.tail = new Node(item, self2.tail, null, self2);
    if (!self2.head) {
      self2.head = self2.tail;
    }
    self2.length++;
  };
  var unshift = function(self2, item) {
    self2.head = new Node(item, null, self2.head, self2);
    if (!self2.tail) {
      self2.tail = self2.head;
    }
    self2.length++;
  };
  var Node = function(value15, prev, next, list) {
    if (!(this instanceof Node)) {
      return new Node(value15, prev, next, list);
    }
    this.list = list;
    this.value = value15;
    if (prev) {
      prev.next = this;
      this.prev = prev;
    } else {
      this.prev = null;
    }
    if (next) {
      next.prev = this;
      this.next = next;
    } else {
      this.next = null;
    }
  };
  module.exports = Yallist;
  Yallist.Node = Node;
  Yallist.create = Yallist;
  Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
      throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    if (node === this.head) {
      this.head = next;
    }
    if (node === this.tail) {
      this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
  };
  Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
      head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
      this.tail = node;
    }
    this.length++;
  };
  Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
      return;
    }
    if (node.list) {
      node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
      tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
      this.head = node;
    }
    this.length++;
  };
  Yallist.prototype.push = function() {
    for (var i = 0, l2 = arguments.length;i < l2; i++) {
      push(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.unshift = function() {
    for (var i = 0, l2 = arguments.length;i < l2; i++) {
      unshift(this, arguments[i]);
    }
    return this.length;
  };
  Yallist.prototype.pop = function() {
    if (!this.tail) {
      return;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
      this.tail.next = null;
    } else {
      this.head = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.shift = function() {
    if (!this.head) {
      return;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
      this.head.prev = null;
    } else {
      this.tail = null;
    }
    this.length--;
    return res;
  };
  Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.head, i = 0;walker !== null; i++) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.next;
    }
  };
  Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for (var walker = this.tail, i = this.length - 1;walker !== null; i--) {
      fn.call(thisp, walker.value, i, this);
      walker = walker.prev;
    }
  };
  Yallist.prototype.get = function(n2) {
    for (var i = 0, walker = this.head;walker !== null && i < n2; i++) {
      walker = walker.next;
    }
    if (i === n2 && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.getReverse = function(n2) {
    for (var i = 0, walker = this.tail;walker !== null && i < n2; i++) {
      walker = walker.prev;
    }
    if (i === n2 && walker !== null) {
      return walker.value;
    }
  };
  Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.head;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.next;
    }
    return res;
  };
  Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist;
    for (var walker = this.tail;walker !== null; ) {
      res.push(fn.call(thisp, walker.value, this));
      walker = walker.prev;
    }
    return res;
  };
  Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.head) {
      walker = this.head.next;
      acc = this.head.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = 0;walker !== null; i++) {
      acc = fn(acc, walker.value, i);
      walker = walker.next;
    }
    return acc;
  };
  Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
      acc = initial;
    } else if (this.tail) {
      walker = this.tail.prev;
      acc = this.tail.value;
    } else {
      throw new TypeError("Reduce of empty list with no initial value");
    }
    for (var i = this.length - 1;walker !== null; i--) {
      acc = fn(acc, walker.value, i);
      walker = walker.prev;
    }
    return acc;
  };
  Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.head;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.next;
    }
    return arr;
  };
  Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for (var i = 0, walker = this.tail;walker !== null; i++) {
      arr[i] = walker.value;
      walker = walker.prev;
    }
    return arr;
  };
  Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = 0, walker = this.head;walker !== null && i < from; i++) {
      walker = walker.next;
    }
    for (;walker !== null && i < to; i++, walker = walker.next) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
      to += this.length;
    }
    from = from || 0;
    if (from < 0) {
      from += this.length;
    }
    var ret = new Yallist;
    if (to < from || to < 0) {
      return ret;
    }
    if (from < 0) {
      from = 0;
    }
    if (to > this.length) {
      to = this.length;
    }
    for (var i = this.length, walker = this.tail;walker !== null && i > to; i--) {
      walker = walker.prev;
    }
    for (;walker !== null && i > from; i--, walker = walker.prev) {
      ret.push(walker.value);
    }
    return ret;
  };
  Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
      start = this.length - 1;
    }
    if (start < 0) {
      start = this.length + start;
    }
    for (var i = 0, walker = this.head;walker !== null && i < start; i++) {
      walker = walker.next;
    }
    var ret = [];
    for (var i = 0;walker && i < deleteCount; i++) {
      ret.push(walker.value);
      walker = this.removeNode(walker);
    }
    if (walker === null) {
      walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
      walker = walker.prev;
    }
    for (var i = 0;i < nodes.length; i++) {
      walker = insert(this, walker, nodes[i]);
    }
    return ret;
  };
  Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for (var walker = head;walker !== null; walker = walker.prev) {
      var p2 = walker.prev;
      walker.prev = walker.next;
      walker.next = p2;
    }
    this.head = tail;
    this.tail = head;
    return this;
  };
  try {
    require_iterator()(Yallist);
  } catch (er) {
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS((exports, module) => {
  var Yallist = require_yallist();
  var MAX = Symbol("max");
  var LENGTH = Symbol("length");
  var LENGTH_CALCULATOR = Symbol("lengthCalculator");
  var ALLOW_STALE = Symbol("allowStale");
  var MAX_AGE = Symbol("maxAge");
  var DISPOSE = Symbol("dispose");
  var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
  var LRU_LIST = Symbol("lruList");
  var CACHE = Symbol("cache");
  var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
  var naiveLength = () => 1;

  class LRUCache {
    constructor(options) {
      if (typeof options === "number")
        options = { max: options };
      if (!options)
        options = {};
      if (options.max && (typeof options.max !== "number" || options.max < 0))
        throw new TypeError("max must be a non-negative number");
      const max = this[MAX] = options.max || Infinity;
      const lc = options.length || naiveLength;
      this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
      this[ALLOW_STALE] = options.stale || false;
      if (options.maxAge && typeof options.maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      this[MAX_AGE] = options.maxAge || 0;
      this[DISPOSE] = options.dispose;
      this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
      this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
      this.reset();
    }
    set max(mL) {
      if (typeof mL !== "number" || mL < 0)
        throw new TypeError("max must be a non-negative number");
      this[MAX] = mL || Infinity;
      trim(this);
    }
    get max() {
      return this[MAX];
    }
    set allowStale(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
      return this[ALLOW_STALE];
    }
    set maxAge(mA) {
      if (typeof mA !== "number")
        throw new TypeError("maxAge must be a non-negative number");
      this[MAX_AGE] = mA;
      trim(this);
    }
    get maxAge() {
      return this[MAX_AGE];
    }
    set lengthCalculator(lC) {
      if (typeof lC !== "function")
        lC = naiveLength;
      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach((hit) => {
          hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
          this[LENGTH] += hit.length;
        });
      }
      trim(this);
    }
    get lengthCalculator() {
      return this[LENGTH_CALCULATOR];
    }
    get length() {
      return this[LENGTH];
    }
    get itemCount() {
      return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].tail;walker !== null; ) {
        const prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
    forEach(fn, thisp) {
      thisp = thisp || this;
      for (let walker = this[LRU_LIST].head;walker !== null; ) {
        const next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
    keys() {
      return this[LRU_LIST].toArray().map((k) => k.key);
    }
    values() {
      return this[LRU_LIST].toArray().map((k) => k.value);
    }
    reset() {
      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
      }
      this[CACHE] = new Map;
      this[LRU_LIST] = new Yallist;
      this[LENGTH] = 0;
    }
    dump() {
      return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }).toArray().filter((h2) => h2);
    }
    dumpLru() {
      return this[LRU_LIST];
    }
    set(key, value15, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== "number")
        throw new TypeError("maxAge must be a number");
      const now = maxAge ? Date.now() : 0;
      const len = this[LENGTH_CALCULATOR](value15, key);
      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          del(this, this[CACHE].get(key));
          return false;
        }
        const node = this[CACHE].get(key);
        const item = node.value;
        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET])
            this[DISPOSE](key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value15;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      const hit = new Entry(key, value15, len, now, maxAge);
      if (hit.length > this[MAX]) {
        if (this[DISPOSE])
          this[DISPOSE](key, value15);
        return false;
      }
      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
    has(key) {
      if (!this[CACHE].has(key))
        return false;
      const hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
    get(key) {
      return get(this, key, true);
    }
    peek(key) {
      return get(this, key, false);
    }
    pop() {
      const node = this[LRU_LIST].tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    }
    del(key) {
      del(this, this[CACHE].get(key));
    }
    load(arr) {
      this.reset();
      const now = Date.now();
      for (let l2 = arr.length - 1;l2 >= 0; l2--) {
        const hit = arr[l2];
        const expiresAt = hit.e || 0;
        if (expiresAt === 0)
          this.set(hit.k, hit.v);
        else {
          const maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
    prune() {
      this[CACHE].forEach((value15, key) => get(this, key, false));
    }
  }
  var get = (self2, key, doUse) => {
    const node = self2[CACHE].get(key);
    if (node) {
      const hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          return;
      } else {
        if (doUse) {
          if (self2[UPDATE_AGE_ON_GET])
            node.value.now = Date.now();
          self2[LRU_LIST].unshiftNode(node);
        }
      }
      return hit.value;
    }
  };
  var isStale = (self2, hit) => {
    if (!hit || !hit.maxAge && !self2[MAX_AGE])
      return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
  };
  var trim = (self2) => {
    if (self2[LENGTH] > self2[MAX]) {
      for (let walker = self2[LRU_LIST].tail;self2[LENGTH] > self2[MAX] && walker !== null; ) {
        const prev = walker.prev;
        del(self2, walker);
        walker = prev;
      }
    }
  };
  var del = (self2, node) => {
    if (node) {
      const hit = node.value;
      if (self2[DISPOSE])
        self2[DISPOSE](hit.key, hit.value);
      self2[LENGTH] -= hit.length;
      self2[CACHE].delete(hit.key);
      self2[LRU_LIST].removeNode(node);
    }
  };

  class Entry {
    constructor(key, value15, length, now, maxAge) {
      this.key = key;
      this.value = value15;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
  var forEachStep = (self2, fn, node, thisp) => {
    let hit = node.value;
    if (isStale(self2, hit)) {
      del(self2, node);
      if (!self2[ALLOW_STALE])
        hit = undefined;
    }
    if (hit)
      fn.call(thisp, hit.value, hit.key, self2);
  };
  module.exports = LRUCache;
});

// node_modules/semver/classes/range.js
var require_range = __commonJS((exports, module) => {
  class Range {
    constructor(range, options) {
      options = parseOptions2(options);
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        this.raw = range.value;
        this.set = [[range]];
        this.format();
        return this;
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map((r2) => this.parseRange(r2.trim())).filter((c2) => c2.length);
      if (!this.set.length) {
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      }
      if (this.set.length > 1) {
        const first = this.set[0];
        this.set = this.set.filter((c2) => !isNullSet(c2[0]));
        if (this.set.length === 0) {
          this.set = [first];
        } else if (this.set.length > 1) {
          for (const c2 of this.set) {
            if (c2.length === 1 && isAny(c2[0])) {
              this.set = [c2];
              break;
            }
          }
        }
      }
      this.format();
    }
    format() {
      this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
      return this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(range) {
      const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
      const memoKey = memoOpts + ":" + range;
      const cached = cache.get(memoKey);
      if (cached) {
        return cached;
      }
      const loose = this.options.loose;
      const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      debug("tilde trim", range);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      debug("caret trim", range);
      let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
      if (loose) {
        rangeList = rangeList.filter((comp) => {
          debug("loose invalid filter", comp, this.options);
          return !!comp.match(re[t.COMPARATORLOOSE]);
        });
      }
      debug("range list", rangeList);
      const rangeMap = new Map;
      const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
      for (const comp of comparators) {
        if (isNullSet(comp)) {
          return [comp];
        }
        rangeMap.set(comp.value, comp);
      }
      if (rangeMap.size > 1 && rangeMap.has("")) {
        rangeMap.delete("");
      }
      const result2 = [...rangeMap.values()];
      cache.set(memoKey, result2);
      return result2;
    }
    intersects(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some((thisComparators) => {
        return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
          return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
            return rangeComparators.every((rangeComparator) => {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }
    test(version3) {
      if (!version3) {
        return false;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      for (let i = 0;i < this.set.length; i++) {
        if (testSet(this.set[i], version3, this.options)) {
          return true;
        }
      }
      return false;
    }
  }
  module.exports = Range;
  var LRU = require_lru_cache();
  var cache = new LRU({ max: 1000 });
  var parseOptions2 = require_parse_options();
  var Comparator = require_comparator();
  var debug = require_debug2();
  var SemVer = require_semver();
  var {
    safeRe: re,
    t,
    comparatorTrimReplace,
    tildeTrimReplace,
    caretTrimReplace
  } = require_re();
  var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
  var isNullSet = (c2) => c2.value === "<0.0.0-0";
  var isAny = (c2) => c2.value === "";
  var isSatisfiable = (comparators, options) => {
    let result2 = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while (result2 && remainingComparators.length) {
      result2 = remainingComparators.every((otherComparator) => {
        return testComparator.intersects(otherComparator, options);
      });
      testComparator = remainingComparators.pop();
    }
    return result2;
  };
  var parseComparator = (comp, options) => {
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
  };
  var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
  var replaceTildes = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceTilde(c2, options)).join(" ");
  };
  var replaceTilde = (comp, options) => {
    const r2 = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r2, (_, M, m2, p2, pr) => {
      debug("tilde", comp, _, M, m2, p2, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
      } else if (isX(p2)) {
        ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
      } else if (pr) {
        debug("replaceTilde pr", pr);
        ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
      } else {
        ret = `>=${M}.${m2}.${p2} <${M}.${+m2 + 1}.0-0`;
      }
      debug("tilde return", ret);
      return ret;
    });
  };
  var replaceCarets = (comp, options) => {
    return comp.trim().split(/\s+/).map((c2) => replaceCaret(c2, options)).join(" ");
  };
  var replaceCaret = (comp, options) => {
    debug("caret", comp, options);
    const r2 = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z2 = options.includePrerelease ? "-0" : "";
    return comp.replace(r2, (_, M, m2, p2, pr) => {
      debug("caret", comp, _, M, m2, p2, pr);
      let ret;
      if (isX(M)) {
        ret = "";
      } else if (isX(m2)) {
        ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
      } else if (isX(p2)) {
        if (M === "0") {
          ret = `>=${M}.${m2}.0${z2} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.0${z2} <${+M + 1}.0.0-0`;
        }
      } else if (pr) {
        debug("replaceCaret pr", pr);
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p2}-${pr} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p2}-${pr} <${+M + 1}.0.0-0`;
        }
      } else {
        debug("no pr");
        if (M === "0") {
          if (m2 === "0") {
            ret = `>=${M}.${m2}.${p2}${z2} <${M}.${m2}.${+p2 + 1}-0`;
          } else {
            ret = `>=${M}.${m2}.${p2}${z2} <${M}.${+m2 + 1}.0-0`;
          }
        } else {
          ret = `>=${M}.${m2}.${p2} <${+M + 1}.0.0-0`;
        }
      }
      debug("caret return", ret);
      return ret;
    });
  };
  var replaceXRanges = (comp, options) => {
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c2) => replaceXRange(c2, options)).join(" ");
  };
  var replaceXRange = (comp, options) => {
    comp = comp.trim();
    const r2 = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r2, (ret, gtlt, M, m2, p2, pr) => {
      debug("xRange", comp, ret, gtlt, M, m2, p2, pr);
      const xM = isX(M);
      const xm = xM || isX(m2);
      const xp = xm || isX(p2);
      const anyX = xp;
      if (gtlt === "=" && anyX) {
        gtlt = "";
      }
      pr = options.includePrerelease ? "-0" : "";
      if (xM) {
        if (gtlt === ">" || gtlt === "<") {
          ret = "<0.0.0-0";
        } else {
          ret = "*";
        }
      } else if (gtlt && anyX) {
        if (xm) {
          m2 = 0;
        }
        p2 = 0;
        if (gtlt === ">") {
          gtlt = ">=";
          if (xm) {
            M = +M + 1;
            m2 = 0;
            p2 = 0;
          } else {
            m2 = +m2 + 1;
            p2 = 0;
          }
        } else if (gtlt === "<=") {
          gtlt = "<";
          if (xm) {
            M = +M + 1;
          } else {
            m2 = +m2 + 1;
          }
        }
        if (gtlt === "<") {
          pr = "-0";
        }
        ret = `${gtlt + M}.${m2}.${p2}${pr}`;
      } else if (xm) {
        ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
      } else if (xp) {
        ret = `>=${M}.${m2}.0${pr} <${M}.${+m2 + 1}.0-0`;
      }
      debug("xRange return", ret);
      return ret;
    });
  };
  var replaceStars = (comp, options) => {
    debug("replaceStars", comp, options);
    return comp.trim().replace(re[t.STAR], "");
  };
  var replaceGTE0 = (comp, options) => {
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
  };
  var hyphenReplace = (incPr) => ($02, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
    if (isX(fM)) {
      from = "";
    } else if (isX(fm)) {
      from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
    } else if (isX(fp)) {
      from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
    } else if (fpr) {
      from = `>=${from}`;
    } else {
      from = `>=${from}${incPr ? "-0" : ""}`;
    }
    if (isX(tM)) {
      to = "";
    } else if (isX(tm)) {
      to = `<${+tM + 1}.0.0-0`;
    } else if (isX(tp)) {
      to = `<${tM}.${+tm + 1}.0-0`;
    } else if (tpr) {
      to = `<=${tM}.${tm}.${tp}-${tpr}`;
    } else if (incPr) {
      to = `<${tM}.${tm}.${+tp + 1}-0`;
    } else {
      to = `<=${to}`;
    }
    return `${from} ${to}`.trim();
  };
  var testSet = (set2, version3, options) => {
    for (let i = 0;i < set2.length; i++) {
      if (!set2[i].test(version3)) {
        return false;
      }
    }
    if (version3.prerelease.length && !options.includePrerelease) {
      for (let i = 0;i < set2.length; i++) {
        debug(set2[i].semver);
        if (set2[i].semver === Comparator.ANY) {
          continue;
        }
        if (set2[i].semver.prerelease.length > 0) {
          const allowed = set2[i].semver;
          if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
            return true;
          }
        }
      }
      return false;
    }
    return true;
  };
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS((exports, module) => {
  var ANY = Symbol("SemVer ANY");

  class Comparator {
    static get ANY() {
      return ANY;
    }
    constructor(comp, options) {
      options = parseOptions2(options);
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    parse(comp) {
      const r2 = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      const m2 = comp.match(r2);
      if (!m2) {
        throw new TypeError(`Invalid comparator: ${comp}`);
      }
      this.operator = m2[1] !== undefined ? m2[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m2[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m2[2], this.options.loose);
      }
    }
    toString() {
      return this.value;
    }
    test(version3) {
      debug("Comparator.test", version3, this.options.loose);
      if (this.semver === ANY || version3 === ANY) {
        return true;
      }
      if (typeof version3 === "string") {
        try {
          version3 = new SemVer(version3, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version3, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        return new Range(comp.value, options).test(this.value);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        return new Range(this.value, options).test(comp.semver);
      }
      options = parseOptions2(options);
      if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
        return false;
      }
      if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
        return false;
      }
      if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
        return true;
      }
      if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
        return true;
      }
      if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
        return true;
      }
      if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
        return true;
      }
      if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
        return true;
      }
      return false;
    }
  }
  module.exports = Comparator;
  var parseOptions2 = require_parse_options();
  var { safeRe: re, t } = require_re();
  var cmp = require_cmp();
  var debug = require_debug2();
  var SemVer = require_semver();
  var Range = require_range();
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS((exports, module) => {
  var Range = require_range();
  var satisfies = (version3, range, options) => {
    try {
      range = new Range(range, options);
    } catch (er) {
      return false;
    }
    return range.test(version3);
  };
  module.exports = satisfies;
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS((exports, module) => {
  var Range = require_range();
  var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c2) => c2.value).join(" ").trim().split(" "));
  module.exports = toComparators;
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var maxSatisfying = (versions, range, options) => {
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!max || maxSV.compare(v2) === -1) {
          max = v2;
          maxSV = new SemVer(max, options);
        }
      }
    });
    return max;
  };
  module.exports = maxSatisfying;
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var minSatisfying = (versions, range, options) => {
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
      rangeObj = new Range(range, options);
    } catch (er) {
      return null;
    }
    versions.forEach((v2) => {
      if (rangeObj.test(v2)) {
        if (!min || minSV.compare(v2) === 1) {
          min = v2;
          minSV = new SemVer(min, options);
        }
      }
    });
    return min;
  };
  module.exports = minSatisfying;
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Range = require_range();
  var gt2 = require_gt();
  var minVersion = (range, loose) => {
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
      return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
      return minver;
    }
    minver = null;
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let setMin = null;
      comparators.forEach((comparator) => {
        const compver = new SemVer(comparator.semver.version);
        switch (comparator.operator) {
          case ">":
            if (compver.prerelease.length === 0) {
              compver.patch++;
            } else {
              compver.prerelease.push(0);
            }
            compver.raw = compver.format();
          case "":
          case ">=":
            if (!setMin || gt2(compver, setMin)) {
              setMin = compver;
            }
            break;
          case "<":
          case "<=":
            break;
          default:
            throw new Error(`Unexpected operation: ${comparator.operator}`);
        }
      });
      if (setMin && (!minver || gt2(minver, setMin))) {
        minver = setMin;
      }
    }
    if (minver && range.test(minver)) {
      return minver;
    }
    return null;
  };
  module.exports = minVersion;
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS((exports, module) => {
  var Range = require_range();
  var validRange = (range, options) => {
    try {
      return new Range(range, options).range || "*";
    } catch (er) {
      return null;
    }
  };
  module.exports = validRange;
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS((exports, module) => {
  var SemVer = require_semver();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var Range = require_range();
  var satisfies = require_satisfies();
  var gt2 = require_gt();
  var lt2 = require_lt();
  var lte2 = require_lte();
  var gte2 = require_gte();
  var outside = (version3, range, hilo, options) => {
    version3 = new SemVer(version3, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch (hilo) {
      case ">":
        gtfn = gt2;
        ltefn = lte2;
        ltfn = lt2;
        comp = ">";
        ecomp = ">=";
        break;
      case "<":
        gtfn = lt2;
        ltefn = gte2;
        ltfn = gt2;
        comp = "<";
        ecomp = "<=";
        break;
      default:
        throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (satisfies(version3, range, options)) {
      return false;
    }
    for (let i = 0;i < range.set.length; ++i) {
      const comparators = range.set[i];
      let high = null;
      let low = null;
      comparators.forEach((comparator) => {
        if (comparator.semver === ANY) {
          comparator = new Comparator(">=0.0.0");
        }
        high = high || comparator;
        low = low || comparator;
        if (gtfn(comparator.semver, high.semver, options)) {
          high = comparator;
        } else if (ltfn(comparator.semver, low.semver, options)) {
          low = comparator;
        }
      });
      if (high.operator === comp || high.operator === ecomp) {
        return false;
      }
      if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
        return false;
      } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
        return false;
      }
    }
    return true;
  };
  module.exports = outside;
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS((exports, module) => {
  var outside = require_outside();
  var gtr = (version3, range, options) => outside(version3, range, ">", options);
  module.exports = gtr;
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS((exports, module) => {
  var outside = require_outside();
  var ltr = (version3, range, options) => outside(version3, range, "<", options);
  module.exports = ltr;
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS((exports, module) => {
  var Range = require_range();
  var intersects = (r12, r2, options) => {
    r12 = new Range(r12, options);
    r2 = new Range(r2, options);
    return r12.intersects(r2, options);
  };
  module.exports = intersects;
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS((exports, module) => {
  var satisfies = require_satisfies();
  var compare = require_compare();
  module.exports = (versions, range, options) => {
    const set2 = [];
    let first = null;
    let prev = null;
    const v2 = versions.sort((a2, b3) => compare(a2, b3, options));
    for (const version3 of v2) {
      const included = satisfies(version3, range, options);
      if (included) {
        prev = version3;
        if (!first) {
          first = version3;
        }
      } else {
        if (prev) {
          set2.push([first, prev]);
        }
        prev = null;
        first = null;
      }
    }
    if (first) {
      set2.push([first, null]);
    }
    const ranges = [];
    for (const [min, max] of set2) {
      if (min === max) {
        ranges.push(min);
      } else if (!max && min === v2[0]) {
        ranges.push("*");
      } else if (!max) {
        ranges.push(`>=${min}`);
      } else if (min === v2[0]) {
        ranges.push(`<=${max}`);
      } else {
        ranges.push(`${min} - ${max}`);
      }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
  };
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS((exports, module) => {
  var Range = require_range();
  var Comparator = require_comparator();
  var { ANY } = Comparator;
  var satisfies = require_satisfies();
  var compare = require_compare();
  var subset = (sub, dom, options = {}) => {
    if (sub === dom) {
      return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER:
      for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
    return true;
  };
  var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
  var minimumVersion = [new Comparator(">=0.0.0")];
  var simpleSubset = (sub, dom, options) => {
    if (sub === dom) {
      return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
      if (dom.length === 1 && dom[0].semver === ANY) {
        return true;
      } else if (options.includePrerelease) {
        sub = minimumVersionWithPreRelease;
      } else {
        sub = minimumVersion;
      }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
      if (options.includePrerelease) {
        return true;
      } else {
        dom = minimumVersion;
      }
    }
    const eqSet = new Set;
    let gt2, lt2;
    for (const c2 of sub) {
      if (c2.operator === ">" || c2.operator === ">=") {
        gt2 = higherGT(gt2, c2, options);
      } else if (c2.operator === "<" || c2.operator === "<=") {
        lt2 = lowerLT(lt2, c2, options);
      } else {
        eqSet.add(c2.semver);
      }
    }
    if (eqSet.size > 1) {
      return null;
    }
    let gtltComp;
    if (gt2 && lt2) {
      gtltComp = compare(gt2.semver, lt2.semver, options);
      if (gtltComp > 0) {
        return null;
      } else if (gtltComp === 0 && (gt2.operator !== ">=" || lt2.operator !== "<=")) {
        return null;
      }
    }
    for (const eq2 of eqSet) {
      if (gt2 && !satisfies(eq2, String(gt2), options)) {
        return null;
      }
      if (lt2 && !satisfies(eq2, String(lt2), options)) {
        return null;
      }
      for (const c2 of dom) {
        if (!satisfies(eq2, String(c2), options)) {
          return false;
        }
      }
      return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    let needDomLTPre = lt2 && !options.includePrerelease && lt2.semver.prerelease.length ? lt2.semver : false;
    let needDomGTPre = gt2 && !options.includePrerelease && gt2.semver.prerelease.length ? gt2.semver : false;
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt2.operator === "<" && needDomLTPre.prerelease[0] === 0) {
      needDomLTPre = false;
    }
    for (const c2 of dom) {
      hasDomGT = hasDomGT || c2.operator === ">" || c2.operator === ">=";
      hasDomLT = hasDomLT || c2.operator === "<" || c2.operator === "<=";
      if (gt2) {
        if (needDomGTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomGTPre.major && c2.semver.minor === needDomGTPre.minor && c2.semver.patch === needDomGTPre.patch) {
            needDomGTPre = false;
          }
        }
        if (c2.operator === ">" || c2.operator === ">=") {
          higher = higherGT(gt2, c2, options);
          if (higher === c2 && higher !== gt2) {
            return false;
          }
        } else if (gt2.operator === ">=" && !satisfies(gt2.semver, String(c2), options)) {
          return false;
        }
      }
      if (lt2) {
        if (needDomLTPre) {
          if (c2.semver.prerelease && c2.semver.prerelease.length && c2.semver.major === needDomLTPre.major && c2.semver.minor === needDomLTPre.minor && c2.semver.patch === needDomLTPre.patch) {
            needDomLTPre = false;
          }
        }
        if (c2.operator === "<" || c2.operator === "<=") {
          lower = lowerLT(lt2, c2, options);
          if (lower === c2 && lower !== lt2) {
            return false;
          }
        } else if (lt2.operator === "<=" && !satisfies(lt2.semver, String(c2), options)) {
          return false;
        }
      }
      if (!c2.operator && (lt2 || gt2) && gtltComp !== 0) {
        return false;
      }
    }
    if (gt2 && hasDomLT && !lt2 && gtltComp !== 0) {
      return false;
    }
    if (lt2 && hasDomGT && !gt2 && gtltComp !== 0) {
      return false;
    }
    if (needDomGTPre || needDomLTPre) {
      return false;
    }
    return true;
  };
  var higherGT = (a2, b3, options) => {
    if (!a2) {
      return b3;
    }
    const comp = compare(a2.semver, b3.semver, options);
    return comp > 0 ? a2 : comp < 0 ? b3 : b3.operator === ">" && a2.operator === ">=" ? b3 : a2;
  };
  var lowerLT = (a2, b3, options) => {
    if (!a2) {
      return b3;
    }
    const comp = compare(a2.semver, b3.semver, options);
    return comp < 0 ? a2 : comp > 0 ? b3 : b3.operator === "<" && a2.operator === "<=" ? b3 : a2;
  };
  module.exports = subset;
});

// node_modules/semver/index.js
var require_semver2 = __commonJS((exports, module) => {
  var internalRe = require_re();
  var constants = require_constants();
  var SemVer = require_semver();
  var identifiers = require_identifiers();
  var parse5 = require_parse2();
  var valid = require_valid();
  var clean4 = require_clean();
  var inc = require_inc();
  var diff = require_diff();
  var major = require_major();
  var minor = require_minor();
  var patch = require_patch();
  var prerelease = require_prerelease();
  var compare = require_compare();
  var rcompare = require_rcompare();
  var compareLoose = require_compare_loose();
  var compareBuild = require_compare_build();
  var sort = require_sort();
  var rsort = require_rsort();
  var gt2 = require_gt();
  var lt2 = require_lt();
  var eq2 = require_eq();
  var neq = require_neq();
  var gte2 = require_gte();
  var lte2 = require_lte();
  var cmp = require_cmp();
  var coerce2 = require_coerce();
  var Comparator = require_comparator();
  var Range = require_range();
  var satisfies = require_satisfies();
  var toComparators = require_to_comparators();
  var maxSatisfying = require_max_satisfying();
  var minSatisfying = require_min_satisfying();
  var minVersion = require_min_version();
  var validRange = require_valid2();
  var outside = require_outside();
  var gtr = require_gtr();
  var ltr = require_ltr();
  var intersects = require_intersects();
  var simplifyRange = require_simplify();
  var subset = require_subset();
  module.exports = {
    parse: parse5,
    valid,
    clean: clean4,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt: gt2,
    lt: lt2,
    eq: eq2,
    neq,
    gte: gte2,
    lte: lte2,
    cmp,
    coerce: coerce2,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
  };
});

// node_modules/bull/lib/commands/index.js
var require_commands2 = __commonJS((exports, module) => {
  async function loadScripts() {
    const scriptsDir = await fsAsync.readdir(__dirname);
    const luaFiles = scriptsDir.filter((file) => path.extname(file) === ".lua");
    if (luaFiles.length === 0) {
      throw new Error("No .lua files found!");
    }
    return Promise.all(luaFiles.map(async (file) => {
      const lua = await fsAsync.readFile(path.join(__dirname, file));
      const longName = path.basename(file, ".lua");
      return {
        name: longName.split("-")[0],
        options: {
          numberOfKeys: parseInt(longName.split("-")[1]),
          lua: lua.toString()
        }
      };
    }));
  }
  var __dirname = "/home/jeffsilva01/www/pizzashop-api/node_modules/bull/lib/commands";
  var fsAsync = import.meta.require("fs").promises;
  var path = import.meta.require("path");
  module.exports = function() {
    let scripts;
    return async function(client) {
      scripts = await (scripts || loadScripts());
      return scripts.map(({ name, options }) => client.defineCommand(name, options));
    };
  }();
});

// node_modules/bull/lib/getters.js
var require_getters = __commonJS((exports, module) => {
  var parseTypeArg = function(args) {
    const types4 = _.chain([]).concat(args).join(",").split(/\s*,\s*/g).compact().value();
    return types4.length ? types4 : ["waiting", "active", "completed", "failed", "delayed", "paused"];
  };
  var _ = require_lodash4();
  var Job = require_job();
  module.exports = function(Queue2) {
    Queue2.prototype.getJob = async function(jobId) {
      await this.isReady();
      return Job.fromId(this, jobId);
    };
    Queue2.prototype._commandByType = function(types4, count, callback) {
      return _.map(types4, (type75) => {
        type75 = type75 === "waiting" ? "wait" : type75;
        const key = this.toKey(type75);
        switch (type75) {
          case "completed":
          case "failed":
          case "delayed":
          case "repeat":
            return callback(key, count ? "zcard" : "zrange");
          case "active":
          case "wait":
          case "paused":
            return callback(key, count ? "llen" : "lrange");
        }
      });
    };
    Queue2.prototype.count = function() {
      return this.getJobCountByTypes("wait", "paused", "delayed");
    };
    Queue2.prototype.getJobCountByTypes = function() {
      return this.getJobCounts.apply(this, arguments).then((result2) => {
        return _.chain(result2).values().sum().value();
      });
    };
    Queue2.prototype.getJobCounts = function() {
      const types4 = parseTypeArg(arguments);
      const multi = this.multi();
      this._commandByType(types4, true, (key, command) => {
        multi[command](key);
      });
      return multi.exec().then((res) => {
        const counts = {};
        res.forEach((res2, index) => {
          counts[types4[index]] = res2[1] || 0;
        });
        return counts;
      });
    };
    Queue2.prototype.getCompletedCount = function() {
      return this.getJobCountByTypes("completed");
    };
    Queue2.prototype.getFailedCount = function() {
      return this.getJobCountByTypes("failed");
    };
    Queue2.prototype.getDelayedCount = function() {
      return this.getJobCountByTypes("delayed");
    };
    Queue2.prototype.getActiveCount = function() {
      return this.getJobCountByTypes("active");
    };
    Queue2.prototype.getWaitingCount = function() {
      return this.getJobCountByTypes("wait", "paused");
    };
    Queue2.prototype.getStalledCount = function() {
      const key = this.toKey("stalled");
      return this.client.scard(key);
    };
    Queue2.prototype.getPausedCount = function() {
      return this.getJobCountByTypes("paused");
    };
    Queue2.prototype.getWaiting = function(start, end, opts) {
      return this.getJobs(["wait", "paused"], start, end, true, opts);
    };
    Queue2.prototype.getActive = function(start, end, opts) {
      return this.getJobs("active", start, end, true, opts);
    };
    Queue2.prototype.getDelayed = function(start, end, opts) {
      return this.getJobs("delayed", start, end, true, opts);
    };
    Queue2.prototype.getCompleted = function(start, end, opts) {
      return this.getJobs("completed", start, end, false, opts);
    };
    Queue2.prototype.getFailed = function(start, end, opts) {
      return this.getJobs("failed", start, end, false, opts);
    };
    Queue2.prototype.getRanges = function(types4, start, end, asc2) {
      start = _.isUndefined(start) ? 0 : start;
      end = _.isUndefined(end) ? -1 : end;
      const multi = this.multi();
      const multiCommands = [];
      this._commandByType(parseTypeArg(types4), false, (key, command) => {
        switch (command) {
          case "lrange":
            if (asc2) {
              multiCommands.push("lrange");
              multi.lrange(key, -(end + 1), -(start + 1));
            } else {
              multi.lrange(key, start, end);
            }
            break;
          case "zrange":
            multiCommands.push("zrange");
            if (asc2) {
              multi.zrange(key, start, end);
            } else {
              multi.zrevrange(key, start, end);
            }
            break;
        }
      });
      return multi.exec().then((responses) => {
        let results = [];
        responses.forEach((response, index) => {
          const result2 = response[1] || [];
          if (asc2 && multiCommands[index] === "lrange") {
            results = results.concat(result2.reverse());
          } else {
            results = results.concat(result2);
          }
        });
        return results;
      });
    };
    Queue2.prototype.getJobs = function(types4, start, end, asc2, opts) {
      return this.getRanges(types4, start, end, asc2).then((jobIds) => {
        return Promise.all(jobIds.map((jobId) => this.getJobFromId(jobId, opts)));
      });
    };
    Queue2.prototype.getJobLogs = function(jobId, start, end, asc2 = true) {
      start = _.isUndefined(start) ? 0 : start;
      end = _.isUndefined(end) ? -1 : end;
      const multi = this.multi();
      const logsKey = this.toKey(jobId + ":logs");
      if (asc2) {
        multi.lrange(logsKey, start, end);
      } else {
        multi.lrange(logsKey, -(end + 1), -(start + 1));
      }
      multi.llen(logsKey);
      return multi.exec().then((result2) => {
        if (!asc2) {
          result2[0][1].reverse();
        }
        return {
          logs: result2[0][1],
          count: result2[1][1]
        };
      });
    };
    Queue2.prototype.getMetrics = async function(type75, start = 0, end = -1) {
      const metricsKey = this.toKey(`metrics:${type75}`);
      const dataKey = `${metricsKey}:data`;
      const multi = this.multi();
      multi.hmget(metricsKey, "count", "prevTS", "prevCount");
      multi.lrange(dataKey, start, end);
      multi.llen(dataKey);
      const [hmget, range, len] = await multi.exec();
      const [err, [count, prevTS, prevCount]] = hmget;
      const [err2, data] = range;
      const [err3, numPoints] = len;
      if (err || err2) {
        throw err || err2 || err3;
      }
      return {
        meta: {
          count: parseInt(count || "0", 10),
          prevTS: parseInt(prevTS || "0", 10),
          prevCount: parseInt(prevCount || "0", 10)
        },
        data,
        count: numPoints
      };
    };
  };
});

// node_modules/bull/lib/worker.js
var require_worker = __commonJS((exports, module) => {
  var utils8 = require_utils4();
  var clientCommandMessageReg = /ERR unknown command ['`]\s*client\s*['`]/;
  module.exports = function(Queue2) {
    Queue2.prototype.setWorkerName = function() {
      return utils8.isRedisReady(this.client).then(() => {
        const connectionName = this.clientName();
        this.bclient.options.connectionName = connectionName;
        return this.bclient.client("setname", connectionName);
      }).catch((err) => {
        if (!clientCommandMessageReg.test(err.message))
          throw err;
      });
    };
    Queue2.prototype.getWorkers = function() {
      return utils8.isRedisReady(this.client).then(() => {
        return this.client.client("list");
      }).then((clients) => {
        return this.parseClientList(clients);
      }).catch((err) => {
        if (!clientCommandMessageReg.test(err.message))
          throw err;
      });
    };
    Queue2.prototype.base64Name = function() {
      return Buffer.from(this.name).toString("base64");
    };
    Queue2.prototype.clientName = function() {
      return this.keyPrefix + ":" + this.base64Name();
    };
    Queue2.prototype.parseClientList = function(list) {
      const lines = list.split("\n");
      const clients = [];
      lines.forEach((line) => {
        const client = {};
        const keyValues = line.split(" ");
        keyValues.forEach((keyValue) => {
          const index = keyValue.indexOf("=");
          const key = keyValue.substring(0, index);
          const value15 = keyValue.substring(index + 1);
          client[key] = value15;
        });
        const name = client["name"];
        if (name && name.startsWith(this.clientName())) {
          client["name"] = this.name;
          clients.push(client);
        }
      });
      return clients;
    };
  };
});

// node_modules/luxon/build/node/luxon.js
var require_luxon = __commonJS((exports) => {
  var makeDTF = function(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  };
  var hackyOffset = function(dtf, date5) {
    const formatted = dtf.format(date5).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  };
  var partsOffset = function(dtf, date5) {
    const formatted = dtf.formatToParts(date5);
    const filled = [];
    for (let i = 0;i < formatted.length; i++) {
      const {
        type: type75,
        value: value15
      } = formatted[i];
      const pos = typeToPos[type75];
      if (type75 === "era") {
        filled[pos] = value15;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value15, 10);
      }
    }
    return filled;
  };
  var getCachedLF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedDTF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  };
  var getCachedINF = function(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  };
  var getCachedRTF = function(locString, opts = {}) {
    const {
      base,
      ...cacheKeyOpts
    } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  };
  var systemLocale = function() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  };
  var getCachedWeekInfo = function(locString) {
    let data = weekInfoCache[locString];
    if (!data) {
      const locale = new Intl.Locale(locString);
      data = "getWeekInfo" in locale ? locale.getWeekInfo() : locale.weekInfo;
      weekInfoCache[locString] = data;
    }
    return data;
  };
  var parseLocaleString = function(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e2) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const {
        numberingSystem,
        calendar
      } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  };
  var intlConfigString = function(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  };
  var mapMonths = function(f) {
    const ms = [];
    for (let i = 1;i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  };
  var mapWeekdays = function(f) {
    const ms = [];
    for (let i = 1;i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  };
  var listStuff = function(loc, length, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length);
    } else {
      return intlFn(length);
    }
  };
  var supportsFastNumbers = function(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  };
  var normalizeZone = function(input, defaultZone2) {
    if (isUndefined(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default")
        return defaultZone2;
      else if (lowered === "local" || lowered === "system")
        return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt")
        return FixedOffsetZone.utcInstance;
      else
        return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  };
  var unitOutOfRange = function(unit, value15) {
    return new Invalid("unit out of range", `you specified ${value15} (of type ${typeof value15}) as a ${unit}, which is invalid`);
  };
  var dayOfWeek = function(year, month, day) {
    const d2 = new Date(Date.UTC(year, month - 1, day));
    if (year < 100 && year >= 0) {
      d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
    }
    const js = d2.getUTCDay();
    return js === 0 ? 7 : js;
  };
  var computeOrdinal = function(year, month, day) {
    return day + (isLeapYear(year) ? leapLadder : nonLeapLadder)[month - 1];
  };
  var uncomputeOrdinal = function(year, ordinal) {
    const table16 = isLeapYear(year) ? leapLadder : nonLeapLadder, month0 = table16.findIndex((i) => i < ordinal), day = ordinal - table16[month0];
    return {
      month: month0 + 1,
      day
    };
  };
  var isoWeekdayToLocal = function(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  };
  var gregorianToWeek = function(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      year,
      month,
      day
    } = gregObj, ordinal = computeOrdinal(year, month, day), weekday = isoWeekdayToLocal(dayOfWeek(year, month, day), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year + 1;
      weekNumber = 1;
    } else {
      weekYear = year;
    }
    return {
      weekYear,
      weekNumber,
      weekday,
      ...timeObject(gregObj)
    };
  };
  var weekToGregorian = function(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const {
      weekYear,
      weekNumber,
      weekday
    } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year;
    if (ordinal < 1) {
      year = weekYear - 1;
      ordinal += daysInYear(year);
    } else if (ordinal > yearInDays) {
      year = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year = weekYear;
    }
    const {
      month,
      day
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day,
      ...timeObject(weekData)
    };
  };
  var gregorianToOrdinal = function(gregData) {
    const {
      year,
      month,
      day
    } = gregData;
    const ordinal = computeOrdinal(year, month, day);
    return {
      year,
      ordinal,
      ...timeObject(gregData)
    };
  };
  var ordinalToGregorian = function(ordinalData) {
    const {
      year,
      ordinal
    } = ordinalData;
    const {
      month,
      day
    } = uncomputeOrdinal(year, ordinal);
    return {
      year,
      month,
      day,
      ...timeObject(ordinalData)
    };
  };
  var usesLocalWeekValues = function(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
      }
      if (!isUndefined(obj.localWeekday))
        obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber))
        obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear))
        obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return {
        minDaysInFirstWeek: 4,
        startOfWeek: 1
      };
    }
  };
  var hasInvalidWeekData = function(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(obj.weekNumber, 1, weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else
      return false;
  };
  var hasInvalidOrdinalData = function(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else
      return false;
  };
  var hasInvalidGregorianData = function(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else
      return false;
  };
  var hasInvalidTimeData = function(obj) {
    const {
      hour,
      minute,
      second,
      millisecond
    } = obj;
    const validHour = integerBetween(hour, 0, 23) || hour === 24 && minute === 0 && second === 0 && millisecond === 0, validMinute = integerBetween(minute, 0, 59), validSecond = integerBetween(second, 0, 59), validMillisecond = integerBetween(millisecond, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute);
    } else if (!validSecond) {
      return unitOutOfRange("second", second);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond);
    } else
      return false;
  };
  var isUndefined = function(o2) {
    return typeof o2 === "undefined";
  };
  var isNumber = function(o2) {
    return typeof o2 === "number";
  };
  var isInteger = function(o2) {
    return typeof o2 === "number" && o2 % 1 === 0;
  };
  var isString = function(o2) {
    return typeof o2 === "string";
  };
  var isDate = function(o2) {
    return Object.prototype.toString.call(o2) === "[object Date]";
  };
  var hasRelative = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e2) {
      return false;
    }
  };
  var hasLocaleWeekInfo = function() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && (("weekInfo" in Intl.Locale.prototype) || ("getWeekInfo" in Intl.Locale.prototype));
    } catch (e2) {
      return false;
    }
  };
  var maybeArray = function(thing) {
    return Array.isArray(thing) ? thing : [thing];
  };
  var bestBy = function(arr, by, compare) {
    if (arr.length === 0) {
      return;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  };
  var pick6 = function(obj, keys) {
    return keys.reduce((a2, k) => {
      a2[k] = obj[k];
      return a2;
    }, {});
  };
  var hasOwnProperty = function(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  };
  var validateWeekSettings = function(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v2) => !integerBetween(v2, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  };
  var integerBetween = function(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  };
  var floorMod = function(x, n3) {
    return x - n3 * Math.floor(x / n3);
  };
  var padStart = function(input, n3 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n3, "0");
    } else {
      padded = ("" + input).padStart(n3, "0");
    }
    return padded;
  };
  var parseInteger = function(string7) {
    if (isUndefined(string7) || string7 === null || string7 === "") {
      return;
    } else {
      return parseInt(string7, 10);
    }
  };
  var parseFloating = function(string7) {
    if (isUndefined(string7) || string7 === null || string7 === "") {
      return;
    } else {
      return parseFloat(string7);
    }
  };
  var parseMillis = function(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return;
    } else {
      const f = parseFloat("0." + fraction) * 1000;
      return Math.floor(f);
    }
  };
  var roundTo = function(number7, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number7 * factor) / factor;
  };
  var isLeapYear = function(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  };
  var daysInYear = function(year) {
    return isLeapYear(year) ? 366 : 365;
  };
  var daysInMonth = function(year, month) {
    const modMonth = floorMod(month - 1, 12) + 1, modYear = year + (month - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  };
  var objToLocalTS = function(obj) {
    let d2 = Date.UTC(obj.year, obj.month - 1, obj.day, obj.hour, obj.minute, obj.second, obj.millisecond);
    if (obj.year < 100 && obj.year >= 0) {
      d2 = new Date(d2);
      d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d2;
  };
  var firstWeekOffset = function(year, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  };
  var weeksInWeekYear = function(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  };
  var untruncateYear = function(year) {
    if (year > 99) {
      return year;
    } else
      return year > Settings.twoDigitCutoffYear ? 1900 + year : 2000 + year;
  };
  var parseZoneInfo = function(ts, offsetFormat, locale, timeZone = null) {
    const date5 = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = {
      timeZoneName: offsetFormat,
      ...intlOpts
    };
    const parsed = new Intl.DateTimeFormat(locale, modified).formatToParts(date5).find((m2) => m2.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  };
  var signedOffset = function(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  };
  var asNumber = function(value15) {
    const numericValue = Number(value15);
    if (typeof value15 === "boolean" || value15 === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value15}`);
    return numericValue;
  };
  var normalizeObject = function(obj, normalizer) {
    const normalized = {};
    for (const u2 in obj) {
      if (hasOwnProperty(obj, u2)) {
        const v2 = obj[u2];
        if (v2 === undefined || v2 === null)
          continue;
        normalized[normalizer(u2)] = asNumber(v2);
      }
    }
    return normalized;
  };
  var formatOffset = function(offset2, format) {
    const hours = Math.trunc(Math.abs(offset2 / 60)), minutes = Math.trunc(Math.abs(offset2 % 60)), sign = offset2 >= 0 ? "+" : "-";
    switch (format) {
      case "short":
        return `${sign}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format} is out of range for property format`);
    }
  };
  var timeObject = function(obj) {
    return pick6(obj, ["hour", "minute", "second", "millisecond"]);
  };
  var months = function(length) {
    switch (length) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  };
  var weekdays = function(length) {
    switch (length) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  };
  var eras = function(length) {
    switch (length) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  };
  var meridiemForDateTime = function(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  };
  var weekdayForDateTime = function(dt, length) {
    return weekdays(length)[dt.weekday - 1];
  };
  var monthForDateTime = function(dt, length) {
    return months(length)[dt.month - 1];
  };
  var eraForDateTime = function(dt, length) {
    return eras(length)[dt.year < 0 ? 0 : 1];
  };
  var formatRelativeTime = function(unit, count, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
      }
    }
    const isInPast = Object.is(count, -0) || count < 0, fmtValue = Math.abs(count), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  };
  var stringifyTokens = function(splits, tokenToString) {
    let s3 = "";
    for (const token of splits) {
      if (token.literal) {
        s3 += token.val;
      } else {
        s3 += tokenToString(token.val);
      }
    }
    return s3;
  };
  var combineRegexes = function(...regexes) {
    const full = regexes.reduce((f, r2) => f + r2.source, "");
    return RegExp(`^${full}\$`);
  };
  var combineExtractors = function(...extractors) {
    return (m2) => extractors.reduce(([mergedVals, mergedZone, cursor], ex) => {
      const [val, zone, next] = ex(m2, cursor);
      return [{
        ...mergedVals,
        ...val
      }, zone || mergedZone, next];
    }, [{}, null, 1]).slice(0, 2);
  };
  var parse5 = function(s3, ...patterns7) {
    if (s3 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns7) {
      const m2 = regex.exec(s3);
      if (m2) {
        return extractor(m2);
      }
    }
    return [null, null];
  };
  var simpleParse = function(...keys) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0;i < keys.length; i++) {
        ret[keys[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  };
  var int = function(match2, pos, fallback) {
    const m2 = match2[pos];
    return isUndefined(m2) ? fallback : parseInteger(m2);
  };
  var extractISOYmd = function(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  };
  var extractISOTime = function(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  };
  var extractISOOffset = function(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  };
  var extractIANAZone = function(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  };
  var extractISODuration = function(match2) {
    const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s3[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== undefined && (force || num && hasNegativePrefix) ? -num : num;
    return [{
      years: maybeNegate(parseFloating(yearStr)),
      months: maybeNegate(parseFloating(monthStr)),
      weeks: maybeNegate(parseFloating(weekStr)),
      days: maybeNegate(parseFloating(dayStr)),
      hours: maybeNegate(parseFloating(hourStr)),
      minutes: maybeNegate(parseFloating(minuteStr)),
      seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
      milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
    }];
  };
  var fromStrings = function(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result2 = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr)
      result2.second = parseInteger(secondStr);
    if (weekdayStr) {
      result2.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result2;
  };
  var extractRFC2822 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr, obsOffset, milOffset, offHourStr, offMinuteStr] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset2;
    if (obsOffset) {
      offset2 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset2 = 0;
    } else {
      offset2 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result2, new FixedOffsetZone(offset2)];
  };
  var preprocessRFC2822 = function(s3) {
    return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  };
  var extractRFC1123Or850 = function(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result2, FixedOffsetZone.utcInstance];
  };
  var extractASCII = function(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result2 = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result2, FixedOffsetZone.utcInstance];
  };
  var parseISODate = function(s3) {
    return parse5(s3, [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset], [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime], [isoTimeCombinedRegex, extractISOTimeAndOffset]);
  };
  var parseRFC2822Date = function(s3) {
    return parse5(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
  };
  var parseHTTPDate = function(s3) {
    return parse5(s3, [rfc1123, extractRFC1123Or850], [rfc850, extractRFC1123Or850], [ascii, extractASCII]);
  };
  var parseISODuration = function(s3) {
    return parse5(s3, [isoDuration, extractISODuration]);
  };
  var parseISOTimeOnly = function(s3) {
    return parse5(s3, [isoTimeOnly, extractISOTimeOnly]);
  };
  var parseSQL = function(s3) {
    return parse5(s3, [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset], [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]);
  };
  var clone$1 = function(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : {
        ...dur.values,
        ...alts.values || {}
      },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  };
  var durationToMillis = function(matrix, vals) {
    var _vals$milliseconds;
    let sum = (_vals$milliseconds = vals.milliseconds) != null ? _vals$milliseconds : 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum += vals[unit] * matrix[unit]["milliseconds"];
      }
    }
    return sum;
  };
  var normalizeValues = function(matrix, vals) {
    const factor = durationToMillis(matrix, vals) < 0 ? -1 : 1;
    orderedUnits$1.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits$1.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  };
  var removeZeroes = function(vals) {
    const newVals = {};
    for (const [key, value15] of Object.entries(vals)) {
      if (value15 !== 0) {
        newVals[key] = value15;
      }
    }
    return newVals;
  };
  var validateStartEnd = function(start, end) {
    if (!start || !start.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start) {
      return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${start.toISO()} and end=${end.toISO()}`);
    } else {
      return null;
    }
  };
  var dayDiff = function(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, {
      keepLocalTime: true
    }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  };
  var highOrderDiffs = function(cursor, later, units) {
    const differs = [["years", (a2, b3) => b3.year - a2.year], ["quarters", (a2, b3) => b3.quarter - a2.quarter + (b3.year - a2.year) * 4], ["months", (a2, b3) => b3.month - a2.month + (b3.year - a2.year) * 12], ["weeks", (a2, b3) => {
      const days = dayDiff(a2, b3);
      return (days - days % 7) / 7;
    }], ["days", dayDiff]];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  };
  var diff = function(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter((u2) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u2) >= 0);
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({
          [lowestOrder]: 1
        });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  };
  var parseDigits = function(str) {
    let value15 = parseInt(str, 10);
    if (isNaN(value15)) {
      value15 = "";
      for (let i = 0;i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (str[i].search(numberingSystems.hanidec) !== -1) {
          value15 += hanidecChars.indexOf(str[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min, max] = numberingSystemsUTF16[key];
            if (code >= min && code <= max) {
              value15 += code - min;
            }
          }
        }
      }
      return parseInt(value15, 10);
    } else {
      return value15;
    }
  };
  var digitRegex = function({
    numberingSystem
  }, append = "") {
    return new RegExp(`${numberingSystems[numberingSystem || "latn"]}${append}`);
  };
  var intUnit = function(regex, post = (i) => i) {
    return {
      regex,
      deser: ([s3]) => post(parseDigits(s3))
    };
  };
  var fixListRegex = function(s3) {
    return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  };
  var stripInsensitivities = function(s3) {
    return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  };
  var oneOf = function(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s3]) => strings.findIndex((i) => stripInsensitivities(s3) === stripInsensitivities(i)) + startIndex
      };
    }
  };
  var offset = function(regex, groups) {
    return {
      regex,
      deser: ([, h2, m2]) => signedOffset(h2, m2),
      groups
    };
  };
  var simple = function(regex) {
    return {
      regex,
      deser: ([s3]) => s3
    };
  };
  var escapeToken = function(value15) {
    return value15.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  };
  var unitForToken = function(token, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal14 = (t) => ({
      regex: RegExp(escapeToken(t.val)),
      deser: ([s3]) => s3,
      literal: true
    }), unitate = (t) => {
      if (token.literal) {
        return literal14(t);
      }
      switch (t.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal14(t);
      }
    };
    const unit = unitate(token) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token;
    return unit;
  };
  var tokenForPart = function(part, formatOpts, resolvedOpts) {
    const {
      type: type75,
      value: value15
    } = part;
    if (type75 === "literal") {
      const isSpace = /^\s+$/.test(value15);
      return {
        literal: !isSpace,
        val: isSpace ? " " : value15
      };
    }
    const style = formatOpts[type75];
    let actualType = type75;
    if (type75 === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return;
  };
  var buildRegex = function(units) {
    const re = units.map((u2) => u2.regex).reduce((f, r2) => `${f}(${r2.source})`, "");
    return [`^${re}\$`, units];
  };
  var match = function(input, regex, handlers) {
    const matches = input.match(regex);
    if (matches) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty(handlers, i)) {
          const h2 = handlers[i], groups = h2.groups ? h2.groups + 1 : 1;
          if (!h2.literal && h2.token) {
            all[h2.token.val[0]] = h2.deser(matches.slice(matchIndex, matchIndex + groups));
          }
          matchIndex += groups;
        }
      }
      return [matches, all];
    } else {
      return [matches, {}];
    }
  };
  var dateTimeFromMatches = function(matches) {
    const toField = (token) => {
      switch (token) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches.z)) {
      zone = IANAZone.create(matches.z);
    }
    if (!isUndefined(matches.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches.Z);
      }
      specificOffset = matches.Z;
    }
    if (!isUndefined(matches.q)) {
      matches.M = (matches.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches.h)) {
      if (matches.h < 12 && matches.a === 1) {
        matches.h += 12;
      } else if (matches.h === 12 && matches.a === 0) {
        matches.h = 0;
      }
    }
    if (matches.G === 0 && matches.y) {
      matches.y = -matches.y;
    }
    if (!isUndefined(matches.u)) {
      matches.S = parseMillis(matches.u);
    }
    const vals = Object.keys(matches).reduce((r2, k) => {
      const f = toField(k);
      if (f) {
        r2[f] = matches[k];
      }
      return r2;
    }, {});
    return [vals, zone, specificOffset];
  };
  var getDummyDateTime = function() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  };
  var maybeExpandMacroToken = function(token, locale) {
    if (token.literal) {
      return token;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token.val);
    const tokens = formatOptsToTokens(formatOpts, locale);
    if (tokens == null || tokens.includes(undefined)) {
      return token;
    }
    return tokens;
  };
  var expandMacroTokens = function(tokens, locale) {
    return Array.prototype.concat(...tokens.map((t) => maybeExpandMacroToken(t, locale)));
  };
  var explainFromTokens = function(locale, input, format) {
    const tokens = expandMacroTokens(Formatter.parseFormat(format), locale), units = tokens.map((t) => unitForToken(t, locale)), disqualifyingUnit = units.find((t) => t.invalidReason);
    if (disqualifyingUnit) {
      return {
        input,
        tokens,
        invalidReason: disqualifyingUnit.invalidReason
      };
    } else {
      const [regexString, handlers] = buildRegex(units), regex = RegExp(regexString, "i"), [rawMatches, matches] = match(input, regex, handlers), [result2, zone, specificOffset] = matches ? dateTimeFromMatches(matches) : [null, null, undefined];
      if (hasOwnProperty(matches, "a") && hasOwnProperty(matches, "H")) {
        throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
      }
      return {
        input,
        tokens,
        regex,
        rawMatches,
        matches,
        result: result2,
        zone,
        specificOffset
      };
    }
  };
  var parseFromTokens = function(locale, input, format) {
    const {
      result: result2,
      zone,
      specificOffset,
      invalidReason
    } = explainFromTokens(locale, input, format);
    return [result2, zone, specificOffset, invalidReason];
  };
  var formatOptsToTokens = function(formatOpts, locale) {
    if (!formatOpts) {
      return null;
    }
    const formatter = Formatter.create(locale, formatOpts);
    const df = formatter.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
  };
  var unsupportedZone = function(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  };
  var possiblyCachedWeekData = function(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  };
  var possiblyCachedLocalWeekData = function(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(dt.c, dt.loc.getMinDaysInFirstWeek(), dt.loc.getStartOfWeek());
    }
    return dt.localWeekData;
  };
  var clone13 = function(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({
      ...current,
      ...alts,
      old: current
    });
  };
  var fixOffset = function(localTS, o2, tz) {
    let utcGuess = localTS - o2 * 60 * 1000;
    const o22 = tz.offset(utcGuess);
    if (o2 === o22) {
      return [utcGuess, o2];
    }
    utcGuess -= (o22 - o2) * 60 * 1000;
    const o3 = tz.offset(utcGuess);
    if (o22 === o3) {
      return [utcGuess, o22];
    }
    return [localTS - Math.min(o22, o3) * 60 * 1000, Math.max(o22, o3)];
  };
  var tsToObj = function(ts, offset2) {
    ts += offset2 * 60 * 1000;
    const d2 = new Date(ts);
    return {
      year: d2.getUTCFullYear(),
      month: d2.getUTCMonth() + 1,
      day: d2.getUTCDate(),
      hour: d2.getUTCHours(),
      minute: d2.getUTCMinutes(),
      second: d2.getUTCSeconds(),
      millisecond: d2.getUTCMilliseconds()
    };
  };
  var objToTS = function(obj, offset2, zone) {
    return fixOffset(objToLocalTS(obj), offset2, zone);
  };
  var adjustTime = function(inst, dur) {
    const oPre = inst.o, year = inst.c.year + Math.trunc(dur.years), month = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c2 = {
      ...inst.c,
      year,
      month,
      day: Math.min(inst.c.day, daysInMonth(year, month)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c2);
    let [ts, o2] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o2 = inst.zone.offset(ts);
    }
    return {
      ts,
      o: o2
    };
  };
  var parseDataToDateTime = function(parsed, parsedZone, opts, format, text2, specificOffset) {
    const {
      setZone,
      zone
    } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(new Invalid("unparsable", `the input "${text2}" can't be parsed as ${format}`));
    }
  };
  var toTechFormat = function(dt, format, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format) : null;
  };
  var toISODate = function(o2, extended) {
    const longFormat = o2.c.year > 9999 || o2.c.year < 0;
    let c2 = "";
    if (longFormat && o2.c.year >= 0)
      c2 += "+";
    c2 += padStart(o2.c.year, longFormat ? 6 : 4);
    if (extended) {
      c2 += "-";
      c2 += padStart(o2.c.month);
      c2 += "-";
      c2 += padStart(o2.c.day);
    } else {
      c2 += padStart(o2.c.month);
      c2 += padStart(o2.c.day);
    }
    return c2;
  };
  var toISOTime = function(o2, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c2 = padStart(o2.c.hour);
    if (extended) {
      c2 += ":";
      c2 += padStart(o2.c.minute);
      if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
        c2 += ":";
      }
    } else {
      c2 += padStart(o2.c.minute);
    }
    if (o2.c.millisecond !== 0 || o2.c.second !== 0 || !suppressSeconds) {
      c2 += padStart(o2.c.second);
      if (o2.c.millisecond !== 0 || !suppressMilliseconds) {
        c2 += ".";
        c2 += padStart(o2.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o2.isOffsetFixed && o2.offset === 0 && !extendedZone) {
        c2 += "Z";
      } else if (o2.o < 0) {
        c2 += "-";
        c2 += padStart(Math.trunc(-o2.o / 60));
        c2 += ":";
        c2 += padStart(Math.trunc(-o2.o % 60));
      } else {
        c2 += "+";
        c2 += padStart(Math.trunc(o2.o / 60));
        c2 += ":";
        c2 += padStart(Math.trunc(o2.o % 60));
      }
    }
    if (extendedZone) {
      c2 += "[" + o2.zone.ianaName + "]";
    }
    return c2;
  };
  var normalizeUnit = function(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized)
      throw new InvalidUnitError(unit);
    return normalized;
  };
  var normalizeUnitWithLocalWeeks = function(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  };
  var quickDT = function(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone), loc = Locale.fromObject(opts), tsNow = Settings.now();
    let ts, o2;
    if (!isUndefined(obj.year)) {
      for (const u2 of orderedUnits) {
        if (isUndefined(obj[u2])) {
          obj[u2] = defaultUnitValues[u2];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = zone.offset(tsNow);
      [ts, o2] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = tsNow;
    }
    return new DateTime({
      ts,
      zone,
      loc,
      o: o2
    });
  };
  var diffRelative = function(start, end, opts) {
    const round = isUndefined(opts.round) ? true : opts.round, format = (c2, unit) => {
      c2 = roundTo(c2, round || opts.calendary ? 0 : 2, true);
      const formatter = end.loc.clone(opts).relFormatter(opts);
      return formatter.format(c2, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start, unit)) {
          return end.startOf(unit).diff(start.startOf(unit), unit).get(unit);
        } else
          return 0;
      } else {
        return end.diff(start, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count = differ(unit);
      if (Math.abs(count) >= 1) {
        return format(count, unit);
      }
    }
    return format(start > end ? -0 : 0, opts.units[opts.units.length - 1]);
  };
  var lastOpts = function(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  };
  var friendlyDateTime = function(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(`Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class LuxonError extends Error {
  }

  class InvalidDateTimeError extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  }

  class InvalidIntervalError extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  }

  class InvalidDurationError extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  }

  class ConflictingSpecificationError extends LuxonError {
  }

  class InvalidUnitError extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  }

  class InvalidArgumentError extends LuxonError {
  }

  class ZoneIsAbstractError extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  }
  var n2 = "numeric";
  var s2 = "short";
  var l2 = "long";
  var DATE_SHORT = {
    year: n2,
    month: n2,
    day: n2
  };
  var DATE_MED = {
    year: n2,
    month: s2,
    day: n2
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n2,
    month: s2,
    day: n2,
    weekday: s2
  };
  var DATE_FULL = {
    year: n2,
    month: l2,
    day: n2
  };
  var DATE_HUGE = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2
  };
  var TIME_SIMPLE = {
    hour: n2,
    minute: n2
  };
  var TIME_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s2
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l2
  };
  var TIME_24_SIMPLE = {
    hour: n2,
    minute: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: s2
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n2,
    minute: n2,
    second: n2,
    hourCycle: "h23",
    timeZoneName: l2
  };
  var DATETIME_SHORT = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n2,
    month: n2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED = {
    year: n2,
    month: s2,
    day: n2,
    hour: n2,
    minute: n2
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n2,
    month: s2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n2,
    month: s2,
    day: n2,
    weekday: s2,
    hour: n2,
    minute: n2
  };
  var DATETIME_FULL = {
    year: n2,
    month: l2,
    day: n2,
    hour: n2,
    minute: n2,
    timeZoneName: s2
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n2,
    month: l2,
    day: n2,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: s2
  };
  var DATETIME_HUGE = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2,
    hour: n2,
    minute: n2,
    timeZoneName: l2
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n2,
    month: l2,
    day: n2,
    weekday: l2,
    hour: n2,
    minute: n2,
    second: n2,
    timeZoneName: l2
  };

  class Zone {
    get type() {
      throw new ZoneIsAbstractError;
    }
    get name() {
      throw new ZoneIsAbstractError;
    }
    get ianaName() {
      return this.name;
    }
    get isUniversal() {
      throw new ZoneIsAbstractError;
    }
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError;
    }
    formatOffset(ts, format) {
      throw new ZoneIsAbstractError;
    }
    offset(ts) {
      throw new ZoneIsAbstractError;
    }
    equals(otherZone) {
      throw new ZoneIsAbstractError;
    }
    get isValid() {
      throw new ZoneIsAbstractError;
    }
  }
  var singleton$1 = null;

  class SystemZone extends Zone {
    static get instance() {
      if (singleton$1 === null) {
        singleton$1 = new SystemZone;
      }
      return singleton$1;
    }
    get type() {
      return "system";
    }
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    equals(otherZone) {
      return otherZone.type === "system";
    }
    get isValid() {
      return true;
    }
  }
  var dtfCache = {};
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  var ianaZoneCache = {};

  class IANAZone extends Zone {
    static create(name) {
      if (!ianaZoneCache[name]) {
        ianaZoneCache[name] = new IANAZone(name);
      }
      return ianaZoneCache[name];
    }
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    static isValidSpecifier(s3) {
      return this.isValidZone(s3);
    }
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", {
          timeZone: zone
        }).format();
        return true;
      } catch (e2) {
        return false;
      }
    }
    constructor(name) {
      super();
      this.zoneName = name;
      this.valid = IANAZone.isValidZone(name);
    }
    get type() {
      return "iana";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName(ts, {
      format,
      locale
    }) {
      return parseZoneInfo(ts, format, locale, this.name);
    }
    formatOffset(ts, format) {
      return formatOffset(this.offset(ts), format);
    }
    offset(ts) {
      const date5 = new Date(ts);
      if (isNaN(date5))
        return NaN;
      const dtf = makeDTF(this.name);
      let [year, month, day, adOrBc, hour, minute, second] = dtf.formatToParts ? partsOffset(dtf, date5) : hackyOffset(dtf, date5);
      if (adOrBc === "BC") {
        year = -Math.abs(year) + 1;
      }
      const adjustedHour = hour === 24 ? 0 : hour;
      const asUTC = objToLocalTS({
        year,
        month,
        day,
        hour: adjustedHour,
        minute,
        second,
        millisecond: 0
      });
      let asTS = +date5;
      const over = asTS % 1000;
      asTS -= over >= 0 ? over : 1000 + over;
      return (asUTC - asTS) / (60 * 1000);
    }
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    get isValid() {
      return this.valid;
    }
  }
  var intlLFCache = {};
  var intlDTCache = {};
  var intlNumCache = {};
  var intlRelCache = {};
  var sysLocaleCache = null;
  var weekInfoCache = {};

  class PolyNumberFormatter {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const {
        padTo,
        floor,
        ...otherOpts
      } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = {
          useGrouping: false,
          ...opts
        };
        if (opts.padTo > 0)
          intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  }

  class PolyDateFormatter {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = undefined;
      let z2 = undefined;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z2 = offsetZ;
          this.dt = dt;
        } else {
          z2 = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({
            minutes: dt.offset
          });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z2 = dt.zone.name;
      } else {
        z2 = "UTC";
        this.dt = dt.setZone("UTC").plus({
          minutes: dt.offset
        });
        this.originalZone = dt.zone;
      }
      const intlOpts = {
        ...this.opts
      };
      intlOpts.timeZone = intlOpts.timeZone || z2;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({
          value: value15
        }) => value15).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  }

  class PolyRelFormatter {
    constructor(intl, isEnglish, opts) {
      this.opts = {
        style: "long",
        ...opts
      };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count, unit) {
      if (this.rtf) {
        return this.rtf.format(count, unit);
      } else {
        return formatRelativeTime(unit, count, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count, unit);
      } else {
        return [];
      }
    }
  }
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };

  class Locale {
    static fromOpts(opts) {
      return Locale.create(opts.locale, opts.numberingSystem, opts.outputCalendar, opts.weekSettings, opts.defaultToEN);
    }
    static create(locale, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({
      locale,
      numberingSystem,
      outputCalendar,
      weekSettings
    } = {}) {
      return Locale.create(locale, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = {
        format: {},
        standalone: {}
      };
      this.monthsCache = {
        format: {},
        standalone: {}
      };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return Locale.create(alts.locale || this.specifiedLocale, alts.numberingSystem || this.numberingSystem, alts.outputCalendar || this.outputCalendar, validateWeekSettings(alts.weekSettings) || this.weekSettings, alts.defaultToEN || false);
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: true
      });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({
        ...alts,
        defaultToEN: false
      });
    }
    months(length, format = false) {
      return listStuff(this, length, months, () => {
        const intl = format ? {
          month: length,
          day: "numeric"
        } : {
          month: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length]) {
          this.monthsCache[formatStr][length] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length];
      });
    }
    weekdays(length, format = false) {
      return listStuff(this, length, weekdays, () => {
        const intl = format ? {
          weekday: length,
          year: "numeric",
          month: "long",
          day: "numeric"
        } : {
          weekday: length
        }, formatStr = format ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length]) {
          this.weekdaysCache[formatStr][length] = mapWeekdays((dt) => this.extract(dt, intl, "weekday"));
        }
        return this.weekdaysCache[formatStr][length];
      });
    }
    meridiems() {
      return listStuff(this, undefined, () => meridiems, () => {
        if (!this.meridiemCache) {
          const intl = {
            hour: "numeric",
            hourCycle: "h12"
          };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((dt) => this.extract(dt, intl, "dayperiod"));
        }
        return this.meridiemCache;
      });
    }
    eras(length) {
      return listStuff(this, length, eras, () => {
        const intl = {
          era: length
        };
        if (!this.eraCache[length]) {
          this.eraCache[length] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((dt) => this.extract(dt, intl, "era"));
        }
        return this.eraCache[length];
      });
    }
    extract(dt, intlOpts, field) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m2) => m2.type.toLowerCase() === field);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
  }
  var singleton = null;

  class FixedOffsetZone extends Zone {
    static get utcInstance() {
      if (singleton === null) {
        singleton = new FixedOffsetZone(0);
      }
      return singleton;
    }
    static instance(offset2) {
      return offset2 === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(offset2);
    }
    static parseSpecifier(s3) {
      if (s3) {
        const r2 = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r2) {
          return new FixedOffsetZone(signedOffset(r2[1], r2[2]));
        }
      }
      return null;
    }
    constructor(offset2) {
      super();
      this.fixed = offset2;
    }
    get type() {
      return "fixed";
    }
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    offsetName() {
      return this.name;
    }
    formatOffset(ts, format) {
      return formatOffset(this.fixed, format);
    }
    get isUniversal() {
      return true;
    }
    offset() {
      return this.fixed;
    }
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    get isValid() {
      return true;
    }
  }

  class InvalidZone extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    get type() {
      return "invalid";
    }
    get name() {
      return this.zoneName;
    }
    get isUniversal() {
      return false;
    }
    offsetName() {
      return null;
    }
    formatOffset() {
      return "";
    }
    offset() {
      return NaN;
    }
    equals() {
      return false;
    }
    get isValid() {
      return false;
    }
  }
  var now = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;

  class Settings {
    static get now() {
      return now;
    }
    static set now(n3) {
      now = n3;
    }
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    static get defaultLocale() {
      return defaultLocale;
    }
    static set defaultLocale(locale) {
      defaultLocale = locale;
    }
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
    }
  }

  class Invalid {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  }
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  var monthsLong = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var monthsShort = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  var weekdaysLong = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };

  class Formatter {
    static create(locale, opts = {}) {
      return new Formatter(locale, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0;i < fmt.length; i++) {
        const c2 = fmt.charAt(i);
        if (c2 === "'") {
          if (currentFull.length > 0) {
            splits.push({
              literal: bracketed || /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c2;
        } else if (c2 === current) {
          currentFull += c2;
        } else {
          if (currentFull.length > 0) {
            splits.push({
              literal: /^\s+$/.test(currentFull),
              val: currentFull
            });
          }
          currentFull = c2;
          current = c2;
        }
      }
      if (currentFull.length > 0) {
        splits.push({
          literal: bracketed || /^\s+$/.test(currentFull),
          val: currentFull
        });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token) {
      return macroTokenToFormatOpts[token];
    }
    constructor(locale, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, {
        ...this.opts,
        ...opts
      });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval, opts) {
      const df = this.dtFormatter(interval.start, opts);
      return df.dtf.formatRange(interval.start.toJSDate(), interval.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n3, p2 = 0) {
      if (this.opts.forceSimple) {
        return padStart(n3, p2);
      }
      const opts = {
        ...this.opts
      };
      if (p2 > 0) {
        opts.padTo = p2;
      }
      return this.loc.numberFormatter(opts).format(n3);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string7 = (opts, extract6) => this.loc.extract(dt, opts, extract6), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string7({
        hour: "numeric",
        hourCycle: "h12"
      }, "dayperiod"), month = (length, standalone) => knownEnglish ? monthForDateTime(dt, length) : string7(standalone ? {
        month: length
      } : {
        month: length,
        day: "numeric"
      }, "month"), weekday = (length, standalone) => knownEnglish ? weekdayForDateTime(dt, length) : string7(standalone ? {
        weekday: length
      } : {
        weekday: length,
        month: "long",
        day: "numeric"
      }, "weekday"), maybeMacro = (token) => {
        const formatOpts = Formatter.macroTokenToFormatOpts(token);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token;
        }
      }, era = (length) => knownEnglish ? eraForDateTime(dt, length) : string7({
        era: length
      }, "era"), tokenToString = (token) => {
        switch (token) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({
              format: "narrow",
              allowZ: this.opts.allowZ
            });
          case "ZZ":
            return formatOffset2({
              format: "short",
              allowZ: this.opts.allowZ
            });
          case "ZZZ":
            return formatOffset2({
              format: "techie",
              allowZ: this.opts.allowZ
            });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "short",
              locale: this.loc.locale
            });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, {
              format: "long",
              locale: this.loc.locale
            });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string7({
              day: "numeric"
            }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string7({
              day: "2-digit"
            }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string7({
              month: "numeric",
              day: "numeric"
            }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string7({
              month: "2-digit",
              day: "numeric"
            }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return useDateTimeFormatter ? string7({
              month: "numeric"
            }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string7({
              month: "2-digit"
            }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return useDateTimeFormatter ? string7({
              year: "numeric"
            }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string7({
              year: "2-digit"
            }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string7({
              year: "numeric"
            }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string7({
              year: "numeric"
            }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1000));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token);
        }
      };
      return stringifyTokens(Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token) => {
        switch (token[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token) => {
        const mapped20 = tokenToField(token);
        if (mapped20) {
          return this.num(lildur.get(mapped20), token.length);
        } else {
          return token;
        }
      }, tokens = Formatter.parseFormat(fmt), realTokens = tokens.reduce((found, {
        literal: literal14,
        val
      }) => literal14 ? found : found.concat(val), []), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens, tokenToString(collapsed));
    }
  }
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(`${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`);
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}\$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOWeekTimeAndOffset = combineExtractors(extractISOWeekData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOOrdinalDateAndTime = combineExtractors(extractISOOrdinalData, extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeAndOffset = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
  var INVALID$2 = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1000
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1000
    },
    hours: {
      minutes: 60,
      seconds: 60 * 60,
      milliseconds: 60 * 60 * 1000
    },
    minutes: {
      seconds: 60,
      milliseconds: 60 * 1000
    },
    seconds: {
      milliseconds: 1000
    }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1000
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1000 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1000
    },
    ...lowOrderMatrix
  };
  var orderedUnits$1 = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
  var reverseUnits = orderedUnits$1.slice(0).reverse();

  class Duration {
    constructor(config) {
      const accurate = config.conversionAccuracy === "longterm" || false;
      let matrix = accurate ? accurateMatrix : casualMatrix;
      if (config.matrix) {
        matrix = config.matrix;
      }
      this.values = config.values;
      this.loc = config.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config.invalid || null;
      this.matrix = matrix;
      this.isLuxonDuration = true;
    }
    static fromMillis(count, opts) {
      return Duration.fromObject({
        milliseconds: count
      }, opts);
    }
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`);
      }
      return new Duration({
        values: normalizeObject(obj, Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return Duration.fromMillis(durationLike);
      } else if (Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(`Unknown duration argument ${durationLike} of type ${typeof durationLike}`);
      }
    }
    static fromISO(text2, opts) {
      const [parsed] = parseISODuration(text2);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
    }
    static fromISOTime(text2, opts) {
      const [parsed] = parseISOTimeOnly(text2);
      if (parsed) {
        return Duration.fromObject(parsed, opts);
      } else {
        return Duration.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
      }
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new Duration({
          invalid
        });
      }
    }
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized)
        throw new InvalidUnitError(unit);
      return normalized;
    }
    static isDuration(o2) {
      return o2 && o2.isLuxonDuration || false;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID$2;
    }
    toHuman(opts = {}) {
      if (!this.isValid)
        return INVALID$2;
      const l3 = orderedUnits$1.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({
          style: "unit",
          unitDisplay: "long",
          ...opts,
          unit: unit.slice(0, -1)
        }).format(val);
      }).filter((n3) => n3);
      return this.loc.listFormatter({
        type: "conjunction",
        style: opts.listStyle || "narrow",
        ...opts
      }).format(l3);
    }
    toObject() {
      if (!this.isValid)
        return {};
      return {
        ...this.values
      };
    }
    toISO() {
      if (!this.isValid)
        return null;
      let s3 = "P";
      if (this.years !== 0)
        s3 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0)
        s3 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0)
        s3 += this.weeks + "W";
      if (this.days !== 0)
        s3 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s3 += "T";
      if (this.hours !== 0)
        s3 += this.hours + "H";
      if (this.minutes !== 0)
        s3 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s3 += roundTo(this.seconds + this.milliseconds / 1000, 3) + "S";
      if (s3 === "P")
        s3 += "T0S";
      return s3;
    }
    toISOTime(opts = {}) {
      if (!this.isValid)
        return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 86400000)
        return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, {
        zone: "UTC"
      });
      return dateTime.toISOTime(opts);
    }
    toJSON() {
      return this.toISO();
    }
    toString() {
      return this.toISO();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toMillis() {
      if (!this.isValid)
        return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    valueOf() {
      return this.toMillis();
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration), result2 = {};
      for (const k of orderedUnits$1) {
        if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
          result2[k] = dur.get(k) + this.get(k);
        }
      }
      return clone$1(this, {
        values: result2
      }, true);
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    mapUnits(fn) {
      if (!this.isValid)
        return this;
      const result2 = {};
      for (const k of Object.keys(this.values)) {
        result2[k] = asNumber(fn(this.values[k], k));
      }
      return clone$1(this, {
        values: result2
      }, true);
    }
    get(unit) {
      return this[Duration.normalizeUnit(unit)];
    }
    set(values2) {
      if (!this.isValid)
        return this;
      const mixed = {
        ...this.values,
        ...normalizeObject(values2, Duration.normalizeUnit)
      };
      return clone$1(this, {
        values: mixed
      });
    }
    reconfigure({
      locale,
      numberingSystem,
      conversionAccuracy,
      matrix
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem
      });
      const opts = {
        loc,
        matrix,
        conversionAccuracy
      };
      return clone$1(this, opts);
    }
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    normalize() {
      if (!this.isValid)
        return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone$1(this, {
        values: vals
      }, true);
    }
    rescale() {
      if (!this.isValid)
        return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone$1(this, {
        values: vals
      }, true);
    }
    shiftTo(...units) {
      if (!this.isValid)
        return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u2) => Duration.normalizeUnit(u2));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits$1) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1000 - i * 1000) / 1000;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone$1(this, {
        values: built
      }, true);
    }
    shiftToAll() {
      if (!this.isValid)
        return this;
      return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
    }
    negate() {
      if (!this.isValid)
        return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone$1(this, {
        values: negated
      }, true);
    }
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq2(v12, v2) {
        if (v12 === undefined || v12 === 0)
          return v2 === undefined || v2 === 0;
        return v12 === v2;
      }
      for (const u2 of orderedUnits$1) {
        if (!eq2(this.values[u2], other.values[u2])) {
          return false;
        }
      }
      return true;
    }
  }
  var INVALID$1 = "Invalid Interval";

  class Interval {
    constructor(config) {
      this.s = config.start;
      this.e = config.end;
      this.invalid = config.invalid || null;
      this.isLuxonInterval = true;
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new Interval({
          invalid
        });
      }
    }
    static fromDateTimes(start, end) {
      const builtStart = friendlyDateTime(start), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    static after(start, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start);
      return Interval.fromDateTimes(dt, dt.plus(dur));
    }
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return Interval.fromDateTimes(dt.minus(dur), dt);
    }
    static fromISO(text2, opts) {
      const [s3, e2] = (text2 || "").split("/", 2);
      if (s3 && e2) {
        let start, startIsValid;
        try {
          start = DateTime.fromISO(s3, opts);
          startIsValid = start.isValid;
        } catch (e3) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e2, opts);
          endIsValid = end.isValid;
        } catch (e3) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return Interval.fromDateTimes(start, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e2, opts);
          if (dur.isValid) {
            return Interval.after(start, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s3, opts);
          if (dur.isValid) {
            return Interval.before(end, dur);
          }
        }
      }
      return Interval.invalid("unparsable", `the input "${text2}" can't be parsed as ISO 8601`);
    }
    static isInterval(o2) {
      return o2 && o2.isLuxonInterval || false;
    }
    get start() {
      return this.isValid ? this.s : null;
    }
    get end() {
      return this.isValid ? this.e : null;
    }
    get isValid() {
      return this.invalidReason === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    count(unit = "milliseconds", opts) {
      if (!this.isValid)
        return NaN;
      const start = this.start.startOf(unit, opts);
      let end;
      if (opts != null && opts.useLocaleWeeks) {
        end = this.end.reconfigure({
          locale: start.locale
        });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    isAfter(dateTime) {
      if (!this.isValid)
        return false;
      return this.s > dateTime;
    }
    isBefore(dateTime) {
      if (!this.isValid)
        return false;
      return this.e <= dateTime;
    }
    contains(dateTime) {
      if (!this.isValid)
        return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    set({
      start,
      end
    } = {}) {
      if (!this.isValid)
        return this;
      return Interval.fromDateTimes(start || this.s, end || this.e);
    }
    splitAt(...dateTimes) {
      if (!this.isValid)
        return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort((a2, b3) => a2.toMillis() - b3.toMillis()), results = [];
      let {
        s: s3
      } = this, i = 0;
      while (s3 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s3, next));
        s3 = next;
        i += 1;
      }
      return results;
    }
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let {
        s: s3
      } = this, idx = 1, next;
      const results = [];
      while (s3 < this.e) {
        const added = this.start.plus(dur.mapUnits((x) => x * idx));
        next = +added > +this.e ? this.e : added;
        results.push(Interval.fromDateTimes(s3, next));
        s3 = next;
        idx += 1;
      }
      return results;
    }
    divideEqually(numberOfParts) {
      if (!this.isValid)
        return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    abutsStart(other) {
      if (!this.isValid)
        return false;
      return +this.e === +other.s;
    }
    abutsEnd(other) {
      if (!this.isValid)
        return false;
      return +other.e === +this.s;
    }
    engulfs(other) {
      if (!this.isValid)
        return false;
      return this.s <= other.s && this.e >= other.e;
    }
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    intersection(other) {
      if (!this.isValid)
        return this;
      const s3 = this.s > other.s ? this.s : other.s, e2 = this.e < other.e ? this.e : other.e;
      if (s3 >= e2) {
        return null;
      } else {
        return Interval.fromDateTimes(s3, e2);
      }
    }
    union(other) {
      if (!this.isValid)
        return this;
      const s3 = this.s < other.s ? this.s : other.s, e2 = this.e > other.e ? this.e : other.e;
      return Interval.fromDateTimes(s3, e2);
    }
    static merge(intervals) {
      const [found, final] = intervals.sort((a2, b3) => a2.s - b3.s).reduce(([sofar, current], item) => {
        if (!current) {
          return [sofar, item];
        } else if (current.overlaps(item) || current.abutsStart(item)) {
          return [sofar, current.union(item)];
        } else {
          return [sofar.concat([current]), item];
        }
      }, [[], null]);
      if (final) {
        found.push(final);
      }
      return found;
    }
    static xor(intervals) {
      let start = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [{
        time: i.s,
        type: "s"
      }, {
        time: i.e,
        type: "e"
      }]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a2, b3) => a2.time - b3.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start = i.time;
        } else {
          if (start && +start !== +i.time) {
            results.push(Interval.fromDateTimes(start, i.time));
          }
          start = null;
        }
      }
      return Interval.merge(results);
    }
    difference(...intervals) {
      return Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    toString() {
      if (!this.isValid)
        return INVALID$1;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID$1;
    }
    toISO(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    toISODate() {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    toISOTime(opts) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    toFormat(dateFormat, {
      separator = " \u2013 "
    } = {}) {
      if (!this.isValid)
        return INVALID$1;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    mapEndpoints(mapFn) {
      return Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  }

  class Info {
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({
        month: 12
      });
      return !zone.isUniversal && proto.offset !== proto.set({
        month: 6
      }).offset;
    }
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    static getStartOfWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getStartOfWeek();
    }
    static getMinimumDaysInFirstWeek({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getMinDaysInFirstWeek();
    }
    static getWeekendWeekdays({
      locale = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale)).getWeekendDays().slice();
    }
    static months(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length);
    }
    static monthsFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null,
      outputCalendar = "gregory"
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, outputCalendar)).months(length, true);
    }
    static weekdays(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length);
    }
    static weekdaysFormat(length = "long", {
      locale = null,
      numberingSystem = null,
      locObj = null
    } = {}) {
      return (locObj || Locale.create(locale, numberingSystem, null)).weekdays(length, true);
    }
    static meridiems({
      locale = null
    } = {}) {
      return Locale.create(locale).meridiems();
    }
    static eras(length = "short", {
      locale = null
    } = {}) {
      return Locale.create(locale, null, "gregory").eras(length);
    }
    static features() {
      return {
        relative: hasRelative(),
        localeWeek: hasLocaleWeekInfo()
      };
    }
  }
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  var dummyDateTimeCache = null;
  var INVALID2 = "Invalid DateTime";
  var MAX_DATE = 8640000000000000;
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];

  class DateTime {
    constructor(config) {
      const zone = config.zone || Settings.defaultZone;
      let invalid = config.invalid || (Number.isNaN(config.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config.ts) ? Settings.now() : config.ts;
      let c2 = null, o2 = null;
      if (!invalid) {
        const unchanged = config.old && config.old.ts === this.ts && config.old.zone.equals(zone);
        if (unchanged) {
          [c2, o2] = [config.old.c, config.old.o];
        } else {
          const ot = zone.offset(this.ts);
          c2 = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c2.year) ? new Invalid("invalid input") : null;
          c2 = invalid ? null : c2;
          o2 = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c2;
      this.o = o2;
      this.isLuxonDateTime = true;
    }
    static now() {
      return new DateTime({});
    }
    static local() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static utc() {
      const [opts, args] = lastOpts(arguments), [year, month, day, hour, minute, second, millisecond] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({
        year,
        month,
        day,
        hour,
        minute,
        second,
        millisecond
      }, opts);
    }
    static fromJSDate(date5, options = {}) {
      const ts = isDate(date5) ? date5.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`);
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return DateTime.invalid("Timestamp out of range");
      } else {
        return new DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new DateTime({
          ts: seconds * 1000,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u2 of units) {
        const v2 = normalized[u2];
        if (!isUndefined(v2)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u2] = defaultValues[u2];
        } else {
          normalized[u2] = objNow[u2];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`);
      }
      return inst;
    }
    static fromISO(text2, opts = {}) {
      const [vals, parsedZone] = parseISODate(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text2);
    }
    static fromRFC2822(text2, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text2);
    }
    static fromHTTP(text2, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    static fromFormat(text2, fmt, opts = {}) {
      if (isUndefined(text2) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const {
        locale = null,
        numberingSystem = null
      } = opts, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text2, fmt);
      if (invalid) {
        return DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text2, specificOffset);
      }
    }
    static fromString(text2, fmt, opts = {}) {
      return DateTime.fromFormat(text2, fmt, opts);
    }
    static fromSQL(text2, opts = {}) {
      const [vals, parsedZone] = parseSQL(text2);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text2);
    }
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new DateTime({
          invalid
        });
      }
    }
    static isDateTime(o2) {
      return o2 && o2.isLuxonDateTime || false;
    }
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
    }
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }
    get(unit) {
      return this[unit];
    }
    get isValid() {
      return this.invalid === null;
    }
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    get zone() {
      return this._zone;
    }
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    get monthShort() {
      return this.isValid ? Info.months("short", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get monthLong() {
      return this.isValid ? Info.months("long", {
        locObj: this.loc
      })[this.month - 1] : null;
    }
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", {
        locObj: this.loc
      })[this.weekday - 1] : null;
    }
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({
          month: 1,
          day: 1
        }).offset || this.offset > this.set({
          month: 5
        }).offset;
      }
    }
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 86400000;
      const minuteMs = 60000;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o12 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o12 === o2) {
        return [this];
      }
      const ts1 = localTS - o12 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c1 = tsToObj(ts1, o12);
      const c2 = tsToObj(ts2, o2);
      if (c1.hour === c2.hour && c1.minute === c2.minute && c1.second === c2.second && c1.millisecond === c2.millisecond) {
        return [clone13(this, {
          ts: ts1
        }), clone13(this, {
          ts: ts2
        })];
      }
      return [this];
    }
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
    }
    resolvedLocaleOptions(opts = {}) {
      const {
        locale,
        numberingSystem,
        calendar
      } = Formatter.create(this.loc.clone(opts), opts).resolvedOptions(this);
      return {
        locale,
        numberingSystem,
        outputCalendar: calendar
      };
    }
    toUTC(offset2 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset2), opts);
    }
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    setZone(zone, {
      keepLocalTime = false,
      keepCalendarTime = false
    } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone13(this, {
          ts: newTS,
          zone
        });
      }
    }
    reconfigure({
      locale,
      numberingSystem,
      outputCalendar
    } = {}) {
      const loc = this.loc.clone({
        locale,
        numberingSystem,
        outputCalendar
      });
      return clone13(this, {
        loc
      });
    }
    setLocale(locale) {
      return this.reconfigure({
        locale
      });
    }
    set(values2) {
      if (!this.isValid)
        return this;
      const normalized = normalizeObject(values2, normalizeUnitWithLocalWeeks);
      const {
        minDaysInFirstWeek,
        startOfWeek
      } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian({
          ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek),
          ...normalized
        }, minDaysInFirstWeek, startOfWeek);
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({
          ...gregorianToOrdinal(this.c),
          ...normalized
        });
      } else {
        mixed = {
          ...this.toObject(),
          ...normalized
        };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o2] = objToTS(mixed, this.o, this.zone);
      return clone13(this, {
        ts,
        o: o2
      });
    }
    plus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration);
      return clone13(this, adjustTime(this, dur));
    }
    minus(duration) {
      if (!this.isValid)
        return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone13(this, adjustTime(this, dur));
    }
    startOf(unit, {
      useLocaleWeeks = false
    } = {}) {
      if (!this.isValid)
        return this;
      const o2 = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o2.month = 1;
        case "quarters":
        case "months":
          o2.day = 1;
        case "weeks":
        case "days":
          o2.hour = 0;
        case "hours":
          o2.minute = 0;
        case "minutes":
          o2.second = 0;
        case "seconds":
          o2.millisecond = 0;
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const {
            weekday
          } = this;
          if (weekday < startOfWeek) {
            o2.weekNumber = this.weekNumber - 1;
          }
          o2.weekday = startOfWeek;
        } else {
          o2.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q2 = Math.ceil(this.month / 3);
        o2.month = (q2 - 1) * 3 + 1;
      }
      return this.set(o2);
    }
    endOf(unit, opts) {
      return this.isValid ? this.plus({
        [unit]: 1
      }).startOf(unit, opts).minus(1) : this;
    }
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID2;
    }
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID2;
    }
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    toISO({
      format = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format === "extended";
      let c2 = toISODate(this, ext);
      c2 += "T";
      c2 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c2;
    }
    toISODate({
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format === "extended");
    }
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c2 = includePrefix ? "T" : "";
      return c2 + toISOTime(this, format === "extended", suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
    }
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    toSQLTime({
      includeOffset = true,
      includeZone = false,
      includeOffsetSpace = true
    } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    toString() {
      return this.isValid ? this.toISO() : INVALID2;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    valueOf() {
      return this.toMillis();
    }
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    toSeconds() {
      return this.isValid ? this.ts / 1000 : NaN;
    }
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1000) : NaN;
    }
    toJSON() {
      return this.toISO();
    }
    toBSON() {
      return this.toJSDate();
    }
    toObject(opts = {}) {
      if (!this.isValid)
        return {};
      const base = {
        ...this.c
      };
      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = {
        locale: this.locale,
        numberingSystem: this.numberingSystem,
        ...opts
      };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(DateTime.now(), unit, opts);
    }
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid)
        return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, {
        keepLocalTime: true
      });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    toRelative(options = {}) {
      if (!this.isValid)
        return null;
      const base = options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = undefined;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    toRelativeCalendar(options = {}) {
      if (!this.isValid)
        return null;
      return diffRelative(options.base || DateTime.fromObject({}, {
        zone: this.zone
      }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    static min(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    static max(...dateTimes) {
      if (!dateTimes.every(DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    static fromFormatExplain(text2, fmt, options = {}) {
      const {
        locale = null,
        numberingSystem = null
      } = options, localeToUse = Locale.fromOpts({
        locale,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text2, fmt);
    }
    static fromStringExplain(text2, fmt, options = {}) {
      return DateTime.fromFormatExplain(text2, fmt, options);
    }
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    static get DATE_MED() {
      return DATE_MED;
    }
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    static get DATE_FULL() {
      return DATE_FULL;
    }
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  }
  var VERSION = "3.4.4";
  exports.DateTime = DateTime;
  exports.Duration = Duration;
  exports.FixedOffsetZone = FixedOffsetZone;
  exports.IANAZone = IANAZone;
  exports.Info = Info;
  exports.Interval = Interval;
  exports.InvalidZone = InvalidZone;
  exports.Settings = Settings;
  exports.SystemZone = SystemZone;
  exports.VERSION = VERSION;
  exports.Zone = Zone;
});

// node_modules/cron-parser/lib/date.js
var require_date = __commonJS((exports, module) => {
  var CronDate = function(timestamp2, tz) {
    var dateOpts = { zone: tz };
    if (!timestamp2) {
      this._date = luxon.DateTime.local();
    } else if (timestamp2 instanceof CronDate) {
      this._date = timestamp2._date;
    } else if (timestamp2 instanceof Date) {
      this._date = luxon.DateTime.fromJSDate(timestamp2, dateOpts);
    } else if (typeof timestamp2 === "number") {
      this._date = luxon.DateTime.fromMillis(timestamp2, dateOpts);
    } else if (typeof timestamp2 === "string") {
      this._date = luxon.DateTime.fromISO(timestamp2, dateOpts);
      this._date.isValid || (this._date = luxon.DateTime.fromRFC2822(timestamp2, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromSQL(timestamp2, dateOpts));
      this._date.isValid || (this._date = luxon.DateTime.fromFormat(timestamp2, "EEE, d MMM yyyy HH:mm:ss", dateOpts));
    }
    if (!this._date || !this._date.isValid) {
      throw new Error("CronDate: unhandled timestamp: " + JSON.stringify(timestamp2));
    }
    if (tz && tz !== this._date.zoneName) {
      this._date = this._date.setZone(tz);
    }
  };
  var luxon = require_luxon();
  CronDate.prototype.addYear = function() {
    this._date = this._date.plus({ years: 1 });
  };
  CronDate.prototype.addMonth = function() {
    this._date = this._date.plus({ months: 1 }).startOf("month");
  };
  CronDate.prototype.addDay = function() {
    this._date = this._date.plus({ days: 1 }).startOf("day");
  };
  CronDate.prototype.addHour = function() {
    var prev = this._date;
    this._date = this._date.plus({ hours: 1 }).startOf("hour");
    if (this._date <= prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addMinute = function() {
    var prev = this._date;
    this._date = this._date.plus({ minutes: 1 }).startOf("minute");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.addSecond = function() {
    var prev = this._date;
    this._date = this._date.plus({ seconds: 1 }).startOf("second");
    if (this._date < prev) {
      this._date = this._date.plus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractYear = function() {
    this._date = this._date.minus({ years: 1 });
  };
  CronDate.prototype.subtractMonth = function() {
    this._date = this._date.minus({ months: 1 }).endOf("month").startOf("second");
  };
  CronDate.prototype.subtractDay = function() {
    this._date = this._date.minus({ days: 1 }).endOf("day").startOf("second");
  };
  CronDate.prototype.subtractHour = function() {
    var prev = this._date;
    this._date = this._date.minus({ hours: 1 }).endOf("hour").startOf("second");
    if (this._date >= prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractMinute = function() {
    var prev = this._date;
    this._date = this._date.minus({ minutes: 1 }).endOf("minute").startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.subtractSecond = function() {
    var prev = this._date;
    this._date = this._date.minus({ seconds: 1 }).startOf("second");
    if (this._date > prev) {
      this._date = this._date.minus({ hours: 1 });
    }
  };
  CronDate.prototype.getDate = function() {
    return this._date.day;
  };
  CronDate.prototype.getFullYear = function() {
    return this._date.year;
  };
  CronDate.prototype.getDay = function() {
    var weekday = this._date.weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getMonth = function() {
    return this._date.month - 1;
  };
  CronDate.prototype.getHours = function() {
    return this._date.hour;
  };
  CronDate.prototype.getMinutes = function() {
    return this._date.minute;
  };
  CronDate.prototype.getSeconds = function() {
    return this._date.second;
  };
  CronDate.prototype.getMilliseconds = function() {
    return this._date.millisecond;
  };
  CronDate.prototype.getTime = function() {
    return this._date.valueOf();
  };
  CronDate.prototype.getUTCDate = function() {
    return this._getUTC().day;
  };
  CronDate.prototype.getUTCFullYear = function() {
    return this._getUTC().year;
  };
  CronDate.prototype.getUTCDay = function() {
    var weekday = this._getUTC().weekday;
    return weekday == 7 ? 0 : weekday;
  };
  CronDate.prototype.getUTCMonth = function() {
    return this._getUTC().month - 1;
  };
  CronDate.prototype.getUTCHours = function() {
    return this._getUTC().hour;
  };
  CronDate.prototype.getUTCMinutes = function() {
    return this._getUTC().minute;
  };
  CronDate.prototype.getUTCSeconds = function() {
    return this._getUTC().second;
  };
  CronDate.prototype.toISOString = function() {
    return this._date.toUTC().toISO();
  };
  CronDate.prototype.toJSON = function() {
    return this._date.toJSON();
  };
  CronDate.prototype.setDate = function(d2) {
    this._date = this._date.set({ day: d2 });
  };
  CronDate.prototype.setFullYear = function(y2) {
    this._date = this._date.set({ year: y2 });
  };
  CronDate.prototype.setDay = function(d2) {
    this._date = this._date.set({ weekday: d2 });
  };
  CronDate.prototype.setMonth = function(m2) {
    this._date = this._date.set({ month: m2 + 1 });
  };
  CronDate.prototype.setHours = function(h2) {
    this._date = this._date.set({ hour: h2 });
  };
  CronDate.prototype.setMinutes = function(m2) {
    this._date = this._date.set({ minute: m2 });
  };
  CronDate.prototype.setSeconds = function(s2) {
    this._date = this._date.set({ second: s2 });
  };
  CronDate.prototype.setMilliseconds = function(s2) {
    this._date = this._date.set({ millisecond: s2 });
  };
  CronDate.prototype._getUTC = function() {
    return this._date.toUTC();
  };
  CronDate.prototype.toString = function() {
    return this.toDate().toString();
  };
  CronDate.prototype.toDate = function() {
    return this._date.toJSDate();
  };
  CronDate.prototype.isLastDayOfMonth = function() {
    var newDate = this._date.plus({ days: 1 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  CronDate.prototype.isLastWeekdayOfMonth = function() {
    var newDate = this._date.plus({ days: 7 }).startOf("day");
    return this._date.month !== newDate.month;
  };
  module.exports = CronDate;
});

// node_modules/cron-parser/lib/field_compactor.js
var require_field_compactor = __commonJS((exports, module) => {
  var buildRange = function(item) {
    return {
      start: item,
      count: 1
    };
  };
  var completeRangeWithItem = function(range, item) {
    range.end = item;
    range.step = item - range.start;
    range.count = 2;
  };
  var finalizeCurrentRange = function(results, currentRange, currentItemRange) {
    if (currentRange) {
      if (currentRange.count === 2) {
        results.push(buildRange(currentRange.start));
        results.push(buildRange(currentRange.end));
      } else {
        results.push(currentRange);
      }
    }
    if (currentItemRange) {
      results.push(currentItemRange);
    }
  };
  var compactField = function(arr) {
    var results = [];
    var currentRange = undefined;
    for (var i = 0;i < arr.length; i++) {
      var currentItem = arr[i];
      if (typeof currentItem !== "number") {
        finalizeCurrentRange(results, currentRange, buildRange(currentItem));
        currentRange = undefined;
      } else if (!currentRange) {
        currentRange = buildRange(currentItem);
      } else if (currentRange.count === 1) {
        completeRangeWithItem(currentRange, currentItem);
      } else {
        if (currentRange.step === currentItem - currentRange.end) {
          currentRange.count++;
          currentRange.end = currentItem;
        } else if (currentRange.count === 2) {
          results.push(buildRange(currentRange.start));
          currentRange = buildRange(currentRange.end);
          completeRangeWithItem(currentRange, currentItem);
        } else {
          finalizeCurrentRange(results, currentRange);
          currentRange = buildRange(currentItem);
        }
      }
    }
    finalizeCurrentRange(results, currentRange);
    return results;
  };
  module.exports = compactField;
});

// node_modules/cron-parser/lib/field_stringify.js
var require_field_stringify = __commonJS((exports, module) => {
  var stringifyField = function(arr, min, max) {
    var ranges = compactField(arr);
    if (ranges.length === 1) {
      var singleRange = ranges[0];
      var step = singleRange.step;
      if (step === 1 && singleRange.start === min && singleRange.end === max) {
        return "*";
      }
      if (step !== 1 && singleRange.start === min && singleRange.end === max - step + 1) {
        return "*/" + step;
      }
    }
    var result2 = [];
    for (var i = 0, l2 = ranges.length;i < l2; ++i) {
      var range = ranges[i];
      if (range.count === 1) {
        result2.push(range.start);
        continue;
      }
      var step = range.step;
      if (range.step === 1) {
        result2.push(range.start + "-" + range.end);
        continue;
      }
      var multiplier = range.start == 0 ? range.count - 1 : range.count;
      if (range.step * multiplier > range.end) {
        result2 = result2.concat(Array.from({ length: range.end - range.start + 1 }).map(function(_, index) {
          var value15 = range.start + index;
          if ((value15 - range.start) % range.step === 0) {
            return value15;
          }
          return null;
        }).filter(function(value15) {
          return value15 != null;
        }));
      } else if (range.end === max - range.step + 1) {
        result2.push(range.start + "/" + range.step);
      } else {
        result2.push(range.start + "-" + range.end + "/" + range.step);
      }
    }
    return result2.join(",");
  };
  var compactField = require_field_compactor();
  module.exports = stringifyField;
});

// node_modules/cron-parser/lib/expression.js
var require_expression = __commonJS((exports, module) => {
  var CronExpression = function(fields, options) {
    this._options = options;
    this._utc = options.utc || false;
    this._tz = this._utc ? "UTC" : options.tz;
    this._currentDate = new CronDate(options.currentDate, this._tz);
    this._startDate = options.startDate ? new CronDate(options.startDate, this._tz) : null;
    this._endDate = options.endDate ? new CronDate(options.endDate, this._tz) : null;
    this._isIterator = options.iterator || false;
    this._hasIterated = false;
    this._nthDayOfWeek = options.nthDayOfWeek || 0;
    this.fields = CronExpression._freezeFields(fields);
  };
  var CronDate = require_date();
  var stringifyField = require_field_stringify();
  var LOOP_LIMIT = 1e4;
  CronExpression.map = ["second", "minute", "hour", "dayOfMonth", "month", "dayOfWeek"];
  CronExpression.predefined = {
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  CronExpression.constraints = [
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 59, chars: [] },
    { min: 0, max: 23, chars: [] },
    { min: 1, max: 31, chars: ["L"] },
    { min: 1, max: 12, chars: [] },
    { min: 0, max: 7, chars: ["L"] }
  ];
  CronExpression.daysInMonth = [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ];
  CronExpression.aliases = {
    month: {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12
    },
    dayOfWeek: {
      sun: 0,
      mon: 1,
      tue: 2,
      wed: 3,
      thu: 4,
      fri: 5,
      sat: 6
    }
  };
  CronExpression.parseDefaults = ["0", "*", "*", "*", "*", "*"];
  CronExpression.standardValidCharacters = /^[,*\d/-]+$/;
  CronExpression.dayOfWeekValidCharacters = /^[?,*\dL#/-]+$/;
  CronExpression.dayOfMonthValidCharacters = /^[?,*\dL/-]+$/;
  CronExpression.validCharacters = {
    second: CronExpression.standardValidCharacters,
    minute: CronExpression.standardValidCharacters,
    hour: CronExpression.standardValidCharacters,
    dayOfMonth: CronExpression.dayOfMonthValidCharacters,
    month: CronExpression.standardValidCharacters,
    dayOfWeek: CronExpression.dayOfWeekValidCharacters
  };
  CronExpression._isValidConstraintChar = function _isValidConstraintChar(constraints, value15) {
    if (typeof value15 !== "string") {
      return false;
    }
    return constraints.chars.some(function(char) {
      return value15.indexOf(char) > -1;
    });
  };
  CronExpression._parseField = function _parseField(field, value15, constraints) {
    switch (field) {
      case "month":
      case "dayOfWeek":
        var aliases = CronExpression.aliases[field];
        value15 = value15.replace(/[a-z]{3}/gi, function(match) {
          match = match.toLowerCase();
          if (typeof aliases[match] !== "undefined") {
            return aliases[match];
          } else {
            throw new Error('Validation error, cannot resolve alias "' + match + '"');
          }
        });
        break;
    }
    if (!CronExpression.validCharacters[field].test(value15)) {
      throw new Error("Invalid characters, got value: " + value15);
    }
    if (value15.indexOf("*") !== -1) {
      value15 = value15.replace(/\*/g, constraints.min + "-" + constraints.max);
    } else if (value15.indexOf("?") !== -1) {
      value15 = value15.replace(/\?/g, constraints.min + "-" + constraints.max);
    }
    function parseSequence(val) {
      var stack = [];
      function handleResult2(result2) {
        if (result2 instanceof Array) {
          for (var i2 = 0, c3 = result2.length;i2 < c3; i2++) {
            var value16 = result2[i2];
            if (CronExpression._isValidConstraintChar(constraints, value16)) {
              stack.push(value16);
              continue;
            }
            if (typeof value16 !== "number" || Number.isNaN(value16) || value16 < constraints.min || value16 > constraints.max) {
              throw new Error("Constraint error, got value " + value16 + " expected range " + constraints.min + "-" + constraints.max);
            }
            stack.push(value16);
          }
        } else {
          if (CronExpression._isValidConstraintChar(constraints, result2)) {
            stack.push(result2);
            return;
          }
          var numResult = +result2;
          if (Number.isNaN(numResult) || numResult < constraints.min || numResult > constraints.max) {
            throw new Error("Constraint error, got value " + result2 + " expected range " + constraints.min + "-" + constraints.max);
          }
          if (field === "dayOfWeek") {
            numResult = numResult % 7;
          }
          stack.push(numResult);
        }
      }
      var atoms = val.split(",");
      if (!atoms.every(function(atom) {
        return atom.length > 0;
      })) {
        throw new Error("Invalid list value format");
      }
      if (atoms.length > 1) {
        for (var i = 0, c2 = atoms.length;i < c2; i++) {
          handleResult2(parseRepeat(atoms[i]));
        }
      } else {
        handleResult2(parseRepeat(val));
      }
      stack.sort(CronExpression._sortCompareFn);
      return stack;
    }
    function parseRepeat(val) {
      var repeatInterval = 1;
      var atoms = val.split("/");
      if (atoms.length > 2) {
        throw new Error("Invalid repeat: " + val);
      }
      if (atoms.length > 1) {
        if (atoms[0] == +atoms[0]) {
          atoms = [atoms[0] + "-" + constraints.max, atoms[1]];
        }
        return parseRange(atoms[0], atoms[atoms.length - 1]);
      }
      return parseRange(val, repeatInterval);
    }
    function parseRange(val, repeatInterval) {
      var stack = [];
      var atoms = val.split("-");
      if (atoms.length > 1) {
        if (atoms.length < 2) {
          return +val;
        }
        if (!atoms[0].length) {
          if (!atoms[1].length) {
            throw new Error("Invalid range: " + val);
          }
          return +val;
        }
        var min = +atoms[0];
        var max = +atoms[1];
        if (Number.isNaN(min) || Number.isNaN(max) || min < constraints.min || max > constraints.max) {
          throw new Error("Constraint error, got range " + min + "-" + max + " expected range " + constraints.min + "-" + constraints.max);
        } else if (min > max) {
          throw new Error("Invalid range: " + val);
        }
        var repeatIndex = +repeatInterval;
        if (Number.isNaN(repeatIndex) || repeatIndex <= 0) {
          throw new Error("Constraint error, cannot repeat at every " + repeatIndex + " time.");
        }
        if (field === "dayOfWeek" && max % 7 === 0) {
          stack.push(0);
        }
        for (var index = min, count = max;index <= count; index++) {
          var exists2 = stack.indexOf(index) !== -1;
          if (!exists2 && repeatIndex > 0 && repeatIndex % repeatInterval === 0) {
            repeatIndex = 1;
            stack.push(index);
          } else {
            repeatIndex++;
          }
        }
        return stack;
      }
      return Number.isNaN(+val) ? val : +val;
    }
    return parseSequence(value15);
  };
  CronExpression._sortCompareFn = function(a2, b3) {
    var aIsNumber = typeof a2 === "number";
    var bIsNumber = typeof b3 === "number";
    if (aIsNumber && bIsNumber) {
      return a2 - b3;
    }
    if (!aIsNumber && bIsNumber) {
      return 1;
    }
    if (aIsNumber && !bIsNumber) {
      return -1;
    }
    return a2.localeCompare(b3);
  };
  CronExpression._handleMaxDaysInMonth = function(mappedFields) {
    if (mappedFields.month.length === 1) {
      var daysInMonth = CronExpression.daysInMonth[mappedFields.month[0] - 1];
      if (mappedFields.dayOfMonth[0] > daysInMonth) {
        throw new Error("Invalid explicit day of month definition");
      }
      return mappedFields.dayOfMonth.filter(function(dayOfMonth) {
        return dayOfMonth === "L" ? true : dayOfMonth <= daysInMonth;
      }).sort(CronExpression._sortCompareFn);
    }
  };
  CronExpression._freezeFields = function(fields) {
    for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
      var field = CronExpression.map[i];
      var value15 = fields[field];
      fields[field] = Object.freeze(value15);
    }
    return Object.freeze(fields);
  };
  CronExpression.prototype._applyTimezoneShift = function(currentDate, dateMathVerb, method) {
    if (method === "Month" || method === "Day") {
      var prevTime = currentDate.getTime();
      currentDate[dateMathVerb + method]();
      var currTime = currentDate.getTime();
      if (prevTime === currTime) {
        if (currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
          currentDate.addHour();
        } else if (currentDate.getMinutes() === 59 && currentDate.getSeconds() === 59) {
          currentDate.subtractHour();
        }
      }
    } else {
      var previousHour = currentDate.getHours();
      currentDate[dateMathVerb + method]();
      var currentHour = currentDate.getHours();
      var diff = currentHour - previousHour;
      if (diff === 2) {
        if (this.fields.hour.length !== 24) {
          this._dstStart = currentHour;
        }
      } else if (diff === 0 && currentDate.getMinutes() === 0 && currentDate.getSeconds() === 0) {
        if (this.fields.hour.length !== 24) {
          this._dstEnd = currentHour;
        }
      }
    }
  };
  CronExpression.prototype._findSchedule = function _findSchedule(reverse) {
    function matchSchedule(value15, sequence) {
      for (var i = 0, c2 = sequence.length;i < c2; i++) {
        if (sequence[i] >= value15) {
          return sequence[i] === value15;
        }
      }
      return sequence[0] === value15;
    }
    function isNthDayMatch(date5, nthDayOfWeek) {
      if (nthDayOfWeek < 6) {
        if (date5.getDate() < 8 && nthDayOfWeek === 1) {
          return true;
        }
        var offset = date5.getDate() % 7 ? 1 : 0;
        var adjustedDate = date5.getDate() - date5.getDate() % 7;
        var occurrence = Math.floor(adjustedDate / 7) + offset;
        return occurrence === nthDayOfWeek;
      }
      return false;
    }
    function isLInExpressions(expressions2) {
      return expressions2.length > 0 && expressions2.some(function(expression) {
        return typeof expression === "string" && expression.indexOf("L") >= 0;
      });
    }
    reverse = reverse || false;
    var dateMathVerb = reverse ? "subtract" : "add";
    var currentDate = new CronDate(this._currentDate, this._tz);
    var startDate = this._startDate;
    var endDate = this._endDate;
    var startTimestamp = currentDate.getTime();
    var stepCount = 0;
    function isLastWeekdayOfMonthMatch(expressions2) {
      return expressions2.some(function(expression) {
        if (!isLInExpressions([expression])) {
          return false;
        }
        var weekday = Number.parseInt(expression[0]) % 7;
        if (Number.isNaN(weekday)) {
          throw new Error("Invalid last weekday of the month expression: " + expression);
        }
        return currentDate.getDay() === weekday && currentDate.isLastWeekdayOfMonth();
      });
    }
    while (stepCount < LOOP_LIMIT) {
      stepCount++;
      if (reverse) {
        if (startDate && currentDate.getTime() - startDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      } else {
        if (endDate && endDate.getTime() - currentDate.getTime() < 0) {
          throw new Error("Out of the timespan range");
        }
      }
      var dayOfMonthMatch = matchSchedule(currentDate.getDate(), this.fields.dayOfMonth);
      if (isLInExpressions(this.fields.dayOfMonth)) {
        dayOfMonthMatch = dayOfMonthMatch || currentDate.isLastDayOfMonth();
      }
      var dayOfWeekMatch = matchSchedule(currentDate.getDay(), this.fields.dayOfWeek);
      if (isLInExpressions(this.fields.dayOfWeek)) {
        dayOfWeekMatch = dayOfWeekMatch || isLastWeekdayOfMonthMatch(this.fields.dayOfWeek);
      }
      var isDayOfMonthWildcardMatch = this.fields.dayOfMonth.length >= CronExpression.daysInMonth[currentDate.getMonth()];
      var isDayOfWeekWildcardMatch = this.fields.dayOfWeek.length === CronExpression.constraints[5].max - CronExpression.constraints[5].min + 1;
      var currentHour = currentDate.getHours();
      if (!dayOfMonthMatch && (!dayOfWeekMatch || isDayOfWeekWildcardMatch)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!isDayOfMonthWildcardMatch && isDayOfWeekWildcardMatch && !dayOfMonthMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (isDayOfMonthWildcardMatch && !isDayOfWeekWildcardMatch && !dayOfWeekMatch) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (this._nthDayOfWeek > 0 && !isNthDayMatch(currentDate, this._nthDayOfWeek)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Day");
        continue;
      }
      if (!matchSchedule(currentDate.getMonth() + 1, this.fields.month)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Month");
        continue;
      }
      if (!matchSchedule(currentHour, this.fields.hour)) {
        if (this._dstStart !== currentHour) {
          this._dstStart = null;
          this._applyTimezoneShift(currentDate, dateMathVerb, "Hour");
          continue;
        } else if (!matchSchedule(currentHour - 1, this.fields.hour)) {
          currentDate[dateMathVerb + "Hour"]();
          continue;
        }
      } else if (this._dstEnd === currentHour) {
        if (!reverse) {
          this._dstEnd = null;
          this._applyTimezoneShift(currentDate, "add", "Hour");
          continue;
        }
      }
      if (!matchSchedule(currentDate.getMinutes(), this.fields.minute)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Minute");
        continue;
      }
      if (!matchSchedule(currentDate.getSeconds(), this.fields.second)) {
        this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        continue;
      }
      if (startTimestamp === currentDate.getTime()) {
        if (dateMathVerb === "add" || currentDate.getMilliseconds() === 0) {
          this._applyTimezoneShift(currentDate, dateMathVerb, "Second");
        } else {
          currentDate.setMilliseconds(0);
        }
        continue;
      }
      break;
    }
    if (stepCount >= LOOP_LIMIT) {
      throw new Error("Invalid expression, loop limit exceeded");
    }
    this._currentDate = new CronDate(currentDate, this._tz);
    this._hasIterated = true;
    return currentDate;
  };
  CronExpression.prototype.next = function next() {
    var schedule = this._findSchedule();
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasNext()
      };
    }
    return schedule;
  };
  CronExpression.prototype.prev = function prev() {
    var schedule = this._findSchedule(true);
    if (this._isIterator) {
      return {
        value: schedule,
        done: !this.hasPrev()
      };
    }
    return schedule;
  };
  CronExpression.prototype.hasNext = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule();
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.hasPrev = function() {
    var current = this._currentDate;
    var hasIterated = this._hasIterated;
    try {
      this._findSchedule(true);
      return true;
    } catch (err) {
      return false;
    } finally {
      this._currentDate = current;
      this._hasIterated = hasIterated;
    }
  };
  CronExpression.prototype.iterate = function iterate(steps, callback) {
    var dates = [];
    if (steps >= 0) {
      for (var i = 0, c2 = steps;i < c2; i++) {
        try {
          var item = this.next();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    } else {
      for (var i = 0, c2 = steps;i > c2; i--) {
        try {
          var item = this.prev();
          dates.push(item);
          if (callback) {
            callback(item, i);
          }
        } catch (err) {
          break;
        }
      }
    }
    return dates;
  };
  CronExpression.prototype.reset = function reset(newDate) {
    this._currentDate = new CronDate(newDate || this._options.currentDate);
  };
  CronExpression.prototype.stringify = function stringify(includeSeconds) {
    var resultArr = [];
    for (var i = includeSeconds ? 0 : 1, c2 = CronExpression.map.length;i < c2; ++i) {
      var field = CronExpression.map[i];
      var value15 = this.fields[field];
      var constraint = CronExpression.constraints[i];
      if (field === "dayOfMonth" && this.fields.month.length === 1) {
        constraint = { min: 1, max: CronExpression.daysInMonth[this.fields.month[0] - 1] };
      } else if (field === "dayOfWeek") {
        constraint = { min: 0, max: 6 };
        value15 = value15[value15.length - 1] === 7 ? value15.slice(0, -1) : value15;
      }
      resultArr.push(stringifyField(value15, constraint.min, constraint.max));
    }
    return resultArr.join(" ");
  };
  CronExpression.parse = function parse(expression, options) {
    var self2 = this;
    if (typeof options === "function") {
      options = {};
    }
    function parse5(expression2, options2) {
      if (!options2) {
        options2 = {};
      }
      if (typeof options2.currentDate === "undefined") {
        options2.currentDate = new CronDate(undefined, self2._tz);
      }
      if (CronExpression.predefined[expression2]) {
        expression2 = CronExpression.predefined[expression2];
      }
      var fields = [];
      var atoms = (expression2 + "").trim().split(/\s+/);
      if (atoms.length > 6) {
        throw new Error("Invalid cron expression");
      }
      var start = CronExpression.map.length - atoms.length;
      for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
        var field = CronExpression.map[i];
        var value15 = atoms[atoms.length > c2 ? i : i - start];
        if (i < start || !value15) {
          fields.push(CronExpression._parseField(field, CronExpression.parseDefaults[i], CronExpression.constraints[i]));
        } else {
          var val = field === "dayOfWeek" ? parseNthDay(value15) : value15;
          fields.push(CronExpression._parseField(field, val, CronExpression.constraints[i]));
        }
      }
      var mappedFields = {};
      for (var i = 0, c2 = CronExpression.map.length;i < c2; i++) {
        var key = CronExpression.map[i];
        mappedFields[key] = fields[i];
      }
      var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
      mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
      return new CronExpression(mappedFields, options2);
      function parseNthDay(val2) {
        var atoms2 = val2.split("#");
        if (atoms2.length > 1) {
          var nthValue = +atoms2[atoms2.length - 1];
          if (/,/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `,` special characters are incompatible");
          }
          if (/\//.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `/` special characters are incompatible");
          }
          if (/-/.test(val2)) {
            throw new Error("Constraint error, invalid dayOfWeek `#` and `-` special characters are incompatible");
          }
          if (atoms2.length > 2 || Number.isNaN(nthValue) || (nthValue < 1 || nthValue > 5)) {
            throw new Error("Constraint error, invalid dayOfWeek occurrence number (#)");
          }
          options2.nthDayOfWeek = nthValue;
          return atoms2[0];
        }
        return val2;
      }
    }
    return parse5(expression, options);
  };
  CronExpression.fieldsToExpression = function fieldsToExpression(fields, options) {
    function validateConstraints(field2, values3, constraints) {
      if (!values3) {
        throw new Error("Validation error, Field " + field2 + " is missing");
      }
      if (values3.length === 0) {
        throw new Error("Validation error, Field " + field2 + " contains no values");
      }
      for (var i2 = 0, c3 = values3.length;i2 < c3; i2++) {
        var value15 = values3[i2];
        if (CronExpression._isValidConstraintChar(constraints, value15)) {
          continue;
        }
        if (typeof value15 !== "number" || Number.isNaN(value15) || value15 < constraints.min || value15 > constraints.max) {
          throw new Error("Constraint error, got value " + value15 + " expected range " + constraints.min + "-" + constraints.max);
        }
      }
    }
    var mappedFields = {};
    for (var i = 0, c2 = CronExpression.map.length;i < c2; ++i) {
      var field = CronExpression.map[i];
      var values2 = fields[field];
      validateConstraints(field, values2, CronExpression.constraints[i]);
      var copy = [];
      var j = -1;
      while (++j < values2.length) {
        copy[j] = values2[j];
      }
      values2 = copy.sort(CronExpression._sortCompareFn).filter(function(item, pos, ary) {
        return !pos || item !== ary[pos - 1];
      });
      if (values2.length !== copy.length) {
        throw new Error("Validation error, Field " + field + " contains duplicate values");
      }
      mappedFields[field] = values2;
    }
    var dayOfMonth = CronExpression._handleMaxDaysInMonth(mappedFields);
    mappedFields.dayOfMonth = dayOfMonth || mappedFields.dayOfMonth;
    return new CronExpression(mappedFields, options || {});
  };
  module.exports = CronExpression;
});

// node_modules/cron-parser/lib/parser.js
var require_parser2 = __commonJS((exports, module) => {
  var CronParser = function() {
  };
  var CronExpression = require_expression();
  CronParser._parseEntry = function _parseEntry(entry) {
    var atoms = entry.split(" ");
    if (atoms.length === 6) {
      return {
        interval: CronExpression.parse(entry)
      };
    } else if (atoms.length > 6) {
      return {
        interval: CronExpression.parse(atoms.slice(0, 6).join(" ")),
        command: atoms.slice(6, atoms.length)
      };
    } else {
      throw new Error("Invalid entry: " + entry);
    }
  };
  CronParser.parseExpression = function parseExpression(expression, options) {
    return CronExpression.parse(expression, options);
  };
  CronParser.fieldsToExpression = function fieldsToExpression(fields, options) {
    return CronExpression.fieldsToExpression(fields, options);
  };
  CronParser.parseString = function parseString(data) {
    var blocks = data.split("\n");
    var response = {
      variables: {},
      expressions: [],
      errors: {}
    };
    for (var i = 0, c2 = blocks.length;i < c2; i++) {
      var block = blocks[i];
      var matches = null;
      var entry = block.trim();
      if (entry.length > 0) {
        if (entry.match(/^#/)) {
          continue;
        } else if (matches = entry.match(/^(.*)=(.*)$/)) {
          response.variables[matches[1]] = matches[2];
        } else {
          var result2 = null;
          try {
            result2 = CronParser._parseEntry("0 " + entry);
            response.expressions.push(result2.interval);
          } catch (err) {
            response.errors[entry] = err;
          }
        }
      }
    }
    return response;
  };
  CronParser.parseFile = function parseFile(filePath, callback) {
    import.meta.require("fs").readFile(filePath, function(err, data) {
      if (err) {
        callback(err);
        return;
      }
      return callback(null, CronParser.parseString(data.toString()));
    });
  };
  module.exports = CronParser;
});

// node_modules/bull/lib/repeatable.js
var require_repeatable = __commonJS((exports, module) => {
  var _ = require_lodash4();
  var parser = require_parser2();
  var crypto3 = import.meta.require("crypto");
  var Job = require_job();
  module.exports = function(Queue2) {
    Queue2.prototype.nextRepeatableJob = function(name, data, opts, skipCheckExists) {
      const client = this.client;
      const repeat = opts.repeat;
      const prevMillis = opts.prevMillis || 0;
      if (!prevMillis && opts.jobId) {
        repeat.jobId = opts.jobId;
      }
      const currentCount = repeat.count ? repeat.count + 1 : 1;
      if (!_.isUndefined(repeat.limit) && currentCount > repeat.limit) {
        return Promise.resolve();
      }
      let now = Date.now();
      if (!_.isUndefined(repeat.endDate) && now > new Date(repeat.endDate)) {
        return Promise.resolve();
      }
      now = prevMillis < now ? now : prevMillis;
      const nextMillis = getNextMillis(now, repeat);
      if (nextMillis) {
        const jobId = repeat.jobId ? repeat.jobId + ":" : ":";
        const repeatKey = getRepeatKey(name, repeat, jobId);
        const createNextJob = () => {
          return client.zadd(this.keys.repeat, nextMillis, repeatKey).then(() => {
            const customId = getRepeatJobId(name, jobId, nextMillis, md52(repeatKey));
            now = Date.now();
            const delay = nextMillis - now;
            return Job.create(this, name, data, _.defaultsDeep({
              repeat: {
                count: currentCount,
                key: repeatKey
              },
              jobId: customId,
              delay: delay < 0 ? 0 : delay,
              timestamp: now,
              prevMillis: nextMillis
            }, opts));
          });
        };
        if (skipCheckExists) {
          return createNextJob();
        }
        return client.zscore(this.keys.repeat, repeatKey).then((repeatableExists) => {
          if (repeatableExists) {
            return createNextJob();
          }
          return Promise.resolve();
        });
      } else {
        return Promise.resolve();
      }
    };
    Queue2.prototype.removeRepeatable = function(name, repeat) {
      if (typeof name !== "string") {
        repeat = name;
        name = Job.DEFAULT_JOB_NAME;
      }
      return this.isReady().then(() => {
        const jobId = repeat.jobId ? repeat.jobId + ":" : ":";
        const repeatJobKey = getRepeatKey(name, repeat, jobId);
        const repeatJobId = getRepeatJobId(name, jobId, "", md52(repeatJobKey));
        const queueKey = this.keys[""];
        return this.client.removeRepeatable(this.keys.repeat, this.keys.delayed, repeatJobId, repeatJobKey, queueKey);
      });
    };
    Queue2.prototype.removeRepeatableByKey = function(repeatJobKey) {
      const repeatMeta = this._keyToData(repeatJobKey);
      const queueKey = this.keys[""];
      const jobId = repeatMeta.id ? repeatMeta.id + ":" : ":";
      const repeatJobId = getRepeatJobId(repeatMeta.name || Job.DEFAULT_JOB_NAME, jobId, "", md52(repeatJobKey));
      return this.isReady().then(() => {
        return this.client.removeRepeatable(this.keys.repeat, this.keys.delayed, repeatJobId, repeatJobKey, queueKey);
      });
    };
    Queue2.prototype._keyToData = function(key) {
      const data = key.split(":");
      return {
        key,
        name: data[0],
        id: data[1] || null,
        endDate: parseInt(data[2]) || null,
        tz: data[3] || null,
        cron: data[4]
      };
    };
    Queue2.prototype.getRepeatableJobs = function(start, end, asc2) {
      const key = this.keys.repeat;
      start = start || 0;
      end = end || -1;
      return (asc2 ? this.client.zrange(key, start, end, "WITHSCORES") : this.client.zrevrange(key, start, end, "WITHSCORES")).then((result2) => {
        const jobs = [];
        for (let i = 0;i < result2.length; i += 2) {
          const data = this._keyToData(result2[i]);
          jobs.push({
            key: data.key,
            name: data.name,
            id: data.id,
            endDate: data.endDate,
            tz: data.cron ? data.tz : null,
            cron: data.cron || null,
            every: !data.cron ? parseInt(data.tz) : null,
            next: parseInt(result2[i + 1])
          });
        }
        return jobs;
      });
    };
    Queue2.prototype.getRepeatableCount = function() {
      return this.client.zcard(this.toKey("repeat"));
    };
    function getRepeatJobId(name, jobId, nextMillis, namespace) {
      return "repeat:" + md52(name + jobId + namespace) + ":" + nextMillis;
    }
    function getRepeatKey(name, repeat, jobId) {
      const endDate = repeat.endDate ? new Date(repeat.endDate).getTime() + ":" : ":";
      const tz = repeat.tz ? repeat.tz + ":" : ":";
      const suffix = repeat.cron ? tz + repeat.cron : String(repeat.every);
      return name + ":" + jobId + endDate + suffix;
    }
    function getNextMillis(millis, opts) {
      if (opts.cron && opts.every) {
        throw new Error("Both .cron and .every options are defined for this repeatable job");
      }
      if (opts.every) {
        return Math.floor(millis / opts.every) * opts.every + opts.every;
      }
      const currentDate = opts.startDate && new Date(opts.startDate) > new Date(millis) ? new Date(opts.startDate) : new Date(millis);
      const interval = parser.parseExpression(opts.cron, _.defaults({
        currentDate
      }, opts));
      try {
        return interval.next().getTime();
      } catch (e2) {
      }
    }
    function md52(str) {
      return crypto3.createHash("md5").update(str).digest("hex");
    }
  };
});

// node_modules/get-port/index.js
var require_get_port = __commonJS((exports, module) => {
  var net2 = import.meta.require("net");

  class Locked extends Error {
    constructor(port) {
      super(`${port} is locked`);
    }
  }
  var lockedPorts = {
    old: new Set,
    young: new Set
  };
  var releaseOldLockedPortsIntervalMs = 1000 * 15;
  var interval;
  var getAvailablePort = (options) => new Promise((resolve, reject) => {
    const server = net2.createServer();
    server.unref();
    server.on("error", reject);
    server.listen(options, () => {
      const { port } = server.address();
      server.close(() => {
        resolve(port);
      });
    });
  });
  var portCheckSequence = function* (ports) {
    if (ports) {
      yield* ports;
    }
    yield 0;
  };
  module.exports = async (options) => {
    let ports;
    if (options) {
      ports = typeof options.port === "number" ? [options.port] : options.port;
    }
    if (interval === undefined) {
      interval = setInterval(() => {
        lockedPorts.old = lockedPorts.young;
        lockedPorts.young = new Set;
      }, releaseOldLockedPortsIntervalMs);
      if (interval.unref) {
        interval.unref();
      }
    }
    for (const port of portCheckSequence(ports)) {
      try {
        let availablePort = await getAvailablePort({ ...options, port });
        while (lockedPorts.old.has(availablePort) || lockedPorts.young.has(availablePort)) {
          if (port !== 0) {
            throw new Locked(port);
          }
          availablePort = await getAvailablePort({ ...options, port });
        }
        lockedPorts.young.add(availablePort);
        return availablePort;
      } catch (error22) {
        if (!["EADDRINUSE", "EACCES"].includes(error22.code) && !(error22 instanceof Locked)) {
          throw error22;
        }
      }
    }
    throw new Error("No available ports found");
  };
  module.exports.makeRange = (from, to) => {
    if (!Number.isInteger(from) || !Number.isInteger(to)) {
      throw new TypeError("`from` and `to` must be integer numbers");
    }
    if (from < 1024 || from > 65535) {
      throw new RangeError("`from` must be between 1024 and 65535");
    }
    if (to < 1024 || to > 65536) {
      throw new RangeError("`to` must be between 1024 and 65536");
    }
    if (to < from) {
      throw new RangeError("`to` must be greater than or equal to `from`");
    }
    const generator = function* (from2, to2) {
      for (let port = from2;port <= to2; port++) {
        yield port;
      }
    };
    return generator(from, to);
  };
});

// node_modules/bull/lib/process/utils.js
var require_utils5 = __commonJS((exports, module) => {
  var hasProcessExited = function(child) {
    return !!(child.exitCode !== null || child.signalCode);
  };
  var onExitOnce = function(child) {
    return new Promise((resolve) => {
      child.once("exit", () => resolve());
    });
  };
  var killAsync = function(child, signal, timeoutMs) {
    if (hasProcessExited(child)) {
      return Promise.resolve(child);
    }
    let onExit = onExitOnce(child);
    child.kill(signal || "SIGKILL");
    if (timeoutMs === 0 || isFinite(timeoutMs)) {
      const timeout = setTimeout(() => {
        if (!hasProcessExited(child)) {
          child.kill("SIGKILL");
        }
      }, timeoutMs);
      onExit = onExit.then(() => {
        clearTimeout(timeout);
      });
    }
    return onExit;
  };
  var asyncSend = (proc, msg) => {
    return new Promise((resolve, reject) => {
      proc.send(msg, (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  };
  module.exports = {
    killAsync,
    asyncSend
  };
});

// node_modules/bull/lib/process/child-pool.js
var require_child_pool = __commonJS((exports, module) => {
  async function initChild(child, processFile) {
    const onComplete = new Promise((resolve, reject) => {
      const onMessageHandler = (msg) => {
        if (msg.cmd === "init-complete") {
          resolve();
        } else if (msg.cmd === "error") {
          reject(msg.error);
        }
        child.off("message", onMessageHandler);
      };
      child.on("message", onMessageHandler);
    });
    await new Promise((resolve) => child.send({ cmd: "init", value: processFile }, resolve));
    await onComplete;
  }
  var ChildPoolSingleton = function(isSharedChildPool = false) {
    if (isSharedChildPool === false) {
      return new ChildPool;
    } else if (!(this instanceof ChildPool) && ChildPoolSingleton.instance === undefined) {
      ChildPoolSingleton.instance = new ChildPool;
    }
    return ChildPoolSingleton.instance;
  };
  var __dirname = "/home/jeffsilva01/www/pizzashop-api/node_modules/bull/lib/process";
  var fork = import.meta.require("child_process").fork;
  var path = import.meta.require("path");
  var _ = require_lodash4();
  var getPort = require_get_port();
  var { killAsync } = require_utils5();
  var CHILD_KILL_TIMEOUT = 30000;
  var ChildPool = function ChildPool() {
    if (!(this instanceof ChildPool)) {
      return new ChildPool;
    }
    this.retained = {};
    this.free = {};
  };
  var convertExecArgv = function(execArgv) {
    const standard = [];
    const promises = [];
    _.forEach(execArgv, (arg) => {
      if (arg.indexOf("--inspect") === -1) {
        standard.push(arg);
      } else {
        const argName = arg.split("=")[0];
        promises.push(getPort().then((port) => {
          return `${argName}=${port}`;
        }));
      }
    });
    return Promise.all(promises).then((convertedArgs) => {
      return standard.concat(convertedArgs);
    });
  };
  ChildPool.prototype.retain = function(processFile) {
    const _this = this;
    let child = _this.getFree(processFile).pop();
    if (child) {
      _this.retained[child.pid] = child;
      return Promise.resolve(child);
    }
    return convertExecArgv(process.execArgv).then((execArgv) => {
      child = fork(path.join(__dirname, "./master.js"), {
        execArgv
      });
      child.processFile = processFile;
      _this.retained[child.pid] = child;
      child.on("exit", _this.remove.bind(_this, child));
      return initChild(child, child.processFile).then(() => {
        return child;
      }).catch((err) => {
        this.remove(child);
        throw err;
      });
    });
  };
  ChildPool.prototype.release = function(child) {
    delete this.retained[child.pid];
    this.getFree(child.processFile).push(child);
  };
  ChildPool.prototype.remove = function(child) {
    delete this.retained[child.pid];
    const free = this.getFree(child.processFile);
    const childIndex = free.indexOf(child);
    if (childIndex > -1) {
      free.splice(childIndex, 1);
    }
  };
  ChildPool.prototype.kill = function(child, signal) {
    this.remove(child);
    return killAsync(child, signal || "SIGKILL", CHILD_KILL_TIMEOUT);
  };
  ChildPool.prototype.clean = function() {
    const children = _.values(this.retained).concat(this.getAllFree());
    this.retained = {};
    this.free = {};
    const allKillPromises = [];
    children.forEach((child) => {
      allKillPromises.push(this.kill(child, "SIGTERM"));
    });
    return Promise.all(allKillPromises).then(() => {
    });
  };
  ChildPool.prototype.getFree = function(id) {
    return this.free[id] = this.free[id] || [];
  };
  ChildPool.prototype.getAllFree = function() {
    return _.flatten(_.values(this.free));
  };
  module.exports = ChildPoolSingleton;
});

// node_modules/bull/lib/process/sandbox.js
var require_sandbox = __commonJS((exports, module) => {
  var { asyncSend } = require_utils5();
  module.exports = function(processFile, childPool) {
    return function process(job) {
      return childPool.retain(processFile).then(async (child) => {
        let msgHandler;
        let exitHandler;
        await asyncSend(child, {
          cmd: "start",
          job
        });
        const done = new Promise((resolve, reject) => {
          msgHandler = function(msg) {
            switch (msg.cmd) {
              case "completed":
                resolve(msg.value);
                break;
              case "failed":
              case "error": {
                const err = new Error;
                Object.assign(err, msg.value);
                reject(err);
                break;
              }
              case "progress":
                job.progress(msg.value);
                break;
              case "update":
                job.update(msg.value);
                break;
              case "discard":
                job.discard();
                break;
              case "log":
                job.log(msg.value);
                break;
            }
          };
          exitHandler = (exitCode, signal) => {
            reject(new Error("Unexpected exit code: " + exitCode + " signal: " + signal));
          };
          child.on("message", msgHandler);
          child.on("exit", exitHandler);
        });
        return done.finally(() => {
          child.removeListener("message", msgHandler);
          child.removeListener("exit", exitHandler);
          if (child.exitCode !== null || /SIG.*/.test(child.signalCode)) {
            childPool.remove(child);
          } else {
            childPool.release(child);
          }
        });
      });
    };
  };
});

// node_modules/bull/lib/queue.js
var require_queue = __commonJS((exports, module) => {
  var redisClientGetter = function(queue3, options, initCallback) {
    const createClient = _.isFunction(options.createClient) ? options.createClient : function(type75, config) {
      if (["bclient", "subscriber"].includes(type75)) {
        return new Redis({ ...config, maxRetriesPerRequest: null });
      } else {
        return new Redis(config);
      }
    };
    const connections = {};
    return function(type75) {
      return function() {
        if (connections[type75] != null) {
          return connections[type75];
        }
        const clientOptions = _.assign({}, options.redis);
        const client = connections[type75] = createClient(type75, clientOptions);
        const opts = client.options.redisOptions || client.options;
        if (["bclient", "subscriber"].includes(type75) && (opts.enableReadyCheck || opts.maxRetriesPerRequest)) {
          throw new Error(errors10.Messages.MISSING_REDIS_OPTS);
        }
        queue3[type75 + "Initialized"] = true;
        if (!options.createClient) {
          queue3.clients.push(client);
        }
        return initCallback(type75, client), client;
      };
    };
  };
  var redisOptsFromUrl = function(urlString) {
    let redisOpts = {};
    try {
      const redisUrl = url.parse(urlString, true, true);
      redisOpts.port = parseInt(redisUrl.port || "6379", 10);
      redisOpts.host = redisUrl.hostname;
      redisOpts.db = redisUrl.pathname ? redisUrl.pathname.split("/")[1] : 0;
      if (redisUrl.auth) {
        const columnIndex = redisUrl.auth.indexOf(":");
        redisOpts.password = redisUrl.auth.slice(columnIndex + 1);
        if (columnIndex > 0) {
          redisOpts.username = redisUrl.auth.slice(0, columnIndex);
        }
      }
      if (redisUrl.query) {
        redisOpts = { ...redisOpts, ...redisUrl.query };
      }
    } catch (e2) {
      throw new Error(e2.message);
    }
    return redisOpts;
  };
  async function redisClientDisconnect(client) {
    if (client.status !== "end") {
      let _resolve, _reject;
      return new Promise((resolve, reject) => {
        _resolve = resolve;
        _reject = reject;
        client.once("end", _resolve);
        pTimeout(client.quit().catch((err) => {
          if (err.message !== "Connection is closed.") {
            throw err;
          }
        }), 500).catch(() => {
        }).finally(() => {
          client.once("error", _reject);
          client.disconnect();
          if (["connecting", "reconnecting"].includes(client.status)) {
            resolve();
          }
        });
      }).finally(() => {
        client.removeListener("end", _resolve);
        client.removeListener("error", _reject);
      });
    }
  }
  var getRedisVersion = function(client) {
    return client.info().then((doc) => {
      const prefix = "redis_version:";
      const lines = doc.split("\r\n");
      for (let i = 0;i < lines.length; i++) {
        if (lines[i].indexOf(prefix) === 0) {
          return lines[i].substr(prefix.length);
        }
      }
    });
  };
  var jobIdForGroup = function(limiter, opts, data) {
    const jobId = opts && opts.jobId;
    const groupKey = _.get(limiter, "groupKey");
    if (groupKey) {
      return `${jobId || uuid.v4()}:${_.get(data, groupKey)}`;
    }
    return jobId;
  };
  var Redis = require_built3();
  var EventEmitter = import.meta.require("events");
  var _ = require_lodash4();
  var fs2 = import.meta.require("fs");
  var path = import.meta.require("path");
  var util2 = import.meta.require("util");
  var url = import.meta.require("url");
  var Job = require_job();
  var scripts = require_scripts();
  var errors10 = require_errors2();
  var utils8 = require_utils4();
  var TimerManager = require_timer_manager();
  var { promisify } = import.meta.require("util");
  var { pTimeout } = require_p_timeout();
  var semver = require_semver2();
  var debuglog = import.meta.require("util").debuglog("bull");
  var uuid = require_dist();
  var commands = require_commands2();
  var MINIMUM_REDIS_VERSION = "2.8.18";
  var Queue2 = function Queue(name, url2, opts) {
    if (!(this instanceof Queue)) {
      return new Queue(name, url2, opts);
    }
    if (_.isString(url2)) {
      const clonedOpts = _.cloneDeep(opts || {});
      opts = {
        ...clonedOpts,
        redis: {
          ...redisOptsFromUrl(url2),
          ...clonedOpts.redis
        }
      };
    } else {
      opts = _.cloneDeep(url2 || {});
    }
    if (!_.isObject(opts)) {
      throw TypeError("Options must be a valid object");
    }
    if (opts.limiter) {
      if (opts.limiter.max && opts.limiter.duration) {
        this.limiter = opts.limiter;
      } else {
        throw new TypeError("Limiter requires `max` and `duration` options");
      }
    }
    if (opts.defaultJobOptions) {
      this.defaultJobOptions = opts.defaultJobOptions;
    }
    this.name = name;
    this.token = uuid.v4();
    opts.redis = {
      enableReadyCheck: false,
      ..._.isString(opts.redis) ? { ...redisOptsFromUrl(opts.redis) } : opts.redis
    };
    _.defaults(opts.redis, {
      port: 6379,
      host: "127.0.0.1",
      db: opts.redis.db || opts.redis.DB,
      retryStrategy: function(times) {
        return Math.min(Math.exp(times), 20000);
      }
    });
    this.keyPrefix = opts.redis.keyPrefix || opts.prefix || "bull";
    delete opts.redis.keyPrefix;
    this.clients = [];
    const lazyClient = redisClientGetter(this, opts, (type75, client) => {
      const handler = this.emit.bind(this, "error");
      client.on("error", handler);
      this.once("close", () => client.removeListener("error", handler));
      if (type75 === "client") {
        this._initializing = commands(client).then(() => {
          debuglog(name + " queue ready");
        }, (err) => {
          this.emit("error", new Error("Error initializing Lua scripts"));
          throw err;
        });
        this._initializing.catch(() => {
        });
      }
    });
    Object.defineProperties(this, {
      client: {
        get: lazyClient("client")
      },
      eclient: {
        get: lazyClient("subscriber")
      },
      bclient: {
        get: lazyClient("bclient")
      }
    });
    if (opts.skipVersionCheck !== true) {
      getRedisVersion(this.client).then((version3) => {
        if (semver.lt(version3, MINIMUM_REDIS_VERSION)) {
          this.emit("error", new Error("Redis version needs to be greater than " + MINIMUM_REDIS_VERSION + ". Current: " + version3));
        }
      }).catch(() => {
      });
    }
    this.handlers = {};
    this.delayTimer;
    this.processing = [];
    this.retrieving = 0;
    this.drained = true;
    this.settings = _.defaults(opts.settings, {
      lockDuration: 30000,
      stalledInterval: 30000,
      maxStalledCount: 1,
      guardInterval: 5000,
      retryProcessDelay: 5000,
      drainDelay: 5,
      backoffStrategies: {},
      isSharedChildPool: false
    });
    this.metrics = opts.metrics;
    this.settings.lockRenewTime = this.settings.lockRenewTime || this.settings.lockDuration / 2;
    this.on("error", () => {
    });
    this.timers = new TimerManager;
    this.moveUnlockedJobsToWait = this.moveUnlockedJobsToWait.bind(this);
    this.processJob = this.processJob.bind(this);
    this.getJobFromId = Job.fromId.bind(null, this);
    const keys = {};
    _.each([
      "",
      "active",
      "wait",
      "waiting",
      "paused",
      "resumed",
      "meta-paused",
      "active",
      "id",
      "delayed",
      "priority",
      "stalled-check",
      "completed",
      "failed",
      "stalled",
      "repeat",
      "limiter",
      "drained",
      "progress"
    ], (key) => {
      keys[key] = this.toKey(key);
    });
    this.keys = keys;
  };
  util2.inherits(Queue2, EventEmitter);
  require_getters()(Queue2);
  require_worker()(Queue2);
  require_repeatable()(Queue2);
  Queue2.prototype.off = Queue2.prototype.removeListener;
  var _on = Queue2.prototype.on;
  Queue2.prototype.on = function(eventName) {
    this._registerEvent(eventName);
    return _on.apply(this, arguments);
  };
  var _once = Queue2.prototype.once;
  Queue2.prototype.once = function(eventName) {
    this._registerEvent(eventName);
    return _once.apply(this, arguments);
  };
  Queue2.prototype._initProcess = function() {
    if (!this._initializingProcess) {
      this.delayedTimestamp = Number.MAX_VALUE;
      this._initializingProcess = this.isReady().then(() => {
        return this._registerEvent("delayed");
      }).then(() => {
        return this.updateDelayTimer();
      });
      this.errorRetryTimer = {};
    }
    return this._initializingProcess;
  };
  Queue2.prototype._setupQueueEventListeners = function() {
    const activeKey = this.keys.active;
    const stalledKey = this.keys.stalled;
    const progressKey = this.keys.progress;
    const delayedKey = this.keys.delayed;
    const pausedKey = this.keys.paused;
    const resumedKey = this.keys.resumed;
    const waitingKey = this.keys.waiting;
    const completedKey = this.keys.completed;
    const failedKey = this.keys.failed;
    const drainedKey = this.keys.drained;
    const pmessageHandler = (pattern3, channel, message) => {
      const keyAndToken = channel.split("@");
      const key = keyAndToken[0];
      const token = keyAndToken[1];
      switch (key) {
        case activeKey:
          utils8.emitSafe(this, "global:active", message, "waiting");
          break;
        case waitingKey:
          if (this.token === token) {
            utils8.emitSafe(this, "waiting", message, null);
          }
          token && utils8.emitSafe(this, "global:waiting", message, null);
          break;
        case stalledKey:
          if (this.token === token) {
            utils8.emitSafe(this, "stalled", message);
          }
          utils8.emitSafe(this, "global:stalled", message);
          break;
      }
    };
    const messageHandler = (channel, message) => {
      const key = channel.split("@")[0];
      switch (key) {
        case progressKey: {
          try {
            const { progress, jobId } = JSON.parse(message);
            utils8.emitSafe(this, "global:progress", jobId, progress);
          } catch (err) {
            const commaPos = message.indexOf(",");
            const jobId = message.substring(0, commaPos);
            const progress = message.substring(commaPos + 1);
            utils8.emitSafe(this, "global:progress", jobId, JSON.parse(progress));
          }
          break;
        }
        case delayedKey: {
          const newDelayedTimestamp = _.ceil(message);
          if (newDelayedTimestamp < this.delayedTimestamp) {
            this.delayedTimestamp = newDelayedTimestamp;
            this.updateDelayTimer();
          }
          break;
        }
        case pausedKey:
        case resumedKey:
          utils8.emitSafe(this, "global:" + message);
          break;
        case completedKey: {
          const data = JSON.parse(message);
          utils8.emitSafe(this, "global:completed", data.jobId, data.val, "active");
          break;
        }
        case failedKey: {
          const data = JSON.parse(message);
          utils8.emitSafe(this, "global:failed", data.jobId, data.val, "active");
          break;
        }
        case drainedKey:
          utils8.emitSafe(this, "global:drained");
          break;
      }
    };
    this.eclient.on("pmessage", pmessageHandler);
    this.eclient.on("message", messageHandler);
    this.once("close", () => {
      this.eclient.removeListener("pmessage", pmessageHandler);
      this.eclient.removeListener("message", messageHandler);
    });
  };
  Queue2.prototype._registerEvent = function(eventName) {
    const internalEvents = ["waiting", "delayed"];
    if (eventName.startsWith("global:") || internalEvents.indexOf(eventName) !== -1) {
      if (!this.registeredEvents) {
        this._setupQueueEventListeners();
        this.registeredEvents = this.registeredEvents || {};
      }
      const _eventName = eventName.replace("global:", "");
      if (!this.registeredEvents[_eventName]) {
        return utils8.isRedisReady(this.eclient).then(() => {
          const channel = this.toKey(_eventName);
          if (["active", "waiting", "stalled"].indexOf(_eventName) !== -1) {
            return this.registeredEvents[_eventName] = this.eclient.psubscribe(channel + "*");
          } else {
            return this.registeredEvents[_eventName] = this.eclient.subscribe(channel);
          }
        }).then(() => {
          utils8.emitSafe(this, "registered:" + eventName);
        });
      } else {
        return this.registeredEvents[_eventName];
      }
    }
    return Promise.resolve();
  };
  Queue2.ErrorMessages = errors10.Messages;
  Queue2.prototype.isReady = async function() {
    await this._initializing;
    return this;
  };
  Queue2.prototype.disconnect = async function() {
    await Promise.all(this.clients.map((client) => client.blocked ? client.disconnect() : redisClientDisconnect(client)));
  };
  Queue2.prototype.removeJobs = function(pattern3) {
    return Job.remove(this, pattern3);
  };
  Queue2.prototype.close = function(doNotWaitJobs) {
    let isReady = true;
    if (this.closing) {
      return this.closing;
    }
    return this.closing = this.isReady().then(this._initializingProcess).catch(() => {
      isReady = false;
    }).then(() => isReady && this.pause(true, doNotWaitJobs)).catch(() => {
      return;
    }).finally(() => this._clearTimers()).then(() => {
      if (!this.childPool) {
        return;
      }
      const cleanPromise = this.childPool.clean().catch(() => {
      });
      if (doNotWaitJobs) {
        return;
      }
      return cleanPromise;
    }).then(async () => this.disconnect(), (err) => console.error(err)).finally(() => {
      this.closed = true;
      utils8.emitSafe(this, "close");
    });
  };
  Queue2.prototype._clearTimers = function() {
    _.each(this.errorRetryTimer, (timer2) => {
      clearTimeout(timer2);
    });
    clearTimeout(this.delayTimer);
    clearInterval(this.guardianTimer);
    clearInterval(this.moveUnlockedJobsToWaitInterval);
    this.timers.clearAll();
    return this.timers.whenIdle();
  };
  Queue2.prototype.process = function(name, concurrency, handler) {
    switch (arguments.length) {
      case 1:
        handler = name;
        concurrency = 1;
        name = Job.DEFAULT_JOB_NAME;
        break;
      case 2:
        handler = concurrency;
        if (typeof name === "string") {
          concurrency = 1;
        } else {
          concurrency = name;
          name = Job.DEFAULT_JOB_NAME;
        }
        break;
    }
    this.setHandler(name, handler);
    return this._initProcess().then(() => {
      return this.start(concurrency, name);
    });
  };
  Queue2.prototype.start = function(concurrency, name) {
    return this.run(concurrency, name).catch((err) => {
      utils8.emitSafe(this, "error", err, "error running queue");
      throw err;
    });
  };
  Queue2.prototype.setHandler = function(name, handler) {
    if (!handler) {
      throw new Error("Cannot set an undefined handler");
    }
    if (this.handlers[name]) {
      throw new Error("Cannot define the same handler twice " + name);
    }
    this.setWorkerName();
    if (typeof handler === "string") {
      const supportedFileTypes = [".js", ".ts", ".flow", ".cjs"];
      const processorFile = handler + (supportedFileTypes.includes(path.extname(handler)) ? "" : ".js");
      if (!fs2.existsSync(processorFile)) {
        throw new Error("File " + processorFile + " does not exist");
      }
      const isSharedChildPool = this.settings.isSharedChildPool;
      this.childPool = this.childPool || require_child_pool()(isSharedChildPool);
      const sandbox = require_sandbox();
      this.handlers[name] = sandbox(handler, this.childPool).bind(this);
    } else {
      handler = handler.bind(this);
      if (handler.length > 1) {
        this.handlers[name] = promisify(handler);
      } else {
        this.handlers[name] = function() {
          try {
            return Promise.resolve(handler.apply(null, arguments));
          } catch (err) {
            return Promise.reject(err);
          }
        };
      }
    }
  };
  Queue2.prototype.add = function(name, data, opts) {
    if (typeof name !== "string") {
      opts = data;
      data = name;
      name = Job.DEFAULT_JOB_NAME;
    }
    opts = _.cloneDeep({ ...this.defaultJobOptions, ...opts });
    opts.jobId = jobIdForGroup(this.limiter, opts, data);
    if (opts.repeat) {
      return this.isReady().then(() => {
        return this.nextRepeatableJob(name, data, opts, true);
      });
    } else {
      return Job.create(this, name, data, opts);
    }
  };
  Queue2.prototype.retryJobs = async function(opts = {}) {
    let cursor = 0;
    do {
      cursor = await scripts.retryJobs(this, opts.count);
    } while (cursor);
  };
  Queue2.prototype.addBulk = function(jobs) {
    const decoratedJobs = jobs.map((job) => {
      const jobId = jobIdForGroup(this.limiter, job.opts, job.data);
      return {
        ...job,
        name: typeof job.name !== "string" ? Job.DEFAULT_JOB_NAME : job.name,
        opts: {
          ...this.defaultJobOptions,
          ...job.opts,
          jobId
        }
      };
    });
    return Job.createBulk(this, decoratedJobs);
  };
  Queue2.prototype.empty = function() {
    const queueKeys = this.keys;
    let multi = this.multi();
    multi.lrange(queueKeys.wait, 0, -1);
    multi.lrange(queueKeys.paused, 0, -1);
    multi.keys(this.toKey("*:limited"));
    multi.del(queueKeys.wait, queueKeys.paused, queueKeys["meta-paused"], queueKeys.delayed, queueKeys.priority, queueKeys.limiter, `${queueKeys.limiter}:index`);
    return multi.exec().then((res) => {
      let [waiting, paused, limited] = res;
      waiting = waiting[1];
      paused = paused[1];
      limited = limited[1];
      const jobKeys = paused.concat(waiting).map(this.toKey, this);
      if (jobKeys.length || limited.length) {
        multi = this.multi();
        for (let i = 0;i < jobKeys.length; i += 1e4) {
          multi.del.apply(multi, jobKeys.slice(i, i + 1e4));
        }
        for (let i = 0;i < limited.length; i += 1e4) {
          multi.del.apply(multi, limited.slice(i, i + 1e4));
        }
        return multi.exec();
      }
    });
  };
  Queue2.prototype.pause = function(isLocal, doNotWaitActive) {
    return this.isReady().then(() => {
      if (isLocal) {
        if (!this.paused) {
          this.paused = new Promise((resolve) => {
            this.resumeLocal = function() {
              this.paused = null;
              resolve();
            };
          });
        }
        if (!this.bclientInitialized) {
          return;
        }
        if (doNotWaitActive) {
          return redisClientDisconnect(this.bclient).then(() => this.bclient.connect());
        }
        return this.whenCurrentJobsFinished();
      } else {
        return scripts.pause(this, true);
      }
    }).then(() => {
      return utils8.emitSafe(this, "paused");
    });
  };
  Queue2.prototype.resume = function(isLocal) {
    return this.isReady().then(() => {
      if (isLocal) {
        if (this.resumeLocal) {
          this.resumeLocal();
        }
      } else {
        return scripts.pause(this, false);
      }
    }).then(() => {
      utils8.emitSafe(this, "resumed");
    });
  };
  Queue2.prototype.isPaused = async function(isLocal) {
    if (isLocal) {
      return !!this.paused;
    } else {
      await this.isReady();
      const multi = this.multi();
      multi.exists(this.keys["meta-paused"]);
      multi.hexists(this.toKey("meta"), "paused");
      const [[, isPaused], [, isPausedNew]] = await multi.exec();
      return !!(isPaused || isPausedNew);
    }
  };
  Queue2.prototype.run = function(concurrency, handlerName) {
    if (!Number.isInteger(concurrency)) {
      throw new Error("Cannot set Float as concurrency");
    }
    const promises = [];
    return this.isReady().then(() => {
      return this.moveUnlockedJobsToWait();
    }).then(() => {
      return utils8.isRedisReady(this.bclient);
    }).then(() => {
      while (concurrency--) {
        promises.push(new Promise((resolve) => {
          this.processJobs(`${handlerName}:${concurrency}`, resolve);
        }));
      }
      this.startMoveUnlockedJobsToWait();
      return Promise.all(promises);
    });
  };
  Queue2.prototype.updateDelayTimer = function() {
    if (this.closing) {
      return Promise.resolve();
    }
    return scripts.updateDelaySet(this, Date.now()).then((nextTimestamp) => {
      this.delayedTimestamp = nextTimestamp ? nextTimestamp / 4096 : Number.MAX_VALUE;
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
      }
      const delay = _.min([
        this.delayedTimestamp - Date.now(),
        this.settings.guardInterval
      ]);
      if (delay <= 0) {
        this.updateDelayTimer();
      } else {
        this.delayTimer = setTimeout(() => this.updateDelayTimer(), delay);
      }
      return null;
    }).catch((err) => {
      utils8.emitSafe(this, "error", err, "Error updating the delay timer");
      if (this.delayTimer) {
        clearTimeout(this.delayTimer);
      }
      this.delayTimer = setTimeout(() => this.updateDelayTimer(), this.settings.guardInterval);
    });
  };
  Queue2.prototype.moveUnlockedJobsToWait = function() {
    if (this.closing) {
      return Promise.resolve();
    }
    return scripts.moveUnlockedJobsToWait(this).then(([failed, stalled]) => {
      const handleFailedJobs = failed.map((jobId) => {
        return this.getJobFromId(jobId).then((job) => {
          utils8.emitSafe(this, "failed", job, new Error("job stalled more than allowable limit"), "active");
          return null;
        });
      });
      const handleStalledJobs = stalled.map((jobId) => {
        return this.getJobFromId(jobId).then((job) => {
          if (job !== null) {
            utils8.emitSafe(this, "stalled", job);
          }
          return null;
        });
      });
      return Promise.all(handleFailedJobs.concat(handleStalledJobs));
    }).catch((err) => {
      utils8.emitSafe(this, "error", err, "Failed to handle unlocked job in active");
    });
  };
  Queue2.prototype.startMoveUnlockedJobsToWait = function() {
    clearInterval(this.moveUnlockedJobsToWaitInterval);
    if (this.settings.stalledInterval > 0 && !this.closing) {
      this.moveUnlockedJobsToWaitInterval = setInterval(this.moveUnlockedJobsToWait, this.settings.stalledInterval);
    }
  };
  Queue2.prototype.processJobs = function(index, resolve, job) {
    const processJobs = this.processJobs.bind(this, index, resolve);
    process.nextTick(() => {
      this._processJobOnNextTick(processJobs, index, resolve, job);
    });
  };
  Queue2.prototype._processJobOnNextTick = function(processJobs, index, resolve, job) {
    if (!this.closing) {
      (this.paused || Promise.resolve()).then(() => {
        const gettingNextJob = job ? Promise.resolve(job) : this.getNextJob();
        return this.processing[index] = gettingNextJob.then(this.processJob).then(processJobs, (err) => {
          if (!(this.closing && err.message === "Connection is closed.")) {
            utils8.emitSafe(this, "error", err, "Error processing job");
            clearTimeout(this.errorRetryTimer[index]);
            this.errorRetryTimer[index] = setTimeout(() => {
              processJobs();
            }, this.settings.retryProcessDelay);
          }
          return null;
        });
      }).catch((err) => {
        utils8.emitSafe(this, "error", err, "Error processing job");
      });
    } else {
      resolve(this.closing);
    }
  };
  Queue2.prototype.processJob = function(job, notFetch = false) {
    let lockRenewId;
    let timerStopped = false;
    if (!job) {
      return Promise.resolve();
    }
    const lockExtender = () => {
      lockRenewId = this.timers.set("lockExtender", this.settings.lockRenewTime, () => {
        scripts.extendLock(this, job.id, this.settings.lockDuration).then((lock) => {
          if (lock && !timerStopped) {
            lockExtender();
          }
        }).catch((err) => {
          utils8.emitSafe(this, "lock-extension-failed", job, err);
        });
      });
    };
    const timeoutMs = job.opts.timeout;
    const stopTimer = () => {
      timerStopped = true;
      this.timers.clear(lockRenewId);
    };
    const handleCompleted = (result2) => {
      return job.moveToCompleted(result2, undefined, notFetch).then((jobData) => {
        utils8.emitSafe(this, "completed", job, result2, "active");
        return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;
      });
    };
    const handleFailed = (err) => {
      const error22 = err;
      return job.moveToFailed(err).then((jobData) => {
        utils8.emitSafe(this, "failed", job, error22, "active");
        return jobData ? this.nextJobFromJobData(jobData[0], jobData[1]) : null;
      });
    };
    lockExtender();
    const handler = this.handlers[job.name] || this.handlers["*"];
    if (!handler) {
      return handleFailed(new Error("Missing process handler for job type " + job.name));
    } else {
      let jobPromise = handler(job);
      if (timeoutMs) {
        jobPromise = pTimeout(jobPromise, timeoutMs);
      }
      utils8.emitSafe(this, "active", job, jobPromise, "waiting");
      return jobPromise.then(handleCompleted).catch(handleFailed).finally(() => {
        stopTimer();
      });
    }
  };
  Queue2.prototype.multi = function() {
    return this.client.multi();
  };
  Queue2.prototype.getNextJob = async function() {
    if (this.closing) {
      return Promise.resolve();
    }
    if (this.drained) {
      try {
        this.bclient.blocked = true;
        const jobId = await this.bclient.brpoplpush(this.keys.wait, this.keys.active, this.settings.drainDelay);
        this.bclient.blocked = false;
        if (jobId) {
          return this.moveToActive(jobId);
        }
      } catch (err) {
        if (!(this.paused && err.message === "Connection is closed.")) {
          throw err;
        }
      }
    } else {
      return this.moveToActive();
    }
  };
  Queue2.prototype.moveToActive = async function(jobId) {
    await this.isReady();
    return scripts.moveToActive(this, jobId).then(([jobData, jobId2]) => {
      return this.nextJobFromJobData(jobData, jobId2);
    });
  };
  Queue2.prototype.nextJobFromJobData = function(jobData, jobId) {
    if (jobData) {
      this.drained = false;
      const job = Job.fromJSON(this, jobData, jobId);
      if (job.opts.repeat) {
        return this.nextRepeatableJob(job.name, job.data, job.opts).then(() => {
          return job;
        });
      }
      return job;
    } else {
      this.drained = true;
      utils8.emitSafe(this, "drained");
      return null;
    }
  };
  Queue2.prototype.retryJob = function(job) {
    return job.retry();
  };
  Queue2.prototype.toKey = function(queueType) {
    return [this.keyPrefix, this.name, queueType].join(":");
  };
  Queue2.prototype.clean = function(grace, type75, limit) {
    return this.isReady().then(() => {
      if (grace === undefined || grace === null) {
        throw new Error("You must define a grace period.");
      }
      if (!type75) {
        type75 = "completed";
      }
      if (_.indexOf(["completed", "wait", "active", "paused", "delayed", "failed"], type75) === -1) {
        throw new Error("Cannot clean unknown queue type " + type75);
      }
      return scripts.cleanJobsInSet(this, type75, Date.now() - grace, limit).then((jobs) => {
        utils8.emitSafe(this, "cleaned", jobs, type75);
        return jobs;
      }).catch((err) => {
        utils8.emitSafe(this, "error", err);
        throw err;
      });
    });
  };
  Queue2.prototype.obliterate = async function(opts) {
    await this.pause();
    let cursor = 0;
    do {
      cursor = await scripts.obliterate(this, {
        force: false,
        count: 1000,
        ...opts
      });
    } while (cursor);
  };
  Queue2.prototype.whenCurrentJobsFinished = function() {
    if (!this.bclientInitialized) {
      return Promise.resolve();
    }
    const forcedReconnection = redisClientDisconnect(this.bclient).then(() => {
      return this.bclient.connect();
    });
    return Promise.all(Object.values(this.processing)).then(() => forcedReconnection);
  };
  module.exports = Queue2;
});

// node_modules/bull/index.js
var require_bull = __commonJS((exports, module) => {
  module.exports = require_queue();
  module.exports.Job = require_job();
  module.exports.utils = require_utils4();
});

// node_modules/nodemailer/lib/fetch/cookies.js
var require_cookies = __commonJS((exports, module) => {
  var urllib = import.meta.require("url");
  var SESSION_TIMEOUT = 1800;

  class Cookies {
    constructor(options) {
      this.options = options || {};
      this.cookies = [];
    }
    set(cookieStr, url) {
      let urlparts = urllib.parse(url || "");
      let cookie = this.parse(cookieStr);
      let domain;
      if (cookie.domain) {
        domain = cookie.domain.replace(/^\./, "");
        if (urlparts.hostname.length < domain.length || ("." + urlparts.hostname).substr(-domain.length + 1) !== "." + domain) {
          cookie.domain = urlparts.hostname;
        }
      } else {
        cookie.domain = urlparts.hostname;
      }
      if (!cookie.path) {
        cookie.path = this.getPath(urlparts.pathname);
      }
      if (!cookie.expires) {
        cookie.expires = new Date(Date.now() + (Number(this.options.sessionTimeout || SESSION_TIMEOUT) || SESSION_TIMEOUT) * 1000);
      }
      return this.add(cookie);
    }
    get(url) {
      return this.list(url).map((cookie) => cookie.name + "=" + cookie.value).join("; ");
    }
    list(url) {
      let result2 = [];
      let i;
      let cookie;
      for (i = this.cookies.length - 1;i >= 0; i--) {
        cookie = this.cookies[i];
        if (this.isExpired(cookie)) {
          this.cookies.splice(i, i);
          continue;
        }
        if (this.match(cookie, url)) {
          result2.unshift(cookie);
        }
      }
      return result2;
    }
    parse(cookieStr) {
      let cookie = {};
      (cookieStr || "").toString().split(";").forEach((cookiePart) => {
        let valueParts = cookiePart.split("=");
        let key = valueParts.shift().trim().toLowerCase();
        let value15 = valueParts.join("=").trim();
        let domain;
        if (!key) {
          return;
        }
        switch (key) {
          case "expires":
            value15 = new Date(value15);
            if (value15.toString() !== "Invalid Date") {
              cookie.expires = value15;
            }
            break;
          case "path":
            cookie.path = value15;
            break;
          case "domain":
            domain = value15.toLowerCase();
            if (domain.length && domain.charAt(0) !== ".") {
              domain = "." + domain;
            }
            cookie.domain = domain;
            break;
          case "max-age":
            cookie.expires = new Date(Date.now() + (Number(value15) || 0) * 1000);
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httponly = true;
            break;
          default:
            if (!cookie.name) {
              cookie.name = key;
              cookie.value = value15;
            }
        }
      });
      return cookie;
    }
    match(cookie, url) {
      let urlparts = urllib.parse(url || "");
      if (urlparts.hostname !== cookie.domain && (cookie.domain.charAt(0) !== "." || ("." + urlparts.hostname).substr(-cookie.domain.length) !== cookie.domain)) {
        return false;
      }
      let path = this.getPath(urlparts.pathname);
      if (path.substr(0, cookie.path.length) !== cookie.path) {
        return false;
      }
      if (cookie.secure && urlparts.protocol !== "https:") {
        return false;
      }
      return true;
    }
    add(cookie) {
      let i;
      let len;
      if (!cookie || !cookie.name) {
        return false;
      }
      for (i = 0, len = this.cookies.length;i < len; i++) {
        if (this.compare(this.cookies[i], cookie)) {
          if (this.isExpired(cookie)) {
            this.cookies.splice(i, 1);
            return false;
          }
          this.cookies[i] = cookie;
          return true;
        }
      }
      if (!this.isExpired(cookie)) {
        this.cookies.push(cookie);
      }
      return true;
    }
    compare(a2, b3) {
      return a2.name === b3.name && a2.path === b3.path && a2.domain === b3.domain && a2.secure === b3.secure && a2.httponly === a2.httponly;
    }
    isExpired(cookie) {
      return cookie.expires && cookie.expires < new Date || !cookie.value;
    }
    getPath(pathname) {
      let path = (pathname || "/").split("/");
      path.pop();
      path = path.join("/").trim();
      if (path.charAt(0) !== "/") {
        path = "/" + path;
      }
      if (path.substr(-1) !== "/") {
        path += "/";
      }
      return path;
    }
  }
  module.exports = Cookies;
});

// node_modules/nodemailer/package.json
var require_package = __commonJS((exports, module) => {
  module.exports = {
    name: "nodemailer",
    version: "6.9.12",
    description: "Easy as cake e-mail sending from your Node.js applications",
    main: "lib/nodemailer.js",
    scripts: {
      test: "node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      "test:coverage": "c8 node --test --test-concurrency=1 test/**/*.test.js test/**/*-test.js",
      lint: "eslint .",
      update: "rm -rf node_modules/ package-lock.json && ncu -u && npm install"
    },
    repository: {
      type: "git",
      url: "https://github.com/nodemailer/nodemailer.git"
    },
    keywords: [
      "Nodemailer"
    ],
    author: "Andris Reinman",
    license: "MIT-0",
    bugs: {
      url: "https://github.com/nodemailer/nodemailer/issues"
    },
    homepage: "https://nodemailer.com/",
    devDependencies: {
      "@aws-sdk/client-ses": "3.529.1",
      bunyan: "1.8.15",
      c8: "9.1.0",
      eslint: "8.57.0",
      "eslint-config-nodemailer": "1.2.0",
      "eslint-config-prettier": "9.1.0",
      libbase64: "1.3.0",
      libmime: "5.3.4",
      libqp: "2.1.0",
      "nodemailer-ntlm-auth": "1.0.4",
      proxy: "1.0.2",
      "proxy-test-server": "1.0.0",
      "smtp-server": "3.13.3"
    },
    engines: {
      node: ">=6.0.0"
    }
  };
});

// node_modules/nodemailer/lib/fetch/index.js
var require_fetch = __commonJS((exports, module) => {
  var nmfetch = function(url, options) {
    options = options || {};
    options.fetchRes = options.fetchRes || new PassThrough;
    options.cookies = options.cookies || new Cookies;
    options.redirects = options.redirects || 0;
    options.maxRedirects = isNaN(options.maxRedirects) ? MAX_REDIRECTS : options.maxRedirects;
    if (options.cookie) {
      [].concat(options.cookie || []).forEach((cookie) => {
        options.cookies.set(cookie, url);
      });
      options.cookie = false;
    }
    let fetchRes = options.fetchRes;
    let parsed = urllib.parse(url);
    let method = (options.method || "").toString().trim().toUpperCase() || "GET";
    let finished = false;
    let cookies;
    let body;
    let handler = parsed.protocol === "https:" ? https : http;
    let headers = {
      "accept-encoding": "gzip,deflate",
      "user-agent": "nodemailer/" + packageData.version
    };
    Object.keys(options.headers || {}).forEach((key) => {
      headers[key.toLowerCase().trim()] = options.headers[key];
    });
    if (options.userAgent) {
      headers["user-agent"] = options.userAgent;
    }
    if (parsed.auth) {
      headers.Authorization = "Basic " + Buffer.from(parsed.auth).toString("base64");
    }
    if (cookies = options.cookies.get(url)) {
      headers.cookie = cookies;
    }
    if (options.body) {
      if (options.contentType !== false) {
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
      }
      if (typeof options.body.pipe === "function") {
        headers["Transfer-Encoding"] = "chunked";
        body = options.body;
        body.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
        });
      } else {
        if (options.body instanceof Buffer) {
          body = options.body;
        } else if (typeof options.body === "object") {
          try {
            body = Buffer.from(Object.keys(options.body).map((key) => {
              let value15 = options.body[key].toString().trim();
              return encodeURIComponent(key) + "=" + encodeURIComponent(value15);
            }).join("&"));
          } catch (E) {
            if (finished) {
              return;
            }
            finished = true;
            E.type = "FETCH";
            E.sourceUrl = url;
            fetchRes.emit("error", E);
            return;
          }
        } else {
          body = Buffer.from(options.body.toString().trim());
        }
        headers["Content-Type"] = options.contentType || "application/x-www-form-urlencoded";
        headers["Content-Length"] = body.length;
      }
      method = (options.method || "").toString().trim().toUpperCase() || "POST";
    }
    let req;
    let reqOptions = {
      method,
      host: parsed.hostname,
      path: parsed.path,
      port: parsed.port ? parsed.port : parsed.protocol === "https:" ? 443 : 80,
      headers,
      rejectUnauthorized: false,
      agent: false
    };
    if (options.tls) {
      Object.keys(options.tls).forEach((key) => {
        reqOptions[key] = options.tls[key];
      });
    }
    if (parsed.protocol === "https:" && parsed.hostname && parsed.hostname !== reqOptions.host && !net2.isIP(parsed.hostname) && !reqOptions.servername) {
      reqOptions.servername = parsed.hostname;
    }
    try {
      req = handler.request(reqOptions);
    } catch (E) {
      finished = true;
      setImmediate(() => {
        E.type = "FETCH";
        E.sourceUrl = url;
        fetchRes.emit("error", E);
      });
      return fetchRes;
    }
    if (options.timeout) {
      req.setTimeout(options.timeout, () => {
        if (finished) {
          return;
        }
        finished = true;
        req.abort();
        let err = new Error("Request Timeout");
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
      });
    }
    req.on("error", (err) => {
      if (finished) {
        return;
      }
      finished = true;
      err.type = "FETCH";
      err.sourceUrl = url;
      fetchRes.emit("error", err);
    });
    req.on("response", (res) => {
      let inflate;
      if (finished) {
        return;
      }
      switch (res.headers["content-encoding"]) {
        case "gzip":
        case "deflate":
          inflate = zlib.createUnzip();
          break;
      }
      if (res.headers["set-cookie"]) {
        [].concat(res.headers["set-cookie"] || []).forEach((cookie) => {
          options.cookies.set(cookie, url);
        });
      }
      if ([301, 302, 303, 307, 308].includes(res.statusCode) && res.headers.location) {
        options.redirects++;
        if (options.redirects > options.maxRedirects) {
          finished = true;
          let err = new Error("Maximum redirect count exceeded");
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
          return;
        }
        options.method = "GET";
        options.body = false;
        return nmfetch(urllib.resolve(url, res.headers.location), options);
      }
      fetchRes.statusCode = res.statusCode;
      fetchRes.headers = res.headers;
      if (res.statusCode >= 300 && !options.allowErrorResponse) {
        finished = true;
        let err = new Error("Invalid status code " + res.statusCode);
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
        return;
      }
      res.on("error", (err) => {
        if (finished) {
          return;
        }
        finished = true;
        err.type = "FETCH";
        err.sourceUrl = url;
        fetchRes.emit("error", err);
        req.abort();
      });
      if (inflate) {
        res.pipe(inflate).pipe(fetchRes);
        inflate.on("error", (err) => {
          if (finished) {
            return;
          }
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          req.abort();
        });
      } else {
        res.pipe(fetchRes);
      }
    });
    setImmediate(() => {
      if (body) {
        try {
          if (typeof body.pipe === "function") {
            return body.pipe(req);
          } else {
            req.write(body);
          }
        } catch (err) {
          finished = true;
          err.type = "FETCH";
          err.sourceUrl = url;
          fetchRes.emit("error", err);
          return;
        }
      }
      req.end();
    });
    return fetchRes;
  };
  var http = import.meta.require("http");
  var https = import.meta.require("https");
  var urllib = import.meta.require("url");
  var zlib = import.meta.require("zlib");
  var PassThrough = import.meta.require("stream").PassThrough;
  var Cookies = require_cookies();
  var packageData = require_package();
  var net2 = import.meta.require("net");
  var MAX_REDIRECTS = 5;
  module.exports = function(url, options) {
    return nmfetch(url, options);
  };
  module.exports.Cookies = Cookies;
});

// node_modules/nodemailer/lib/shared/index.js
var require_shared = __commonJS((exports, module) => {
  var resolveStream = function(stream, callback) {
    let responded = false;
    let chunks = [];
    let chunklen = 0;
    stream.on("error", (err) => {
      if (responded) {
        return;
      }
      responded = true;
      callback(err);
    });
    stream.on("readable", () => {
      let chunk;
      while ((chunk = stream.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    stream.on("end", () => {
      if (responded) {
        return;
      }
      responded = true;
      let value15;
      try {
        value15 = Buffer.concat(chunks, chunklen);
      } catch (E) {
        return callback(E);
      }
      callback(null, value15);
    });
  };
  var createDefaultLogger = function(levels) {
    let levelMaxLen = 0;
    let levelNames = new Map;
    levels.forEach((level) => {
      if (level.length > levelMaxLen) {
        levelMaxLen = level.length;
      }
    });
    levels.forEach((level) => {
      let levelName = level.toUpperCase();
      if (levelName.length < levelMaxLen) {
        levelName += " ".repeat(levelMaxLen - levelName.length);
      }
      levelNames.set(level, levelName);
    });
    let print = (level, entry, message, ...args) => {
      let prefix = "";
      if (entry) {
        if (entry.tnx === "server") {
          prefix = "S: ";
        } else if (entry.tnx === "client") {
          prefix = "C: ";
        }
        if (entry.sid) {
          prefix = "[" + entry.sid + "] " + prefix;
        }
        if (entry.cid) {
          prefix = "[#" + entry.cid + "] " + prefix;
        }
      }
      message = util2.format(message, ...args);
      message.split(/\r?\n/).forEach((line) => {
        console.log("[%s] %s %s", new Date().toISOString().substr(0, 19).replace(/T/, " "), levelNames.get(level), prefix + line);
      });
    };
    let logger3 = {};
    levels.forEach((level) => {
      logger3[level] = print.bind(null, level);
    });
    return logger3;
  };
  var urllib = import.meta.require("url");
  var util2 = import.meta.require("util");
  var fs2 = import.meta.require("fs");
  var nmfetch = require_fetch();
  var dns = import.meta.require("dns");
  var net2 = import.meta.require("net");
  var os2 = import.meta.require("os");
  var DNS_TTL = 5 * 60 * 1000;
  var networkInterfaces;
  try {
    networkInterfaces = os2.networkInterfaces();
  } catch (err) {
  }
  exports.networkInterfaces = networkInterfaces;
  var isFamilySupported = (family, allowInternal) => {
    let networkInterfaces2 = exports.networkInterfaces;
    if (!networkInterfaces2) {
      return true;
    }
    const familySupported = Object.keys(networkInterfaces2).map((key) => networkInterfaces2[key]).reduce((acc, val) => acc.concat(val), []).filter((i) => !i.internal || allowInternal).filter((i) => i.family === "IPv" + family || i.family === family).length > 0;
    return familySupported;
  };
  var resolver = (family, hostname, options, callback) => {
    options = options || {};
    const familySupported = isFamilySupported(family, options.allowInternalNetworkInterfaces);
    if (!familySupported) {
      return callback(null, []);
    }
    const resolver2 = dns.Resolver ? new dns.Resolver(options) : dns;
    resolver2["resolve" + family](hostname, (err, addresses) => {
      if (err) {
        switch (err.code) {
          case dns.NODATA:
          case dns.NOTFOUND:
          case dns.NOTIMP:
          case dns.SERVFAIL:
          case dns.CONNREFUSED:
          case dns.REFUSED:
          case "EAI_AGAIN":
            return callback(null, []);
        }
        return callback(err);
      }
      return callback(null, Array.isArray(addresses) ? addresses : [].concat(addresses || []));
    });
  };
  var dnsCache = exports.dnsCache = new Map;
  var formatDNSValue = (value15, extra) => {
    if (!value15) {
      return Object.assign({}, extra || {});
    }
    return Object.assign({
      servername: value15.servername,
      host: !value15.addresses || !value15.addresses.length ? null : value15.addresses.length === 1 ? value15.addresses[0] : value15.addresses[Math.floor(Math.random() * value15.addresses.length)]
    }, extra || {});
  };
  exports.resolveHostname = (options, callback) => {
    options = options || {};
    if (!options.host && options.servername) {
      options.host = options.servername;
    }
    if (!options.host || net2.isIP(options.host)) {
      let value15 = {
        addresses: [options.host],
        servername: options.servername || false
      };
      return callback(null, formatDNSValue(value15, {
        cached: false
      }));
    }
    let cached;
    if (dnsCache.has(options.host)) {
      cached = dnsCache.get(options.host);
      if (!cached.expires || cached.expires >= Date.now()) {
        return callback(null, formatDNSValue(cached.value, {
          cached: true
        }));
      }
    }
    resolver(4, options.host, options, (err, addresses) => {
      if (err) {
        if (cached) {
          return callback(null, formatDNSValue(cached.value, {
            cached: true,
            error: err
          }));
        }
        return callback(err);
      }
      if (addresses && addresses.length) {
        let value15 = {
          addresses,
          servername: options.servername || options.host
        };
        dnsCache.set(options.host, {
          value: value15,
          expires: Date.now() + (options.dnsTtl || DNS_TTL)
        });
        return callback(null, formatDNSValue(value15, {
          cached: false
        }));
      }
      resolver(6, options.host, options, (err2, addresses2) => {
        if (err2) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err2
            }));
          }
          return callback(err2);
        }
        if (addresses2 && addresses2.length) {
          let value15 = {
            addresses: addresses2,
            servername: options.servername || options.host
          };
          dnsCache.set(options.host, {
            value: value15,
            expires: Date.now() + (options.dnsTtl || DNS_TTL)
          });
          return callback(null, formatDNSValue(value15, {
            cached: false
          }));
        }
        try {
          dns.lookup(options.host, { all: true }, (err3, addresses3) => {
            if (err3) {
              if (cached) {
                return callback(null, formatDNSValue(cached.value, {
                  cached: true,
                  error: err3
                }));
              }
              return callback(err3);
            }
            let address = addresses3 ? addresses3.filter((addr) => isFamilySupported(addr.family)).map((addr) => addr.address).shift() : false;
            if (addresses3 && addresses3.length && !address) {
              console.warn(`Failed to resolve IPv${addresses3[0].family} addresses with current network`);
            }
            if (!address && cached) {
              return callback(null, formatDNSValue(cached.value, {
                cached: true
              }));
            }
            let value15 = {
              addresses: address ? [address] : [options.host],
              servername: options.servername || options.host
            };
            dnsCache.set(options.host, {
              value: value15,
              expires: Date.now() + (options.dnsTtl || DNS_TTL)
            });
            return callback(null, formatDNSValue(value15, {
              cached: false
            }));
          });
        } catch (err3) {
          if (cached) {
            return callback(null, formatDNSValue(cached.value, {
              cached: true,
              error: err3
            }));
          }
          return callback(err3);
        }
      });
    });
  };
  exports.parseConnectionUrl = (str) => {
    str = str || "";
    let options = {};
    [urllib.parse(str, true)].forEach((url) => {
      let auth;
      switch (url.protocol) {
        case "smtp:":
          options.secure = false;
          break;
        case "smtps:":
          options.secure = true;
          break;
        case "direct:":
          options.direct = true;
          break;
      }
      if (!isNaN(url.port) && Number(url.port)) {
        options.port = Number(url.port);
      }
      if (url.hostname) {
        options.host = url.hostname;
      }
      if (url.auth) {
        auth = url.auth.split(":");
        if (!options.auth) {
          options.auth = {};
        }
        options.auth.user = auth.shift();
        options.auth.pass = auth.join(":");
      }
      Object.keys(url.query || {}).forEach((key) => {
        let obj = options;
        let lKey = key;
        let value15 = url.query[key];
        if (!isNaN(value15)) {
          value15 = Number(value15);
        }
        switch (value15) {
          case "true":
            value15 = true;
            break;
          case "false":
            value15 = false;
            break;
        }
        if (key.indexOf("tls.") === 0) {
          lKey = key.substr(4);
          if (!options.tls) {
            options.tls = {};
          }
          obj = options.tls;
        } else if (key.indexOf(".") >= 0) {
          return;
        }
        if (!(lKey in obj)) {
          obj[lKey] = value15;
        }
      });
    });
    return options;
  };
  exports._logFunc = (logger3, level, defaults, data, message, ...args) => {
    let entry = {};
    Object.keys(defaults || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = defaults[key];
      }
    });
    Object.keys(data || {}).forEach((key) => {
      if (key !== "level") {
        entry[key] = data[key];
      }
    });
    logger3[level](entry, message, ...args);
  };
  exports.getLogger = (options, defaults) => {
    options = options || {};
    let response = {};
    let levels = ["trace", "debug", "info", "warn", "error", "fatal"];
    if (!options.logger) {
      levels.forEach((level) => {
        response[level] = () => false;
      });
      return response;
    }
    let logger3 = options.logger;
    if (options.logger === true) {
      logger3 = createDefaultLogger(levels);
    }
    levels.forEach((level) => {
      response[level] = (data, message, ...args) => {
        exports._logFunc(logger3, level, defaults, data, message, ...args);
      };
    });
    return response;
  };
  exports.callbackPromise = (resolve, reject) => function() {
    let args = Array.from(arguments);
    let err = args.shift();
    if (err) {
      reject(err);
    } else {
      resolve(...args);
    }
  };
  exports.parseDataURI = (uri) => {
    let input = uri;
    let commaPos = input.indexOf(",");
    if (!commaPos) {
      return uri;
    }
    let data = input.substring(commaPos + 1);
    let metaStr = input.substring("data:".length, commaPos);
    let encoding;
    let metaEntries = metaStr.split(";");
    let lastMetaEntry = metaEntries.length > 1 ? metaEntries[metaEntries.length - 1] : false;
    if (lastMetaEntry && lastMetaEntry.indexOf("=") < 0) {
      encoding = lastMetaEntry.toLowerCase();
      metaEntries.pop();
    }
    let contentType = metaEntries.shift() || "application/octet-stream";
    let params = {};
    for (let entry of metaEntries) {
      let sep = entry.indexOf("=");
      if (sep >= 0) {
        let key = entry.substring(0, sep);
        let value15 = entry.substring(sep + 1);
        params[key] = value15;
      }
    }
    switch (encoding) {
      case "base64":
        data = Buffer.from(data, "base64");
        break;
      case "utf8":
        data = Buffer.from(data);
        break;
      default:
        try {
          data = Buffer.from(decodeURIComponent(data));
        } catch (err) {
          data = Buffer.from(data);
        }
        data = Buffer.from(data);
    }
    return { data, encoding, contentType, params };
  };
  exports.resolveContent = (data, key, callback) => {
    let promise5;
    if (!callback) {
      promise5 = new Promise((resolve, reject) => {
        callback = exports.callbackPromise(resolve, reject);
      });
    }
    let content = data && data[key] && data[key].content || data[key];
    let contentStream;
    let encoding = (typeof data[key] === "object" && data[key].encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
    if (!content) {
      return callback(null, content);
    }
    if (typeof content === "object") {
      if (typeof content.pipe === "function") {
        return resolveStream(content, (err, value15) => {
          if (err) {
            return callback(err);
          }
          if (data[key].content) {
            data[key].content = value15;
          } else {
            data[key] = value15;
          }
          callback(null, value15);
        });
      } else if (/^https?:\/\//i.test(content.path || content.href)) {
        contentStream = nmfetch(content.path || content.href);
        return resolveStream(contentStream, callback);
      } else if (/^data:/i.test(content.path || content.href)) {
        let parsedDataUri = exports.parseDataURI(content.path || content.href);
        if (!parsedDataUri || !parsedDataUri.data) {
          return callback(null, Buffer.from(0));
        }
        return callback(null, parsedDataUri.data);
      } else if (content.path) {
        return resolveStream(fs2.createReadStream(content.path), callback);
      }
    }
    if (typeof data[key].content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
      content = Buffer.from(data[key].content, encoding);
    }
    setImmediate(() => callback(null, content));
    return promise5;
  };
  exports.assign = function() {
    let args = Array.from(arguments);
    let target = args.shift() || {};
    args.forEach((source) => {
      Object.keys(source || {}).forEach((key) => {
        if (["tls", "auth"].includes(key) && source[key] && typeof source[key] === "object") {
          if (!target[key]) {
            target[key] = {};
          }
          Object.keys(source[key]).forEach((subKey) => {
            target[key][subKey] = source[key][subKey];
          });
        } else {
          target[key] = source[key];
        }
      });
    });
    return target;
  };
  exports.encodeXText = (str) => {
    if (!/[^\x21-\x2A\x2C-\x3C\x3E-\x7E]/.test(str)) {
      return str;
    }
    let buf = Buffer.from(str);
    let result2 = "";
    for (let i = 0, len = buf.length;i < len; i++) {
      let c2 = buf[i];
      if (c2 < 33 || c2 > 126 || c2 === 43 || c2 === 61) {
        result2 += "+" + (c2 < 16 ? "0" : "") + c2.toString(16).toUpperCase();
      } else {
        result2 += String.fromCharCode(c2);
      }
    }
    return result2;
  };
});

// node_modules/nodemailer/lib/mime-funcs/mime-types.js
var require_mime_types = __commonJS((exports, module) => {
  var path = import.meta.require("path");
  var defaultMimeType = "application/octet-stream";
  var defaultExtension = "bin";
  var mimeTypes = new Map([
    ["application/acad", "dwg"],
    ["application/applixware", "aw"],
    ["application/arj", "arj"],
    ["application/atom+xml", "xml"],
    ["application/atomcat+xml", "atomcat"],
    ["application/atomsvc+xml", "atomsvc"],
    ["application/base64", ["mm", "mme"]],
    ["application/binhex", "hqx"],
    ["application/binhex4", "hqx"],
    ["application/book", ["book", "boo"]],
    ["application/ccxml+xml,", "ccxml"],
    ["application/cdf", "cdf"],
    ["application/cdmi-capability", "cdmia"],
    ["application/cdmi-container", "cdmic"],
    ["application/cdmi-domain", "cdmid"],
    ["application/cdmi-object", "cdmio"],
    ["application/cdmi-queue", "cdmiq"],
    ["application/clariscad", "ccad"],
    ["application/commonground", "dp"],
    ["application/cu-seeme", "cu"],
    ["application/davmount+xml", "davmount"],
    ["application/drafting", "drw"],
    ["application/dsptype", "tsp"],
    ["application/dssc+der", "dssc"],
    ["application/dssc+xml", "xdssc"],
    ["application/dxf", "dxf"],
    ["application/ecmascript", ["js", "es"]],
    ["application/emma+xml", "emma"],
    ["application/envoy", "evy"],
    ["application/epub+zip", "epub"],
    ["application/excel", ["xls", "xl", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/exi", "exi"],
    ["application/font-tdpfr", "pfr"],
    ["application/fractals", "fif"],
    ["application/freeloader", "frl"],
    ["application/futuresplash", "spl"],
    ["application/gnutar", "tgz"],
    ["application/groupwise", "vew"],
    ["application/hlp", "hlp"],
    ["application/hta", "hta"],
    ["application/hyperstudio", "stk"],
    ["application/i-deas", "unv"],
    ["application/iges", ["iges", "igs"]],
    ["application/inf", "inf"],
    ["application/internet-property-stream", "acx"],
    ["application/ipfix", "ipfix"],
    ["application/java", "class"],
    ["application/java-archive", "jar"],
    ["application/java-byte-code", "class"],
    ["application/java-serialized-object", "ser"],
    ["application/java-vm", "class"],
    ["application/javascript", "js"],
    ["application/json", "json"],
    ["application/lha", "lha"],
    ["application/lzx", "lzx"],
    ["application/mac-binary", "bin"],
    ["application/mac-binhex", "hqx"],
    ["application/mac-binhex40", "hqx"],
    ["application/mac-compactpro", "cpt"],
    ["application/macbinary", "bin"],
    ["application/mads+xml", "mads"],
    ["application/marc", "mrc"],
    ["application/marcxml+xml", "mrcx"],
    ["application/mathematica", "ma"],
    ["application/mathml+xml", "mathml"],
    ["application/mbedlet", "mbd"],
    ["application/mbox", "mbox"],
    ["application/mcad", "mcd"],
    ["application/mediaservercontrol+xml", "mscml"],
    ["application/metalink4+xml", "meta4"],
    ["application/mets+xml", "mets"],
    ["application/mime", "aps"],
    ["application/mods+xml", "mods"],
    ["application/mp21", "m21"],
    ["application/mp4", "mp4"],
    ["application/mspowerpoint", ["ppt", "pot", "pps", "ppz"]],
    ["application/msword", ["doc", "dot", "w6w", "wiz", "word"]],
    ["application/mswrite", "wri"],
    ["application/mxf", "mxf"],
    ["application/netmc", "mcp"],
    ["application/octet-stream", ["*"]],
    ["application/oda", "oda"],
    ["application/oebps-package+xml", "opf"],
    ["application/ogg", "ogx"],
    ["application/olescript", "axs"],
    ["application/onenote", "onetoc"],
    ["application/patch-ops-error+xml", "xer"],
    ["application/pdf", "pdf"],
    ["application/pgp-encrypted", "asc"],
    ["application/pgp-signature", "pgp"],
    ["application/pics-rules", "prf"],
    ["application/pkcs-12", "p12"],
    ["application/pkcs-crl", "crl"],
    ["application/pkcs10", "p10"],
    ["application/pkcs7-mime", ["p7c", "p7m"]],
    ["application/pkcs7-signature", "p7s"],
    ["application/pkcs8", "p8"],
    ["application/pkix-attr-cert", "ac"],
    ["application/pkix-cert", ["cer", "crt"]],
    ["application/pkix-crl", "crl"],
    ["application/pkix-pkipath", "pkipath"],
    ["application/pkixcmp", "pki"],
    ["application/plain", "text"],
    ["application/pls+xml", "pls"],
    ["application/postscript", ["ps", "ai", "eps"]],
    ["application/powerpoint", "ppt"],
    ["application/pro_eng", ["part", "prt"]],
    ["application/prs.cww", "cww"],
    ["application/pskc+xml", "pskcxml"],
    ["application/rdf+xml", "rdf"],
    ["application/reginfo+xml", "rif"],
    ["application/relax-ng-compact-syntax", "rnc"],
    ["application/resource-lists+xml", "rl"],
    ["application/resource-lists-diff+xml", "rld"],
    ["application/ringing-tones", "rng"],
    ["application/rls-services+xml", "rs"],
    ["application/rsd+xml", "rsd"],
    ["application/rss+xml", "xml"],
    ["application/rtf", ["rtf", "rtx"]],
    ["application/sbml+xml", "sbml"],
    ["application/scvp-cv-request", "scq"],
    ["application/scvp-cv-response", "scs"],
    ["application/scvp-vp-request", "spq"],
    ["application/scvp-vp-response", "spp"],
    ["application/sdp", "sdp"],
    ["application/sea", "sea"],
    ["application/set", "set"],
    ["application/set-payment-initiation", "setpay"],
    ["application/set-registration-initiation", "setreg"],
    ["application/shf+xml", "shf"],
    ["application/sla", "stl"],
    ["application/smil", ["smi", "smil"]],
    ["application/smil+xml", "smi"],
    ["application/solids", "sol"],
    ["application/sounder", "sdr"],
    ["application/sparql-query", "rq"],
    ["application/sparql-results+xml", "srx"],
    ["application/srgs", "gram"],
    ["application/srgs+xml", "grxml"],
    ["application/sru+xml", "sru"],
    ["application/ssml+xml", "ssml"],
    ["application/step", ["step", "stp"]],
    ["application/streamingmedia", "ssm"],
    ["application/tei+xml", "tei"],
    ["application/thraud+xml", "tfi"],
    ["application/timestamped-data", "tsd"],
    ["application/toolbook", "tbk"],
    ["application/vda", "vda"],
    ["application/vnd.3gpp.pic-bw-large", "plb"],
    ["application/vnd.3gpp.pic-bw-small", "psb"],
    ["application/vnd.3gpp.pic-bw-var", "pvb"],
    ["application/vnd.3gpp2.tcap", "tcap"],
    ["application/vnd.3m.post-it-notes", "pwn"],
    ["application/vnd.accpac.simply.aso", "aso"],
    ["application/vnd.accpac.simply.imp", "imp"],
    ["application/vnd.acucobol", "acu"],
    ["application/vnd.acucorp", "atc"],
    ["application/vnd.adobe.air-application-installer-package+zip", "air"],
    ["application/vnd.adobe.fxp", "fxp"],
    ["application/vnd.adobe.xdp+xml", "xdp"],
    ["application/vnd.adobe.xfdf", "xfdf"],
    ["application/vnd.ahead.space", "ahead"],
    ["application/vnd.airzip.filesecure.azf", "azf"],
    ["application/vnd.airzip.filesecure.azs", "azs"],
    ["application/vnd.amazon.ebook", "azw"],
    ["application/vnd.americandynamics.acc", "acc"],
    ["application/vnd.amiga.ami", "ami"],
    ["application/vnd.android.package-archive", "apk"],
    ["application/vnd.anser-web-certificate-issue-initiation", "cii"],
    ["application/vnd.anser-web-funds-transfer-initiation", "fti"],
    ["application/vnd.antix.game-component", "atx"],
    ["application/vnd.apple.installer+xml", "mpkg"],
    ["application/vnd.apple.mpegurl", "m3u8"],
    ["application/vnd.aristanetworks.swi", "swi"],
    ["application/vnd.audiograph", "aep"],
    ["application/vnd.blueice.multipass", "mpm"],
    ["application/vnd.bmi", "bmi"],
    ["application/vnd.businessobjects", "rep"],
    ["application/vnd.chemdraw+xml", "cdxml"],
    ["application/vnd.chipnuts.karaoke-mmd", "mmd"],
    ["application/vnd.cinderella", "cdy"],
    ["application/vnd.claymore", "cla"],
    ["application/vnd.cloanto.rp9", "rp9"],
    ["application/vnd.clonk.c4group", "c4g"],
    ["application/vnd.cluetrust.cartomobile-config", "c11amc"],
    ["application/vnd.cluetrust.cartomobile-config-pkg", "c11amz"],
    ["application/vnd.commonspace", "csp"],
    ["application/vnd.contact.cmsg", "cdbcmsg"],
    ["application/vnd.cosmocaller", "cmc"],
    ["application/vnd.crick.clicker", "clkx"],
    ["application/vnd.crick.clicker.keyboard", "clkk"],
    ["application/vnd.crick.clicker.palette", "clkp"],
    ["application/vnd.crick.clicker.template", "clkt"],
    ["application/vnd.crick.clicker.wordbank", "clkw"],
    ["application/vnd.criticaltools.wbs+xml", "wbs"],
    ["application/vnd.ctc-posml", "pml"],
    ["application/vnd.cups-ppd", "ppd"],
    ["application/vnd.curl.car", "car"],
    ["application/vnd.curl.pcurl", "pcurl"],
    ["application/vnd.data-vision.rdz", "rdz"],
    ["application/vnd.denovo.fcselayout-link", "fe_launch"],
    ["application/vnd.dna", "dna"],
    ["application/vnd.dolby.mlp", "mlp"],
    ["application/vnd.dpgraph", "dpg"],
    ["application/vnd.dreamfactory", "dfac"],
    ["application/vnd.dvb.ait", "ait"],
    ["application/vnd.dvb.service", "svc"],
    ["application/vnd.dynageo", "geo"],
    ["application/vnd.ecowin.chart", "mag"],
    ["application/vnd.enliven", "nml"],
    ["application/vnd.epson.esf", "esf"],
    ["application/vnd.epson.msf", "msf"],
    ["application/vnd.epson.quickanime", "qam"],
    ["application/vnd.epson.salt", "slt"],
    ["application/vnd.epson.ssf", "ssf"],
    ["application/vnd.eszigno3+xml", "es3"],
    ["application/vnd.ezpix-album", "ez2"],
    ["application/vnd.ezpix-package", "ez3"],
    ["application/vnd.fdf", "fdf"],
    ["application/vnd.fdsn.seed", "seed"],
    ["application/vnd.flographit", "gph"],
    ["application/vnd.fluxtime.clip", "ftc"],
    ["application/vnd.framemaker", "fm"],
    ["application/vnd.frogans.fnc", "fnc"],
    ["application/vnd.frogans.ltf", "ltf"],
    ["application/vnd.fsc.weblaunch", "fsc"],
    ["application/vnd.fujitsu.oasys", "oas"],
    ["application/vnd.fujitsu.oasys2", "oa2"],
    ["application/vnd.fujitsu.oasys3", "oa3"],
    ["application/vnd.fujitsu.oasysgp", "fg5"],
    ["application/vnd.fujitsu.oasysprs", "bh2"],
    ["application/vnd.fujixerox.ddd", "ddd"],
    ["application/vnd.fujixerox.docuworks", "xdw"],
    ["application/vnd.fujixerox.docuworks.binder", "xbd"],
    ["application/vnd.fuzzysheet", "fzs"],
    ["application/vnd.genomatix.tuxedo", "txd"],
    ["application/vnd.geogebra.file", "ggb"],
    ["application/vnd.geogebra.tool", "ggt"],
    ["application/vnd.geometry-explorer", "gex"],
    ["application/vnd.geonext", "gxt"],
    ["application/vnd.geoplan", "g2w"],
    ["application/vnd.geospace", "g3w"],
    ["application/vnd.gmx", "gmx"],
    ["application/vnd.google-earth.kml+xml", "kml"],
    ["application/vnd.google-earth.kmz", "kmz"],
    ["application/vnd.grafeq", "gqf"],
    ["application/vnd.groove-account", "gac"],
    ["application/vnd.groove-help", "ghf"],
    ["application/vnd.groove-identity-message", "gim"],
    ["application/vnd.groove-injector", "grv"],
    ["application/vnd.groove-tool-message", "gtm"],
    ["application/vnd.groove-tool-template", "tpl"],
    ["application/vnd.groove-vcard", "vcg"],
    ["application/vnd.hal+xml", "hal"],
    ["application/vnd.handheld-entertainment+xml", "zmm"],
    ["application/vnd.hbci", "hbci"],
    ["application/vnd.hhe.lesson-player", "les"],
    ["application/vnd.hp-hpgl", ["hgl", "hpg", "hpgl"]],
    ["application/vnd.hp-hpid", "hpid"],
    ["application/vnd.hp-hps", "hps"],
    ["application/vnd.hp-jlyt", "jlt"],
    ["application/vnd.hp-pcl", "pcl"],
    ["application/vnd.hp-pclxl", "pclxl"],
    ["application/vnd.hydrostatix.sof-data", "sfd-hdstx"],
    ["application/vnd.hzn-3d-crossword", "x3d"],
    ["application/vnd.ibm.minipay", "mpy"],
    ["application/vnd.ibm.modcap", "afp"],
    ["application/vnd.ibm.rights-management", "irm"],
    ["application/vnd.ibm.secure-container", "sc"],
    ["application/vnd.iccprofile", "icc"],
    ["application/vnd.igloader", "igl"],
    ["application/vnd.immervision-ivp", "ivp"],
    ["application/vnd.immervision-ivu", "ivu"],
    ["application/vnd.insors.igm", "igm"],
    ["application/vnd.intercon.formnet", "xpw"],
    ["application/vnd.intergeo", "i2g"],
    ["application/vnd.intu.qbo", "qbo"],
    ["application/vnd.intu.qfx", "qfx"],
    ["application/vnd.ipunplugged.rcprofile", "rcprofile"],
    ["application/vnd.irepository.package+xml", "irp"],
    ["application/vnd.is-xpr", "xpr"],
    ["application/vnd.isac.fcs", "fcs"],
    ["application/vnd.jam", "jam"],
    ["application/vnd.jcp.javame.midlet-rms", "rms"],
    ["application/vnd.jisp", "jisp"],
    ["application/vnd.joost.joda-archive", "joda"],
    ["application/vnd.kahootz", "ktz"],
    ["application/vnd.kde.karbon", "karbon"],
    ["application/vnd.kde.kchart", "chrt"],
    ["application/vnd.kde.kformula", "kfo"],
    ["application/vnd.kde.kivio", "flw"],
    ["application/vnd.kde.kontour", "kon"],
    ["application/vnd.kde.kpresenter", "kpr"],
    ["application/vnd.kde.kspread", "ksp"],
    ["application/vnd.kde.kword", "kwd"],
    ["application/vnd.kenameaapp", "htke"],
    ["application/vnd.kidspiration", "kia"],
    ["application/vnd.kinar", "kne"],
    ["application/vnd.koan", "skp"],
    ["application/vnd.kodak-descriptor", "sse"],
    ["application/vnd.las.las+xml", "lasxml"],
    ["application/vnd.llamagraphics.life-balance.desktop", "lbd"],
    ["application/vnd.llamagraphics.life-balance.exchange+xml", "lbe"],
    ["application/vnd.lotus-1-2-3", "123"],
    ["application/vnd.lotus-approach", "apr"],
    ["application/vnd.lotus-freelance", "pre"],
    ["application/vnd.lotus-notes", "nsf"],
    ["application/vnd.lotus-organizer", "org"],
    ["application/vnd.lotus-screencam", "scm"],
    ["application/vnd.lotus-wordpro", "lwp"],
    ["application/vnd.macports.portpkg", "portpkg"],
    ["application/vnd.mcd", "mcd"],
    ["application/vnd.medcalcdata", "mc1"],
    ["application/vnd.mediastation.cdkey", "cdkey"],
    ["application/vnd.mfer", "mwf"],
    ["application/vnd.mfmp", "mfm"],
    ["application/vnd.micrografx.flo", "flo"],
    ["application/vnd.micrografx.igx", "igx"],
    ["application/vnd.mif", "mif"],
    ["application/vnd.mobius.daf", "daf"],
    ["application/vnd.mobius.dis", "dis"],
    ["application/vnd.mobius.mbk", "mbk"],
    ["application/vnd.mobius.mqy", "mqy"],
    ["application/vnd.mobius.msl", "msl"],
    ["application/vnd.mobius.plc", "plc"],
    ["application/vnd.mobius.txf", "txf"],
    ["application/vnd.mophun.application", "mpn"],
    ["application/vnd.mophun.certificate", "mpc"],
    ["application/vnd.mozilla.xul+xml", "xul"],
    ["application/vnd.ms-artgalry", "cil"],
    ["application/vnd.ms-cab-compressed", "cab"],
    ["application/vnd.ms-excel", ["xls", "xla", "xlc", "xlm", "xlt", "xlw", "xlb", "xll"]],
    ["application/vnd.ms-excel.addin.macroenabled.12", "xlam"],
    ["application/vnd.ms-excel.sheet.binary.macroenabled.12", "xlsb"],
    ["application/vnd.ms-excel.sheet.macroenabled.12", "xlsm"],
    ["application/vnd.ms-excel.template.macroenabled.12", "xltm"],
    ["application/vnd.ms-fontobject", "eot"],
    ["application/vnd.ms-htmlhelp", "chm"],
    ["application/vnd.ms-ims", "ims"],
    ["application/vnd.ms-lrm", "lrm"],
    ["application/vnd.ms-officetheme", "thmx"],
    ["application/vnd.ms-outlook", "msg"],
    ["application/vnd.ms-pki.certstore", "sst"],
    ["application/vnd.ms-pki.pko", "pko"],
    ["application/vnd.ms-pki.seccat", "cat"],
    ["application/vnd.ms-pki.stl", "stl"],
    ["application/vnd.ms-pkicertstore", "sst"],
    ["application/vnd.ms-pkiseccat", "cat"],
    ["application/vnd.ms-pkistl", "stl"],
    ["application/vnd.ms-powerpoint", ["ppt", "pot", "pps", "ppa", "pwz"]],
    ["application/vnd.ms-powerpoint.addin.macroenabled.12", "ppam"],
    ["application/vnd.ms-powerpoint.presentation.macroenabled.12", "pptm"],
    ["application/vnd.ms-powerpoint.slide.macroenabled.12", "sldm"],
    ["application/vnd.ms-powerpoint.slideshow.macroenabled.12", "ppsm"],
    ["application/vnd.ms-powerpoint.template.macroenabled.12", "potm"],
    ["application/vnd.ms-project", "mpp"],
    ["application/vnd.ms-word.document.macroenabled.12", "docm"],
    ["application/vnd.ms-word.template.macroenabled.12", "dotm"],
    ["application/vnd.ms-works", ["wks", "wcm", "wdb", "wps"]],
    ["application/vnd.ms-wpl", "wpl"],
    ["application/vnd.ms-xpsdocument", "xps"],
    ["application/vnd.mseq", "mseq"],
    ["application/vnd.musician", "mus"],
    ["application/vnd.muvee.style", "msty"],
    ["application/vnd.neurolanguage.nlu", "nlu"],
    ["application/vnd.noblenet-directory", "nnd"],
    ["application/vnd.noblenet-sealer", "nns"],
    ["application/vnd.noblenet-web", "nnw"],
    ["application/vnd.nokia.configuration-message", "ncm"],
    ["application/vnd.nokia.n-gage.data", "ngdat"],
    ["application/vnd.nokia.n-gage.symbian.install", "n-gage"],
    ["application/vnd.nokia.radio-preset", "rpst"],
    ["application/vnd.nokia.radio-presets", "rpss"],
    ["application/vnd.nokia.ringing-tone", "rng"],
    ["application/vnd.novadigm.edm", "edm"],
    ["application/vnd.novadigm.edx", "edx"],
    ["application/vnd.novadigm.ext", "ext"],
    ["application/vnd.oasis.opendocument.chart", "odc"],
    ["application/vnd.oasis.opendocument.chart-template", "otc"],
    ["application/vnd.oasis.opendocument.database", "odb"],
    ["application/vnd.oasis.opendocument.formula", "odf"],
    ["application/vnd.oasis.opendocument.formula-template", "odft"],
    ["application/vnd.oasis.opendocument.graphics", "odg"],
    ["application/vnd.oasis.opendocument.graphics-template", "otg"],
    ["application/vnd.oasis.opendocument.image", "odi"],
    ["application/vnd.oasis.opendocument.image-template", "oti"],
    ["application/vnd.oasis.opendocument.presentation", "odp"],
    ["application/vnd.oasis.opendocument.presentation-template", "otp"],
    ["application/vnd.oasis.opendocument.spreadsheet", "ods"],
    ["application/vnd.oasis.opendocument.spreadsheet-template", "ots"],
    ["application/vnd.oasis.opendocument.text", "odt"],
    ["application/vnd.oasis.opendocument.text-master", "odm"],
    ["application/vnd.oasis.opendocument.text-template", "ott"],
    ["application/vnd.oasis.opendocument.text-web", "oth"],
    ["application/vnd.olpc-sugar", "xo"],
    ["application/vnd.oma.dd2+xml", "dd2"],
    ["application/vnd.openofficeorg.extension", "oxt"],
    ["application/vnd.openxmlformats-officedocument.presentationml.presentation", "pptx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slide", "sldx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.slideshow", "ppsx"],
    ["application/vnd.openxmlformats-officedocument.presentationml.template", "potx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "xlsx"],
    ["application/vnd.openxmlformats-officedocument.spreadsheetml.template", "xltx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.document", "docx"],
    ["application/vnd.openxmlformats-officedocument.wordprocessingml.template", "dotx"],
    ["application/vnd.osgeo.mapguide.package", "mgp"],
    ["application/vnd.osgi.dp", "dp"],
    ["application/vnd.palm", "pdb"],
    ["application/vnd.pawaafile", "paw"],
    ["application/vnd.pg.format", "str"],
    ["application/vnd.pg.osasli", "ei6"],
    ["application/vnd.picsel", "efif"],
    ["application/vnd.pmi.widget", "wg"],
    ["application/vnd.pocketlearn", "plf"],
    ["application/vnd.powerbuilder6", "pbd"],
    ["application/vnd.previewsystems.box", "box"],
    ["application/vnd.proteus.magazine", "mgz"],
    ["application/vnd.publishare-delta-tree", "qps"],
    ["application/vnd.pvi.ptid1", "ptid"],
    ["application/vnd.quark.quarkxpress", "qxd"],
    ["application/vnd.realvnc.bed", "bed"],
    ["application/vnd.recordare.musicxml", "mxl"],
    ["application/vnd.recordare.musicxml+xml", "musicxml"],
    ["application/vnd.rig.cryptonote", "cryptonote"],
    ["application/vnd.rim.cod", "cod"],
    ["application/vnd.rn-realmedia", "rm"],
    ["application/vnd.rn-realplayer", "rnx"],
    ["application/vnd.route66.link66+xml", "link66"],
    ["application/vnd.sailingtracker.track", "st"],
    ["application/vnd.seemail", "see"],
    ["application/vnd.sema", "sema"],
    ["application/vnd.semd", "semd"],
    ["application/vnd.semf", "semf"],
    ["application/vnd.shana.informed.formdata", "ifm"],
    ["application/vnd.shana.informed.formtemplate", "itp"],
    ["application/vnd.shana.informed.interchange", "iif"],
    ["application/vnd.shana.informed.package", "ipk"],
    ["application/vnd.simtech-mindmapper", "twd"],
    ["application/vnd.smaf", "mmf"],
    ["application/vnd.smart.teacher", "teacher"],
    ["application/vnd.solent.sdkm+xml", "sdkm"],
    ["application/vnd.spotfire.dxp", "dxp"],
    ["application/vnd.spotfire.sfs", "sfs"],
    ["application/vnd.stardivision.calc", "sdc"],
    ["application/vnd.stardivision.draw", "sda"],
    ["application/vnd.stardivision.impress", "sdd"],
    ["application/vnd.stardivision.math", "smf"],
    ["application/vnd.stardivision.writer", "sdw"],
    ["application/vnd.stardivision.writer-global", "sgl"],
    ["application/vnd.stepmania.stepchart", "sm"],
    ["application/vnd.sun.xml.calc", "sxc"],
    ["application/vnd.sun.xml.calc.template", "stc"],
    ["application/vnd.sun.xml.draw", "sxd"],
    ["application/vnd.sun.xml.draw.template", "std"],
    ["application/vnd.sun.xml.impress", "sxi"],
    ["application/vnd.sun.xml.impress.template", "sti"],
    ["application/vnd.sun.xml.math", "sxm"],
    ["application/vnd.sun.xml.writer", "sxw"],
    ["application/vnd.sun.xml.writer.global", "sxg"],
    ["application/vnd.sun.xml.writer.template", "stw"],
    ["application/vnd.sus-calendar", "sus"],
    ["application/vnd.svd", "svd"],
    ["application/vnd.symbian.install", "sis"],
    ["application/vnd.syncml+xml", "xsm"],
    ["application/vnd.syncml.dm+wbxml", "bdm"],
    ["application/vnd.syncml.dm+xml", "xdm"],
    ["application/vnd.tao.intent-module-archive", "tao"],
    ["application/vnd.tmobile-livetv", "tmo"],
    ["application/vnd.trid.tpt", "tpt"],
    ["application/vnd.triscape.mxs", "mxs"],
    ["application/vnd.trueapp", "tra"],
    ["application/vnd.ufdl", "ufd"],
    ["application/vnd.uiq.theme", "utz"],
    ["application/vnd.umajin", "umj"],
    ["application/vnd.unity", "unityweb"],
    ["application/vnd.uoml+xml", "uoml"],
    ["application/vnd.vcx", "vcx"],
    ["application/vnd.visio", "vsd"],
    ["application/vnd.visionary", "vis"],
    ["application/vnd.vsf", "vsf"],
    ["application/vnd.wap.wbxml", "wbxml"],
    ["application/vnd.wap.wmlc", "wmlc"],
    ["application/vnd.wap.wmlscriptc", "wmlsc"],
    ["application/vnd.webturbo", "wtb"],
    ["application/vnd.wolfram.player", "nbp"],
    ["application/vnd.wordperfect", "wpd"],
    ["application/vnd.wqd", "wqd"],
    ["application/vnd.wt.stf", "stf"],
    ["application/vnd.xara", ["web", "xar"]],
    ["application/vnd.xfdl", "xfdl"],
    ["application/vnd.yamaha.hv-dic", "hvd"],
    ["application/vnd.yamaha.hv-script", "hvs"],
    ["application/vnd.yamaha.hv-voice", "hvp"],
    ["application/vnd.yamaha.openscoreformat", "osf"],
    ["application/vnd.yamaha.openscoreformat.osfpvg+xml", "osfpvg"],
    ["application/vnd.yamaha.smaf-audio", "saf"],
    ["application/vnd.yamaha.smaf-phrase", "spf"],
    ["application/vnd.yellowriver-custom-menu", "cmp"],
    ["application/vnd.zul", "zir"],
    ["application/vnd.zzazz.deck+xml", "zaz"],
    ["application/vocaltec-media-desc", "vmd"],
    ["application/vocaltec-media-file", "vmf"],
    ["application/voicexml+xml", "vxml"],
    ["application/widget", "wgt"],
    ["application/winhlp", "hlp"],
    ["application/wordperfect", ["wp", "wp5", "wp6", "wpd"]],
    ["application/wordperfect6.0", ["w60", "wp5"]],
    ["application/wordperfect6.1", "w61"],
    ["application/wsdl+xml", "wsdl"],
    ["application/wspolicy+xml", "wspolicy"],
    ["application/x-123", "wk1"],
    ["application/x-7z-compressed", "7z"],
    ["application/x-abiword", "abw"],
    ["application/x-ace-compressed", "ace"],
    ["application/x-aim", "aim"],
    ["application/x-authorware-bin", "aab"],
    ["application/x-authorware-map", "aam"],
    ["application/x-authorware-seg", "aas"],
    ["application/x-bcpio", "bcpio"],
    ["application/x-binary", "bin"],
    ["application/x-binhex40", "hqx"],
    ["application/x-bittorrent", "torrent"],
    ["application/x-bsh", ["bsh", "sh", "shar"]],
    ["application/x-bytecode.elisp", "elc"],
    ["application/x-bytecode.python", "pyc"],
    ["application/x-bzip", "bz"],
    ["application/x-bzip2", ["boz", "bz2"]],
    ["application/x-cdf", "cdf"],
    ["application/x-cdlink", "vcd"],
    ["application/x-chat", ["cha", "chat"]],
    ["application/x-chess-pgn", "pgn"],
    ["application/x-cmu-raster", "ras"],
    ["application/x-cocoa", "cco"],
    ["application/x-compactpro", "cpt"],
    ["application/x-compress", "z"],
    ["application/x-compressed", ["tgz", "gz", "z", "zip"]],
    ["application/x-conference", "nsc"],
    ["application/x-cpio", "cpio"],
    ["application/x-cpt", "cpt"],
    ["application/x-csh", "csh"],
    ["application/x-debian-package", "deb"],
    ["application/x-deepv", "deepv"],
    ["application/x-director", ["dir", "dcr", "dxr"]],
    ["application/x-doom", "wad"],
    ["application/x-dtbncx+xml", "ncx"],
    ["application/x-dtbook+xml", "dtb"],
    ["application/x-dtbresource+xml", "res"],
    ["application/x-dvi", "dvi"],
    ["application/x-elc", "elc"],
    ["application/x-envoy", ["env", "evy"]],
    ["application/x-esrehber", "es"],
    ["application/x-excel", ["xls", "xla", "xlb", "xlc", "xld", "xlk", "xll", "xlm", "xlt", "xlv", "xlw"]],
    ["application/x-font-bdf", "bdf"],
    ["application/x-font-ghostscript", "gsf"],
    ["application/x-font-linux-psf", "psf"],
    ["application/x-font-otf", "otf"],
    ["application/x-font-pcf", "pcf"],
    ["application/x-font-snf", "snf"],
    ["application/x-font-ttf", "ttf"],
    ["application/x-font-type1", "pfa"],
    ["application/x-font-woff", "woff"],
    ["application/x-frame", "mif"],
    ["application/x-freelance", "pre"],
    ["application/x-futuresplash", "spl"],
    ["application/x-gnumeric", "gnumeric"],
    ["application/x-gsp", "gsp"],
    ["application/x-gss", "gss"],
    ["application/x-gtar", "gtar"],
    ["application/x-gzip", ["gz", "gzip"]],
    ["application/x-hdf", "hdf"],
    ["application/x-helpfile", ["help", "hlp"]],
    ["application/x-httpd-imap", "imap"],
    ["application/x-ima", "ima"],
    ["application/x-internet-signup", ["ins", "isp"]],
    ["application/x-internett-signup", "ins"],
    ["application/x-inventor", "iv"],
    ["application/x-ip2", "ip"],
    ["application/x-iphone", "iii"],
    ["application/x-java-class", "class"],
    ["application/x-java-commerce", "jcm"],
    ["application/x-java-jnlp-file", "jnlp"],
    ["application/x-javascript", "js"],
    ["application/x-koan", ["skd", "skm", "skp", "skt"]],
    ["application/x-ksh", "ksh"],
    ["application/x-latex", ["latex", "ltx"]],
    ["application/x-lha", "lha"],
    ["application/x-lisp", "lsp"],
    ["application/x-livescreen", "ivy"],
    ["application/x-lotus", "wq1"],
    ["application/x-lotusscreencam", "scm"],
    ["application/x-lzh", "lzh"],
    ["application/x-lzx", "lzx"],
    ["application/x-mac-binhex40", "hqx"],
    ["application/x-macbinary", "bin"],
    ["application/x-magic-cap-package-1.0", "mc$"],
    ["application/x-mathcad", "mcd"],
    ["application/x-meme", "mm"],
    ["application/x-midi", ["mid", "midi"]],
    ["application/x-mif", "mif"],
    ["application/x-mix-transfer", "nix"],
    ["application/x-mobipocket-ebook", "prc"],
    ["application/x-mplayer2", "asx"],
    ["application/x-ms-application", "application"],
    ["application/x-ms-wmd", "wmd"],
    ["application/x-ms-wmz", "wmz"],
    ["application/x-ms-xbap", "xbap"],
    ["application/x-msaccess", "mdb"],
    ["application/x-msbinder", "obd"],
    ["application/x-mscardfile", "crd"],
    ["application/x-msclip", "clp"],
    ["application/x-msdownload", ["exe", "dll"]],
    ["application/x-msexcel", ["xls", "xla", "xlw"]],
    ["application/x-msmediaview", ["mvb", "m13", "m14"]],
    ["application/x-msmetafile", "wmf"],
    ["application/x-msmoney", "mny"],
    ["application/x-mspowerpoint", "ppt"],
    ["application/x-mspublisher", "pub"],
    ["application/x-msschedule", "scd"],
    ["application/x-msterminal", "trm"],
    ["application/x-mswrite", "wri"],
    ["application/x-navi-animation", "ani"],
    ["application/x-navidoc", "nvd"],
    ["application/x-navimap", "map"],
    ["application/x-navistyle", "stl"],
    ["application/x-netcdf", ["cdf", "nc"]],
    ["application/x-newton-compatible-pkg", "pkg"],
    ["application/x-nokia-9000-communicator-add-on-software", "aos"],
    ["application/x-omc", "omc"],
    ["application/x-omcdatamaker", "omcd"],
    ["application/x-omcregerator", "omcr"],
    ["application/x-pagemaker", ["pm4", "pm5"]],
    ["application/x-pcl", "pcl"],
    ["application/x-perfmon", ["pma", "pmc", "pml", "pmr", "pmw"]],
    ["application/x-pixclscript", "plx"],
    ["application/x-pkcs10", "p10"],
    ["application/x-pkcs12", ["p12", "pfx"]],
    ["application/x-pkcs7-certificates", ["p7b", "spc"]],
    ["application/x-pkcs7-certreqresp", "p7r"],
    ["application/x-pkcs7-mime", ["p7m", "p7c"]],
    ["application/x-pkcs7-signature", ["p7s", "p7a"]],
    ["application/x-pointplus", "css"],
    ["application/x-portable-anymap", "pnm"],
    ["application/x-project", ["mpc", "mpt", "mpv", "mpx"]],
    ["application/x-qpro", "wb1"],
    ["application/x-rar-compressed", "rar"],
    ["application/x-rtf", "rtf"],
    ["application/x-sdp", "sdp"],
    ["application/x-sea", "sea"],
    ["application/x-seelogo", "sl"],
    ["application/x-sh", "sh"],
    ["application/x-shar", ["shar", "sh"]],
    ["application/x-shockwave-flash", "swf"],
    ["application/x-silverlight-app", "xap"],
    ["application/x-sit", "sit"],
    ["application/x-sprite", ["spr", "sprite"]],
    ["application/x-stuffit", "sit"],
    ["application/x-stuffitx", "sitx"],
    ["application/x-sv4cpio", "sv4cpio"],
    ["application/x-sv4crc", "sv4crc"],
    ["application/x-tar", "tar"],
    ["application/x-tbook", ["sbk", "tbk"]],
    ["application/x-tcl", "tcl"],
    ["application/x-tex", "tex"],
    ["application/x-tex-tfm", "tfm"],
    ["application/x-texinfo", ["texi", "texinfo"]],
    ["application/x-troff", ["roff", "t", "tr"]],
    ["application/x-troff-man", "man"],
    ["application/x-troff-me", "me"],
    ["application/x-troff-ms", "ms"],
    ["application/x-troff-msvideo", "avi"],
    ["application/x-ustar", "ustar"],
    ["application/x-visio", ["vsd", "vst", "vsw"]],
    ["application/x-vnd.audioexplosion.mzz", "mzz"],
    ["application/x-vnd.ls-xpix", "xpix"],
    ["application/x-vrml", "vrml"],
    ["application/x-wais-source", ["src", "wsrc"]],
    ["application/x-winhelp", "hlp"],
    ["application/x-wintalk", "wtk"],
    ["application/x-world", ["wrl", "svr"]],
    ["application/x-wpwin", "wpd"],
    ["application/x-wri", "wri"],
    ["application/x-x509-ca-cert", ["cer", "crt", "der"]],
    ["application/x-x509-user-cert", "crt"],
    ["application/x-xfig", "fig"],
    ["application/x-xpinstall", "xpi"],
    ["application/x-zip-compressed", "zip"],
    ["application/xcap-diff+xml", "xdf"],
    ["application/xenc+xml", "xenc"],
    ["application/xhtml+xml", "xhtml"],
    ["application/xml", "xml"],
    ["application/xml-dtd", "dtd"],
    ["application/xop+xml", "xop"],
    ["application/xslt+xml", "xslt"],
    ["application/xspf+xml", "xspf"],
    ["application/xv+xml", "mxml"],
    ["application/yang", "yang"],
    ["application/yin+xml", "yin"],
    ["application/ynd.ms-pkipko", "pko"],
    ["application/zip", "zip"],
    ["audio/adpcm", "adp"],
    ["audio/aiff", ["aiff", "aif", "aifc"]],
    ["audio/basic", ["snd", "au"]],
    ["audio/it", "it"],
    ["audio/make", ["funk", "my", "pfunk"]],
    ["audio/make.my.funk", "pfunk"],
    ["audio/mid", ["mid", "rmi"]],
    ["audio/midi", ["midi", "kar", "mid"]],
    ["audio/mod", "mod"],
    ["audio/mp4", "mp4a"],
    ["audio/mpeg", ["mpga", "mp3", "m2a", "mp2", "mpa", "mpg"]],
    ["audio/mpeg3", "mp3"],
    ["audio/nspaudio", ["la", "lma"]],
    ["audio/ogg", "oga"],
    ["audio/s3m", "s3m"],
    ["audio/tsp-audio", "tsi"],
    ["audio/tsplayer", "tsp"],
    ["audio/vnd.dece.audio", "uva"],
    ["audio/vnd.digital-winds", "eol"],
    ["audio/vnd.dra", "dra"],
    ["audio/vnd.dts", "dts"],
    ["audio/vnd.dts.hd", "dtshd"],
    ["audio/vnd.lucent.voice", "lvp"],
    ["audio/vnd.ms-playready.media.pya", "pya"],
    ["audio/vnd.nuera.ecelp4800", "ecelp4800"],
    ["audio/vnd.nuera.ecelp7470", "ecelp7470"],
    ["audio/vnd.nuera.ecelp9600", "ecelp9600"],
    ["audio/vnd.qcelp", "qcp"],
    ["audio/vnd.rip", "rip"],
    ["audio/voc", "voc"],
    ["audio/voxware", "vox"],
    ["audio/wav", "wav"],
    ["audio/webm", "weba"],
    ["audio/x-aac", "aac"],
    ["audio/x-adpcm", "snd"],
    ["audio/x-aiff", ["aiff", "aif", "aifc"]],
    ["audio/x-au", "au"],
    ["audio/x-gsm", ["gsd", "gsm"]],
    ["audio/x-jam", "jam"],
    ["audio/x-liveaudio", "lam"],
    ["audio/x-mid", ["mid", "midi"]],
    ["audio/x-midi", ["midi", "mid"]],
    ["audio/x-mod", "mod"],
    ["audio/x-mpeg", "mp2"],
    ["audio/x-mpeg-3", "mp3"],
    ["audio/x-mpegurl", "m3u"],
    ["audio/x-mpequrl", "m3u"],
    ["audio/x-ms-wax", "wax"],
    ["audio/x-ms-wma", "wma"],
    ["audio/x-nspaudio", ["la", "lma"]],
    ["audio/x-pn-realaudio", ["ra", "ram", "rm", "rmm", "rmp"]],
    ["audio/x-pn-realaudio-plugin", ["ra", "rmp", "rpm"]],
    ["audio/x-psid", "sid"],
    ["audio/x-realaudio", "ra"],
    ["audio/x-twinvq", "vqf"],
    ["audio/x-twinvq-plugin", ["vqe", "vql"]],
    ["audio/x-vnd.audioexplosion.mjuicemediafile", "mjf"],
    ["audio/x-voc", "voc"],
    ["audio/x-wav", "wav"],
    ["audio/xm", "xm"],
    ["chemical/x-cdx", "cdx"],
    ["chemical/x-cif", "cif"],
    ["chemical/x-cmdf", "cmdf"],
    ["chemical/x-cml", "cml"],
    ["chemical/x-csml", "csml"],
    ["chemical/x-pdb", ["pdb", "xyz"]],
    ["chemical/x-xyz", "xyz"],
    ["drawing/x-dwf", "dwf"],
    ["i-world/i-vrml", "ivr"],
    ["image/bmp", ["bmp", "bm"]],
    ["image/cgm", "cgm"],
    ["image/cis-cod", "cod"],
    ["image/cmu-raster", ["ras", "rast"]],
    ["image/fif", "fif"],
    ["image/florian", ["flo", "turbot"]],
    ["image/g3fax", "g3"],
    ["image/gif", "gif"],
    ["image/ief", ["ief", "iefs"]],
    ["image/jpeg", ["jpeg", "jpe", "jpg", "jfif", "jfif-tbnl"]],
    ["image/jutvision", "jut"],
    ["image/ktx", "ktx"],
    ["image/naplps", ["nap", "naplps"]],
    ["image/pict", ["pic", "pict"]],
    ["image/pipeg", "jfif"],
    ["image/pjpeg", ["jfif", "jpe", "jpeg", "jpg"]],
    ["image/png", ["png", "x-png"]],
    ["image/prs.btif", "btif"],
    ["image/svg+xml", "svg"],
    ["image/tiff", ["tif", "tiff"]],
    ["image/vasa", "mcf"],
    ["image/vnd.adobe.photoshop", "psd"],
    ["image/vnd.dece.graphic", "uvi"],
    ["image/vnd.djvu", "djvu"],
    ["image/vnd.dvb.subtitle", "sub"],
    ["image/vnd.dwg", ["dwg", "dxf", "svf"]],
    ["image/vnd.dxf", "dxf"],
    ["image/vnd.fastbidsheet", "fbs"],
    ["image/vnd.fpx", "fpx"],
    ["image/vnd.fst", "fst"],
    ["image/vnd.fujixerox.edmics-mmr", "mmr"],
    ["image/vnd.fujixerox.edmics-rlc", "rlc"],
    ["image/vnd.ms-modi", "mdi"],
    ["image/vnd.net-fpx", ["fpx", "npx"]],
    ["image/vnd.rn-realflash", "rf"],
    ["image/vnd.rn-realpix", "rp"],
    ["image/vnd.wap.wbmp", "wbmp"],
    ["image/vnd.xiff", "xif"],
    ["image/webp", "webp"],
    ["image/x-cmu-raster", "ras"],
    ["image/x-cmx", "cmx"],
    ["image/x-dwg", ["dwg", "dxf", "svf"]],
    ["image/x-freehand", "fh"],
    ["image/x-icon", "ico"],
    ["image/x-jg", "art"],
    ["image/x-jps", "jps"],
    ["image/x-niff", ["niff", "nif"]],
    ["image/x-pcx", "pcx"],
    ["image/x-pict", ["pct", "pic"]],
    ["image/x-portable-anymap", "pnm"],
    ["image/x-portable-bitmap", "pbm"],
    ["image/x-portable-graymap", "pgm"],
    ["image/x-portable-greymap", "pgm"],
    ["image/x-portable-pixmap", "ppm"],
    ["image/x-quicktime", ["qif", "qti", "qtif"]],
    ["image/x-rgb", "rgb"],
    ["image/x-tiff", ["tif", "tiff"]],
    ["image/x-windows-bmp", "bmp"],
    ["image/x-xbitmap", "xbm"],
    ["image/x-xbm", "xbm"],
    ["image/x-xpixmap", ["xpm", "pm"]],
    ["image/x-xwd", "xwd"],
    ["image/x-xwindowdump", "xwd"],
    ["image/xbm", "xbm"],
    ["image/xpm", "xpm"],
    ["message/rfc822", ["eml", "mht", "mhtml", "nws", "mime"]],
    ["model/iges", ["iges", "igs"]],
    ["model/mesh", "msh"],
    ["model/vnd.collada+xml", "dae"],
    ["model/vnd.dwf", "dwf"],
    ["model/vnd.gdl", "gdl"],
    ["model/vnd.gtw", "gtw"],
    ["model/vnd.mts", "mts"],
    ["model/vnd.vtu", "vtu"],
    ["model/vrml", ["vrml", "wrl", "wrz"]],
    ["model/x-pov", "pov"],
    ["multipart/x-gzip", "gzip"],
    ["multipart/x-ustar", "ustar"],
    ["multipart/x-zip", "zip"],
    ["music/crescendo", ["mid", "midi"]],
    ["music/x-karaoke", "kar"],
    ["paleovu/x-pv", "pvu"],
    ["text/asp", "asp"],
    ["text/calendar", "ics"],
    ["text/css", "css"],
    ["text/csv", "csv"],
    ["text/ecmascript", "js"],
    ["text/h323", "323"],
    ["text/html", ["html", "htm", "stm", "acgi", "htmls", "htx", "shtml"]],
    ["text/iuls", "uls"],
    ["text/javascript", "js"],
    ["text/mcf", "mcf"],
    ["text/n3", "n3"],
    ["text/pascal", "pas"],
    [
      "text/plain",
      [
        "txt",
        "bas",
        "c",
        "h",
        "c++",
        "cc",
        "com",
        "conf",
        "cxx",
        "def",
        "f",
        "f90",
        "for",
        "g",
        "hh",
        "idc",
        "jav",
        "java",
        "list",
        "log",
        "lst",
        "m",
        "mar",
        "pl",
        "sdml",
        "text"
      ]
    ],
    ["text/plain-bas", "par"],
    ["text/prs.lines.tag", "dsc"],
    ["text/richtext", ["rtx", "rt", "rtf"]],
    ["text/scriplet", "wsc"],
    ["text/scriptlet", "sct"],
    ["text/sgml", ["sgm", "sgml"]],
    ["text/tab-separated-values", "tsv"],
    ["text/troff", "t"],
    ["text/turtle", "ttl"],
    ["text/uri-list", ["uni", "unis", "uri", "uris"]],
    ["text/vnd.abc", "abc"],
    ["text/vnd.curl", "curl"],
    ["text/vnd.curl.dcurl", "dcurl"],
    ["text/vnd.curl.mcurl", "mcurl"],
    ["text/vnd.curl.scurl", "scurl"],
    ["text/vnd.fly", "fly"],
    ["text/vnd.fmi.flexstor", "flx"],
    ["text/vnd.graphviz", "gv"],
    ["text/vnd.in3d.3dml", "3dml"],
    ["text/vnd.in3d.spot", "spot"],
    ["text/vnd.rn-realtext", "rt"],
    ["text/vnd.sun.j2me.app-descriptor", "jad"],
    ["text/vnd.wap.wml", "wml"],
    ["text/vnd.wap.wmlscript", "wmls"],
    ["text/webviewhtml", "htt"],
    ["text/x-asm", ["asm", "s"]],
    ["text/x-audiosoft-intra", "aip"],
    ["text/x-c", ["c", "cc", "cpp"]],
    ["text/x-component", "htc"],
    ["text/x-fortran", ["for", "f", "f77", "f90"]],
    ["text/x-h", ["h", "hh"]],
    ["text/x-java-source", ["java", "jav"]],
    ["text/x-java-source,java", "java"],
    ["text/x-la-asf", "lsx"],
    ["text/x-m", "m"],
    ["text/x-pascal", "p"],
    ["text/x-script", "hlb"],
    ["text/x-script.csh", "csh"],
    ["text/x-script.elisp", "el"],
    ["text/x-script.guile", "scm"],
    ["text/x-script.ksh", "ksh"],
    ["text/x-script.lisp", "lsp"],
    ["text/x-script.perl", "pl"],
    ["text/x-script.perl-module", "pm"],
    ["text/x-script.phyton", "py"],
    ["text/x-script.rexx", "rexx"],
    ["text/x-script.scheme", "scm"],
    ["text/x-script.sh", "sh"],
    ["text/x-script.tcl", "tcl"],
    ["text/x-script.tcsh", "tcsh"],
    ["text/x-script.zsh", "zsh"],
    ["text/x-server-parsed-html", ["shtml", "ssi"]],
    ["text/x-setext", "etx"],
    ["text/x-sgml", ["sgm", "sgml"]],
    ["text/x-speech", ["spc", "talk"]],
    ["text/x-uil", "uil"],
    ["text/x-uuencode", ["uu", "uue"]],
    ["text/x-vcalendar", "vcs"],
    ["text/x-vcard", "vcf"],
    ["text/xml", "xml"],
    ["video/3gpp", "3gp"],
    ["video/3gpp2", "3g2"],
    ["video/animaflex", "afl"],
    ["video/avi", "avi"],
    ["video/avs-video", "avs"],
    ["video/dl", "dl"],
    ["video/fli", "fli"],
    ["video/gl", "gl"],
    ["video/h261", "h261"],
    ["video/h263", "h263"],
    ["video/h264", "h264"],
    ["video/jpeg", "jpgv"],
    ["video/jpm", "jpm"],
    ["video/mj2", "mj2"],
    ["video/mp4", "mp4"],
    ["video/mpeg", ["mpeg", "mp2", "mpa", "mpe", "mpg", "mpv2", "m1v", "m2v", "mp3"]],
    ["video/msvideo", "avi"],
    ["video/ogg", "ogv"],
    ["video/quicktime", ["mov", "qt", "moov"]],
    ["video/vdo", "vdo"],
    ["video/vivo", ["viv", "vivo"]],
    ["video/vnd.dece.hd", "uvh"],
    ["video/vnd.dece.mobile", "uvm"],
    ["video/vnd.dece.pd", "uvp"],
    ["video/vnd.dece.sd", "uvs"],
    ["video/vnd.dece.video", "uvv"],
    ["video/vnd.fvt", "fvt"],
    ["video/vnd.mpegurl", "mxu"],
    ["video/vnd.ms-playready.media.pyv", "pyv"],
    ["video/vnd.rn-realvideo", "rv"],
    ["video/vnd.uvvu.mp4", "uvu"],
    ["video/vnd.vivo", ["viv", "vivo"]],
    ["video/vosaic", "vos"],
    ["video/webm", "webm"],
    ["video/x-amt-demorun", "xdr"],
    ["video/x-amt-showrun", "xsr"],
    ["video/x-atomic3d-feature", "fmf"],
    ["video/x-dl", "dl"],
    ["video/x-dv", ["dif", "dv"]],
    ["video/x-f4v", "f4v"],
    ["video/x-fli", "fli"],
    ["video/x-flv", "flv"],
    ["video/x-gl", "gl"],
    ["video/x-isvideo", "isu"],
    ["video/x-la-asf", ["lsf", "lsx"]],
    ["video/x-m4v", "m4v"],
    ["video/x-motion-jpeg", "mjpg"],
    ["video/x-mpeg", ["mp3", "mp2"]],
    ["video/x-mpeq2a", "mp2"],
    ["video/x-ms-asf", ["asf", "asr", "asx"]],
    ["video/x-ms-asf-plugin", "asx"],
    ["video/x-ms-wm", "wm"],
    ["video/x-ms-wmv", "wmv"],
    ["video/x-ms-wmx", "wmx"],
    ["video/x-ms-wvx", "wvx"],
    ["video/x-msvideo", "avi"],
    ["video/x-qtc", "qtc"],
    ["video/x-scm", "scm"],
    ["video/x-sgi-movie", ["movie", "mv"]],
    ["windows/metafile", "wmf"],
    ["www/mime", "mime"],
    ["x-conference/x-cooltalk", "ice"],
    ["x-music/x-midi", ["mid", "midi"]],
    ["x-world/x-3dmf", ["3dm", "3dmf", "qd3", "qd3d"]],
    ["x-world/x-svr", "svr"],
    ["x-world/x-vrml", ["flr", "vrml", "wrl", "wrz", "xaf", "xof"]],
    ["x-world/x-vrt", "vrt"],
    ["xgl/drawing", "xgz"],
    ["xgl/movie", "xmz"]
  ]);
  var extensions = new Map([
    ["123", "application/vnd.lotus-1-2-3"],
    ["323", "text/h323"],
    ["*", "application/octet-stream"],
    ["3dm", "x-world/x-3dmf"],
    ["3dmf", "x-world/x-3dmf"],
    ["3dml", "text/vnd.in3d.3dml"],
    ["3g2", "video/3gpp2"],
    ["3gp", "video/3gpp"],
    ["7z", "application/x-7z-compressed"],
    ["a", "application/octet-stream"],
    ["aab", "application/x-authorware-bin"],
    ["aac", "audio/x-aac"],
    ["aam", "application/x-authorware-map"],
    ["aas", "application/x-authorware-seg"],
    ["abc", "text/vnd.abc"],
    ["abw", "application/x-abiword"],
    ["ac", "application/pkix-attr-cert"],
    ["acc", "application/vnd.americandynamics.acc"],
    ["ace", "application/x-ace-compressed"],
    ["acgi", "text/html"],
    ["acu", "application/vnd.acucobol"],
    ["acx", "application/internet-property-stream"],
    ["adp", "audio/adpcm"],
    ["aep", "application/vnd.audiograph"],
    ["afl", "video/animaflex"],
    ["afp", "application/vnd.ibm.modcap"],
    ["ahead", "application/vnd.ahead.space"],
    ["ai", "application/postscript"],
    ["aif", ["audio/aiff", "audio/x-aiff"]],
    ["aifc", ["audio/aiff", "audio/x-aiff"]],
    ["aiff", ["audio/aiff", "audio/x-aiff"]],
    ["aim", "application/x-aim"],
    ["aip", "text/x-audiosoft-intra"],
    ["air", "application/vnd.adobe.air-application-installer-package+zip"],
    ["ait", "application/vnd.dvb.ait"],
    ["ami", "application/vnd.amiga.ami"],
    ["ani", "application/x-navi-animation"],
    ["aos", "application/x-nokia-9000-communicator-add-on-software"],
    ["apk", "application/vnd.android.package-archive"],
    ["application", "application/x-ms-application"],
    ["apr", "application/vnd.lotus-approach"],
    ["aps", "application/mime"],
    ["arc", "application/octet-stream"],
    ["arj", ["application/arj", "application/octet-stream"]],
    ["art", "image/x-jg"],
    ["asf", "video/x-ms-asf"],
    ["asm", "text/x-asm"],
    ["aso", "application/vnd.accpac.simply.aso"],
    ["asp", "text/asp"],
    ["asr", "video/x-ms-asf"],
    ["asx", ["video/x-ms-asf", "application/x-mplayer2", "video/x-ms-asf-plugin"]],
    ["atc", "application/vnd.acucorp"],
    ["atomcat", "application/atomcat+xml"],
    ["atomsvc", "application/atomsvc+xml"],
    ["atx", "application/vnd.antix.game-component"],
    ["au", ["audio/basic", "audio/x-au"]],
    ["avi", ["video/avi", "video/msvideo", "application/x-troff-msvideo", "video/x-msvideo"]],
    ["avs", "video/avs-video"],
    ["aw", "application/applixware"],
    ["axs", "application/olescript"],
    ["azf", "application/vnd.airzip.filesecure.azf"],
    ["azs", "application/vnd.airzip.filesecure.azs"],
    ["azw", "application/vnd.amazon.ebook"],
    ["bas", "text/plain"],
    ["bcpio", "application/x-bcpio"],
    ["bdf", "application/x-font-bdf"],
    ["bdm", "application/vnd.syncml.dm+wbxml"],
    ["bed", "application/vnd.realvnc.bed"],
    ["bh2", "application/vnd.fujitsu.oasysprs"],
    ["bin", ["application/octet-stream", "application/mac-binary", "application/macbinary", "application/x-macbinary", "application/x-binary"]],
    ["bm", "image/bmp"],
    ["bmi", "application/vnd.bmi"],
    ["bmp", ["image/bmp", "image/x-windows-bmp"]],
    ["boo", "application/book"],
    ["book", "application/book"],
    ["box", "application/vnd.previewsystems.box"],
    ["boz", "application/x-bzip2"],
    ["bsh", "application/x-bsh"],
    ["btif", "image/prs.btif"],
    ["bz", "application/x-bzip"],
    ["bz2", "application/x-bzip2"],
    ["c", ["text/plain", "text/x-c"]],
    ["c++", "text/plain"],
    ["c11amc", "application/vnd.cluetrust.cartomobile-config"],
    ["c11amz", "application/vnd.cluetrust.cartomobile-config-pkg"],
    ["c4g", "application/vnd.clonk.c4group"],
    ["cab", "application/vnd.ms-cab-compressed"],
    ["car", "application/vnd.curl.car"],
    ["cat", ["application/vnd.ms-pkiseccat", "application/vnd.ms-pki.seccat"]],
    ["cc", ["text/plain", "text/x-c"]],
    ["ccad", "application/clariscad"],
    ["cco", "application/x-cocoa"],
    ["ccxml", "application/ccxml+xml,"],
    ["cdbcmsg", "application/vnd.contact.cmsg"],
    ["cdf", ["application/cdf", "application/x-cdf", "application/x-netcdf"]],
    ["cdkey", "application/vnd.mediastation.cdkey"],
    ["cdmia", "application/cdmi-capability"],
    ["cdmic", "application/cdmi-container"],
    ["cdmid", "application/cdmi-domain"],
    ["cdmio", "application/cdmi-object"],
    ["cdmiq", "application/cdmi-queue"],
    ["cdx", "chemical/x-cdx"],
    ["cdxml", "application/vnd.chemdraw+xml"],
    ["cdy", "application/vnd.cinderella"],
    ["cer", ["application/pkix-cert", "application/x-x509-ca-cert"]],
    ["cgm", "image/cgm"],
    ["cha", "application/x-chat"],
    ["chat", "application/x-chat"],
    ["chm", "application/vnd.ms-htmlhelp"],
    ["chrt", "application/vnd.kde.kchart"],
    ["cif", "chemical/x-cif"],
    ["cii", "application/vnd.anser-web-certificate-issue-initiation"],
    ["cil", "application/vnd.ms-artgalry"],
    ["cla", "application/vnd.claymore"],
    ["class", ["application/octet-stream", "application/java", "application/java-byte-code", "application/java-vm", "application/x-java-class"]],
    ["clkk", "application/vnd.crick.clicker.keyboard"],
    ["clkp", "application/vnd.crick.clicker.palette"],
    ["clkt", "application/vnd.crick.clicker.template"],
    ["clkw", "application/vnd.crick.clicker.wordbank"],
    ["clkx", "application/vnd.crick.clicker"],
    ["clp", "application/x-msclip"],
    ["cmc", "application/vnd.cosmocaller"],
    ["cmdf", "chemical/x-cmdf"],
    ["cml", "chemical/x-cml"],
    ["cmp", "application/vnd.yellowriver-custom-menu"],
    ["cmx", "image/x-cmx"],
    ["cod", ["image/cis-cod", "application/vnd.rim.cod"]],
    ["com", ["application/octet-stream", "text/plain"]],
    ["conf", "text/plain"],
    ["cpio", "application/x-cpio"],
    ["cpp", "text/x-c"],
    ["cpt", ["application/mac-compactpro", "application/x-compactpro", "application/x-cpt"]],
    ["crd", "application/x-mscardfile"],
    ["crl", ["application/pkix-crl", "application/pkcs-crl"]],
    ["crt", ["application/pkix-cert", "application/x-x509-user-cert", "application/x-x509-ca-cert"]],
    ["cryptonote", "application/vnd.rig.cryptonote"],
    ["csh", ["text/x-script.csh", "application/x-csh"]],
    ["csml", "chemical/x-csml"],
    ["csp", "application/vnd.commonspace"],
    ["css", ["text/css", "application/x-pointplus"]],
    ["csv", "text/csv"],
    ["cu", "application/cu-seeme"],
    ["curl", "text/vnd.curl"],
    ["cww", "application/prs.cww"],
    ["cxx", "text/plain"],
    ["dae", "model/vnd.collada+xml"],
    ["daf", "application/vnd.mobius.daf"],
    ["davmount", "application/davmount+xml"],
    ["dcr", "application/x-director"],
    ["dcurl", "text/vnd.curl.dcurl"],
    ["dd2", "application/vnd.oma.dd2+xml"],
    ["ddd", "application/vnd.fujixerox.ddd"],
    ["deb", "application/x-debian-package"],
    ["deepv", "application/x-deepv"],
    ["def", "text/plain"],
    ["der", "application/x-x509-ca-cert"],
    ["dfac", "application/vnd.dreamfactory"],
    ["dif", "video/x-dv"],
    ["dir", "application/x-director"],
    ["dis", "application/vnd.mobius.dis"],
    ["djvu", "image/vnd.djvu"],
    ["dl", ["video/dl", "video/x-dl"]],
    ["dll", "application/x-msdownload"],
    ["dms", "application/octet-stream"],
    ["dna", "application/vnd.dna"],
    ["doc", "application/msword"],
    ["docm", "application/vnd.ms-word.document.macroenabled.12"],
    ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
    ["dot", "application/msword"],
    ["dotm", "application/vnd.ms-word.template.macroenabled.12"],
    ["dotx", "application/vnd.openxmlformats-officedocument.wordprocessingml.template"],
    ["dp", ["application/commonground", "application/vnd.osgi.dp"]],
    ["dpg", "application/vnd.dpgraph"],
    ["dra", "audio/vnd.dra"],
    ["drw", "application/drafting"],
    ["dsc", "text/prs.lines.tag"],
    ["dssc", "application/dssc+der"],
    ["dtb", "application/x-dtbook+xml"],
    ["dtd", "application/xml-dtd"],
    ["dts", "audio/vnd.dts"],
    ["dtshd", "audio/vnd.dts.hd"],
    ["dump", "application/octet-stream"],
    ["dv", "video/x-dv"],
    ["dvi", "application/x-dvi"],
    ["dwf", ["model/vnd.dwf", "drawing/x-dwf"]],
    ["dwg", ["application/acad", "image/vnd.dwg", "image/x-dwg"]],
    ["dxf", ["application/dxf", "image/vnd.dwg", "image/vnd.dxf", "image/x-dwg"]],
    ["dxp", "application/vnd.spotfire.dxp"],
    ["dxr", "application/x-director"],
    ["ecelp4800", "audio/vnd.nuera.ecelp4800"],
    ["ecelp7470", "audio/vnd.nuera.ecelp7470"],
    ["ecelp9600", "audio/vnd.nuera.ecelp9600"],
    ["edm", "application/vnd.novadigm.edm"],
    ["edx", "application/vnd.novadigm.edx"],
    ["efif", "application/vnd.picsel"],
    ["ei6", "application/vnd.pg.osasli"],
    ["el", "text/x-script.elisp"],
    ["elc", ["application/x-elc", "application/x-bytecode.elisp"]],
    ["eml", "message/rfc822"],
    ["emma", "application/emma+xml"],
    ["env", "application/x-envoy"],
    ["eol", "audio/vnd.digital-winds"],
    ["eot", "application/vnd.ms-fontobject"],
    ["eps", "application/postscript"],
    ["epub", "application/epub+zip"],
    ["es", ["application/ecmascript", "application/x-esrehber"]],
    ["es3", "application/vnd.eszigno3+xml"],
    ["esf", "application/vnd.epson.esf"],
    ["etx", "text/x-setext"],
    ["evy", ["application/envoy", "application/x-envoy"]],
    ["exe", ["application/octet-stream", "application/x-msdownload"]],
    ["exi", "application/exi"],
    ["ext", "application/vnd.novadigm.ext"],
    ["ez2", "application/vnd.ezpix-album"],
    ["ez3", "application/vnd.ezpix-package"],
    ["f", ["text/plain", "text/x-fortran"]],
    ["f4v", "video/x-f4v"],
    ["f77", "text/x-fortran"],
    ["f90", ["text/plain", "text/x-fortran"]],
    ["fbs", "image/vnd.fastbidsheet"],
    ["fcs", "application/vnd.isac.fcs"],
    ["fdf", "application/vnd.fdf"],
    ["fe_launch", "application/vnd.denovo.fcselayout-link"],
    ["fg5", "application/vnd.fujitsu.oasysgp"],
    ["fh", "image/x-freehand"],
    ["fif", ["application/fractals", "image/fif"]],
    ["fig", "application/x-xfig"],
    ["fli", ["video/fli", "video/x-fli"]],
    ["flo", ["image/florian", "application/vnd.micrografx.flo"]],
    ["flr", "x-world/x-vrml"],
    ["flv", "video/x-flv"],
    ["flw", "application/vnd.kde.kivio"],
    ["flx", "text/vnd.fmi.flexstor"],
    ["fly", "text/vnd.fly"],
    ["fm", "application/vnd.framemaker"],
    ["fmf", "video/x-atomic3d-feature"],
    ["fnc", "application/vnd.frogans.fnc"],
    ["for", ["text/plain", "text/x-fortran"]],
    ["fpx", ["image/vnd.fpx", "image/vnd.net-fpx"]],
    ["frl", "application/freeloader"],
    ["fsc", "application/vnd.fsc.weblaunch"],
    ["fst", "image/vnd.fst"],
    ["ftc", "application/vnd.fluxtime.clip"],
    ["fti", "application/vnd.anser-web-funds-transfer-initiation"],
    ["funk", "audio/make"],
    ["fvt", "video/vnd.fvt"],
    ["fxp", "application/vnd.adobe.fxp"],
    ["fzs", "application/vnd.fuzzysheet"],
    ["g", "text/plain"],
    ["g2w", "application/vnd.geoplan"],
    ["g3", "image/g3fax"],
    ["g3w", "application/vnd.geospace"],
    ["gac", "application/vnd.groove-account"],
    ["gdl", "model/vnd.gdl"],
    ["geo", "application/vnd.dynageo"],
    ["gex", "application/vnd.geometry-explorer"],
    ["ggb", "application/vnd.geogebra.file"],
    ["ggt", "application/vnd.geogebra.tool"],
    ["ghf", "application/vnd.groove-help"],
    ["gif", "image/gif"],
    ["gim", "application/vnd.groove-identity-message"],
    ["gl", ["video/gl", "video/x-gl"]],
    ["gmx", "application/vnd.gmx"],
    ["gnumeric", "application/x-gnumeric"],
    ["gph", "application/vnd.flographit"],
    ["gqf", "application/vnd.grafeq"],
    ["gram", "application/srgs"],
    ["grv", "application/vnd.groove-injector"],
    ["grxml", "application/srgs+xml"],
    ["gsd", "audio/x-gsm"],
    ["gsf", "application/x-font-ghostscript"],
    ["gsm", "audio/x-gsm"],
    ["gsp", "application/x-gsp"],
    ["gss", "application/x-gss"],
    ["gtar", "application/x-gtar"],
    ["gtm", "application/vnd.groove-tool-message"],
    ["gtw", "model/vnd.gtw"],
    ["gv", "text/vnd.graphviz"],
    ["gxt", "application/vnd.geonext"],
    ["gz", ["application/x-gzip", "application/x-compressed"]],
    ["gzip", ["multipart/x-gzip", "application/x-gzip"]],
    ["h", ["text/plain", "text/x-h"]],
    ["h261", "video/h261"],
    ["h263", "video/h263"],
    ["h264", "video/h264"],
    ["hal", "application/vnd.hal+xml"],
    ["hbci", "application/vnd.hbci"],
    ["hdf", "application/x-hdf"],
    ["help", "application/x-helpfile"],
    ["hgl", "application/vnd.hp-hpgl"],
    ["hh", ["text/plain", "text/x-h"]],
    ["hlb", "text/x-script"],
    ["hlp", ["application/winhlp", "application/hlp", "application/x-helpfile", "application/x-winhelp"]],
    ["hpg", "application/vnd.hp-hpgl"],
    ["hpgl", "application/vnd.hp-hpgl"],
    ["hpid", "application/vnd.hp-hpid"],
    ["hps", "application/vnd.hp-hps"],
    [
      "hqx",
      [
        "application/mac-binhex40",
        "application/binhex",
        "application/binhex4",
        "application/mac-binhex",
        "application/x-binhex40",
        "application/x-mac-binhex40"
      ]
    ],
    ["hta", "application/hta"],
    ["htc", "text/x-component"],
    ["htke", "application/vnd.kenameaapp"],
    ["htm", "text/html"],
    ["html", "text/html"],
    ["htmls", "text/html"],
    ["htt", "text/webviewhtml"],
    ["htx", "text/html"],
    ["hvd", "application/vnd.yamaha.hv-dic"],
    ["hvp", "application/vnd.yamaha.hv-voice"],
    ["hvs", "application/vnd.yamaha.hv-script"],
    ["i2g", "application/vnd.intergeo"],
    ["icc", "application/vnd.iccprofile"],
    ["ice", "x-conference/x-cooltalk"],
    ["ico", "image/x-icon"],
    ["ics", "text/calendar"],
    ["idc", "text/plain"],
    ["ief", "image/ief"],
    ["iefs", "image/ief"],
    ["ifm", "application/vnd.shana.informed.formdata"],
    ["iges", ["application/iges", "model/iges"]],
    ["igl", "application/vnd.igloader"],
    ["igm", "application/vnd.insors.igm"],
    ["igs", ["application/iges", "model/iges"]],
    ["igx", "application/vnd.micrografx.igx"],
    ["iif", "application/vnd.shana.informed.interchange"],
    ["iii", "application/x-iphone"],
    ["ima", "application/x-ima"],
    ["imap", "application/x-httpd-imap"],
    ["imp", "application/vnd.accpac.simply.imp"],
    ["ims", "application/vnd.ms-ims"],
    ["inf", "application/inf"],
    ["ins", ["application/x-internet-signup", "application/x-internett-signup"]],
    ["ip", "application/x-ip2"],
    ["ipfix", "application/ipfix"],
    ["ipk", "application/vnd.shana.informed.package"],
    ["irm", "application/vnd.ibm.rights-management"],
    ["irp", "application/vnd.irepository.package+xml"],
    ["isp", "application/x-internet-signup"],
    ["isu", "video/x-isvideo"],
    ["it", "audio/it"],
    ["itp", "application/vnd.shana.informed.formtemplate"],
    ["iv", "application/x-inventor"],
    ["ivp", "application/vnd.immervision-ivp"],
    ["ivr", "i-world/i-vrml"],
    ["ivu", "application/vnd.immervision-ivu"],
    ["ivy", "application/x-livescreen"],
    ["jad", "text/vnd.sun.j2me.app-descriptor"],
    ["jam", ["application/vnd.jam", "audio/x-jam"]],
    ["jar", "application/java-archive"],
    ["jav", ["text/plain", "text/x-java-source"]],
    ["java", ["text/plain", "text/x-java-source,java", "text/x-java-source"]],
    ["jcm", "application/x-java-commerce"],
    ["jfif", ["image/pipeg", "image/jpeg", "image/pjpeg"]],
    ["jfif-tbnl", "image/jpeg"],
    ["jisp", "application/vnd.jisp"],
    ["jlt", "application/vnd.hp-jlyt"],
    ["jnlp", "application/x-java-jnlp-file"],
    ["joda", "application/vnd.joost.joda-archive"],
    ["jpe", ["image/jpeg", "image/pjpeg"]],
    ["jpeg", ["image/jpeg", "image/pjpeg"]],
    ["jpg", ["image/jpeg", "image/pjpeg"]],
    ["jpgv", "video/jpeg"],
    ["jpm", "video/jpm"],
    ["jps", "image/x-jps"],
    ["js", ["application/javascript", "application/ecmascript", "text/javascript", "text/ecmascript", "application/x-javascript"]],
    ["json", "application/json"],
    ["jut", "image/jutvision"],
    ["kar", ["audio/midi", "music/x-karaoke"]],
    ["karbon", "application/vnd.kde.karbon"],
    ["kfo", "application/vnd.kde.kformula"],
    ["kia", "application/vnd.kidspiration"],
    ["kml", "application/vnd.google-earth.kml+xml"],
    ["kmz", "application/vnd.google-earth.kmz"],
    ["kne", "application/vnd.kinar"],
    ["kon", "application/vnd.kde.kontour"],
    ["kpr", "application/vnd.kde.kpresenter"],
    ["ksh", ["application/x-ksh", "text/x-script.ksh"]],
    ["ksp", "application/vnd.kde.kspread"],
    ["ktx", "image/ktx"],
    ["ktz", "application/vnd.kahootz"],
    ["kwd", "application/vnd.kde.kword"],
    ["la", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["lam", "audio/x-liveaudio"],
    ["lasxml", "application/vnd.las.las+xml"],
    ["latex", "application/x-latex"],
    ["lbd", "application/vnd.llamagraphics.life-balance.desktop"],
    ["lbe", "application/vnd.llamagraphics.life-balance.exchange+xml"],
    ["les", "application/vnd.hhe.lesson-player"],
    ["lha", ["application/octet-stream", "application/lha", "application/x-lha"]],
    ["lhx", "application/octet-stream"],
    ["link66", "application/vnd.route66.link66+xml"],
    ["list", "text/plain"],
    ["lma", ["audio/nspaudio", "audio/x-nspaudio"]],
    ["log", "text/plain"],
    ["lrm", "application/vnd.ms-lrm"],
    ["lsf", "video/x-la-asf"],
    ["lsp", ["application/x-lisp", "text/x-script.lisp"]],
    ["lst", "text/plain"],
    ["lsx", ["video/x-la-asf", "text/x-la-asf"]],
    ["ltf", "application/vnd.frogans.ltf"],
    ["ltx", "application/x-latex"],
    ["lvp", "audio/vnd.lucent.voice"],
    ["lwp", "application/vnd.lotus-wordpro"],
    ["lzh", ["application/octet-stream", "application/x-lzh"]],
    ["lzx", ["application/lzx", "application/octet-stream", "application/x-lzx"]],
    ["m", ["text/plain", "text/x-m"]],
    ["m13", "application/x-msmediaview"],
    ["m14", "application/x-msmediaview"],
    ["m1v", "video/mpeg"],
    ["m21", "application/mp21"],
    ["m2a", "audio/mpeg"],
    ["m2v", "video/mpeg"],
    ["m3u", ["audio/x-mpegurl", "audio/x-mpequrl"]],
    ["m3u8", "application/vnd.apple.mpegurl"],
    ["m4v", "video/x-m4v"],
    ["ma", "application/mathematica"],
    ["mads", "application/mads+xml"],
    ["mag", "application/vnd.ecowin.chart"],
    ["man", "application/x-troff-man"],
    ["map", "application/x-navimap"],
    ["mar", "text/plain"],
    ["mathml", "application/mathml+xml"],
    ["mbd", "application/mbedlet"],
    ["mbk", "application/vnd.mobius.mbk"],
    ["mbox", "application/mbox"],
    ["mc$", "application/x-magic-cap-package-1.0"],
    ["mc1", "application/vnd.medcalcdata"],
    ["mcd", ["application/mcad", "application/vnd.mcd", "application/x-mathcad"]],
    ["mcf", ["image/vasa", "text/mcf"]],
    ["mcp", "application/netmc"],
    ["mcurl", "text/vnd.curl.mcurl"],
    ["mdb", "application/x-msaccess"],
    ["mdi", "image/vnd.ms-modi"],
    ["me", "application/x-troff-me"],
    ["meta4", "application/metalink4+xml"],
    ["mets", "application/mets+xml"],
    ["mfm", "application/vnd.mfmp"],
    ["mgp", "application/vnd.osgeo.mapguide.package"],
    ["mgz", "application/vnd.proteus.magazine"],
    ["mht", "message/rfc822"],
    ["mhtml", "message/rfc822"],
    ["mid", ["audio/mid", "audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["midi", ["audio/midi", "music/crescendo", "x-music/x-midi", "audio/x-midi", "application/x-midi", "audio/x-mid"]],
    ["mif", ["application/vnd.mif", "application/x-mif", "application/x-frame"]],
    ["mime", ["message/rfc822", "www/mime"]],
    ["mj2", "video/mj2"],
    ["mjf", "audio/x-vnd.audioexplosion.mjuicemediafile"],
    ["mjpg", "video/x-motion-jpeg"],
    ["mlp", "application/vnd.dolby.mlp"],
    ["mm", ["application/base64", "application/x-meme"]],
    ["mmd", "application/vnd.chipnuts.karaoke-mmd"],
    ["mme", "application/base64"],
    ["mmf", "application/vnd.smaf"],
    ["mmr", "image/vnd.fujixerox.edmics-mmr"],
    ["mny", "application/x-msmoney"],
    ["mod", ["audio/mod", "audio/x-mod"]],
    ["mods", "application/mods+xml"],
    ["moov", "video/quicktime"],
    ["mov", "video/quicktime"],
    ["movie", "video/x-sgi-movie"],
    ["mp2", ["video/mpeg", "audio/mpeg", "video/x-mpeg", "audio/x-mpeg", "video/x-mpeq2a"]],
    ["mp3", ["audio/mpeg", "audio/mpeg3", "video/mpeg", "audio/x-mpeg-3", "video/x-mpeg"]],
    ["mp4", ["video/mp4", "application/mp4"]],
    ["mp4a", "audio/mp4"],
    ["mpa", ["video/mpeg", "audio/mpeg"]],
    ["mpc", ["application/vnd.mophun.certificate", "application/x-project"]],
    ["mpe", "video/mpeg"],
    ["mpeg", "video/mpeg"],
    ["mpg", ["video/mpeg", "audio/mpeg"]],
    ["mpga", "audio/mpeg"],
    ["mpkg", "application/vnd.apple.installer+xml"],
    ["mpm", "application/vnd.blueice.multipass"],
    ["mpn", "application/vnd.mophun.application"],
    ["mpp", "application/vnd.ms-project"],
    ["mpt", "application/x-project"],
    ["mpv", "application/x-project"],
    ["mpv2", "video/mpeg"],
    ["mpx", "application/x-project"],
    ["mpy", "application/vnd.ibm.minipay"],
    ["mqy", "application/vnd.mobius.mqy"],
    ["mrc", "application/marc"],
    ["mrcx", "application/marcxml+xml"],
    ["ms", "application/x-troff-ms"],
    ["mscml", "application/mediaservercontrol+xml"],
    ["mseq", "application/vnd.mseq"],
    ["msf", "application/vnd.epson.msf"],
    ["msg", "application/vnd.ms-outlook"],
    ["msh", "model/mesh"],
    ["msl", "application/vnd.mobius.msl"],
    ["msty", "application/vnd.muvee.style"],
    ["mts", "model/vnd.mts"],
    ["mus", "application/vnd.musician"],
    ["musicxml", "application/vnd.recordare.musicxml+xml"],
    ["mv", "video/x-sgi-movie"],
    ["mvb", "application/x-msmediaview"],
    ["mwf", "application/vnd.mfer"],
    ["mxf", "application/mxf"],
    ["mxl", "application/vnd.recordare.musicxml"],
    ["mxml", "application/xv+xml"],
    ["mxs", "application/vnd.triscape.mxs"],
    ["mxu", "video/vnd.mpegurl"],
    ["my", "audio/make"],
    ["mzz", "application/x-vnd.audioexplosion.mzz"],
    ["n-gage", "application/vnd.nokia.n-gage.symbian.install"],
    ["n3", "text/n3"],
    ["nap", "image/naplps"],
    ["naplps", "image/naplps"],
    ["nbp", "application/vnd.wolfram.player"],
    ["nc", "application/x-netcdf"],
    ["ncm", "application/vnd.nokia.configuration-message"],
    ["ncx", "application/x-dtbncx+xml"],
    ["ngdat", "application/vnd.nokia.n-gage.data"],
    ["nif", "image/x-niff"],
    ["niff", "image/x-niff"],
    ["nix", "application/x-mix-transfer"],
    ["nlu", "application/vnd.neurolanguage.nlu"],
    ["nml", "application/vnd.enliven"],
    ["nnd", "application/vnd.noblenet-directory"],
    ["nns", "application/vnd.noblenet-sealer"],
    ["nnw", "application/vnd.noblenet-web"],
    ["npx", "image/vnd.net-fpx"],
    ["nsc", "application/x-conference"],
    ["nsf", "application/vnd.lotus-notes"],
    ["nvd", "application/x-navidoc"],
    ["nws", "message/rfc822"],
    ["o", "application/octet-stream"],
    ["oa2", "application/vnd.fujitsu.oasys2"],
    ["oa3", "application/vnd.fujitsu.oasys3"],
    ["oas", "application/vnd.fujitsu.oasys"],
    ["obd", "application/x-msbinder"],
    ["oda", "application/oda"],
    ["odb", "application/vnd.oasis.opendocument.database"],
    ["odc", "application/vnd.oasis.opendocument.chart"],
    ["odf", "application/vnd.oasis.opendocument.formula"],
    ["odft", "application/vnd.oasis.opendocument.formula-template"],
    ["odg", "application/vnd.oasis.opendocument.graphics"],
    ["odi", "application/vnd.oasis.opendocument.image"],
    ["odm", "application/vnd.oasis.opendocument.text-master"],
    ["odp", "application/vnd.oasis.opendocument.presentation"],
    ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
    ["odt", "application/vnd.oasis.opendocument.text"],
    ["oga", "audio/ogg"],
    ["ogv", "video/ogg"],
    ["ogx", "application/ogg"],
    ["omc", "application/x-omc"],
    ["omcd", "application/x-omcdatamaker"],
    ["omcr", "application/x-omcregerator"],
    ["onetoc", "application/onenote"],
    ["opf", "application/oebps-package+xml"],
    ["org", "application/vnd.lotus-organizer"],
    ["osf", "application/vnd.yamaha.openscoreformat"],
    ["osfpvg", "application/vnd.yamaha.openscoreformat.osfpvg+xml"],
    ["otc", "application/vnd.oasis.opendocument.chart-template"],
    ["otf", "application/x-font-otf"],
    ["otg", "application/vnd.oasis.opendocument.graphics-template"],
    ["oth", "application/vnd.oasis.opendocument.text-web"],
    ["oti", "application/vnd.oasis.opendocument.image-template"],
    ["otp", "application/vnd.oasis.opendocument.presentation-template"],
    ["ots", "application/vnd.oasis.opendocument.spreadsheet-template"],
    ["ott", "application/vnd.oasis.opendocument.text-template"],
    ["oxt", "application/vnd.openofficeorg.extension"],
    ["p", "text/x-pascal"],
    ["p10", ["application/pkcs10", "application/x-pkcs10"]],
    ["p12", ["application/pkcs-12", "application/x-pkcs12"]],
    ["p7a", "application/x-pkcs7-signature"],
    ["p7b", "application/x-pkcs7-certificates"],
    ["p7c", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7m", ["application/pkcs7-mime", "application/x-pkcs7-mime"]],
    ["p7r", "application/x-pkcs7-certreqresp"],
    ["p7s", ["application/pkcs7-signature", "application/x-pkcs7-signature"]],
    ["p8", "application/pkcs8"],
    ["par", "text/plain-bas"],
    ["part", "application/pro_eng"],
    ["pas", "text/pascal"],
    ["paw", "application/vnd.pawaafile"],
    ["pbd", "application/vnd.powerbuilder6"],
    ["pbm", "image/x-portable-bitmap"],
    ["pcf", "application/x-font-pcf"],
    ["pcl", ["application/vnd.hp-pcl", "application/x-pcl"]],
    ["pclxl", "application/vnd.hp-pclxl"],
    ["pct", "image/x-pict"],
    ["pcurl", "application/vnd.curl.pcurl"],
    ["pcx", "image/x-pcx"],
    ["pdb", ["application/vnd.palm", "chemical/x-pdb"]],
    ["pdf", "application/pdf"],
    ["pfa", "application/x-font-type1"],
    ["pfr", "application/font-tdpfr"],
    ["pfunk", ["audio/make", "audio/make.my.funk"]],
    ["pfx", "application/x-pkcs12"],
    ["pgm", ["image/x-portable-graymap", "image/x-portable-greymap"]],
    ["pgn", "application/x-chess-pgn"],
    ["pgp", "application/pgp-signature"],
    ["pic", ["image/pict", "image/x-pict"]],
    ["pict", "image/pict"],
    ["pkg", "application/x-newton-compatible-pkg"],
    ["pki", "application/pkixcmp"],
    ["pkipath", "application/pkix-pkipath"],
    ["pko", ["application/ynd.ms-pkipko", "application/vnd.ms-pki.pko"]],
    ["pl", ["text/plain", "text/x-script.perl"]],
    ["plb", "application/vnd.3gpp.pic-bw-large"],
    ["plc", "application/vnd.mobius.plc"],
    ["plf", "application/vnd.pocketlearn"],
    ["pls", "application/pls+xml"],
    ["plx", "application/x-pixclscript"],
    ["pm", ["text/x-script.perl-module", "image/x-xpixmap"]],
    ["pm4", "application/x-pagemaker"],
    ["pm5", "application/x-pagemaker"],
    ["pma", "application/x-perfmon"],
    ["pmc", "application/x-perfmon"],
    ["pml", ["application/vnd.ctc-posml", "application/x-perfmon"]],
    ["pmr", "application/x-perfmon"],
    ["pmw", "application/x-perfmon"],
    ["png", "image/png"],
    ["pnm", ["application/x-portable-anymap", "image/x-portable-anymap"]],
    ["portpkg", "application/vnd.macports.portpkg"],
    ["pot", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["potm", "application/vnd.ms-powerpoint.template.macroenabled.12"],
    ["potx", "application/vnd.openxmlformats-officedocument.presentationml.template"],
    ["pov", "model/x-pov"],
    ["ppa", "application/vnd.ms-powerpoint"],
    ["ppam", "application/vnd.ms-powerpoint.addin.macroenabled.12"],
    ["ppd", "application/vnd.cups-ppd"],
    ["ppm", "image/x-portable-pixmap"],
    ["pps", ["application/vnd.ms-powerpoint", "application/mspowerpoint"]],
    ["ppsm", "application/vnd.ms-powerpoint.slideshow.macroenabled.12"],
    ["ppsx", "application/vnd.openxmlformats-officedocument.presentationml.slideshow"],
    ["ppt", ["application/vnd.ms-powerpoint", "application/mspowerpoint", "application/powerpoint", "application/x-mspowerpoint"]],
    ["pptm", "application/vnd.ms-powerpoint.presentation.macroenabled.12"],
    ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
    ["ppz", "application/mspowerpoint"],
    ["prc", "application/x-mobipocket-ebook"],
    ["pre", ["application/vnd.lotus-freelance", "application/x-freelance"]],
    ["prf", "application/pics-rules"],
    ["prt", "application/pro_eng"],
    ["ps", "application/postscript"],
    ["psb", "application/vnd.3gpp.pic-bw-small"],
    ["psd", ["application/octet-stream", "image/vnd.adobe.photoshop"]],
    ["psf", "application/x-font-linux-psf"],
    ["pskcxml", "application/pskc+xml"],
    ["ptid", "application/vnd.pvi.ptid1"],
    ["pub", "application/x-mspublisher"],
    ["pvb", "application/vnd.3gpp.pic-bw-var"],
    ["pvu", "paleovu/x-pv"],
    ["pwn", "application/vnd.3m.post-it-notes"],
    ["pwz", "application/vnd.ms-powerpoint"],
    ["py", "text/x-script.phyton"],
    ["pya", "audio/vnd.ms-playready.media.pya"],
    ["pyc", "application/x-bytecode.python"],
    ["pyv", "video/vnd.ms-playready.media.pyv"],
    ["qam", "application/vnd.epson.quickanime"],
    ["qbo", "application/vnd.intu.qbo"],
    ["qcp", "audio/vnd.qcelp"],
    ["qd3", "x-world/x-3dmf"],
    ["qd3d", "x-world/x-3dmf"],
    ["qfx", "application/vnd.intu.qfx"],
    ["qif", "image/x-quicktime"],
    ["qps", "application/vnd.publishare-delta-tree"],
    ["qt", "video/quicktime"],
    ["qtc", "video/x-qtc"],
    ["qti", "image/x-quicktime"],
    ["qtif", "image/x-quicktime"],
    ["qxd", "application/vnd.quark.quarkxpress"],
    ["ra", ["audio/x-realaudio", "audio/x-pn-realaudio", "audio/x-pn-realaudio-plugin"]],
    ["ram", "audio/x-pn-realaudio"],
    ["rar", "application/x-rar-compressed"],
    ["ras", ["image/cmu-raster", "application/x-cmu-raster", "image/x-cmu-raster"]],
    ["rast", "image/cmu-raster"],
    ["rcprofile", "application/vnd.ipunplugged.rcprofile"],
    ["rdf", "application/rdf+xml"],
    ["rdz", "application/vnd.data-vision.rdz"],
    ["rep", "application/vnd.businessobjects"],
    ["res", "application/x-dtbresource+xml"],
    ["rexx", "text/x-script.rexx"],
    ["rf", "image/vnd.rn-realflash"],
    ["rgb", "image/x-rgb"],
    ["rif", "application/reginfo+xml"],
    ["rip", "audio/vnd.rip"],
    ["rl", "application/resource-lists+xml"],
    ["rlc", "image/vnd.fujixerox.edmics-rlc"],
    ["rld", "application/resource-lists-diff+xml"],
    ["rm", ["application/vnd.rn-realmedia", "audio/x-pn-realaudio"]],
    ["rmi", "audio/mid"],
    ["rmm", "audio/x-pn-realaudio"],
    ["rmp", ["audio/x-pn-realaudio-plugin", "audio/x-pn-realaudio"]],
    ["rms", "application/vnd.jcp.javame.midlet-rms"],
    ["rnc", "application/relax-ng-compact-syntax"],
    ["rng", ["application/ringing-tones", "application/vnd.nokia.ringing-tone"]],
    ["rnx", "application/vnd.rn-realplayer"],
    ["roff", "application/x-troff"],
    ["rp", "image/vnd.rn-realpix"],
    ["rp9", "application/vnd.cloanto.rp9"],
    ["rpm", "audio/x-pn-realaudio-plugin"],
    ["rpss", "application/vnd.nokia.radio-presets"],
    ["rpst", "application/vnd.nokia.radio-preset"],
    ["rq", "application/sparql-query"],
    ["rs", "application/rls-services+xml"],
    ["rsd", "application/rsd+xml"],
    ["rt", ["text/richtext", "text/vnd.rn-realtext"]],
    ["rtf", ["application/rtf", "text/richtext", "application/x-rtf"]],
    ["rtx", ["text/richtext", "application/rtf"]],
    ["rv", "video/vnd.rn-realvideo"],
    ["s", "text/x-asm"],
    ["s3m", "audio/s3m"],
    ["saf", "application/vnd.yamaha.smaf-audio"],
    ["saveme", "application/octet-stream"],
    ["sbk", "application/x-tbook"],
    ["sbml", "application/sbml+xml"],
    ["sc", "application/vnd.ibm.secure-container"],
    ["scd", "application/x-msschedule"],
    ["scm", ["application/vnd.lotus-screencam", "video/x-scm", "text/x-script.guile", "application/x-lotusscreencam", "text/x-script.scheme"]],
    ["scq", "application/scvp-cv-request"],
    ["scs", "application/scvp-cv-response"],
    ["sct", "text/scriptlet"],
    ["scurl", "text/vnd.curl.scurl"],
    ["sda", "application/vnd.stardivision.draw"],
    ["sdc", "application/vnd.stardivision.calc"],
    ["sdd", "application/vnd.stardivision.impress"],
    ["sdkm", "application/vnd.solent.sdkm+xml"],
    ["sdml", "text/plain"],
    ["sdp", ["application/sdp", "application/x-sdp"]],
    ["sdr", "application/sounder"],
    ["sdw", "application/vnd.stardivision.writer"],
    ["sea", ["application/sea", "application/x-sea"]],
    ["see", "application/vnd.seemail"],
    ["seed", "application/vnd.fdsn.seed"],
    ["sema", "application/vnd.sema"],
    ["semd", "application/vnd.semd"],
    ["semf", "application/vnd.semf"],
    ["ser", "application/java-serialized-object"],
    ["set", "application/set"],
    ["setpay", "application/set-payment-initiation"],
    ["setreg", "application/set-registration-initiation"],
    ["sfd-hdstx", "application/vnd.hydrostatix.sof-data"],
    ["sfs", "application/vnd.spotfire.sfs"],
    ["sgl", "application/vnd.stardivision.writer-global"],
    ["sgm", ["text/sgml", "text/x-sgml"]],
    ["sgml", ["text/sgml", "text/x-sgml"]],
    ["sh", ["application/x-shar", "application/x-bsh", "application/x-sh", "text/x-script.sh"]],
    ["shar", ["application/x-bsh", "application/x-shar"]],
    ["shf", "application/shf+xml"],
    ["shtml", ["text/html", "text/x-server-parsed-html"]],
    ["sid", "audio/x-psid"],
    ["sis", "application/vnd.symbian.install"],
    ["sit", ["application/x-stuffit", "application/x-sit"]],
    ["sitx", "application/x-stuffitx"],
    ["skd", "application/x-koan"],
    ["skm", "application/x-koan"],
    ["skp", ["application/vnd.koan", "application/x-koan"]],
    ["skt", "application/x-koan"],
    ["sl", "application/x-seelogo"],
    ["sldm", "application/vnd.ms-powerpoint.slide.macroenabled.12"],
    ["sldx", "application/vnd.openxmlformats-officedocument.presentationml.slide"],
    ["slt", "application/vnd.epson.salt"],
    ["sm", "application/vnd.stepmania.stepchart"],
    ["smf", "application/vnd.stardivision.math"],
    ["smi", ["application/smil", "application/smil+xml"]],
    ["smil", "application/smil"],
    ["snd", ["audio/basic", "audio/x-adpcm"]],
    ["snf", "application/x-font-snf"],
    ["sol", "application/solids"],
    ["spc", ["text/x-speech", "application/x-pkcs7-certificates"]],
    ["spf", "application/vnd.yamaha.smaf-phrase"],
    ["spl", ["application/futuresplash", "application/x-futuresplash"]],
    ["spot", "text/vnd.in3d.spot"],
    ["spp", "application/scvp-vp-response"],
    ["spq", "application/scvp-vp-request"],
    ["spr", "application/x-sprite"],
    ["sprite", "application/x-sprite"],
    ["src", "application/x-wais-source"],
    ["sru", "application/sru+xml"],
    ["srx", "application/sparql-results+xml"],
    ["sse", "application/vnd.kodak-descriptor"],
    ["ssf", "application/vnd.epson.ssf"],
    ["ssi", "text/x-server-parsed-html"],
    ["ssm", "application/streamingmedia"],
    ["ssml", "application/ssml+xml"],
    ["sst", ["application/vnd.ms-pkicertstore", "application/vnd.ms-pki.certstore"]],
    ["st", "application/vnd.sailingtracker.track"],
    ["stc", "application/vnd.sun.xml.calc.template"],
    ["std", "application/vnd.sun.xml.draw.template"],
    ["step", "application/step"],
    ["stf", "application/vnd.wt.stf"],
    ["sti", "application/vnd.sun.xml.impress.template"],
    ["stk", "application/hyperstudio"],
    ["stl", ["application/vnd.ms-pkistl", "application/sla", "application/vnd.ms-pki.stl", "application/x-navistyle"]],
    ["stm", "text/html"],
    ["stp", "application/step"],
    ["str", "application/vnd.pg.format"],
    ["stw", "application/vnd.sun.xml.writer.template"],
    ["sub", "image/vnd.dvb.subtitle"],
    ["sus", "application/vnd.sus-calendar"],
    ["sv4cpio", "application/x-sv4cpio"],
    ["sv4crc", "application/x-sv4crc"],
    ["svc", "application/vnd.dvb.service"],
    ["svd", "application/vnd.svd"],
    ["svf", ["image/vnd.dwg", "image/x-dwg"]],
    ["svg", "image/svg+xml"],
    ["svr", ["x-world/x-svr", "application/x-world"]],
    ["swf", "application/x-shockwave-flash"],
    ["swi", "application/vnd.aristanetworks.swi"],
    ["sxc", "application/vnd.sun.xml.calc"],
    ["sxd", "application/vnd.sun.xml.draw"],
    ["sxg", "application/vnd.sun.xml.writer.global"],
    ["sxi", "application/vnd.sun.xml.impress"],
    ["sxm", "application/vnd.sun.xml.math"],
    ["sxw", "application/vnd.sun.xml.writer"],
    ["t", ["text/troff", "application/x-troff"]],
    ["talk", "text/x-speech"],
    ["tao", "application/vnd.tao.intent-module-archive"],
    ["tar", "application/x-tar"],
    ["tbk", ["application/toolbook", "application/x-tbook"]],
    ["tcap", "application/vnd.3gpp2.tcap"],
    ["tcl", ["text/x-script.tcl", "application/x-tcl"]],
    ["tcsh", "text/x-script.tcsh"],
    ["teacher", "application/vnd.smart.teacher"],
    ["tei", "application/tei+xml"],
    ["tex", "application/x-tex"],
    ["texi", "application/x-texinfo"],
    ["texinfo", "application/x-texinfo"],
    ["text", ["application/plain", "text/plain"]],
    ["tfi", "application/thraud+xml"],
    ["tfm", "application/x-tex-tfm"],
    ["tgz", ["application/gnutar", "application/x-compressed"]],
    ["thmx", "application/vnd.ms-officetheme"],
    ["tif", ["image/tiff", "image/x-tiff"]],
    ["tiff", ["image/tiff", "image/x-tiff"]],
    ["tmo", "application/vnd.tmobile-livetv"],
    ["torrent", "application/x-bittorrent"],
    ["tpl", "application/vnd.groove-tool-template"],
    ["tpt", "application/vnd.trid.tpt"],
    ["tr", "application/x-troff"],
    ["tra", "application/vnd.trueapp"],
    ["trm", "application/x-msterminal"],
    ["tsd", "application/timestamped-data"],
    ["tsi", "audio/tsp-audio"],
    ["tsp", ["application/dsptype", "audio/tsplayer"]],
    ["tsv", "text/tab-separated-values"],
    ["ttf", "application/x-font-ttf"],
    ["ttl", "text/turtle"],
    ["turbot", "image/florian"],
    ["twd", "application/vnd.simtech-mindmapper"],
    ["txd", "application/vnd.genomatix.tuxedo"],
    ["txf", "application/vnd.mobius.txf"],
    ["txt", "text/plain"],
    ["ufd", "application/vnd.ufdl"],
    ["uil", "text/x-uil"],
    ["uls", "text/iuls"],
    ["umj", "application/vnd.umajin"],
    ["uni", "text/uri-list"],
    ["unis", "text/uri-list"],
    ["unityweb", "application/vnd.unity"],
    ["unv", "application/i-deas"],
    ["uoml", "application/vnd.uoml+xml"],
    ["uri", "text/uri-list"],
    ["uris", "text/uri-list"],
    ["ustar", ["application/x-ustar", "multipart/x-ustar"]],
    ["utz", "application/vnd.uiq.theme"],
    ["uu", ["application/octet-stream", "text/x-uuencode"]],
    ["uue", "text/x-uuencode"],
    ["uva", "audio/vnd.dece.audio"],
    ["uvh", "video/vnd.dece.hd"],
    ["uvi", "image/vnd.dece.graphic"],
    ["uvm", "video/vnd.dece.mobile"],
    ["uvp", "video/vnd.dece.pd"],
    ["uvs", "video/vnd.dece.sd"],
    ["uvu", "video/vnd.uvvu.mp4"],
    ["uvv", "video/vnd.dece.video"],
    ["vcd", "application/x-cdlink"],
    ["vcf", "text/x-vcard"],
    ["vcg", "application/vnd.groove-vcard"],
    ["vcs", "text/x-vcalendar"],
    ["vcx", "application/vnd.vcx"],
    ["vda", "application/vda"],
    ["vdo", "video/vdo"],
    ["vew", "application/groupwise"],
    ["vis", "application/vnd.visionary"],
    ["viv", ["video/vivo", "video/vnd.vivo"]],
    ["vivo", ["video/vivo", "video/vnd.vivo"]],
    ["vmd", "application/vocaltec-media-desc"],
    ["vmf", "application/vocaltec-media-file"],
    ["voc", ["audio/voc", "audio/x-voc"]],
    ["vos", "video/vosaic"],
    ["vox", "audio/voxware"],
    ["vqe", "audio/x-twinvq-plugin"],
    ["vqf", "audio/x-twinvq"],
    ["vql", "audio/x-twinvq-plugin"],
    ["vrml", ["model/vrml", "x-world/x-vrml", "application/x-vrml"]],
    ["vrt", "x-world/x-vrt"],
    ["vsd", ["application/vnd.visio", "application/x-visio"]],
    ["vsf", "application/vnd.vsf"],
    ["vst", "application/x-visio"],
    ["vsw", "application/x-visio"],
    ["vtu", "model/vnd.vtu"],
    ["vxml", "application/voicexml+xml"],
    ["w60", "application/wordperfect6.0"],
    ["w61", "application/wordperfect6.1"],
    ["w6w", "application/msword"],
    ["wad", "application/x-doom"],
    ["wav", ["audio/wav", "audio/x-wav"]],
    ["wax", "audio/x-ms-wax"],
    ["wb1", "application/x-qpro"],
    ["wbmp", "image/vnd.wap.wbmp"],
    ["wbs", "application/vnd.criticaltools.wbs+xml"],
    ["wbxml", "application/vnd.wap.wbxml"],
    ["wcm", "application/vnd.ms-works"],
    ["wdb", "application/vnd.ms-works"],
    ["web", "application/vnd.xara"],
    ["weba", "audio/webm"],
    ["webm", "video/webm"],
    ["webp", "image/webp"],
    ["wg", "application/vnd.pmi.widget"],
    ["wgt", "application/widget"],
    ["wiz", "application/msword"],
    ["wk1", "application/x-123"],
    ["wks", "application/vnd.ms-works"],
    ["wm", "video/x-ms-wm"],
    ["wma", "audio/x-ms-wma"],
    ["wmd", "application/x-ms-wmd"],
    ["wmf", ["windows/metafile", "application/x-msmetafile"]],
    ["wml", "text/vnd.wap.wml"],
    ["wmlc", "application/vnd.wap.wmlc"],
    ["wmls", "text/vnd.wap.wmlscript"],
    ["wmlsc", "application/vnd.wap.wmlscriptc"],
    ["wmv", "video/x-ms-wmv"],
    ["wmx", "video/x-ms-wmx"],
    ["wmz", "application/x-ms-wmz"],
    ["woff", "application/x-font-woff"],
    ["word", "application/msword"],
    ["wp", "application/wordperfect"],
    ["wp5", ["application/wordperfect", "application/wordperfect6.0"]],
    ["wp6", "application/wordperfect"],
    ["wpd", ["application/wordperfect", "application/vnd.wordperfect", "application/x-wpwin"]],
    ["wpl", "application/vnd.ms-wpl"],
    ["wps", "application/vnd.ms-works"],
    ["wq1", "application/x-lotus"],
    ["wqd", "application/vnd.wqd"],
    ["wri", ["application/mswrite", "application/x-wri", "application/x-mswrite"]],
    ["wrl", ["model/vrml", "x-world/x-vrml", "application/x-world"]],
    ["wrz", ["model/vrml", "x-world/x-vrml"]],
    ["wsc", "text/scriplet"],
    ["wsdl", "application/wsdl+xml"],
    ["wspolicy", "application/wspolicy+xml"],
    ["wsrc", "application/x-wais-source"],
    ["wtb", "application/vnd.webturbo"],
    ["wtk", "application/x-wintalk"],
    ["wvx", "video/x-ms-wvx"],
    ["x-png", "image/png"],
    ["x3d", "application/vnd.hzn-3d-crossword"],
    ["xaf", "x-world/x-vrml"],
    ["xap", "application/x-silverlight-app"],
    ["xar", "application/vnd.xara"],
    ["xbap", "application/x-ms-xbap"],
    ["xbd", "application/vnd.fujixerox.docuworks.binder"],
    ["xbm", ["image/xbm", "image/x-xbm", "image/x-xbitmap"]],
    ["xdf", "application/xcap-diff+xml"],
    ["xdm", "application/vnd.syncml.dm+xml"],
    ["xdp", "application/vnd.adobe.xdp+xml"],
    ["xdr", "video/x-amt-demorun"],
    ["xdssc", "application/dssc+xml"],
    ["xdw", "application/vnd.fujixerox.docuworks"],
    ["xenc", "application/xenc+xml"],
    ["xer", "application/patch-ops-error+xml"],
    ["xfdf", "application/vnd.adobe.xfdf"],
    ["xfdl", "application/vnd.xfdl"],
    ["xgz", "xgl/drawing"],
    ["xhtml", "application/xhtml+xml"],
    ["xif", "image/vnd.xiff"],
    ["xl", "application/excel"],
    ["xla", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlam", "application/vnd.ms-excel.addin.macroenabled.12"],
    ["xlb", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlc", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xld", ["application/excel", "application/x-excel"]],
    ["xlk", ["application/excel", "application/x-excel"]],
    ["xll", ["application/excel", "application/vnd.ms-excel", "application/x-excel"]],
    ["xlm", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xls", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xlsb", "application/vnd.ms-excel.sheet.binary.macroenabled.12"],
    ["xlsm", "application/vnd.ms-excel.sheet.macroenabled.12"],
    ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
    ["xlt", ["application/vnd.ms-excel", "application/excel", "application/x-excel"]],
    ["xltm", "application/vnd.ms-excel.template.macroenabled.12"],
    ["xltx", "application/vnd.openxmlformats-officedocument.spreadsheetml.template"],
    ["xlv", ["application/excel", "application/x-excel"]],
    ["xlw", ["application/vnd.ms-excel", "application/excel", "application/x-msexcel", "application/x-excel"]],
    ["xm", "audio/xm"],
    ["xml", ["application/xml", "text/xml", "application/atom+xml", "application/rss+xml"]],
    ["xmz", "xgl/movie"],
    ["xo", "application/vnd.olpc-sugar"],
    ["xof", "x-world/x-vrml"],
    ["xop", "application/xop+xml"],
    ["xpi", "application/x-xpinstall"],
    ["xpix", "application/x-vnd.ls-xpix"],
    ["xpm", ["image/xpm", "image/x-xpixmap"]],
    ["xpr", "application/vnd.is-xpr"],
    ["xps", "application/vnd.ms-xpsdocument"],
    ["xpw", "application/vnd.intercon.formnet"],
    ["xslt", "application/xslt+xml"],
    ["xsm", "application/vnd.syncml+xml"],
    ["xspf", "application/xspf+xml"],
    ["xsr", "video/x-amt-showrun"],
    ["xul", "application/vnd.mozilla.xul+xml"],
    ["xwd", ["image/x-xwd", "image/x-xwindowdump"]],
    ["xyz", ["chemical/x-xyz", "chemical/x-pdb"]],
    ["yang", "application/yang"],
    ["yin", "application/yin+xml"],
    ["z", ["application/x-compressed", "application/x-compress"]],
    ["zaz", "application/vnd.zzazz.deck+xml"],
    ["zip", ["application/zip", "multipart/x-zip", "application/x-zip-compressed", "application/x-compressed"]],
    ["zir", "application/vnd.zul"],
    ["zmm", "application/vnd.handheld-entertainment+xml"],
    ["zoo", "application/octet-stream"],
    ["zsh", "text/x-script.zsh"]
  ]);
  module.exports = {
    detectMimeType(filename) {
      if (!filename) {
        return defaultMimeType;
      }
      let parsed = path.parse(filename);
      let extension = (parsed.ext.substr(1) || parsed.name || "").split("?").shift().trim().toLowerCase();
      let value15 = defaultMimeType;
      if (extensions.has(extension)) {
        value15 = extensions.get(extension);
      }
      if (Array.isArray(value15)) {
        return value15[0];
      }
      return value15;
    },
    detectExtension(mimeType) {
      if (!mimeType) {
        return defaultExtension;
      }
      let parts = (mimeType || "").toLowerCase().trim().split("/");
      let rootType = parts.shift().trim();
      let subType = parts.join("/").trim();
      if (mimeTypes.has(rootType + "/" + subType)) {
        let value15 = mimeTypes.get(rootType + "/" + subType);
        if (Array.isArray(value15)) {
          return value15[0];
        }
        return value15;
      }
      switch (rootType) {
        case "text":
          return "txt";
        default:
          return "bin";
      }
    }
  };
});

// node_modules/nodemailer/lib/punycode/index.js
var require_punycode = __commonJS((exports, module) => {
  var error22 = function(type75) {
    throw new RangeError(errors10[type75]);
  };
  var map3 = function(array6, callback) {
    const result2 = [];
    let length = array6.length;
    while (length--) {
      result2[length] = callback(array6[length]);
    }
    return result2;
  };
  var mapDomain = function(domain, callback) {
    const parts = domain.split("@");
    let result2 = "";
    if (parts.length > 1) {
      result2 = parts[0] + "@";
      domain = parts[1];
    }
    domain = domain.replace(regexSeparators, ".");
    const labels = domain.split(".");
    const encoded = map3(labels, callback).join(".");
    return result2 + encoded;
  };
  var ucs2decode = function(string7) {
    const output = [];
    let counter = 0;
    const length = string7.length;
    while (counter < length) {
      const value15 = string7.charCodeAt(counter++);
      if (value15 >= 55296 && value15 <= 56319 && counter < length) {
        const extra = string7.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value15 & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value15);
          counter--;
        }
      } else {
        output.push(value15);
      }
    }
    return output;
  };
  var maxInt = 2147483647;
  var base = 36;
  var tMin = 1;
  var tMax = 26;
  var skew = 38;
  var damp = 700;
  var initialBias = 72;
  var initialN = 128;
  var delimiter = "-";
  var regexPunycode = /^xn--/;
  var regexNonASCII = /[^\0-\x7F]/;
  var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  var errors10 = {
    overflow: "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  var baseMinusTMin = base - tMin;
  var floor = Math.floor;
  var stringFromCharCode = String.fromCharCode;
  var ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  var basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  var digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  var adapt = function(delta4, numPoints, firstTime) {
    let k = 0;
    delta4 = firstTime ? floor(delta4 / damp) : delta4 >> 1;
    delta4 += floor(delta4 / numPoints);
    for (;delta4 > baseMinusTMin * tMax >> 1; k += base) {
      delta4 = floor(delta4 / baseMinusTMin);
    }
    return floor(k + (baseMinusTMin + 1) * delta4 / (delta4 + skew));
  };
  var decode2 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i = 0;
    let n2 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter);
    if (basic < 0) {
      basic = 0;
    }
    for (let j = 0;j < basic; ++j) {
      if (input.charCodeAt(j) >= 128) {
        error22("not-basic");
      }
      output.push(input.charCodeAt(j));
    }
    for (let index = basic > 0 ? basic + 1 : 0;index < inputLength; ) {
      const oldi = i;
      for (let w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error22("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error22("invalid-input");
        }
        if (digit > floor((maxInt - i) / w)) {
          error22("overflow");
        }
        i += digit * w;
        const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
        if (digit < t) {
          break;
        }
        const baseMinusT = base - t;
        if (w > floor(maxInt / baseMinusT)) {
          error22("overflow");
        }
        w *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0);
      if (floor(i / out) > maxInt - n2) {
        error22("overflow");
      }
      n2 += floor(i / out);
      i %= out;
      output.splice(i++, 0, n2);
    }
    return String.fromCodePoint(...output);
  };
  var encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n2 = initialN;
    let delta4 = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter);
    }
    while (handledCPCount < inputLength) {
      let m2 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n2 && currentValue < m2) {
          m2 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m2 - n2 > floor((maxInt - delta4) / handledCPCountPlusOne)) {
        error22("overflow");
      }
      delta4 += (m2 - n2) * handledCPCountPlusOne;
      n2 = m2;
      for (const currentValue of input) {
        if (currentValue < n2 && ++delta4 > maxInt) {
          error22("overflow");
        }
        if (currentValue === n2) {
          let q2 = delta4;
          for (let k = base;; k += base) {
            const t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (q2 < t) {
              break;
            }
            const qMinusT = q2 - t;
            const baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q2 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q2, 0)));
          bias = adapt(delta4, handledCPCountPlusOne, handledCPCount === basicLength);
          delta4 = 0;
          ++handledCPCount;
        }
      }
      ++delta4;
      ++n2;
    }
    return output.join("");
  };
  var toUnicode = function(input) {
    return mapDomain(input, function(string7) {
      return regexPunycode.test(string7) ? decode2(string7.slice(4).toLowerCase()) : string7;
    });
  };
  var toASCII = function(input) {
    return mapDomain(input, function(string7) {
      return regexNonASCII.test(string7) ? "xn--" + encode2(string7) : string7;
    });
  };
  var punycode = {
    version: "2.3.1",
    ucs2: {
      decode: ucs2decode,
      encode: ucs2encode
    },
    decode: decode2,
    encode: encode2,
    toASCII,
    toUnicode
  };
  module.exports = punycode;
});

// node_modules/nodemailer/lib/base64/index.js
var require_base64 = __commonJS((exports, module) => {
  var encode2 = function(buffer2) {
    if (typeof buffer2 === "string") {
      buffer2 = Buffer.from(buffer2, "utf-8");
    }
    return buffer2.toString("base64");
  };
  var wrap = function(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let result2 = [];
    let pos = 0;
    let chunkLength = lineLength * 1024;
    while (pos < str.length) {
      let wrappedLines = str.substr(pos, chunkLength).replace(new RegExp(".{" + lineLength + "}", "g"), "$&\r\n").trim();
      result2.push(wrappedLines);
      pos += chunkLength;
    }
    return result2.join("\r\n").trim();
  };
  var Transform2 = import.meta.require("stream").Transform;

  class Encoder extends Transform2 {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this._remainingBytes = false;
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return setImmediate(done);
      }
      this.inputBytes += chunk.length;
      if (this._remainingBytes && this._remainingBytes.length) {
        chunk = Buffer.concat([this._remainingBytes, chunk], this._remainingBytes.length + chunk.length);
        this._remainingBytes = false;
      }
      if (chunk.length % 3) {
        this._remainingBytes = chunk.slice(chunk.length - chunk.length % 3);
        chunk = chunk.slice(0, chunk.length - chunk.length % 3);
      } else {
        this._remainingBytes = false;
      }
      let b64 = this._curLine + encode2(chunk);
      if (this.options.lineLength) {
        b64 = wrap(b64, this.options.lineLength);
        let lastLF = b64.lastIndexOf("\n");
        if (lastLF < 0) {
          this._curLine = b64;
          b64 = "";
        } else if (lastLF === b64.length - 1) {
          this._curLine = "";
        } else {
          this._curLine = b64.substr(lastLF + 1);
          b64 = b64.substr(0, lastLF + 1);
        }
      }
      if (b64) {
        this.outputBytes += b64.length;
        this.push(Buffer.from(b64, "ascii"));
      }
      setImmediate(done);
    }
    _flush(done) {
      if (this._remainingBytes && this._remainingBytes.length) {
        this._curLine += encode2(this._remainingBytes);
      }
      if (this._curLine) {
        this._curLine = wrap(this._curLine, this.options.lineLength);
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
        this._curLine = "";
      }
      done();
    }
  }
  module.exports = {
    encode: encode2,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/qp/index.js
var require_qp = __commonJS((exports, module) => {
  var encode2 = function(buffer2) {
    if (typeof buffer2 === "string") {
      buffer2 = Buffer.from(buffer2, "utf-8");
    }
    let ranges = [
      [9],
      [10],
      [13],
      [32, 60],
      [62, 126]
    ];
    let result2 = "";
    let ord;
    for (let i = 0, len = buffer2.length;i < len; i++) {
      ord = buffer2[i];
      if (checkRanges(ord, ranges) && !((ord === 32 || ord === 9) && (i === len - 1 || buffer2[i + 1] === 10 || buffer2[i + 1] === 13))) {
        result2 += String.fromCharCode(ord);
        continue;
      }
      result2 += "=" + (ord < 16 ? "0" : "") + ord.toString(16).toUpperCase();
    }
    return result2;
  };
  var wrap = function(str, lineLength) {
    str = (str || "").toString();
    lineLength = lineLength || 76;
    if (str.length <= lineLength) {
      return str;
    }
    let pos = 0;
    let len = str.length;
    let match, code, line;
    let lineMargin = Math.floor(lineLength / 3);
    let result2 = "";
    while (pos < len) {
      line = str.substr(pos, lineLength);
      if (match = line.match(/\r\n/)) {
        line = line.substr(0, match.index + match[0].length);
        result2 += line;
        pos += line.length;
        continue;
      }
      if (line.substr(-1) === "\n") {
        result2 += line;
        pos += line.length;
        continue;
      } else if (match = line.substr(-lineMargin).match(/\n.*?$/)) {
        line = line.substr(0, line.length - (match[0].length - 1));
        result2 += line;
        pos += line.length;
        continue;
      } else if (line.length > lineLength - lineMargin && (match = line.substr(-lineMargin).match(/[ \t.,!?][^ \t.,!?]*$/))) {
        line = line.substr(0, line.length - (match[0].length - 1));
      } else if (line.match(/[=][\da-f]{0,2}$/i)) {
        if (match = line.match(/[=][\da-f]{0,1}$/i)) {
          line = line.substr(0, line.length - match[0].length);
        }
        while (line.length > 3 && line.length < len - pos && !line.match(/^(?:=[\da-f]{2}){1,4}$/i) && (match = line.match(/[=][\da-f]{2}$/gi))) {
          code = parseInt(match[0].substr(1, 2), 16);
          if (code < 128) {
            break;
          }
          line = line.substr(0, line.length - 3);
          if (code >= 192) {
            break;
          }
        }
      }
      if (pos + line.length < len && line.substr(-1) !== "\n") {
        if (line.length === lineLength && line.match(/[=][\da-f]{2}$/i)) {
          line = line.substr(0, line.length - 3);
        } else if (line.length === lineLength) {
          line = line.substr(0, line.length - 1);
        }
        pos += line.length;
        line += "=\r\n";
      } else {
        pos += line.length;
      }
      result2 += line;
    }
    return result2;
  };
  var checkRanges = function(nr, ranges) {
    for (let i = ranges.length - 1;i >= 0; i--) {
      if (!ranges[i].length) {
        continue;
      }
      if (ranges[i].length === 1 && nr === ranges[i][0]) {
        return true;
      }
      if (ranges[i].length === 2 && nr >= ranges[i][0] && nr <= ranges[i][1]) {
        return true;
      }
    }
    return false;
  };
  var Transform2 = import.meta.require("stream").Transform;

  class Encoder extends Transform2 {
    constructor(options) {
      super();
      this.options = options || {};
      if (this.options.lineLength !== false) {
        this.options.lineLength = this.options.lineLength || 76;
      }
      this._curLine = "";
      this.inputBytes = 0;
      this.outputBytes = 0;
    }
    _transform(chunk, encoding, done) {
      let qp;
      if (encoding !== "buffer") {
        chunk = Buffer.from(chunk, encoding);
      }
      if (!chunk || !chunk.length) {
        return done();
      }
      this.inputBytes += chunk.length;
      if (this.options.lineLength) {
        qp = this._curLine + encode2(chunk);
        qp = wrap(qp, this.options.lineLength);
        qp = qp.replace(/(^|\n)([^\n]*)$/, (match, lineBreak, lastLine) => {
          this._curLine = lastLine;
          return lineBreak;
        });
        if (qp) {
          this.outputBytes += qp.length;
          this.push(qp);
        }
      } else {
        qp = encode2(chunk);
        this.outputBytes += qp.length;
        this.push(qp, "ascii");
      }
      done();
    }
    _flush(done) {
      if (this._curLine) {
        this.outputBytes += this._curLine.length;
        this.push(this._curLine, "ascii");
      }
      done();
    }
  }
  module.exports = {
    encode: encode2,
    wrap,
    Encoder
  };
});

// node_modules/nodemailer/lib/mime-funcs/index.js
var require_mime_funcs = __commonJS((exports, module) => {
  var base64 = require_base64();
  var qp = require_qp();
  var mimeTypes = require_mime_types();
  module.exports = {
    isPlainText(value15, isParam) {
      const re = isParam ? /[\x00-\x08\x0b\x0c\x0e-\x1f"\u0080-\uFFFF]/ : /[\x00-\x08\x0b\x0c\x0e-\x1f\u0080-\uFFFF]/;
      if (typeof value15 !== "string" || re.test(value15)) {
        return false;
      } else {
        return true;
      }
    },
    hasLongerLines(str, lineLength) {
      if (str.length > 128 * 1024) {
        return true;
      }
      return new RegExp("^.{" + (lineLength + 1) + ",}", "m").test(str);
    },
    encodeWord(data, mimeWordEncoding, maxLength) {
      mimeWordEncoding = (mimeWordEncoding || "Q").toString().toUpperCase().trim().charAt(0);
      maxLength = maxLength || 0;
      let encodedStr;
      let toCharset = "UTF-8";
      if (maxLength && maxLength > 7 + toCharset.length) {
        maxLength -= 7 + toCharset.length;
      }
      if (mimeWordEncoding === "Q") {
        encodedStr = qp.encode(data).replace(/[^a-z0-9!*+\-/=]/gi, (chr) => {
          let ord = chr.charCodeAt(0).toString(16).toUpperCase();
          if (chr === " ") {
            return "_";
          } else {
            return "=" + (ord.length === 1 ? "0" + ord : ord);
          }
        });
      } else if (mimeWordEncoding === "B") {
        encodedStr = typeof data === "string" ? data : base64.encode(data);
        maxLength = maxLength ? Math.max(3, (maxLength - maxLength % 4) / 4 * 3) : 0;
      }
      if (maxLength && (mimeWordEncoding !== "B" ? encodedStr : base64.encode(data)).length > maxLength) {
        if (mimeWordEncoding === "Q") {
          encodedStr = this.splitMimeEncodedString(encodedStr, maxLength).join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
        } else {
          let parts = [];
          let lpart = "";
          for (let i = 0, len = encodedStr.length;i < len; i++) {
            let chr = encodedStr.charAt(i);
            if (/[\ud83c\ud83d\ud83e]/.test(chr) && i < len - 1) {
              chr += encodedStr.charAt(++i);
            }
            if (Buffer.byteLength(lpart + chr) <= maxLength || i === 0) {
              lpart += chr;
            } else {
              parts.push(base64.encode(lpart));
              lpart = chr;
            }
          }
          if (lpart) {
            parts.push(base64.encode(lpart));
          }
          if (parts.length > 1) {
            encodedStr = parts.join("?= =?" + toCharset + "?" + mimeWordEncoding + "?");
          } else {
            encodedStr = parts.join("");
          }
        }
      } else if (mimeWordEncoding === "B") {
        encodedStr = base64.encode(data);
      }
      return "=?" + toCharset + "?" + mimeWordEncoding + "?" + encodedStr + (encodedStr.substr(-2) === "?=" ? "" : "?=");
    },
    encodeWords(value15, mimeWordEncoding, maxLength, encodeAll) {
      maxLength = maxLength || 0;
      let encodedValue;
      let firstMatch = value15.match(/(?:^|\s)([^\s]*["\u0080-\uFFFF])/);
      if (!firstMatch) {
        return value15;
      }
      if (encodeAll) {
        return this.encodeWord(value15, mimeWordEncoding, maxLength);
      }
      let lastMatch = value15.match(/(["\u0080-\uFFFF][^\s]*)[^"\u0080-\uFFFF]*$/);
      if (!lastMatch) {
        return value15;
      }
      let startIndex = firstMatch.index + (firstMatch[0].match(/[^\s]/) || {
        index: 0
      }).index;
      let endIndex = lastMatch.index + (lastMatch[1] || "").length;
      encodedValue = (startIndex ? value15.substr(0, startIndex) : "") + this.encodeWord(value15.substring(startIndex, endIndex), mimeWordEncoding || "Q", maxLength) + (endIndex < value15.length ? value15.substr(endIndex) : "");
      return encodedValue;
    },
    buildHeaderValue(structured) {
      let paramsArray = [];
      Object.keys(structured.params || {}).forEach((param) => {
        let value15 = structured.params[param];
        if (!this.isPlainText(value15, true) || value15.length >= 75) {
          this.buildHeaderParam(param, value15, 50).forEach((encodedParam) => {
            if (!/[\s"\\;:/=(),<>@[\]?]|^[-']|'$/.test(encodedParam.value) || encodedParam.key.substr(-1) === "*") {
              paramsArray.push(encodedParam.key + "=" + encodedParam.value);
            } else {
              paramsArray.push(encodedParam.key + "=" + JSON.stringify(encodedParam.value));
            }
          });
        } else if (/[\s'"\\;:/=(),<>@[\]?]|^-/.test(value15)) {
          paramsArray.push(param + "=" + JSON.stringify(value15));
        } else {
          paramsArray.push(param + "=" + value15);
        }
      });
      return structured.value + (paramsArray.length ? "; " + paramsArray.join("; ") : "");
    },
    buildHeaderParam(key, data, maxLength) {
      let list = [];
      let encodedStr = typeof data === "string" ? data : (data || "").toString();
      let encodedStrArr;
      let chr, ord;
      let line;
      let startPos = 0;
      let i, len;
      maxLength = maxLength || 50;
      if (this.isPlainText(data, true)) {
        if (encodedStr.length <= maxLength) {
          return [
            {
              key,
              value: encodedStr
            }
          ];
        }
        encodedStr = encodedStr.replace(new RegExp(".{" + maxLength + "}", "g"), (str) => {
          list.push({
            line: str
          });
          return "";
        });
        if (encodedStr) {
          list.push({
            line: encodedStr
          });
        }
      } else {
        if (/[\uD800-\uDBFF]/.test(encodedStr)) {
          encodedStrArr = [];
          for (i = 0, len = encodedStr.length;i < len; i++) {
            chr = encodedStr.charAt(i);
            ord = chr.charCodeAt(0);
            if (ord >= 55296 && ord <= 56319 && i < len - 1) {
              chr += encodedStr.charAt(i + 1);
              encodedStrArr.push(chr);
              i++;
            } else {
              encodedStrArr.push(chr);
            }
          }
          encodedStr = encodedStrArr;
        }
        line = "utf-8''";
        let encoded = true;
        startPos = 0;
        for (i = 0, len = encodedStr.length;i < len; i++) {
          chr = encodedStr[i];
          if (encoded) {
            chr = this.safeEncodeURIComponent(chr);
          } else {
            chr = chr === " " ? chr : this.safeEncodeURIComponent(chr);
            if (chr !== encodedStr[i]) {
              if ((this.safeEncodeURIComponent(line) + chr).length >= maxLength) {
                list.push({
                  line,
                  encoded
                });
                line = "";
                startPos = i - 1;
              } else {
                encoded = true;
                i = startPos;
                line = "";
                continue;
              }
            }
          }
          if ((line + chr).length >= maxLength) {
            list.push({
              line,
              encoded
            });
            line = chr = encodedStr[i] === " " ? " " : this.safeEncodeURIComponent(encodedStr[i]);
            if (chr === encodedStr[i]) {
              encoded = false;
              startPos = i - 1;
            } else {
              encoded = true;
            }
          } else {
            line += chr;
          }
        }
        if (line) {
          list.push({
            line,
            encoded
          });
        }
      }
      return list.map((item, i2) => ({
        key: key + "*" + i2 + (item.encoded ? "*" : ""),
        value: item.line
      }));
    },
    parseHeaderValue(str) {
      let response = {
        value: false,
        params: {}
      };
      let key = false;
      let value15 = "";
      let type75 = "value";
      let quote = false;
      let escaped = false;
      let chr;
      for (let i = 0, len = str.length;i < len; i++) {
        chr = str.charAt(i);
        if (type75 === "key") {
          if (chr === "=") {
            key = value15.trim().toLowerCase();
            type75 = "value";
            value15 = "";
            continue;
          }
          value15 += chr;
        } else {
          if (escaped) {
            value15 += chr;
          } else if (chr === "\\") {
            escaped = true;
            continue;
          } else if (quote && chr === quote) {
            quote = false;
          } else if (!quote && chr === '"') {
            quote = chr;
          } else if (!quote && chr === ";") {
            if (key === false) {
              response.value = value15.trim();
            } else {
              response.params[key] = value15.trim();
            }
            type75 = "key";
            value15 = "";
          } else {
            value15 += chr;
          }
          escaped = false;
        }
      }
      if (type75 === "value") {
        if (key === false) {
          response.value = value15.trim();
        } else {
          response.params[key] = value15.trim();
        }
      } else if (value15.trim()) {
        response.params[value15.trim().toLowerCase()] = "";
      }
      Object.keys(response.params).forEach((key2) => {
        let actualKey, nr, match, value16;
        if (match = key2.match(/(\*(\d+)|\*(\d+)\*|\*)$/)) {
          actualKey = key2.substr(0, match.index);
          nr = Number(match[2] || match[3]) || 0;
          if (!response.params[actualKey] || typeof response.params[actualKey] !== "object") {
            response.params[actualKey] = {
              charset: false,
              values: []
            };
          }
          value16 = response.params[key2];
          if (nr === 0 && match[0].substr(-1) === "*" && (match = value16.match(/^([^']*)'[^']*'(.*)$/))) {
            response.params[actualKey].charset = match[1] || "iso-8859-1";
            value16 = match[2];
          }
          response.params[actualKey].values[nr] = value16;
          delete response.params[key2];
        }
      });
      Object.keys(response.params).forEach((key2) => {
        let value16;
        if (response.params[key2] && Array.isArray(response.params[key2].values)) {
          value16 = response.params[key2].values.map((val) => val || "").join("");
          if (response.params[key2].charset) {
            response.params[key2] = "=?" + response.params[key2].charset + "?Q?" + value16.replace(/[=?_\s]/g, (s2) => {
              let c2 = s2.charCodeAt(0).toString(16);
              if (s2 === " ") {
                return "_";
              } else {
                return "%" + (c2.length < 2 ? "0" : "") + c2;
              }
            }).replace(/%/g, "=") + "?=";
          } else {
            response.params[key2] = value16;
          }
        }
      });
      return response;
    },
    detectExtension: (mimeType) => mimeTypes.detectExtension(mimeType),
    detectMimeType: (extension) => mimeTypes.detectMimeType(extension),
    foldLines(str, lineLength, afterSpace) {
      str = (str || "").toString();
      lineLength = lineLength || 76;
      let pos = 0, len = str.length, result2 = "", line, match;
      while (pos < len) {
        line = str.substr(pos, lineLength);
        if (line.length < lineLength) {
          result2 += line;
          break;
        }
        if (match = line.match(/^[^\n\r]*(\r?\n|\r)/)) {
          line = match[0];
          result2 += line;
          pos += line.length;
          continue;
        } else if ((match = line.match(/(\s+)[^\s]*$/)) && match[0].length - (afterSpace ? (match[1] || "").length : 0) < line.length) {
          line = line.substr(0, line.length - (match[0].length - (afterSpace ? (match[1] || "").length : 0)));
        } else if (match = str.substr(pos + line.length).match(/^[^\s]+(\s*)/)) {
          line = line + match[0].substr(0, match[0].length - (!afterSpace ? (match[1] || "").length : 0));
        }
        result2 += line;
        pos += line.length;
        if (pos < len) {
          result2 += "\r\n";
        }
      }
      return result2;
    },
    splitMimeEncodedString: (str, maxlen) => {
      let curLine, match, chr, done, lines = [];
      maxlen = Math.max(maxlen || 0, 12);
      while (str.length) {
        curLine = str.substr(0, maxlen);
        if (match = curLine.match(/[=][0-9A-F]?$/i)) {
          curLine = curLine.substr(0, match.index);
        }
        done = false;
        while (!done) {
          done = true;
          if (match = str.substr(curLine.length).match(/^[=]([0-9A-F]{2})/i)) {
            chr = parseInt(match[1], 16);
            if (chr < 194 && chr > 127) {
              curLine = curLine.substr(0, curLine.length - 3);
              done = false;
            }
          }
        }
        if (curLine.length) {
          lines.push(curLine);
        }
        str = str.substr(curLine.length);
      }
      return lines;
    },
    encodeURICharComponent: (chr) => {
      let res = "";
      let ord = chr.charCodeAt(0).toString(16).toUpperCase();
      if (ord.length % 2) {
        ord = "0" + ord;
      }
      if (ord.length > 2) {
        for (let i = 0, len = ord.length / 2;i < len; i++) {
          res += "%" + ord.substr(i, 2);
        }
      } else {
        res += "%" + ord;
      }
      return res;
    },
    safeEncodeURIComponent(str) {
      str = (str || "").toString();
      try {
        str = encodeURIComponent(str);
      } catch (E) {
        return str.replace(/[^\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]+/g, "");
      }
      return str.replace(/[\x00-\x1F *'()<>@,;:\\"[\]?=\u007F-\uFFFF]/g, (chr) => this.encodeURICharComponent(chr));
    }
  };
});

// node_modules/nodemailer/lib/addressparser/index.js
var require_addressparser = __commonJS((exports, module) => {
  var _handleAddress = function(tokens) {
    let token;
    let isGroup = false;
    let state = "text";
    let address;
    let addresses = [];
    let data = {
      address: [],
      comment: [],
      group: [],
      text: []
    };
    let i;
    let len;
    for (i = 0, len = tokens.length;i < len; i++) {
      token = tokens[i];
      if (token.type === "operator") {
        switch (token.value) {
          case "<":
            state = "address";
            break;
          case "(":
            state = "comment";
            break;
          case ":":
            state = "group";
            isGroup = true;
            break;
          default:
            state = "text";
        }
      } else if (token.value) {
        if (state === "address") {
          token.value = token.value.replace(/^[^<]*<\s*/, "");
        }
        data[state].push(token.value);
      }
    }
    if (!data.text.length && data.comment.length) {
      data.text = data.comment;
      data.comment = [];
    }
    if (isGroup) {
      data.text = data.text.join(" ");
      addresses.push({
        name: data.text || address && address.name,
        group: data.group.length ? addressparser(data.group.join(",")) : []
      });
    } else {
      if (!data.address.length && data.text.length) {
        for (i = data.text.length - 1;i >= 0; i--) {
          if (data.text[i].match(/^[^@\s]+@[^@\s]+$/)) {
            data.address = data.text.splice(i, 1);
            break;
          }
        }
        let _regexHandler = function(address2) {
          if (!data.address.length) {
            data.address = [address2.trim()];
            return " ";
          } else {
            return address2;
          }
        };
        if (!data.address.length) {
          for (i = data.text.length - 1;i >= 0; i--) {
            data.text[i] = data.text[i].replace(/\s*\b[^@\s]+@[^\s]+\b\s*/, _regexHandler).trim();
            if (data.address.length) {
              break;
            }
          }
        }
      }
      if (!data.text.length && data.comment.length) {
        data.text = data.comment;
        data.comment = [];
      }
      if (data.address.length > 1) {
        data.text = data.text.concat(data.address.splice(1));
      }
      data.text = data.text.join(" ");
      data.address = data.address.join(" ");
      if (!data.address && isGroup) {
        return [];
      } else {
        address = {
          address: data.address || data.text || "",
          name: data.text || data.address || ""
        };
        if (address.address === address.name) {
          if ((address.address || "").match(/@/)) {
            address.name = "";
          } else {
            address.address = "";
          }
        }
        addresses.push(address);
      }
    }
    return addresses;
  };
  var addressparser = function(str, options) {
    options = options || {};
    let tokenizer = new Tokenizer(str);
    let tokens = tokenizer.tokenize();
    let addresses = [];
    let address = [];
    let parsedAddresses = [];
    tokens.forEach((token) => {
      if (token.type === "operator" && (token.value === "," || token.value === ";")) {
        if (address.length) {
          addresses.push(address);
        }
        address = [];
      } else {
        address.push(token);
      }
    });
    if (address.length) {
      addresses.push(address);
    }
    addresses.forEach((address2) => {
      address2 = _handleAddress(address2);
      if (address2.length) {
        parsedAddresses = parsedAddresses.concat(address2);
      }
    });
    if (options.flatten) {
      let addresses2 = [];
      let walkAddressList = (list) => {
        list.forEach((address2) => {
          if (address2.group) {
            return walkAddressList(address2.group);
          } else {
            addresses2.push(address2);
          }
        });
      };
      walkAddressList(parsedAddresses);
      return addresses2;
    }
    return parsedAddresses;
  };

  class Tokenizer {
    constructor(str) {
      this.str = (str || "").toString();
      this.operatorCurrent = "";
      this.operatorExpecting = "";
      this.node = null;
      this.escaped = false;
      this.list = [];
      this.operators = {
        '"': '"',
        "(": ")",
        "<": ">",
        ",": "",
        ":": ";",
        ";": ""
      };
    }
    tokenize() {
      let chr, list = [];
      for (let i = 0, len = this.str.length;i < len; i++) {
        chr = this.str.charAt(i);
        this.checkChar(chr);
      }
      this.list.forEach((node) => {
        node.value = (node.value || "").toString().trim();
        if (node.value) {
          list.push(node);
        }
      });
      return list;
    }
    checkChar(chr) {
      if (this.escaped) {
      } else if (chr === this.operatorExpecting) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = "";
        this.escaped = false;
        return;
      } else if (!this.operatorExpecting && chr in this.operators) {
        this.node = {
          type: "operator",
          value: chr
        };
        this.list.push(this.node);
        this.node = null;
        this.operatorExpecting = this.operators[chr];
        this.escaped = false;
        return;
      } else if (['"', "'"].includes(this.operatorExpecting) && chr === "\\") {
        this.escaped = true;
        return;
      }
      if (!this.node) {
        this.node = {
          type: "text",
          value: ""
        };
        this.list.push(this.node);
      }
      if (chr === "\n") {
        chr = " ";
      }
      if (chr.charCodeAt(0) >= 33 || [" ", "\t"].includes(chr)) {
        this.node.value += chr;
      }
      this.escaped = false;
    }
  }
  module.exports = addressparser;
});

// node_modules/nodemailer/lib/mime-node/last-newline.js
var require_last_newline = __commonJS((exports, module) => {
  var Transform2 = import.meta.require("stream").Transform;

  class LastNewline extends Transform2 {
    constructor() {
      super();
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      if (chunk.length) {
        this.lastByte = chunk[chunk.length - 1];
      }
      this.push(chunk);
      done();
    }
    _flush(done) {
      if (this.lastByte === 10) {
        return done();
      }
      if (this.lastByte === 13) {
        this.push(Buffer.from("\n"));
        return done();
      }
      this.push(Buffer.from("\r\n"));
      return done();
    }
  }
  module.exports = LastNewline;
});

// node_modules/nodemailer/lib/mime-node/le-windows.js
var require_le_windows = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform2 = stream.Transform;

  class LeWindows extends Transform2 {
    constructor(options) {
      super(options);
      this.options = options || {};
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              this.push(buf);
            }
            this.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/le-unix.js
var require_le_unix = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform2 = stream.Transform;

  class LeWindows extends Transform2 {
    constructor(options) {
      super(options);
      this.options = options || {};
    }
    _transform(chunk, encoding, done) {
      let buf;
      let lastPos = 0;
      for (let i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 13) {
          buf = chunk.slice(lastPos, i);
          lastPos = i + 1;
          this.push(buf);
        }
      }
      if (lastPos && lastPos < chunk.length) {
        buf = chunk.slice(lastPos);
        this.push(buf);
      } else if (!lastPos) {
        this.push(chunk);
      }
      done();
    }
  }
  module.exports = LeWindows;
});

// node_modules/nodemailer/lib/mime-node/index.js
var require_mime_node = __commonJS((exports, module) => {
  var crypto3 = import.meta.require("crypto");
  var fs2 = import.meta.require("fs");
  var punycode = require_punycode();
  var PassThrough = import.meta.require("stream").PassThrough;
  var shared = require_shared();
  var mimeFuncs = require_mime_funcs();
  var qp = require_qp();
  var base64 = require_base64();
  var addressparser = require_addressparser();
  var nmfetch = require_fetch();
  var LastNewline = require_last_newline();
  var LeWindows = require_le_windows();
  var LeUnix = require_le_unix();

  class MimeNode {
    constructor(contentType, options) {
      this.nodeCounter = 0;
      options = options || {};
      this.baseBoundary = options.baseBoundary || crypto3.randomBytes(8).toString("hex");
      this.boundaryPrefix = options.boundaryPrefix || "--_NmP";
      this.disableFileAccess = !!options.disableFileAccess;
      this.disableUrlAccess = !!options.disableUrlAccess;
      this.normalizeHeaderKey = options.normalizeHeaderKey;
      this.date = new Date;
      this.rootNode = options.rootNode || this;
      this.keepBcc = !!options.keepBcc;
      if (options.filename) {
        this.filename = options.filename;
        if (!contentType) {
          contentType = mimeFuncs.detectMimeType(this.filename.split(".").pop());
        }
      }
      this.textEncoding = (options.textEncoding || "").toString().trim().charAt(0).toUpperCase();
      this.parentNode = options.parentNode;
      this.hostname = options.hostname;
      this.newline = options.newline;
      this.childNodes = [];
      this._nodeId = ++this.rootNode.nodeCounter;
      this._headers = [];
      this._isPlainText = false;
      this._hasLongLines = false;
      this._envelope = false;
      this._raw = false;
      this._transforms = [];
      this._processFuncs = [];
      if (contentType) {
        this.setHeader("Content-Type", contentType);
      }
    }
    createChild(contentType, options) {
      if (!options && typeof contentType === "object") {
        options = contentType;
        contentType = undefined;
      }
      let node = new MimeNode(contentType, options);
      this.appendChild(node);
      return node;
    }
    appendChild(childNode) {
      if (childNode.rootNode !== this.rootNode) {
        childNode.rootNode = this.rootNode;
        childNode._nodeId = ++this.rootNode.nodeCounter;
      }
      childNode.parentNode = this;
      this.childNodes.push(childNode);
      return childNode;
    }
    replace(node) {
      if (node === this) {
        return this;
      }
      this.parentNode.childNodes.forEach((childNode, i) => {
        if (childNode === this) {
          node.rootNode = this.rootNode;
          node.parentNode = this.parentNode;
          node._nodeId = this._nodeId;
          this.rootNode = this;
          this.parentNode = undefined;
          node.parentNode.childNodes[i] = node;
        }
      });
      return node;
    }
    remove() {
      if (!this.parentNode) {
        return this;
      }
      for (let i = this.parentNode.childNodes.length - 1;i >= 0; i--) {
        if (this.parentNode.childNodes[i] === this) {
          this.parentNode.childNodes.splice(i, 1);
          this.parentNode = undefined;
          this.rootNode = this;
          return this;
        }
      }
    }
    setHeader(key, value15) {
      let added = false, headerValue;
      if (!value15 && key && typeof key === "object") {
        if (key.key && "value" in key) {
          this.setHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.setHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.setHeader(i, key[i]);
          });
        }
        return this;
      }
      key = this._normalizeHeaderKey(key);
      headerValue = {
        key,
        value: value15
      };
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          if (!added) {
            this._headers[i] = headerValue;
            added = true;
          } else {
            this._headers.splice(i, 1);
            i--;
            len--;
          }
        }
      }
      if (!added) {
        this._headers.push(headerValue);
      }
      return this;
    }
    addHeader(key, value15) {
      if (!value15 && key && typeof key === "object") {
        if (key.key && key.value) {
          this.addHeader(key.key, key.value);
        } else if (Array.isArray(key)) {
          key.forEach((i) => {
            this.addHeader(i.key, i.value);
          });
        } else {
          Object.keys(key).forEach((i) => {
            this.addHeader(i, key[i]);
          });
        }
        return this;
      } else if (Array.isArray(value15)) {
        value15.forEach((val) => {
          this.addHeader(key, val);
        });
        return this;
      }
      this._headers.push({
        key: this._normalizeHeaderKey(key),
        value: value15
      });
      return this;
    }
    getHeader(key) {
      key = this._normalizeHeaderKey(key);
      for (let i = 0, len = this._headers.length;i < len; i++) {
        if (this._headers[i].key === key) {
          return this._headers[i].value;
        }
      }
    }
    setContent(content) {
      this.content = content;
      if (typeof this.content.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this.content.removeListener("error", this._contentErrorHandler);
          this.content = err;
        };
        this.content.once("error", this._contentErrorHandler);
      } else if (typeof this.content === "string") {
        this._isPlainText = mimeFuncs.isPlainText(this.content);
        if (this._isPlainText && mimeFuncs.hasLongerLines(this.content, 76)) {
          this._hasLongLines = true;
        }
      }
      return this;
    }
    build(callback) {
      let promise5;
      if (!callback) {
        promise5 = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let stream = this.createReadStream();
      let buf = [];
      let buflen = 0;
      let returned = false;
      stream.on("readable", () => {
        let chunk;
        while ((chunk = stream.read()) !== null) {
          buf.push(chunk);
          buflen += chunk.length;
        }
      });
      stream.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      stream.once("end", (chunk) => {
        if (returned) {
          return;
        }
        returned = true;
        if (chunk && chunk.length) {
          buf.push(chunk);
          buflen += chunk.length;
        }
        return callback(null, Buffer.concat(buf, buflen));
      });
      return promise5;
    }
    getTransferEncoding() {
      let transferEncoding = false;
      let contentType = (this.getHeader("Content-Type") || "").toString().toLowerCase().trim();
      if (this.content) {
        transferEncoding = (this.getHeader("Content-Transfer-Encoding") || "").toString().toLowerCase().trim();
        if (!transferEncoding || !["base64", "quoted-printable"].includes(transferEncoding)) {
          if (/^text\//i.test(contentType)) {
            if (this._isPlainText && !this._hasLongLines) {
              transferEncoding = "7bit";
            } else if (typeof this.content === "string" || this.content instanceof Buffer) {
              transferEncoding = this._getTextEncoding(this.content) === "Q" ? "quoted-printable" : "base64";
            } else {
              transferEncoding = this.textEncoding === "B" ? "base64" : "quoted-printable";
            }
          } else if (!/^(multipart|message)\//i.test(contentType)) {
            transferEncoding = transferEncoding || "base64";
          }
        }
      }
      return transferEncoding;
    }
    buildHeaders() {
      let transferEncoding = this.getTransferEncoding();
      let headers = [];
      if (transferEncoding) {
        this.setHeader("Content-Transfer-Encoding", transferEncoding);
      }
      if (this.filename && !this.getHeader("Content-Disposition")) {
        this.setHeader("Content-Disposition", "attachment");
      }
      if (this.rootNode === this) {
        if (!this.getHeader("Date")) {
          this.setHeader("Date", this.date.toUTCString().replace(/GMT/, "+0000"));
        }
        this.messageId();
        if (!this.getHeader("MIME-Version")) {
          this.setHeader("MIME-Version", "1.0");
        }
        for (let i = this._headers.length - 2;i >= 0; i--) {
          let header = this._headers[i];
          if (header.key === "Content-Type") {
            this._headers.splice(i, 1);
            this._headers.push(header);
          }
        }
      }
      this._headers.forEach((header) => {
        let key = header.key;
        let value15 = header.value;
        let structured;
        let param;
        let options = {};
        let formattedHeaders = ["From", "Sender", "To", "Cc", "Bcc", "Reply-To", "Date", "References"];
        if (value15 && typeof value15 === "object" && !formattedHeaders.includes(key)) {
          Object.keys(value15).forEach((key2) => {
            if (key2 !== "value") {
              options[key2] = value15[key2];
            }
          });
          value15 = (value15.value || "").toString();
          if (!value15.trim()) {
            return;
          }
        }
        if (options.prepared) {
          if (options.foldLines) {
            headers.push(mimeFuncs.foldLines(key + ": " + value15));
          } else {
            headers.push(key + ": " + value15);
          }
          return;
        }
        switch (header.key) {
          case "Content-Disposition":
            structured = mimeFuncs.parseHeaderValue(value15);
            if (this.filename) {
              structured.params.filename = this.filename;
            }
            value15 = mimeFuncs.buildHeaderValue(structured);
            break;
          case "Content-Type":
            structured = mimeFuncs.parseHeaderValue(value15);
            this._handleContentType(structured);
            if (structured.value.match(/^text\/plain\b/) && typeof this.content === "string" && /[\u0080-\uFFFF]/.test(this.content)) {
              structured.params.charset = "utf-8";
            }
            value15 = mimeFuncs.buildHeaderValue(structured);
            if (this.filename) {
              param = this._encodeWords(this.filename);
              if (param !== this.filename || /[\s'"\\;:/=(),<>@[\]?]|^-/.test(param)) {
                param = '"' + param + '"';
              }
              value15 += "; name=" + param;
            }
            break;
          case "Bcc":
            if (!this.keepBcc) {
              return;
            }
            break;
        }
        value15 = this._encodeHeaderValue(key, value15);
        if (!(value15 || "").toString().trim()) {
          return;
        }
        if (typeof this.normalizeHeaderKey === "function") {
          let normalized = this.normalizeHeaderKey(key, value15);
          if (normalized && typeof normalized === "string" && normalized.length) {
            key = normalized;
          }
        }
        headers.push(mimeFuncs.foldLines(key + ": " + value15, 76));
      });
      return headers.join("\r\n");
    }
    createReadStream(options) {
      options = options || {};
      let stream = new PassThrough(options);
      let outputStream = stream;
      let transform7;
      this.stream(stream, options, (err) => {
        if (err) {
          outputStream.emit("error", err);
          return;
        }
        stream.end();
      });
      for (let i = 0, len = this._transforms.length;i < len; i++) {
        transform7 = typeof this._transforms[i] === "function" ? this._transforms[i]() : this._transforms[i];
        outputStream.once("error", (err) => {
          transform7.emit("error", err);
        });
        outputStream = outputStream.pipe(transform7);
      }
      transform7 = new LastNewline;
      outputStream.once("error", (err) => {
        transform7.emit("error", err);
      });
      outputStream = outputStream.pipe(transform7);
      for (let i = 0, len = this._processFuncs.length;i < len; i++) {
        transform7 = this._processFuncs[i];
        outputStream = transform7(outputStream);
      }
      if (this.newline) {
        const winbreak = ["win", "windows", "dos", "\r\n"].includes(this.newline.toString().toLowerCase());
        const newlineTransform = winbreak ? new LeWindows : new LeUnix;
        const stream2 = outputStream.pipe(newlineTransform);
        outputStream.on("error", (err) => stream2.emit("error", err));
        return stream2;
      }
      return outputStream;
    }
    transform(transform7) {
      this._transforms.push(transform7);
    }
    processFunc(processFunc) {
      this._processFuncs.push(processFunc);
    }
    stream(outputStream, options, done) {
      let transferEncoding = this.getTransferEncoding();
      let contentStream;
      let localStream;
      let returned = false;
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        done(err);
      };
      let finalize = () => {
        let childId = 0;
        let processChildNode = () => {
          if (childId >= this.childNodes.length) {
            outputStream.write("\r\n--" + this.boundary + "--\r\n");
            return callback();
          }
          let child = this.childNodes[childId++];
          outputStream.write((childId > 1 ? "\r\n" : "") + "--" + this.boundary + "\r\n");
          child.stream(outputStream, options, (err) => {
            if (err) {
              return callback(err);
            }
            setImmediate(processChildNode);
          });
        };
        if (this.multipart) {
          setImmediate(processChildNode);
        } else {
          return callback();
        }
      };
      let sendContent = () => {
        if (this.content) {
          if (Object.prototype.toString.call(this.content) === "[object Error]") {
            return callback(this.content);
          }
          if (typeof this.content.pipe === "function") {
            this.content.removeListener("error", this._contentErrorHandler);
            this._contentErrorHandler = (err) => callback(err);
            this.content.once("error", this._contentErrorHandler);
          }
          let createStream = () => {
            if (["quoted-printable", "base64"].includes(transferEncoding)) {
              contentStream = new (transferEncoding === "base64" ? base64 : qp).Encoder(options);
              contentStream.pipe(outputStream, {
                end: false
              });
              contentStream.once("end", finalize);
              contentStream.once("error", (err) => callback(err));
              localStream = this._getStream(this.content);
              localStream.pipe(contentStream);
            } else {
              localStream = this._getStream(this.content);
              localStream.pipe(outputStream, {
                end: false
              });
              localStream.once("end", finalize);
            }
            localStream.once("error", (err) => callback(err));
          };
          if (this.content._resolve) {
            let chunks = [];
            let chunklen = 0;
            let returned2 = false;
            let sourceStream = this._getStream(this.content);
            sourceStream.on("error", (err) => {
              if (returned2) {
                return;
              }
              returned2 = true;
              callback(err);
            });
            sourceStream.on("readable", () => {
              let chunk;
              while ((chunk = sourceStream.read()) !== null) {
                chunks.push(chunk);
                chunklen += chunk.length;
              }
            });
            sourceStream.on("end", () => {
              if (returned2) {
                return;
              }
              returned2 = true;
              this.content._resolve = false;
              this.content._resolvedValue = Buffer.concat(chunks, chunklen);
              setImmediate(createStream);
            });
          } else {
            setImmediate(createStream);
          }
          return;
        } else {
          return setImmediate(finalize);
        }
      };
      if (this._raw) {
        setImmediate(() => {
          if (Object.prototype.toString.call(this._raw) === "[object Error]") {
            return callback(this._raw);
          }
          if (typeof this._raw.pipe === "function") {
            this._raw.removeListener("error", this._contentErrorHandler);
          }
          let raw2 = this._getStream(this._raw);
          raw2.pipe(outputStream, {
            end: false
          });
          raw2.on("error", (err) => outputStream.emit("error", err));
          raw2.on("end", finalize);
        });
      } else {
        outputStream.write(this.buildHeaders() + "\r\n\r\n");
        setImmediate(sendContent);
      }
    }
    setEnvelope(envelope) {
      let list;
      this._envelope = {
        from: false,
        to: []
      };
      if (envelope.from) {
        list = [];
        this._convertAddresses(this._parseAddresses(envelope.from), list);
        list = list.filter((address) => address && address.address);
        if (list.length && list[0]) {
          this._envelope.from = list[0].address;
        }
      }
      ["to", "cc", "bcc"].forEach((key) => {
        if (envelope[key]) {
          this._convertAddresses(this._parseAddresses(envelope[key]), this._envelope.to);
        }
      });
      this._envelope.to = this._envelope.to.map((to) => to.address).filter((address) => address);
      let standardFields = ["to", "cc", "bcc", "from"];
      Object.keys(envelope).forEach((key) => {
        if (!standardFields.includes(key)) {
          this._envelope[key] = envelope[key];
        }
      });
      return this;
    }
    getAddresses() {
      let addresses = {};
      this._headers.forEach((header) => {
        let key = header.key.toLowerCase();
        if (["from", "sender", "reply-to", "to", "cc", "bcc"].includes(key)) {
          if (!Array.isArray(addresses[key])) {
            addresses[key] = [];
          }
          this._convertAddresses(this._parseAddresses(header.value), addresses[key]);
        }
      });
      return addresses;
    }
    getEnvelope() {
      if (this._envelope) {
        return this._envelope;
      }
      let envelope = {
        from: false,
        to: []
      };
      this._headers.forEach((header) => {
        let list = [];
        if (header.key === "From" || !envelope.from && ["Reply-To", "Sender"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), list);
          if (list.length && list[0]) {
            envelope.from = list[0].address;
          }
        } else if (["To", "Cc", "Bcc"].includes(header.key)) {
          this._convertAddresses(this._parseAddresses(header.value), envelope.to);
        }
      });
      envelope.to = envelope.to.map((to) => to.address);
      return envelope;
    }
    messageId() {
      let messageId = this.getHeader("Message-ID");
      if (!messageId) {
        messageId = this._generateMessageId();
        this.setHeader("Message-ID", messageId);
      }
      return messageId;
    }
    setRaw(raw2) {
      this._raw = raw2;
      if (this._raw && typeof this._raw.pipe === "function") {
        this._contentErrorHandler = (err) => {
          this._raw.removeListener("error", this._contentErrorHandler);
          this._raw = err;
        };
        this._raw.once("error", this._contentErrorHandler);
      }
      return this;
    }
    _getStream(content) {
      let contentStream;
      if (content._resolvedValue) {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content._resolvedValue);
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      } else if (typeof content.pipe === "function") {
        return content;
      } else if (content && typeof content.path === "string" && !content.href) {
        if (this.disableFileAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("File access rejected for " + content.path)));
          return contentStream;
        }
        return fs2.createReadStream(content.path);
      } else if (content && typeof content.href === "string") {
        if (this.disableUrlAccess) {
          contentStream = new PassThrough;
          setImmediate(() => contentStream.emit("error", new Error("Url access rejected for " + content.href)));
          return contentStream;
        }
        return nmfetch(content.href, { headers: content.httpHeaders });
      } else {
        contentStream = new PassThrough;
        setImmediate(() => {
          try {
            contentStream.end(content || "");
          } catch (err) {
            contentStream.emit("error", err);
          }
        });
        return contentStream;
      }
    }
    _parseAddresses(addresses) {
      return [].concat.apply([], [].concat(addresses).map((address) => {
        if (address && address.address) {
          address.address = this._normalizeAddress(address.address);
          address.name = address.name || "";
          return [address];
        }
        return addressparser(address);
      }));
    }
    _normalizeHeaderKey(key) {
      key = (key || "").toString().replace(/\r?\n|\r/g, " ").trim().toLowerCase().replace(/^X-SMTPAPI$|^(MIME|DKIM|ARC|BIMI)\b|^[a-z]|-(SPF|FBL|ID|MD5)$|-[a-z]/gi, (c2) => c2.toUpperCase()).replace(/^Content-Features$/i, "Content-features");
      return key;
    }
    _handleContentType(structured) {
      this.contentType = structured.value.trim().toLowerCase();
      this.multipart = /^multipart\//i.test(this.contentType) ? this.contentType.substr(this.contentType.indexOf("/") + 1) : false;
      if (this.multipart) {
        this.boundary = structured.params.boundary = structured.params.boundary || this.boundary || this._generateBoundary();
      } else {
        this.boundary = false;
      }
    }
    _generateBoundary() {
      return this.rootNode.boundaryPrefix + "-" + this.rootNode.baseBoundary + "-Part_" + this._nodeId;
    }
    _encodeHeaderValue(key, value15) {
      key = this._normalizeHeaderKey(key);
      switch (key) {
        case "From":
        case "Sender":
        case "To":
        case "Cc":
        case "Bcc":
        case "Reply-To":
          return this._convertAddresses(this._parseAddresses(value15));
        case "Message-ID":
        case "In-Reply-To":
        case "Content-Id":
          value15 = (value15 || "").toString().replace(/\r?\n|\r/g, " ");
          if (value15.charAt(0) !== "<") {
            value15 = "<" + value15;
          }
          if (value15.charAt(value15.length - 1) !== ">") {
            value15 = value15 + ">";
          }
          return value15;
        case "References":
          value15 = [].concat.apply([], [].concat(value15 || "").map((elm) => {
            elm = (elm || "").toString().replace(/\r?\n|\r/g, " ").trim();
            return elm.replace(/<[^>]*>/g, (str) => str.replace(/\s/g, "")).split(/\s+/);
          })).map((elm) => {
            if (elm.charAt(0) !== "<") {
              elm = "<" + elm;
            }
            if (elm.charAt(elm.length - 1) !== ">") {
              elm = elm + ">";
            }
            return elm;
          });
          return value15.join(" ").trim();
        case "Date":
          if (Object.prototype.toString.call(value15) === "[object Date]") {
            return value15.toUTCString().replace(/GMT/, "+0000");
          }
          value15 = (value15 || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value15);
        case "Content-Type":
        case "Content-Disposition":
          return (value15 || "").toString().replace(/\r?\n|\r/g, " ");
        default:
          value15 = (value15 || "").toString().replace(/\r?\n|\r/g, " ");
          return this._encodeWords(value15);
      }
    }
    _convertAddresses(addresses, uniqueList) {
      let values2 = [];
      uniqueList = uniqueList || [];
      [].concat(addresses || []).forEach((address) => {
        if (address.address) {
          address.address = this._normalizeAddress(address.address);
          if (!address.name) {
            values2.push(address.address.indexOf(" ") >= 0 ? `<${address.address}>` : `${address.address}`);
          } else if (address.name) {
            values2.push(`${this._encodeAddressName(address.name)} <${address.address}>`);
          }
          if (address.address) {
            if (!uniqueList.filter((a2) => a2.address === address.address).length) {
              uniqueList.push(address);
            }
          }
        } else if (address.group) {
          let groupListAddresses = (address.group.length ? this._convertAddresses(address.group, uniqueList) : "").trim();
          values2.push(`${this._encodeAddressName(address.name)}:${groupListAddresses};`);
        }
      });
      return values2.join(", ");
    }
    _normalizeAddress(address) {
      address = (address || "").toString().replace(/[\x00-\x1F<>]+/g, " ").trim();
      let lastAt = address.lastIndexOf("@");
      if (lastAt < 0) {
        return address;
      }
      let user = address.substr(0, lastAt);
      let domain = address.substr(lastAt + 1);
      let encodedDomain;
      try {
        encodedDomain = punycode.toASCII(domain.toLowerCase());
      } catch (err) {
      }
      if (user.indexOf(" ") >= 0) {
        if (user.charAt(0) !== '"') {
          user = '"' + user;
        }
        if (user.substr(-1) !== '"') {
          user = user + '"';
        }
      }
      return `${user}@${encodedDomain}`;
    }
    _encodeAddressName(name) {
      if (!/^[\w ]*$/.test(name)) {
        if (/^[\x20-\x7e]*$/.test(name)) {
          return '"' + name.replace(/([\\"])/g, "\\$1") + '"';
        } else {
          return mimeFuncs.encodeWord(name, this._getTextEncoding(name), 52);
        }
      }
      return name;
    }
    _encodeWords(value15) {
      return mimeFuncs.encodeWords(value15, this._getTextEncoding(value15), 52, true);
    }
    _getTextEncoding(value15) {
      value15 = (value15 || "").toString();
      let encoding = this.textEncoding;
      let latinLen;
      let nonLatinLen;
      if (!encoding) {
        nonLatinLen = (value15.match(/[\x00-\x08\x0B\x0C\x0E-\x1F\u0080-\uFFFF]/g) || []).length;
        latinLen = (value15.match(/[a-z]/gi) || []).length;
        encoding = nonLatinLen < latinLen ? "Q" : "B";
      }
      return encoding;
    }
    _generateMessageId() {
      return "<" + [2, 2, 2, 6].reduce((prev, len) => prev + "-" + crypto3.randomBytes(len).toString("hex"), crypto3.randomBytes(4).toString("hex")) + "@" + (this.getEnvelope().from || this.hostname || "localhost").split("@").pop() + ">";
    }
  }
  module.exports = MimeNode;
});

// node_modules/nodemailer/lib/mail-composer/index.js
var require_mail_composer = __commonJS((exports, module) => {
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();
  var parseDataURI = require_shared().parseDataURI;

  class MailComposer {
    constructor(mail) {
      this.mail = mail || {};
      this.message = false;
    }
    compile() {
      this._alternatives = this.getAlternatives();
      this._htmlNode = this._alternatives.filter((alternative) => /^text\/html\b/i.test(alternative.contentType)).pop();
      this._attachments = this.getAttachments(!!this._htmlNode);
      this._useRelated = !!(this._htmlNode && this._attachments.related.length);
      this._useAlternative = this._alternatives.length > 1;
      this._useMixed = this._attachments.attached.length > 1 || this._alternatives.length && this._attachments.attached.length === 1;
      if (this.mail.raw) {
        this.message = new MimeNode("message/rfc822", { newline: this.mail.newline }).setRaw(this.mail.raw);
      } else if (this._useMixed) {
        this.message = this._createMixed();
      } else if (this._useAlternative) {
        this.message = this._createAlternative();
      } else if (this._useRelated) {
        this.message = this._createRelated();
      } else {
        this.message = this._createContentNode(false, [].concat(this._alternatives || []).concat(this._attachments.attached || []).shift() || {
          contentType: "text/plain",
          content: ""
        });
      }
      if (this.mail.headers) {
        this.message.addHeader(this.mail.headers);
      }
      ["from", "sender", "to", "cc", "bcc", "reply-to", "in-reply-to", "references", "subject", "message-id", "date"].forEach((header) => {
        let key = header.replace(/-(\w)/g, (o2, c2) => c2.toUpperCase());
        if (this.mail[key]) {
          this.message.setHeader(header, this.mail[key]);
        }
      });
      if (this.mail.envelope) {
        this.message.setEnvelope(this.mail.envelope);
      }
      this.message.messageId();
      return this.message;
    }
    getAttachments(findRelated) {
      let icalEvent, eventObject;
      let attachments = [].concat(this.mail.attachments || []).map((attachment, i) => {
        let data;
        let isMessageNode = /^message\//i.test(attachment.contentType);
        if (/^data:/i.test(attachment.path || attachment.href)) {
          attachment = this._processDataUrl(attachment);
        }
        let contentType = attachment.contentType || mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
        let isImage = /^image\//i.test(contentType);
        let contentDisposition = attachment.contentDisposition || (isMessageNode || isImage && attachment.cid ? "inline" : "attachment");
        data = {
          contentType,
          contentDisposition,
          contentTransferEncoding: "contentTransferEncoding" in attachment ? attachment.contentTransferEncoding : "base64"
        };
        if (attachment.filename) {
          data.filename = attachment.filename;
        } else if (!isMessageNode && attachment.filename !== false) {
          data.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
          if (data.filename.indexOf(".") < 0) {
            data.filename += "." + mimeFuncs.detectExtension(data.contentType);
          }
        }
        if (/^https?:\/\//i.test(attachment.path)) {
          attachment.href = attachment.path;
          attachment.path = undefined;
        }
        if (attachment.cid) {
          data.cid = attachment.cid;
        }
        if (attachment.raw) {
          data.raw = attachment.raw;
        } else if (attachment.path) {
          data.content = {
            path: attachment.path
          };
        } else if (attachment.href) {
          data.content = {
            href: attachment.href,
            httpHeaders: attachment.httpHeaders
          };
        } else {
          data.content = attachment.content || "";
        }
        if (attachment.encoding) {
          data.encoding = attachment.encoding;
        }
        if (attachment.headers) {
          data.headers = attachment.headers;
        }
        return data;
      });
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        eventObject.contentType = "application/ics";
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
        eventObject.filename = eventObject.filename || "invite.ics";
        eventObject.headers["Content-Disposition"] = "attachment";
        eventObject.headers["Content-Transfer-Encoding"] = "base64";
      }
      if (!findRelated) {
        return {
          attached: attachments.concat(eventObject || []),
          related: []
        };
      } else {
        return {
          attached: attachments.filter((attachment) => !attachment.cid).concat(eventObject || []),
          related: attachments.filter((attachment) => !!attachment.cid)
        };
      }
    }
    getAlternatives() {
      let alternatives = [], text2, html, watchHtml, amp, icalEvent, eventObject;
      if (this.mail.text) {
        if (typeof this.mail.text === "object" && (this.mail.text.content || this.mail.text.path || this.mail.text.href || this.mail.text.raw)) {
          text2 = this.mail.text;
        } else {
          text2 = {
            content: this.mail.text
          };
        }
        text2.contentType = "text/plain; charset=utf-8";
      }
      if (this.mail.watchHtml) {
        if (typeof this.mail.watchHtml === "object" && (this.mail.watchHtml.content || this.mail.watchHtml.path || this.mail.watchHtml.href || this.mail.watchHtml.raw)) {
          watchHtml = this.mail.watchHtml;
        } else {
          watchHtml = {
            content: this.mail.watchHtml
          };
        }
        watchHtml.contentType = "text/watch-html; charset=utf-8";
      }
      if (this.mail.amp) {
        if (typeof this.mail.amp === "object" && (this.mail.amp.content || this.mail.amp.path || this.mail.amp.href || this.mail.amp.raw)) {
          amp = this.mail.amp;
        } else {
          amp = {
            content: this.mail.amp
          };
        }
        amp.contentType = "text/x-amp-html; charset=utf-8";
      }
      if (this.mail.icalEvent) {
        if (typeof this.mail.icalEvent === "object" && (this.mail.icalEvent.content || this.mail.icalEvent.path || this.mail.icalEvent.href || this.mail.icalEvent.raw)) {
          icalEvent = this.mail.icalEvent;
        } else {
          icalEvent = {
            content: this.mail.icalEvent
          };
        }
        eventObject = {};
        Object.keys(icalEvent).forEach((key) => {
          eventObject[key] = icalEvent[key];
        });
        if (eventObject.content && typeof eventObject.content === "object") {
          eventObject.content._resolve = true;
        }
        eventObject.filename = false;
        eventObject.contentType = "text/calendar; charset=utf-8; method=" + (eventObject.method || "PUBLISH").toString().trim().toUpperCase();
        if (!eventObject.headers) {
          eventObject.headers = {};
        }
      }
      if (this.mail.html) {
        if (typeof this.mail.html === "object" && (this.mail.html.content || this.mail.html.path || this.mail.html.href || this.mail.html.raw)) {
          html = this.mail.html;
        } else {
          html = {
            content: this.mail.html
          };
        }
        html.contentType = "text/html; charset=utf-8";
      }
      [].concat(text2 || []).concat(watchHtml || []).concat(amp || []).concat(html || []).concat(eventObject || []).concat(this.mail.alternatives || []).forEach((alternative) => {
        let data;
        if (/^data:/i.test(alternative.path || alternative.href)) {
          alternative = this._processDataUrl(alternative);
        }
        data = {
          contentType: alternative.contentType || mimeFuncs.detectMimeType(alternative.filename || alternative.path || alternative.href || "txt"),
          contentTransferEncoding: alternative.contentTransferEncoding
        };
        if (alternative.filename) {
          data.filename = alternative.filename;
        }
        if (/^https?:\/\//i.test(alternative.path)) {
          alternative.href = alternative.path;
          alternative.path = undefined;
        }
        if (alternative.raw) {
          data.raw = alternative.raw;
        } else if (alternative.path) {
          data.content = {
            path: alternative.path
          };
        } else if (alternative.href) {
          data.content = {
            href: alternative.href
          };
        } else {
          data.content = alternative.content || "";
        }
        if (alternative.encoding) {
          data.encoding = alternative.encoding;
        }
        if (alternative.headers) {
          data.headers = alternative.headers;
        }
        alternatives.push(data);
      });
      return alternatives;
    }
    _createMixed(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/mixed", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/mixed", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (this._useAlternative) {
        this._createAlternative(node);
      } else if (this._useRelated) {
        this._createRelated(node);
      }
      [].concat(!this._useAlternative && this._alternatives || []).concat(this._attachments.attached || []).forEach((element) => {
        if (!this._useRelated || element !== this._htmlNode) {
          this._createContentNode(node, element);
        }
      });
      return node;
    }
    _createAlternative(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode("multipart/alternative", {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild("multipart/alternative", {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._alternatives.forEach((alternative) => {
        if (this._useRelated && this._htmlNode === alternative) {
          this._createRelated(node);
        } else {
          this._createContentNode(node, alternative);
        }
      });
      return node;
    }
    _createRelated(parentNode) {
      let node;
      if (!parentNode) {
        node = new MimeNode('multipart/related; type="text/html"', {
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild('multipart/related; type="text/html"', {
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      this._createContentNode(node, this._htmlNode);
      this._attachments.related.forEach((alternative) => this._createContentNode(node, alternative));
      return node;
    }
    _createContentNode(parentNode, element) {
      element = element || {};
      element.content = element.content || "";
      let node;
      let encoding = (element.encoding || "utf8").toString().toLowerCase().replace(/[-_\s]/g, "");
      if (!parentNode) {
        node = new MimeNode(element.contentType, {
          filename: element.filename,
          baseBoundary: this.mail.baseBoundary,
          textEncoding: this.mail.textEncoding,
          boundaryPrefix: this.mail.boundaryPrefix,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      } else {
        node = parentNode.createChild(element.contentType, {
          filename: element.filename,
          textEncoding: this.mail.textEncoding,
          disableUrlAccess: this.mail.disableUrlAccess,
          disableFileAccess: this.mail.disableFileAccess,
          normalizeHeaderKey: this.mail.normalizeHeaderKey,
          newline: this.mail.newline
        });
      }
      if (element.headers) {
        node.addHeader(element.headers);
      }
      if (element.cid) {
        node.setHeader("Content-Id", "<" + element.cid.replace(/[<>]/g, "") + ">");
      }
      if (element.contentTransferEncoding) {
        node.setHeader("Content-Transfer-Encoding", element.contentTransferEncoding);
      } else if (this.mail.encoding && /^text\//i.test(element.contentType)) {
        node.setHeader("Content-Transfer-Encoding", this.mail.encoding);
      }
      if (!/^text\//i.test(element.contentType) || element.contentDisposition) {
        node.setHeader("Content-Disposition", element.contentDisposition || (element.cid && /^image\//i.test(element.contentType) ? "inline" : "attachment"));
      }
      if (typeof element.content === "string" && !["utf8", "usascii", "ascii"].includes(encoding)) {
        element.content = Buffer.from(element.content, encoding);
      }
      if (element.raw) {
        node.setRaw(element.raw);
      } else {
        node.setContent(element.content);
      }
      return node;
    }
    _processDataUrl(element) {
      let parsedDataUri;
      if ((element.path || element.href).match(/^data:/)) {
        parsedDataUri = parseDataURI(element.path || element.href);
      }
      if (!parsedDataUri) {
        return element;
      }
      element.content = parsedDataUri.data;
      element.contentType = element.contentType || parsedDataUri.contentType;
      if ("path" in element) {
        element.path = false;
      }
      if ("href" in element) {
        element.href = false;
      }
      return element;
    }
  }
  module.exports = MailComposer;
});

// node_modules/nodemailer/lib/dkim/message-parser.js
var require_message_parser = __commonJS((exports, module) => {
  var Transform2 = import.meta.require("stream").Transform;

  class MessageParser extends Transform2 {
    constructor(options) {
      super(options);
      this.lastBytes = Buffer.alloc(4);
      this.headersParsed = false;
      this.headerBytes = 0;
      this.headerChunks = [];
      this.rawHeaders = false;
      this.bodySize = 0;
    }
    updateLastBytes(data) {
      let lblen = this.lastBytes.length;
      let nblen = Math.min(data.length, lblen);
      for (let i = 0, len = lblen - nblen;i < len; i++) {
        this.lastBytes[i] = this.lastBytes[i + nblen];
      }
      for (let i = 1;i <= nblen; i++) {
        this.lastBytes[lblen - i] = data[data.length - i];
      }
    }
    checkHeaders(data) {
      if (this.headersParsed) {
        return true;
      }
      let lblen = this.lastBytes.length;
      let headerPos = 0;
      this.curLinePos = 0;
      for (let i = 0, len = this.lastBytes.length + data.length;i < len; i++) {
        let chr;
        if (i < lblen) {
          chr = this.lastBytes[i];
        } else {
          chr = data[i - lblen];
        }
        if (chr === 10 && i) {
          let pr1 = i - 1 < lblen ? this.lastBytes[i - 1] : data[i - 1 - lblen];
          let pr2 = i > 1 ? i - 2 < lblen ? this.lastBytes[i - 2] : data[i - 2 - lblen] : false;
          if (pr1 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          } else if (pr1 === 13 && pr2 === 10) {
            this.headersParsed = true;
            headerPos = i - lblen + 1;
            this.headerBytes += headerPos;
            break;
          }
        }
      }
      if (this.headersParsed) {
        this.headerChunks.push(data.slice(0, headerPos));
        this.rawHeaders = Buffer.concat(this.headerChunks, this.headerBytes);
        this.headerChunks = null;
        this.emit("headers", this.parseHeaders());
        if (data.length - 1 > headerPos) {
          let chunk = data.slice(headerPos);
          this.bodySize += chunk.length;
          setImmediate(() => this.push(chunk));
        }
        return false;
      } else {
        this.headerBytes += data.length;
        this.headerChunks.push(data);
      }
      this.updateLastBytes(data);
      return false;
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      let headersFound;
      try {
        headersFound = this.checkHeaders(chunk);
      } catch (E) {
        return callback(E);
      }
      if (headersFound) {
        this.bodySize += chunk.length;
        this.push(chunk);
      }
      setImmediate(callback);
    }
    _flush(callback) {
      if (this.headerChunks) {
        let chunk = Buffer.concat(this.headerChunks, this.headerBytes);
        this.bodySize += chunk.length;
        this.push(chunk);
        this.headerChunks = null;
      }
      callback();
    }
    parseHeaders() {
      let lines = (this.rawHeaders || "").toString().split(/\r?\n/);
      for (let i = lines.length - 1;i > 0; i--) {
        if (/^\s/.test(lines[i])) {
          lines[i - 1] += "\n" + lines[i];
          lines.splice(i, 1);
        }
      }
      return lines.filter((line) => line.trim()).map((line) => ({
        key: line.substr(0, line.indexOf(":")).trim().toLowerCase(),
        line
      }));
    }
  }
  module.exports = MessageParser;
});

// node_modules/nodemailer/lib/dkim/relaxed-body.js
var require_relaxed_body = __commonJS((exports, module) => {
  var Transform2 = import.meta.require("stream").Transform;
  var crypto3 = import.meta.require("crypto");

  class RelaxedBody extends Transform2 {
    constructor(options) {
      super();
      options = options || {};
      this.chunkBuffer = [];
      this.chunkBufferLen = 0;
      this.bodyHash = crypto3.createHash(options.hashAlgo || "sha1");
      this.remainder = "";
      this.byteLength = 0;
      this.debug = options.debug;
      this._debugBody = options.debug ? [] : false;
    }
    updateHash(chunk) {
      let bodyStr;
      let nextRemainder = "";
      let state = "file";
      for (let i = chunk.length - 1;i >= 0; i--) {
        let c2 = chunk[i];
        if (state === "file" && (c2 === 10 || c2 === 13)) {
        } else if (state === "file" && (c2 === 9 || c2 === 32)) {
          state = "line";
        } else if (state === "line" && (c2 === 9 || c2 === 32)) {
        } else if (state === "file" || state === "line") {
          state = "body";
          if (i === chunk.length - 1) {
            break;
          }
        }
        if (i === 0) {
          if (state === "file" && (!this.remainder || /[\r\n]$/.test(this.remainder)) || state === "line" && (!this.remainder || /[ \t]$/.test(this.remainder))) {
            this.remainder += chunk.toString("binary");
            return;
          } else if (state === "line" || state === "file") {
            nextRemainder = chunk.toString("binary");
            chunk = false;
            break;
          }
        }
        if (state !== "body") {
          continue;
        }
        nextRemainder = chunk.slice(i + 1).toString("binary");
        chunk = chunk.slice(0, i + 1);
        break;
      }
      let needsFixing = !!this.remainder;
      if (chunk && !needsFixing) {
        for (let i = 0, len = chunk.length;i < len; i++) {
          if (i && chunk[i] === 10 && chunk[i - 1] !== 13) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 13 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (i && chunk[i] === 32 && chunk[i - 1] === 32) {
            needsFixing = true;
            break;
          } else if (chunk[i] === 9) {
            needsFixing = true;
            break;
          }
        }
      }
      if (needsFixing) {
        bodyStr = this.remainder + (chunk ? chunk.toString("binary") : "");
        this.remainder = nextRemainder;
        bodyStr = bodyStr.replace(/\r?\n/g, "\n").replace(/[ \t]*$/gm, "").replace(/[ \t]+/gm, " ").replace(/\n/g, "\r\n");
        chunk = Buffer.from(bodyStr, "binary");
      } else if (nextRemainder) {
        this.remainder = nextRemainder;
      }
      if (this.debug) {
        this._debugBody.push(chunk);
      }
      this.bodyHash.update(chunk);
    }
    _transform(chunk, encoding, callback) {
      if (!chunk || !chunk.length) {
        return callback();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk, encoding);
      }
      this.updateHash(chunk);
      this.byteLength += chunk.length;
      this.push(chunk);
      callback();
    }
    _flush(callback) {
      if (/[\r\n]$/.test(this.remainder) && this.byteLength > 2) {
        this.bodyHash.update(Buffer.from("\r\n"));
      }
      if (!this.byteLength) {
        this.push(Buffer.from("\r\n"));
      }
      this.emit("hash", this.bodyHash.digest("base64"), this.debug ? Buffer.concat(this._debugBody) : false);
      callback();
    }
  }
  module.exports = RelaxedBody;
});

// node_modules/nodemailer/lib/dkim/sign.js
var require_sign = __commonJS((exports, module) => {
  var generateDKIMHeader = function(domainName, keySelector, fieldNames, hashAlgo, bodyHash) {
    let dkim = [
      "v=1",
      "a=rsa-" + hashAlgo,
      "c=relaxed/relaxed",
      "d=" + punycode.toASCII(domainName),
      "q=dns/txt",
      "s=" + keySelector,
      "bh=" + bodyHash,
      "h=" + fieldNames
    ].join("; ");
    return mimeFuncs.foldLines("DKIM-Signature: " + dkim, 76) + ";\r\n b=";
  };
  var relaxedHeaders = function(headers, fieldNames, skipFields) {
    let includedFields = new Set;
    let skip = new Set;
    let headerFields = new Map;
    (skipFields || "").toLowerCase().split(":").forEach((field) => {
      skip.add(field.trim());
    });
    (fieldNames || "").toLowerCase().split(":").filter((field) => !skip.has(field.trim())).forEach((field) => {
      includedFields.add(field.trim());
    });
    for (let i = headers.length - 1;i >= 0; i--) {
      let line = headers[i];
      if (includedFields.has(line.key) && !headerFields.has(line.key)) {
        headerFields.set(line.key, relaxedHeaderLine(line.line));
      }
    }
    let headersList = [];
    let fields = [];
    includedFields.forEach((field) => {
      if (headerFields.has(field)) {
        fields.push(field);
        headersList.push(field + ":" + headerFields.get(field));
      }
    });
    return {
      headers: headersList.join("\r\n") + "\r\n",
      fieldNames: fields.join(":")
    };
  };
  var relaxedHeaderLine = function(line) {
    return line.substr(line.indexOf(":") + 1).replace(/\r?\n/g, "").replace(/\s+/g, " ").trim();
  };
  var punycode = require_punycode();
  var mimeFuncs = require_mime_funcs();
  var crypto3 = import.meta.require("crypto");
  module.exports = (headers, hashAlgo, bodyHash, options) => {
    options = options || {};
    let defaultFieldNames = "From:Sender:Reply-To:Subject:Date:Message-ID:To:Cc:MIME-Version:Content-Type:Content-Transfer-Encoding:Content-ID:Content-Description:Resent-Date:Resent-From:Resent-Sender:Resent-To:Resent-Cc:Resent-Message-ID:In-Reply-To:References:List-Id:List-Help:List-Unsubscribe:List-Subscribe:List-Post:List-Owner:List-Archive";
    let fieldNames = options.headerFieldNames || defaultFieldNames;
    let canonicalizedHeaderData = relaxedHeaders(headers, fieldNames, options.skipFields);
    let dkimHeader = generateDKIMHeader(options.domainName, options.keySelector, canonicalizedHeaderData.fieldNames, hashAlgo, bodyHash);
    let signer, signature;
    canonicalizedHeaderData.headers += "dkim-signature:" + relaxedHeaderLine(dkimHeader);
    signer = crypto3.createSign(("rsa-" + hashAlgo).toUpperCase());
    signer.update(canonicalizedHeaderData.headers);
    try {
      signature = signer.sign(options.privateKey, "base64");
    } catch (E) {
      return false;
    }
    return dkimHeader + signature.replace(/(^.{73}|.{75}(?!\r?\n|\r))/g, "$&\r\n ").trim();
  };
  module.exports.relaxedHeaders = relaxedHeaders;
});

// node_modules/nodemailer/lib/dkim/index.js
var require_dkim = __commonJS((exports, module) => {
  var MessageParser = require_message_parser();
  var RelaxedBody = require_relaxed_body();
  var sign = require_sign();
  var PassThrough = import.meta.require("stream").PassThrough;
  var fs2 = import.meta.require("fs");
  var path = import.meta.require("path");
  var crypto3 = import.meta.require("crypto");
  var DKIM_ALGO = "sha256";
  var MAX_MESSAGE_SIZE = 128 * 1024;

  class DKIMSigner {
    constructor(options, keys, input, output) {
      this.options = options || {};
      this.keys = keys;
      this.cacheTreshold = Number(this.options.cacheTreshold) || MAX_MESSAGE_SIZE;
      this.hashAlgo = this.options.hashAlgo || DKIM_ALGO;
      this.cacheDir = this.options.cacheDir || false;
      this.chunks = [];
      this.chunklen = 0;
      this.readPos = 0;
      this.cachePath = this.cacheDir ? path.join(this.cacheDir, "message." + Date.now() + "-" + crypto3.randomBytes(14).toString("hex")) : false;
      this.cache = false;
      this.headers = false;
      this.bodyHash = false;
      this.parser = false;
      this.relaxedBody = false;
      this.input = input;
      this.output = output;
      this.output.usingCache = false;
      this.hasErrored = false;
      this.input.on("error", (err) => {
        this.hasErrored = true;
        this.cleanup();
        output.emit("error", err);
      });
    }
    cleanup() {
      if (!this.cache || !this.cachePath) {
        return;
      }
      fs2.unlink(this.cachePath, () => false);
    }
    createReadCache() {
      this.cache = fs2.createReadStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.cleanup();
      });
      this.cache.pipe(this.output);
    }
    sendNextChunk() {
      if (this.hasErrored) {
        return;
      }
      if (this.readPos >= this.chunks.length) {
        if (!this.cache) {
          return this.output.end();
        }
        return this.createReadCache();
      }
      let chunk = this.chunks[this.readPos++];
      if (this.output.write(chunk) === false) {
        return this.output.once("drain", () => {
          this.sendNextChunk();
        });
      }
      setImmediate(() => this.sendNextChunk());
    }
    sendSignedOutput() {
      let keyPos = 0;
      let signNextKey = () => {
        if (keyPos >= this.keys.length) {
          this.output.write(this.parser.rawHeaders);
          return setImmediate(() => this.sendNextChunk());
        }
        let key = this.keys[keyPos++];
        let dkimField = sign(this.headers, this.hashAlgo, this.bodyHash, {
          domainName: key.domainName,
          keySelector: key.keySelector,
          privateKey: key.privateKey,
          headerFieldNames: this.options.headerFieldNames,
          skipFields: this.options.skipFields
        });
        if (dkimField) {
          this.output.write(Buffer.from(dkimField + "\r\n"));
        }
        return setImmediate(signNextKey);
      };
      if (this.bodyHash && this.headers) {
        return signNextKey();
      }
      this.output.write(this.parser.rawHeaders);
      this.sendNextChunk();
    }
    createWriteCache() {
      this.output.usingCache = true;
      this.cache = fs2.createWriteStream(this.cachePath);
      this.cache.once("error", (err) => {
        this.cleanup();
        this.relaxedBody.unpipe(this.cache);
        this.relaxedBody.on("readable", () => {
          while (this.relaxedBody.read() !== null) {
          }
        });
        this.hasErrored = true;
        this.output.emit("error", err);
      });
      this.cache.once("close", () => {
        this.sendSignedOutput();
      });
      this.relaxedBody.removeAllListeners("readable");
      this.relaxedBody.pipe(this.cache);
    }
    signStream() {
      this.parser = new MessageParser;
      this.relaxedBody = new RelaxedBody({
        hashAlgo: this.hashAlgo
      });
      this.parser.on("headers", (value15) => {
        this.headers = value15;
      });
      this.relaxedBody.on("hash", (value15) => {
        this.bodyHash = value15;
      });
      this.relaxedBody.on("readable", () => {
        let chunk;
        if (this.cache) {
          return;
        }
        while ((chunk = this.relaxedBody.read()) !== null) {
          this.chunks.push(chunk);
          this.chunklen += chunk.length;
          if (this.chunklen >= this.cacheTreshold && this.cachePath) {
            return this.createWriteCache();
          }
        }
      });
      this.relaxedBody.on("end", () => {
        if (this.cache) {
          return;
        }
        this.sendSignedOutput();
      });
      this.parser.pipe(this.relaxedBody);
      setImmediate(() => this.input.pipe(this.parser));
    }
  }

  class DKIM {
    constructor(options) {
      this.options = options || {};
      this.keys = [].concat(this.options.keys || {
        domainName: options.domainName,
        keySelector: options.keySelector,
        privateKey: options.privateKey
      });
    }
    sign(input, extraOptions) {
      let output = new PassThrough;
      let inputStream = input;
      let writeValue = false;
      if (Buffer.isBuffer(input)) {
        writeValue = input;
        inputStream = new PassThrough;
      } else if (typeof input === "string") {
        writeValue = Buffer.from(input);
        inputStream = new PassThrough;
      }
      let options = this.options;
      if (extraOptions && Object.keys(extraOptions).length) {
        options = {};
        Object.keys(this.options || {}).forEach((key) => {
          options[key] = this.options[key];
        });
        Object.keys(extraOptions || {}).forEach((key) => {
          if (!(key in options)) {
            options[key] = extraOptions[key];
          }
        });
      }
      let signer = new DKIMSigner(options, this.keys, inputStream, output);
      setImmediate(() => {
        signer.signStream();
        if (writeValue) {
          setImmediate(() => {
            inputStream.end(writeValue);
          });
        }
      });
      return output;
    }
  }
  module.exports = DKIM;
});

// node_modules/nodemailer/lib/smtp-connection/http-proxy-client.js
var require_http_proxy_client = __commonJS((exports, module) => {
  var httpProxyClient = function(proxyUrl, destinationPort, destinationHost, callback) {
    let proxy = urllib.parse(proxyUrl);
    let options;
    let connect;
    let socket;
    options = {
      host: proxy.hostname,
      port: Number(proxy.port) ? Number(proxy.port) : proxy.protocol === "https:" ? 443 : 80
    };
    if (proxy.protocol === "https:") {
      options.rejectUnauthorized = false;
      connect = tls2.connect.bind(tls2);
    } else {
      connect = net2.connect.bind(net2);
    }
    let finished = false;
    let tempSocketErr = (err) => {
      if (finished) {
        return;
      }
      finished = true;
      try {
        socket.destroy();
      } catch (E) {
      }
      callback(err);
    };
    let timeoutErr = () => {
      let err = new Error("Proxy socket timed out");
      err.code = "ETIMEDOUT";
      tempSocketErr(err);
    };
    socket = connect(options, () => {
      if (finished) {
        return;
      }
      let reqHeaders = {
        Host: destinationHost + ":" + destinationPort,
        Connection: "close"
      };
      if (proxy.auth) {
        reqHeaders["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
      }
      socket.write("CONNECT " + destinationHost + ":" + destinationPort + " HTTP/1.1\r\n" + Object.keys(reqHeaders).map((key) => key + ": " + reqHeaders[key]).join("\r\n") + "\r\n\r\n");
      let headers = "";
      let onSocketData = (chunk) => {
        let match;
        let remainder;
        if (finished) {
          return;
        }
        headers += chunk.toString("binary");
        if (match = headers.match(/\r\n\r\n/)) {
          socket.removeListener("data", onSocketData);
          remainder = headers.substr(match.index + match[0].length);
          headers = headers.substr(0, match.index);
          if (remainder) {
            socket.unshift(Buffer.from(remainder, "binary"));
          }
          finished = true;
          match = headers.match(/^HTTP\/\d+\.\d+ (\d+)/i);
          if (!match || (match[1] || "").charAt(0) !== "2") {
            try {
              socket.destroy();
            } catch (E) {
            }
            return callback(new Error("Invalid response from proxy" + (match && ": " + match[1] || "")));
          }
          socket.removeListener("error", tempSocketErr);
          socket.removeListener("timeout", timeoutErr);
          socket.setTimeout(0);
          return callback(null, socket);
        }
      };
      socket.on("data", onSocketData);
    });
    socket.setTimeout(httpProxyClient.timeout || 30 * 1000);
    socket.on("timeout", timeoutErr);
    socket.once("error", tempSocketErr);
  };
  var net2 = import.meta.require("net");
  var tls2 = import.meta.require("tls");
  var urllib = import.meta.require("url");
  module.exports = httpProxyClient;
});

// node_modules/nodemailer/lib/mailer/mail-message.js
var require_mail_message = __commonJS((exports, module) => {
  var shared = require_shared();
  var MimeNode = require_mime_node();
  var mimeFuncs = require_mime_funcs();

  class MailMessage {
    constructor(mailer, data) {
      this.mailer = mailer;
      this.data = {};
      this.message = null;
      data = data || {};
      let options = mailer.options || {};
      let defaults = mailer._defaults || {};
      Object.keys(data).forEach((key) => {
        this.data[key] = data[key];
      });
      this.data.headers = this.data.headers || {};
      Object.keys(defaults).forEach((key) => {
        if (!(key in this.data)) {
          this.data[key] = defaults[key];
        } else if (key === "headers") {
          Object.keys(defaults.headers).forEach((key2) => {
            if (!(key2 in this.data.headers)) {
              this.data.headers[key2] = defaults.headers[key2];
            }
          });
        }
      });
      ["disableFileAccess", "disableUrlAccess", "normalizeHeaderKey"].forEach((key) => {
        if (key in options) {
          this.data[key] = options[key];
        }
      });
    }
    resolveContent(...args) {
      return shared.resolveContent(...args);
    }
    resolveAll(callback) {
      let keys = [
        [this.data, "html"],
        [this.data, "text"],
        [this.data, "watchHtml"],
        [this.data, "amp"],
        [this.data, "icalEvent"]
      ];
      if (this.data.alternatives && this.data.alternatives.length) {
        this.data.alternatives.forEach((alternative, i) => {
          keys.push([this.data.alternatives, i]);
        });
      }
      if (this.data.attachments && this.data.attachments.length) {
        this.data.attachments.forEach((attachment, i) => {
          if (!attachment.filename) {
            attachment.filename = (attachment.path || attachment.href || "").split("/").pop().split("?").shift() || "attachment-" + (i + 1);
            if (attachment.filename.indexOf(".") < 0) {
              attachment.filename += "." + mimeFuncs.detectExtension(attachment.contentType);
            }
          }
          if (!attachment.contentType) {
            attachment.contentType = mimeFuncs.detectMimeType(attachment.filename || attachment.path || attachment.href || "bin");
          }
          keys.push([this.data.attachments, i]);
        });
      }
      let mimeNode = new MimeNode;
      let addressKeys = ["from", "to", "cc", "bcc", "sender", "replyTo"];
      addressKeys.forEach((address) => {
        let value15;
        if (this.message) {
          value15 = [].concat(mimeNode._parseAddresses(this.message.getHeader(address === "replyTo" ? "reply-to" : address)) || []);
        } else if (this.data[address]) {
          value15 = [].concat(mimeNode._parseAddresses(this.data[address]) || []);
        }
        if (value15 && value15.length) {
          this.data[address] = value15;
        } else if (address in this.data) {
          this.data[address] = null;
        }
      });
      let singleKeys = ["from", "sender"];
      singleKeys.forEach((address) => {
        if (this.data[address]) {
          this.data[address] = this.data[address].shift();
        }
      });
      let pos = 0;
      let resolveNext = () => {
        if (pos >= keys.length) {
          return callback(null, this.data);
        }
        let args = keys[pos++];
        if (!args[0] || !args[0][args[1]]) {
          return resolveNext();
        }
        shared.resolveContent(...args, (err, value15) => {
          if (err) {
            return callback(err);
          }
          let node = {
            content: value15
          };
          if (args[0][args[1]] && typeof args[0][args[1]] === "object" && !Buffer.isBuffer(args[0][args[1]])) {
            Object.keys(args[0][args[1]]).forEach((key) => {
              if (!(key in node) && !["content", "path", "href", "raw"].includes(key)) {
                node[key] = args[0][args[1]][key];
              }
            });
          }
          args[0][args[1]] = node;
          resolveNext();
        });
      };
      setImmediate(() => resolveNext());
    }
    normalize(callback) {
      let envelope = this.data.envelope || this.message.getEnvelope();
      let messageId = this.message.messageId();
      this.resolveAll((err, data) => {
        if (err) {
          return callback(err);
        }
        data.envelope = envelope;
        data.messageId = messageId;
        ["html", "text", "watchHtml", "amp"].forEach((key) => {
          if (data[key] && data[key].content) {
            if (typeof data[key].content === "string") {
              data[key] = data[key].content;
            } else if (Buffer.isBuffer(data[key].content)) {
              data[key] = data[key].content.toString();
            }
          }
        });
        if (data.icalEvent && Buffer.isBuffer(data.icalEvent.content)) {
          data.icalEvent.content = data.icalEvent.content.toString("base64");
          data.icalEvent.encoding = "base64";
        }
        if (data.alternatives && data.alternatives.length) {
          data.alternatives.forEach((alternative) => {
            if (alternative && alternative.content && Buffer.isBuffer(alternative.content)) {
              alternative.content = alternative.content.toString("base64");
              alternative.encoding = "base64";
            }
          });
        }
        if (data.attachments && data.attachments.length) {
          data.attachments.forEach((attachment) => {
            if (attachment && attachment.content && Buffer.isBuffer(attachment.content)) {
              attachment.content = attachment.content.toString("base64");
              attachment.encoding = "base64";
            }
          });
        }
        data.normalizedHeaders = {};
        Object.keys(data.headers || {}).forEach((key) => {
          let value15 = [].concat(data.headers[key] || []).shift();
          value15 = value15 && value15.value || value15;
          if (value15) {
            if (["references", "in-reply-to", "message-id", "content-id"].includes(key)) {
              value15 = this.message._encodeHeaderValue(key, value15);
            }
            data.normalizedHeaders[key] = value15;
          }
        });
        if (data.list && typeof data.list === "object") {
          let listHeaders = this._getListHeaders(data.list);
          listHeaders.forEach((entry) => {
            data.normalizedHeaders[entry.key] = entry.value.map((val) => val && val.value || val).join(", ");
          });
        }
        if (data.references) {
          data.normalizedHeaders.references = this.message._encodeHeaderValue("references", data.references);
        }
        if (data.inReplyTo) {
          data.normalizedHeaders["in-reply-to"] = this.message._encodeHeaderValue("in-reply-to", data.inReplyTo);
        }
        return callback(null, data);
      });
    }
    setMailerHeader() {
      if (!this.message || !this.data.xMailer) {
        return;
      }
      this.message.setHeader("X-Mailer", this.data.xMailer);
    }
    setPriorityHeaders() {
      if (!this.message || !this.data.priority) {
        return;
      }
      switch ((this.data.priority || "").toString().toLowerCase()) {
        case "high":
          this.message.setHeader("X-Priority", "1 (Highest)");
          this.message.setHeader("X-MSMail-Priority", "High");
          this.message.setHeader("Importance", "High");
          break;
        case "low":
          this.message.setHeader("X-Priority", "5 (Lowest)");
          this.message.setHeader("X-MSMail-Priority", "Low");
          this.message.setHeader("Importance", "Low");
          break;
        default:
      }
    }
    setListHeaders() {
      if (!this.message || !this.data.list || typeof this.data.list !== "object") {
        return;
      }
      if (this.data.list && typeof this.data.list === "object") {
        this._getListHeaders(this.data.list).forEach((listHeader) => {
          listHeader.value.forEach((value15) => {
            this.message.addHeader(listHeader.key, value15);
          });
        });
      }
    }
    _getListHeaders(listData) {
      return Object.keys(listData).map((key) => ({
        key: "list-" + key.toLowerCase().trim(),
        value: [].concat(listData[key] || []).map((value15) => ({
          prepared: true,
          foldLines: true,
          value: [].concat(value15 || []).map((value16) => {
            if (typeof value16 === "string") {
              value16 = {
                url: value16
              };
            }
            if (value16 && value16.url) {
              if (key.toLowerCase().trim() === "id") {
                let comment2 = value16.comment || "";
                if (mimeFuncs.isPlainText(comment2)) {
                  comment2 = '"' + comment2 + '"';
                } else {
                  comment2 = mimeFuncs.encodeWord(comment2);
                }
                return (value16.comment ? comment2 + " " : "") + this._formatListUrl(value16.url).replace(/^<[^:]+\/{,2}/, "");
              }
              let comment = value16.comment || "";
              if (!mimeFuncs.isPlainText(comment)) {
                comment = mimeFuncs.encodeWord(comment);
              }
              return this._formatListUrl(value16.url) + (value16.comment ? " (" + comment + ")" : "");
            }
            return "";
          }).filter((value16) => value16).join(", ")
        }))
      }));
    }
    _formatListUrl(url) {
      url = url.replace(/[\s<]+|[\s>]+/g, "");
      if (/^(https?|mailto|ftp):/.test(url)) {
        return "<" + url + ">";
      }
      if (/^[^@]+@[^@]+$/.test(url)) {
        return "<mailto:" + url + ">";
      }
      return "<http://" + url + ">";
    }
  }
  module.exports = MailMessage;
});

// node_modules/nodemailer/lib/mailer/index.js
var require_mailer = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var shared = require_shared();
  var mimeTypes = require_mime_types();
  var MailComposer = require_mail_composer();
  var DKIM = require_dkim();
  var httpProxyClient = require_http_proxy_client();
  var util2 = import.meta.require("util");
  var urllib = import.meta.require("url");
  var packageData = require_package();
  var MailMessage = require_mail_message();
  var net2 = import.meta.require("net");
  var dns = import.meta.require("dns");
  var crypto3 = import.meta.require("crypto");

  class Mail extends EventEmitter {
    constructor(transporter, options, defaults) {
      super();
      this.options = options || {};
      this._defaults = defaults || {};
      this._defaultPlugins = {
        compile: [(...args) => this._convertDataImages(...args)],
        stream: []
      };
      this._userPlugins = {
        compile: [],
        stream: []
      };
      this.meta = new Map;
      this.dkim = this.options.dkim ? new DKIM(this.options.dkim) : false;
      this.transporter = transporter;
      this.transporter.mailer = this;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "mail"
      });
      this.logger.debug({
        tnx: "create"
      }, "Creating transport: %s", this.getVersionString());
      if (typeof this.transporter.on === "function") {
        this.transporter.on("log", (log) => {
          this.logger.debug({
            tnx: "transport"
          }, "%s: %s", log.type, log.message);
        });
        this.transporter.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "transport"
          }, "Transport Error: %s", err.message);
          this.emit("error", err);
        });
        this.transporter.on("idle", (...args) => {
          this.emit("idle", ...args);
        });
      }
      ["close", "isIdle", "verify"].forEach((method) => {
        this[method] = (...args) => {
          if (typeof this.transporter[method] === "function") {
            if (method === "verify" && typeof this.getSocket === "function") {
              this.transporter.getSocket = this.getSocket;
              this.getSocket = false;
            }
            return this.transporter[method](...args);
          } else {
            this.logger.warn({
              tnx: "transport",
              methodName: method
            }, "Non existing method %s called for transport", method);
            return false;
          }
        };
      });
      if (this.options.proxy && typeof this.options.proxy === "string") {
        this.setupProxy(this.options.proxy);
      }
    }
    use(step, plugin) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        this._userPlugins[step] = [plugin];
      } else {
        this._userPlugins[step].push(plugin);
      }
      return this;
    }
    sendMail(data, callback = null) {
      let promise5;
      if (!callback) {
        promise5 = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      if (typeof this.getSocket === "function") {
        this.transporter.getSocket = this.getSocket;
        this.getSocket = false;
      }
      let mail = new MailMessage(this, data);
      this.logger.debug({
        tnx: "transport",
        name: this.transporter.name,
        version: this.transporter.version,
        action: "send"
      }, "Sending mail using %s/%s", this.transporter.name, this.transporter.version);
      this._processPlugins("compile", mail, (err) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "plugin",
            action: "compile"
          }, "PluginCompile Error: %s", err.message);
          return callback(err);
        }
        mail.message = new MailComposer(mail.data).compile();
        mail.setMailerHeader();
        mail.setPriorityHeaders();
        mail.setListHeaders();
        this._processPlugins("stream", mail, (err2) => {
          if (err2) {
            this.logger.error({
              err: err2,
              tnx: "plugin",
              action: "stream"
            }, "PluginStream Error: %s", err2.message);
            return callback(err2);
          }
          if (mail.data.dkim || this.dkim) {
            mail.message.processFunc((input) => {
              let dkim = mail.data.dkim ? new DKIM(mail.data.dkim) : this.dkim;
              this.logger.debug({
                tnx: "DKIM",
                messageId: mail.message.messageId(),
                dkimDomains: dkim.keys.map((key) => key.keySelector + "." + key.domainName).join(", ")
              }, "Signing outgoing message with %s keys", dkim.keys.length);
              return dkim.sign(input, mail.data._dkim);
            });
          }
          this.transporter.send(mail, (...args) => {
            if (args[0]) {
              this.logger.error({
                err: args[0],
                tnx: "transport",
                action: "send"
              }, "Send Error: %s", args[0].message);
            }
            callback(...args);
          });
        });
      });
      return promise5;
    }
    getVersionString() {
      return util2.format("%s (%s; +%s; %s/%s)", packageData.name, packageData.version, packageData.homepage, this.transporter.name, this.transporter.version);
    }
    _processPlugins(step, mail, callback) {
      step = (step || "").toString();
      if (!this._userPlugins.hasOwnProperty(step)) {
        return callback();
      }
      let userPlugins = this._userPlugins[step] || [];
      let defaultPlugins = this._defaultPlugins[step] || [];
      if (userPlugins.length) {
        this.logger.debug({
          tnx: "transaction",
          pluginCount: userPlugins.length,
          step
        }, "Using %s plugins for %s", userPlugins.length, step);
      }
      if (userPlugins.length + defaultPlugins.length === 0) {
        return callback();
      }
      let pos = 0;
      let block = "default";
      let processPlugins = () => {
        let curplugins = block === "default" ? defaultPlugins : userPlugins;
        if (pos >= curplugins.length) {
          if (block === "default" && userPlugins.length) {
            block = "user";
            pos = 0;
            curplugins = userPlugins;
          } else {
            return callback();
          }
        }
        let plugin = curplugins[pos++];
        plugin(mail, (err) => {
          if (err) {
            return callback(err);
          }
          processPlugins();
        });
      };
      processPlugins();
    }
    setupProxy(proxyUrl) {
      let proxy = urllib.parse(proxyUrl);
      this.getSocket = (options, callback) => {
        let protocol = proxy.protocol.replace(/:$/, "").toLowerCase();
        if (this.meta.has("proxy_handler_" + protocol)) {
          return this.meta.get("proxy_handler_" + protocol)(proxy, options, callback);
        }
        switch (protocol) {
          case "http":
          case "https":
            httpProxyClient(proxy.href, options.port, options.host, (err, socket) => {
              if (err) {
                return callback(err);
              }
              return callback(null, {
                connection: socket
              });
            });
            return;
          case "socks":
          case "socks5":
          case "socks4":
          case "socks4a": {
            if (!this.meta.has("proxy_socks_module")) {
              return callback(new Error("Socks module not loaded"));
            }
            let connect = (ipaddress) => {
              let proxyV2 = !!this.meta.get("proxy_socks_module").SocksClient;
              let socksClient = proxyV2 ? this.meta.get("proxy_socks_module").SocksClient : this.meta.get("proxy_socks_module");
              let proxyType = Number(proxy.protocol.replace(/\D/g, "")) || 5;
              let connectionOpts = {
                proxy: {
                  ipaddress,
                  port: Number(proxy.port),
                  type: proxyType
                },
                [proxyV2 ? "destination" : "target"]: {
                  host: options.host,
                  port: options.port
                },
                command: "connect"
              };
              if (proxy.auth) {
                let username = decodeURIComponent(proxy.auth.split(":").shift());
                let password = decodeURIComponent(proxy.auth.split(":").pop());
                if (proxyV2) {
                  connectionOpts.proxy.userId = username;
                  connectionOpts.proxy.password = password;
                } else if (proxyType === 4) {
                  connectionOpts.userid = username;
                } else {
                  connectionOpts.authentication = {
                    username,
                    password
                  };
                }
              }
              socksClient.createConnection(connectionOpts, (err, info) => {
                if (err) {
                  return callback(err);
                }
                return callback(null, {
                  connection: info.socket || info
                });
              });
            };
            if (net2.isIP(proxy.hostname)) {
              return connect(proxy.hostname);
            }
            return dns.resolve(proxy.hostname, (err, address) => {
              if (err) {
                return callback(err);
              }
              connect(Array.isArray(address) ? address[0] : address);
            });
          }
        }
        callback(new Error("Unknown proxy configuration"));
      };
    }
    _convertDataImages(mail, callback) {
      if (!this.options.attachDataUrls && !mail.data.attachDataUrls || !mail.data.html) {
        return callback();
      }
      mail.resolveContent(mail.data, "html", (err, html) => {
        if (err) {
          return callback(err);
        }
        let cidCounter = 0;
        html = (html || "").toString().replace(/(<img\b[^<>]{0,1024} src\s{0,20}=[\s"']{0,20})(data:([^;]+);[^"'>\s]+)/gi, (match, prefix, dataUri, mimeType) => {
          let cid = crypto3.randomBytes(10).toString("hex") + "@localhost";
          if (!mail.data.attachments) {
            mail.data.attachments = [];
          }
          if (!Array.isArray(mail.data.attachments)) {
            mail.data.attachments = [].concat(mail.data.attachments || []);
          }
          mail.data.attachments.push({
            path: dataUri,
            cid,
            filename: "image-" + ++cidCounter + "." + mimeTypes.detectExtension(mimeType)
          });
          return prefix + "cid:" + cid;
        });
        mail.data.html = html;
        callback();
      });
    }
    set(key, value15) {
      return this.meta.set(key, value15);
    }
    get(key) {
      return this.meta.get(key);
    }
  }
  module.exports = Mail;
});

// node_modules/nodemailer/lib/smtp-connection/data-stream.js
var require_data_stream = __commonJS((exports, module) => {
  var stream = import.meta.require("stream");
  var Transform2 = stream.Transform;

  class DataStream extends Transform2 {
    constructor(options) {
      super(options);
      this.options = options || {};
      this._curLine = "";
      this.inByteCount = 0;
      this.outByteCount = 0;
      this.lastByte = false;
    }
    _transform(chunk, encoding, done) {
      let chunks = [];
      let chunklen = 0;
      let i, len, lastPos = 0;
      let buf;
      if (!chunk || !chunk.length) {
        return done();
      }
      if (typeof chunk === "string") {
        chunk = Buffer.from(chunk);
      }
      this.inByteCount += chunk.length;
      for (i = 0, len = chunk.length;i < len; i++) {
        if (chunk[i] === 46) {
          if (i && chunk[i - 1] === 10 || !i && (!this.lastByte || this.lastByte === 10)) {
            buf = chunk.slice(lastPos, i + 1);
            chunks.push(buf);
            chunks.push(Buffer.from("."));
            chunklen += buf.length + 1;
            lastPos = i + 1;
          }
        } else if (chunk[i] === 10) {
          if (i && chunk[i - 1] !== 13 || !i && this.lastByte !== 13) {
            if (i > lastPos) {
              buf = chunk.slice(lastPos, i);
              chunks.push(buf);
              chunklen += buf.length + 2;
            } else {
              chunklen += 2;
            }
            chunks.push(Buffer.from("\r\n"));
            lastPos = i + 1;
          }
        }
      }
      if (chunklen) {
        if (lastPos < chunk.length) {
          buf = chunk.slice(lastPos);
          chunks.push(buf);
          chunklen += buf.length;
        }
        this.outByteCount += chunklen;
        this.push(Buffer.concat(chunks, chunklen));
      } else {
        this.outByteCount += chunk.length;
        this.push(chunk);
      }
      this.lastByte = chunk[chunk.length - 1];
      done();
    }
    _flush(done) {
      let buf;
      if (this.lastByte === 10) {
        buf = Buffer.from(".\r\n");
      } else if (this.lastByte === 13) {
        buf = Buffer.from("\n.\r\n");
      } else {
        buf = Buffer.from("\r\n.\r\n");
      }
      this.outByteCount += buf.length;
      this.push(buf);
      done();
    }
  }
  module.exports = DataStream;
});

// node_modules/nodemailer/lib/smtp-connection/index.js
var require_smtp_connection = __commonJS((exports, module) => {
  var packageInfo = require_package();
  var EventEmitter = import.meta.require("events").EventEmitter;
  var net2 = import.meta.require("net");
  var tls2 = import.meta.require("tls");
  var os2 = import.meta.require("os");
  var crypto3 = import.meta.require("crypto");
  var DataStream = require_data_stream();
  var PassThrough = import.meta.require("stream").PassThrough;
  var shared = require_shared();
  var CONNECTION_TIMEOUT = 2 * 60 * 1000;
  var SOCKET_TIMEOUT = 10 * 60 * 1000;
  var GREETING_TIMEOUT = 30 * 1000;
  var DNS_TIMEOUT = 30 * 1000;

  class SMTPConnection extends EventEmitter {
    constructor(options) {
      super(options);
      this.id = crypto3.randomBytes(8).toString("base64").replace(/\W/g, "");
      this.stage = "init";
      this.options = options || {};
      this.secureConnection = !!this.options.secure;
      this.alreadySecured = !!this.options.secured;
      this.port = Number(this.options.port) || (this.secureConnection ? 465 : 587);
      this.host = this.options.host || "localhost";
      this.allowInternalNetworkInterfaces = this.options.allowInternalNetworkInterfaces || false;
      if (typeof this.options.secure === "undefined" && this.port === 465) {
        this.secureConnection = true;
      }
      this.name = this.options.name || this._getHostname();
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-connection",
        sid: this.id
      });
      this.customAuth = new Map;
      Object.keys(this.options.customAuth || {}).forEach((key) => {
        let mapKey = (key || "").toString().trim().toUpperCase();
        if (!mapKey) {
          return;
        }
        this.customAuth.set(mapKey, this.options.customAuth[key]);
      });
      this.version = packageInfo.version;
      this.authenticated = false;
      this.destroyed = false;
      this.secure = !!this.secureConnection;
      this._remainder = "";
      this._responseQueue = [];
      this.lastServerResponse = false;
      this._socket = false;
      this._supportedAuth = [];
      this.allowsAuth = false;
      this._envelope = false;
      this._supportedExtensions = [];
      this._maxAllowedSize = 0;
      this._responseActions = [];
      this._recipientQueue = [];
      this._greetingTimeout = false;
      this._connectionTimeout = false;
      this._destroyed = false;
      this._closing = false;
      this._onSocketData = (chunk) => this._onData(chunk);
      this._onSocketError = (error22) => this._onError(error22, "ESOCKET", false, "CONN");
      this._onSocketClose = () => this._onClose();
      this._onSocketEnd = () => this._onEnd();
      this._onSocketTimeout = () => this._onTimeout();
    }
    connect(connectCallback) {
      if (typeof connectCallback === "function") {
        this.once("connect", () => {
          this.logger.debug({
            tnx: "smtp"
          }, "SMTP handshake finished");
          connectCallback();
        });
        const isDestroyedMessage = this._isDestroyedMessage("connect");
        if (isDestroyedMessage) {
          return connectCallback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "CONN"));
        }
      }
      let opts = {
        port: this.port,
        host: this.host,
        allowInternalNetworkInterfaces: this.allowInternalNetworkInterfaces,
        timeout: this.options.dnsTimeout || DNS_TIMEOUT
      };
      if (this.options.localAddress) {
        opts.localAddress = this.options.localAddress;
      }
      let setupConnectionHandlers = () => {
        this._connectionTimeout = setTimeout(() => {
          this._onError("Connection timeout", "ETIMEDOUT", false, "CONN");
        }, this.options.connectionTimeout || CONNECTION_TIMEOUT);
        this._socket.on("error", this._onSocketError);
      };
      if (this.options.connection) {
        this._socket = this.options.connection;
        if (this.secureConnection && !this.alreadySecured) {
          setImmediate(() => this._upgradeConnection((err) => {
            if (err) {
              this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "CONN");
              return;
            }
            this._onConnect();
          }));
        } else {
          setImmediate(() => this._onConnect());
        }
        return;
      } else if (this.options.socket) {
        this._socket = this.options.socket;
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket.connect(this.port, this.host, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else if (this.secureConnection) {
        if (this.options.tls) {
          Object.keys(this.options.tls).forEach((key) => {
            opts[key] = this.options.tls[key];
          });
        }
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = tls2.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      } else {
        return shared.resolveHostname(opts, (err, resolved) => {
          if (err) {
            return setImmediate(() => this._onError(err, "EDNS", false, "CONN"));
          }
          this.logger.debug({
            tnx: "dns",
            source: opts.host,
            resolved: resolved.host,
            cached: !!resolved.cached
          }, "Resolved %s as %s [cache %s]", opts.host, resolved.host, resolved.cached ? "hit" : "miss");
          Object.keys(resolved).forEach((key) => {
            if (key.charAt(0) !== "_" && resolved[key]) {
              opts[key] = resolved[key];
            }
          });
          try {
            this._socket = net2.connect(opts, () => {
              this._socket.setKeepAlive(true);
              this._onConnect();
            });
            setupConnectionHandlers();
          } catch (E) {
            return setImmediate(() => this._onError(E, "ECONNECTION", false, "CONN"));
          }
        });
      }
    }
    quit() {
      this._sendCommand("QUIT");
      this._responseActions.push(this.close);
    }
    close() {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      this._responseActions = [];
      if (this._closing) {
        return;
      }
      this._closing = true;
      let closeMethod = "end";
      if (this.stage === "init") {
        closeMethod = "destroy";
      }
      this.logger.debug({
        tnx: "smtp"
      }, 'Closing connection to the server using "%s"', closeMethod);
      let socket = this._socket && this._socket.socket || this._socket;
      if (socket && !socket.destroyed) {
        try {
          this._socket[closeMethod]();
        } catch (E) {
        }
      }
      this._destroy();
    }
    login(authData, callback) {
      const isDestroyedMessage = this._isDestroyedMessage("login");
      if (isDestroyedMessage) {
        return callback(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      this._auth = authData || {};
      this._authMethod = (this._auth.method || "").toString().trim().toUpperCase() || false;
      if (!this._authMethod && this._auth.oauth2 && !this._auth.credentials) {
        this._authMethod = "XOAUTH2";
      } else if (!this._authMethod || this._authMethod === "XOAUTH2" && !this._auth.oauth2) {
        this._authMethod = (this._supportedAuth[0] || "PLAIN").toUpperCase().trim();
      }
      if (this._authMethod !== "XOAUTH2" && (!this._auth.credentials || !this._auth.credentials.user || !this._auth.credentials.pass)) {
        if (this._auth.user && this._auth.pass || this.customAuth.has(this._authMethod)) {
          this._auth.credentials = {
            user: this._auth.user,
            pass: this._auth.pass,
            options: this._auth.options
          };
        } else {
          return callback(this._formatError('Missing credentials for "' + this._authMethod + '"', "EAUTH", false, "API"));
        }
      }
      if (this.customAuth.has(this._authMethod)) {
        let handler = this.customAuth.get(this._authMethod);
        let lastResponse;
        let returned = false;
        let resolve = () => {
          if (returned) {
            return;
          }
          returned = true;
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authenticated",
            method: this._authMethod
          }, "User %s authenticated", JSON.stringify(this._auth.user));
          this.authenticated = true;
          callback(null, true);
        };
        let reject = (err) => {
          if (returned) {
            return;
          }
          returned = true;
          callback(this._formatError(err, "EAUTH", lastResponse, "AUTH " + this._authMethod));
        };
        let handlerResponse = handler({
          auth: this._auth,
          method: this._authMethod,
          extensions: [].concat(this._supportedExtensions),
          authMethods: [].concat(this._supportedAuth),
          maxAllowedSize: this._maxAllowedSize || false,
          sendCommand: (cmd, done) => {
            let promise5;
            if (!done) {
              promise5 = new Promise((resolve2, reject2) => {
                done = shared.callbackPromise(resolve2, reject2);
              });
            }
            this._responseActions.push((str) => {
              lastResponse = str;
              let codes = str.match(/^(\d+)(?:\s(\d+\.\d+\.\d+))?\s/);
              let data = {
                command: cmd,
                response: str
              };
              if (codes) {
                data.status = Number(codes[1]) || 0;
                if (codes[2]) {
                  data.code = codes[2];
                }
                data.text = str.substr(codes[0].length);
              } else {
                data.text = str;
                data.status = 0;
              }
              done(null, data);
            });
            setImmediate(() => this._sendCommand(cmd));
            return promise5;
          },
          resolve,
          reject
        });
        if (handlerResponse && typeof handlerResponse.catch === "function") {
          handlerResponse.then(resolve).catch(reject);
        }
        return;
      }
      switch (this._authMethod) {
        case "XOAUTH2":
          this._handleXOauth2Token(false, callback);
          return;
        case "LOGIN":
          this._responseActions.push((str) => {
            this._actionAUTH_LOGIN_USER(str, callback);
          });
          this._sendCommand("AUTH LOGIN");
          return;
        case "PLAIN":
          this._responseActions.push((str) => {
            this._actionAUTHComplete(str, callback);
          });
          this._sendCommand("AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + this._auth.credentials.pass, "utf-8").toString("base64"), "AUTH PLAIN " + Buffer.from("\0" + this._auth.credentials.user + "\0" + "/* secret */", "utf-8").toString("base64"));
          return;
        case "CRAM-MD5":
          this._responseActions.push((str) => {
            this._actionAUTH_CRAM_MD5(str, callback);
          });
          this._sendCommand("AUTH CRAM-MD5");
          return;
      }
      return callback(this._formatError('Unknown authentication method "' + this._authMethod + '"', "EAUTH", false, "API"));
    }
    send(envelope, message, done) {
      if (!message) {
        return done(this._formatError("Empty message", "EMESSAGE", false, "API"));
      }
      const isDestroyedMessage = this._isDestroyedMessage("send message");
      if (isDestroyedMessage) {
        return done(this._formatError(isDestroyedMessage, "ECONNECTION", false, "API"));
      }
      if (this._maxAllowedSize && envelope.size > this._maxAllowedSize) {
        return setImmediate(() => {
          done(this._formatError("Message size larger than allowed " + this._maxAllowedSize, "EMESSAGE", false, "MAIL FROM"));
        });
      }
      let returned = false;
      let callback = function() {
        if (returned) {
          return;
        }
        returned = true;
        done(...arguments);
      };
      if (typeof message.on === "function") {
        message.on("error", (err) => callback(this._formatError(err, "ESTREAM", false, "API")));
      }
      let startTime = Date.now();
      this._setEnvelope(envelope, (err, info) => {
        if (err) {
          return callback(err);
        }
        let envelopeTime = Date.now();
        let stream = this._createSendStream((err2, str) => {
          if (err2) {
            return callback(err2);
          }
          info.envelopeTime = envelopeTime - startTime;
          info.messageTime = Date.now() - envelopeTime;
          info.messageSize = stream.outByteCount;
          info.response = str;
          return callback(null, info);
        });
        if (typeof message.pipe === "function") {
          message.pipe(stream);
        } else {
          stream.write(message);
          stream.end();
        }
      });
    }
    reset(callback) {
      this._sendCommand("RSET");
      this._responseActions.push((str) => {
        if (str.charAt(0) !== "2") {
          return callback(this._formatError("Could not reset session state. response=" + str, "EPROTOCOL", str, "RSET"));
        }
        this._envelope = false;
        return callback(null, true);
      });
    }
    _onConnect() {
      clearTimeout(this._connectionTimeout);
      this.logger.info({
        tnx: "network",
        localAddress: this._socket.localAddress,
        localPort: this._socket.localPort,
        remoteAddress: this._socket.remoteAddress,
        remotePort: this._socket.remotePort
      }, "%s established to %s:%s", this.secure ? "Secure connection" : "Connection", this._socket.remoteAddress, this._socket.remotePort);
      if (this._destroyed) {
        this.close();
        return;
      }
      this.stage = "connected";
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      this._socket.removeListener("close", this._onSocketClose);
      this._socket.removeListener("end", this._onSocketEnd);
      this._socket.on("data", this._onSocketData);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      this._greetingTimeout = setTimeout(() => {
        if (this._socket && !this._destroyed && this._responseActions[0] === this._actionGreeting) {
          this._onError("Greeting never received", "ETIMEDOUT", false, "CONN");
        }
      }, this.options.greetingTimeout || GREETING_TIMEOUT);
      this._responseActions.push(this._actionGreeting);
      this._socket.resume();
    }
    _onData(chunk) {
      if (this._destroyed || !chunk || !chunk.length) {
        return;
      }
      let data = (chunk || "").toString("binary");
      let lines = (this._remainder + data).split(/\r?\n/);
      let lastline;
      this._remainder = lines.pop();
      for (let i = 0, len = lines.length;i < len; i++) {
        if (this._responseQueue.length) {
          lastline = this._responseQueue[this._responseQueue.length - 1];
          if (/^\d+-/.test(lastline.split("\n").pop())) {
            this._responseQueue[this._responseQueue.length - 1] += "\n" + lines[i];
            continue;
          }
        }
        this._responseQueue.push(lines[i]);
      }
      if (this._responseQueue.length) {
        lastline = this._responseQueue[this._responseQueue.length - 1];
        if (/^\d+-/.test(lastline.split("\n").pop())) {
          return;
        }
      }
      this._processResponse();
    }
    _onError(err, type75, data, command) {
      clearTimeout(this._connectionTimeout);
      clearTimeout(this._greetingTimeout);
      if (this._destroyed) {
        return;
      }
      err = this._formatError(err, type75, data, command);
      this.logger.error(data, err.message);
      this.emit("error", err);
      this.close();
    }
    _formatError(message, type75, response, command) {
      let err;
      if (/Error\]$/i.test(Object.prototype.toString.call(message))) {
        err = message;
      } else {
        err = new Error(message);
      }
      if (type75 && type75 !== "Error") {
        err.code = type75;
      }
      if (response) {
        err.response = response;
        err.message += ": " + response;
      }
      let responseCode = typeof response === "string" && Number((response.match(/^\d+/) || [])[0]) || false;
      if (responseCode) {
        err.responseCode = responseCode;
      }
      if (command) {
        err.command = command;
      }
      return err;
    }
    _onClose() {
      let serverResponse = false;
      if (this._remainder && this._remainder.trim()) {
        if (this.options.debug || this.options.transactionLog) {
          this.logger.debug({
            tnx: "server"
          }, this._remainder.replace(/\r?\n$/, ""));
        }
        this.lastServerResponse = serverResponse = this._remainder.trim();
      }
      this.logger.info({
        tnx: "network"
      }, "Connection closed");
      if (this.upgrading && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ETLS", serverResponse, "CONN");
      } else if (![this._actionGreeting, this.close].includes(this._responseActions[0]) && !this._destroyed) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      } else if (/^[45]\d{2}\b/.test(serverResponse)) {
        return this._onError(new Error("Connection closed unexpectedly"), "ECONNECTION", serverResponse, "CONN");
      }
      this._destroy();
    }
    _onEnd() {
      if (this._socket && !this._socket.destroyed) {
        this._socket.destroy();
      }
    }
    _onTimeout() {
      return this._onError(new Error("Timeout"), "ETIMEDOUT", false, "CONN");
    }
    _destroy() {
      if (this._destroyed) {
        return;
      }
      this._destroyed = true;
      this.emit("end");
    }
    _upgradeConnection(callback) {
      this._socket.removeListener("data", this._onSocketData);
      this._socket.removeListener("timeout", this._onSocketTimeout);
      let socketPlain = this._socket;
      let opts = {
        socket: this._socket,
        host: this.host
      };
      Object.keys(this.options.tls || {}).forEach((key) => {
        opts[key] = this.options.tls[key];
      });
      this.upgrading = true;
      try {
        this._socket = tls2.connect(opts, () => {
          this.secure = true;
          this.upgrading = false;
          this._socket.on("data", this._onSocketData);
          socketPlain.removeListener("close", this._onSocketClose);
          socketPlain.removeListener("end", this._onSocketEnd);
          return callback(null, true);
        });
      } catch (err) {
        return callback(err);
      }
      this._socket.on("error", this._onSocketError);
      this._socket.once("close", this._onSocketClose);
      this._socket.once("end", this._onSocketEnd);
      this._socket.setTimeout(this.options.socketTimeout || SOCKET_TIMEOUT);
      this._socket.on("timeout", this._onSocketTimeout);
      socketPlain.resume();
    }
    _processResponse() {
      if (!this._responseQueue.length) {
        return false;
      }
      let str = this.lastServerResponse = (this._responseQueue.shift() || "").toString();
      if (/^\d+-/.test(str.split("\n").pop())) {
        return;
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "server"
        }, str.replace(/\r?\n$/, ""));
      }
      if (!str.trim()) {
        setImmediate(() => this._processResponse());
      }
      let action = this._responseActions.shift();
      if (typeof action === "function") {
        action.call(this, str);
        setImmediate(() => this._processResponse());
      } else {
        return this._onError(new Error("Unexpected Response"), "EPROTOCOL", str, "CONN");
      }
    }
    _sendCommand(str, logStr) {
      if (this._destroyed) {
        return;
      }
      if (this._socket.destroyed) {
        return this.close();
      }
      if (this.options.debug || this.options.transactionLog) {
        this.logger.debug({
          tnx: "client"
        }, (logStr || str || "").toString().replace(/\r?\n$/, ""));
      }
      this._socket.write(Buffer.from(str + "\r\n", "utf-8"));
    }
    _setEnvelope(envelope, callback) {
      let args = [];
      let useSmtpUtf8 = false;
      this._envelope = envelope || {};
      this._envelope.from = (this._envelope.from && this._envelope.from.address || this._envelope.from || "").toString().trim();
      this._envelope.to = [].concat(this._envelope.to || []).map((to) => (to && to.address || to || "").toString().trim());
      if (!this._envelope.to.length) {
        return callback(this._formatError("No recipients defined", "EENVELOPE", false, "API"));
      }
      if (this._envelope.from && /[\r\n<>]/.test(this._envelope.from)) {
        return callback(this._formatError("Invalid sender " + JSON.stringify(this._envelope.from), "EENVELOPE", false, "API"));
      }
      if (/[\x80-\uFFFF]/.test(this._envelope.from)) {
        useSmtpUtf8 = true;
      }
      for (let i = 0, len = this._envelope.to.length;i < len; i++) {
        if (!this._envelope.to[i] || /[\r\n<>]/.test(this._envelope.to[i])) {
          return callback(this._formatError("Invalid recipient " + JSON.stringify(this._envelope.to[i]), "EENVELOPE", false, "API"));
        }
        if (/[\x80-\uFFFF]/.test(this._envelope.to[i])) {
          useSmtpUtf8 = true;
        }
      }
      this._envelope.rcptQueue = JSON.parse(JSON.stringify(this._envelope.to || []));
      this._envelope.rejected = [];
      this._envelope.rejectedErrors = [];
      this._envelope.accepted = [];
      if (this._envelope.dsn) {
        try {
          this._envelope.dsn = this._setDsnEnvelope(this._envelope.dsn);
        } catch (err) {
          return callback(this._formatError("Invalid DSN " + err.message, "EENVELOPE", false, "API"));
        }
      }
      this._responseActions.push((str) => {
        this._actionMAIL(str, callback);
      });
      if (useSmtpUtf8 && this._supportedExtensions.includes("SMTPUTF8")) {
        args.push("SMTPUTF8");
        this._usingSmtpUtf8 = true;
      }
      if (this._envelope.use8BitMime && this._supportedExtensions.includes("8BITMIME")) {
        args.push("BODY=8BITMIME");
        this._using8BitMime = true;
      }
      if (this._envelope.size && this._supportedExtensions.includes("SIZE")) {
        args.push("SIZE=" + this._envelope.size);
      }
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.ret) {
          args.push("RET=" + shared.encodeXText(this._envelope.dsn.ret));
        }
        if (this._envelope.dsn.envid) {
          args.push("ENVID=" + shared.encodeXText(this._envelope.dsn.envid));
        }
      }
      this._sendCommand("MAIL FROM:<" + this._envelope.from + ">" + (args.length ? " " + args.join(" ") : ""));
    }
    _setDsnEnvelope(params) {
      let ret = (params.ret || params.return || "").toString().toUpperCase() || null;
      if (ret) {
        switch (ret) {
          case "HDRS":
          case "HEADERS":
            ret = "HDRS";
            break;
          case "FULL":
          case "BODY":
            ret = "FULL";
            break;
        }
      }
      if (ret && !["FULL", "HDRS"].includes(ret)) {
        throw new Error("ret: " + JSON.stringify(ret));
      }
      let envid = (params.envid || params.id || "").toString() || null;
      let notify = params.notify || null;
      if (notify) {
        if (typeof notify === "string") {
          notify = notify.split(",");
        }
        notify = notify.map((n2) => n2.trim().toUpperCase());
        let validNotify = ["NEVER", "SUCCESS", "FAILURE", "DELAY"];
        let invaliNotify = notify.filter((n2) => !validNotify.includes(n2));
        if (invaliNotify.length || notify.length > 1 && notify.includes("NEVER")) {
          throw new Error("notify: " + JSON.stringify(notify.join(",")));
        }
        notify = notify.join(",");
      }
      let orcpt = (params.recipient || params.orcpt || "").toString() || null;
      if (orcpt && orcpt.indexOf(";") < 0) {
        orcpt = "rfc822;" + orcpt;
      }
      return {
        ret,
        envid,
        notify,
        orcpt
      };
    }
    _getDsnRcptToArgs() {
      let args = [];
      if (this._envelope.dsn && this._supportedExtensions.includes("DSN")) {
        if (this._envelope.dsn.notify) {
          args.push("NOTIFY=" + shared.encodeXText(this._envelope.dsn.notify));
        }
        if (this._envelope.dsn.orcpt) {
          args.push("ORCPT=" + shared.encodeXText(this._envelope.dsn.orcpt));
        }
      }
      return args.length ? " " + args.join(" ") : "";
    }
    _createSendStream(callback) {
      let dataStream = new DataStream;
      let logStream;
      if (this.options.lmtp) {
        this._envelope.accepted.forEach((recipient, i) => {
          let final = i === this._envelope.accepted.length - 1;
          this._responseActions.push((str) => {
            this._actionLMTPStream(recipient, final, str, callback);
          });
        });
      } else {
        this._responseActions.push((str) => {
          this._actionSMTPStream(str, callback);
        });
      }
      dataStream.pipe(this._socket, {
        end: false
      });
      if (this.options.debug) {
        logStream = new PassThrough;
        logStream.on("readable", () => {
          let chunk;
          while (chunk = logStream.read()) {
            this.logger.debug({
              tnx: "message"
            }, chunk.toString("binary").replace(/\r?\n$/, ""));
          }
        });
        dataStream.pipe(logStream);
      }
      dataStream.once("end", () => {
        this.logger.info({
          tnx: "message",
          inByteCount: dataStream.inByteCount,
          outByteCount: dataStream.outByteCount
        }, "<%s bytes encoded mime message (source size %s bytes)>", dataStream.outByteCount, dataStream.inByteCount);
      });
      return dataStream;
    }
    _actionGreeting(str) {
      clearTimeout(this._greetingTimeout);
      if (str.substr(0, 3) !== "220") {
        this._onError(new Error("Invalid greeting. response=" + str), "EPROTOCOL", str, "CONN");
        return;
      }
      if (this.options.lmtp) {
        this._responseActions.push(this._actionLHLO);
        this._sendCommand("LHLO " + this.name);
      } else {
        this._responseActions.push(this._actionEHLO);
        this._sendCommand("EHLO " + this.name);
      }
    }
    _actionLHLO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid LHLO. response=" + str), "EPROTOCOL", str, "LHLO");
        return;
      }
      this._actionEHLO(str);
    }
    _actionEHLO(str) {
      let match;
      if (str.substr(0, 3) === "421") {
        this._onError(new Error("Server terminates connection. response=" + str), "ECONNECTION", str, "EHLO");
        return;
      }
      if (str.charAt(0) !== "2") {
        if (this.options.requireTLS) {
          this._onError(new Error("EHLO failed but HELO does not support required STARTTLS. response=" + str), "ECONNECTION", str, "EHLO");
          return;
        }
        this._responseActions.push(this._actionHELO);
        this._sendCommand("HELO " + this.name);
        return;
      }
      this._ehloLines = str.split(/\r?\n/).map((line) => line.replace(/^\d+[ -]/, "").trim()).filter((line) => line).slice(1);
      if (!this.secure && !this.options.ignoreTLS && (/[ -]STARTTLS\b/im.test(str) || this.options.requireTLS)) {
        this._sendCommand("STARTTLS");
        this._responseActions.push(this._actionSTARTTLS);
        return;
      }
      if (/[ -]SMTPUTF8\b/im.test(str)) {
        this._supportedExtensions.push("SMTPUTF8");
      }
      if (/[ -]DSN\b/im.test(str)) {
        this._supportedExtensions.push("DSN");
      }
      if (/[ -]8BITMIME\b/im.test(str)) {
        this._supportedExtensions.push("8BITMIME");
      }
      if (/[ -]PIPELINING\b/im.test(str)) {
        this._supportedExtensions.push("PIPELINING");
      }
      if (/[ -]AUTH\b/i.test(str)) {
        this.allowsAuth = true;
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)PLAIN/i.test(str)) {
        this._supportedAuth.push("PLAIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)LOGIN/i.test(str)) {
        this._supportedAuth.push("LOGIN");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)CRAM-MD5/i.test(str)) {
        this._supportedAuth.push("CRAM-MD5");
      }
      if (/[ -]AUTH(?:(\s+|=)[^\n]*\s+|\s+|=)XOAUTH2/i.test(str)) {
        this._supportedAuth.push("XOAUTH2");
      }
      if (match = str.match(/[ -]SIZE(?:[ \t]+(\d+))?/im)) {
        this._supportedExtensions.push("SIZE");
        this._maxAllowedSize = Number(match[1]) || 0;
      }
      this.emit("connect");
    }
    _actionHELO(str) {
      if (str.charAt(0) !== "2") {
        this._onError(new Error("Invalid HELO. response=" + str), "EPROTOCOL", str, "HELO");
        return;
      }
      this.allowsAuth = true;
      this.emit("connect");
    }
    _actionSTARTTLS(str) {
      if (str.charAt(0) !== "2") {
        if (this.options.opportunisticTLS) {
          this.logger.info({
            tnx: "smtp"
          }, "Failed STARTTLS upgrade, continuing unencrypted");
          return this.emit("connect");
        }
        this._onError(new Error("Error upgrading connection with STARTTLS"), "ETLS", str, "STARTTLS");
        return;
      }
      this._upgradeConnection((err, secured) => {
        if (err) {
          this._onError(new Error("Error initiating TLS - " + (err.message || err)), "ETLS", false, "STARTTLS");
          return;
        }
        this.logger.info({
          tnx: "smtp"
        }, "Connection upgraded with STARTTLS");
        if (secured) {
          if (this.options.lmtp) {
            this._responseActions.push(this._actionLHLO);
            this._sendCommand("LHLO " + this.name);
          } else {
            this._responseActions.push(this._actionEHLO);
            this._sendCommand("EHLO " + this.name);
          }
        } else {
          this.emit("connect");
        }
      });
    }
    _actionAUTH_LOGIN_USER(str, callback) {
      if (!/^334[ -]/.test(str)) {
        callback(this._formatError('Invalid login sequence while waiting for "334 VXNlcm5hbWU6"', "EAUTH", str, "AUTH LOGIN"));
        return;
      }
      this._responseActions.push((str2) => {
        this._actionAUTH_LOGIN_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(this._auth.credentials.user + "", "utf-8").toString("base64"));
    }
    _actionAUTH_CRAM_MD5(str, callback) {
      let challengeMatch = str.match(/^334\s+(.+)$/);
      let challengeString = "";
      if (!challengeMatch) {
        return callback(this._formatError("Invalid login sequence while waiting for server challenge string", "EAUTH", str, "AUTH CRAM-MD5"));
      } else {
        challengeString = challengeMatch[1];
      }
      let base64decoded = Buffer.from(challengeString, "base64").toString("ascii"), hmacMD5 = crypto3.createHmac("md5", this._auth.credentials.pass);
      hmacMD5.update(base64decoded);
      let prepended = this._auth.credentials.user + " " + hmacMD5.digest("hex");
      this._responseActions.push((str2) => {
        this._actionAUTH_CRAM_MD5_PASS(str2, callback);
      });
      this._sendCommand(Buffer.from(prepended).toString("base64"), Buffer.from(this._auth.credentials.user + " /* secret */").toString("base64"));
    }
    _actionAUTH_CRAM_MD5_PASS(str, callback) {
      if (!str.match(/^235\s+/)) {
        return callback(this._formatError('Invalid login sequence while waiting for "235"', "EAUTH", str, "AUTH CRAM-MD5"));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionAUTH_LOGIN_PASS(str, callback) {
      if (!/^334[ -]/.test(str)) {
        return callback(this._formatError('Invalid login sequence while waiting for "334 UGFzc3dvcmQ6"', "EAUTH", str, "AUTH LOGIN"));
      }
      this._responseActions.push((str2) => {
        this._actionAUTHComplete(str2, callback);
      });
      this._sendCommand(Buffer.from((this._auth.credentials.pass || "").toString(), "utf-8").toString("base64"), Buffer.from("/* secret */", "utf-8").toString("base64"));
    }
    _actionAUTHComplete(str, isRetry, callback) {
      if (!callback && typeof isRetry === "function") {
        callback = isRetry;
        isRetry = false;
      }
      if (str.substr(0, 3) === "334") {
        this._responseActions.push((str2) => {
          if (isRetry || this._authMethod !== "XOAUTH2") {
            this._actionAUTHComplete(str2, true, callback);
          } else {
            setImmediate(() => this._handleXOauth2Token(true, callback));
          }
        });
        this._sendCommand("");
        return;
      }
      if (str.charAt(0) !== "2") {
        this.logger.info({
          tnx: "smtp",
          username: this._auth.user,
          action: "authfail",
          method: this._authMethod
        }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
        return callback(this._formatError("Invalid login", "EAUTH", str, "AUTH " + this._authMethod));
      }
      this.logger.info({
        tnx: "smtp",
        username: this._auth.user,
        action: "authenticated",
        method: this._authMethod
      }, "User %s authenticated", JSON.stringify(this._auth.user));
      this.authenticated = true;
      callback(null, true);
    }
    _actionMAIL(str, callback) {
      let message, curRecipient;
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^550 /.test(str) && /[\x80-\uFFFF]/.test(this._envelope.from)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Mail command failed";
        }
        return callback(this._formatError(message, "EENVELOPE", str, "MAIL FROM"));
      }
      if (!this._envelope.rcptQueue.length) {
        return callback(this._formatError("Can't send mail - no recipients defined", "EENVELOPE", false, "API"));
      } else {
        this._recipientQueue = [];
        if (this._supportedExtensions.includes("PIPELINING")) {
          while (this._envelope.rcptQueue.length) {
            curRecipient = this._envelope.rcptQueue.shift();
            this._recipientQueue.push(curRecipient);
            this._responseActions.push((str2) => {
              this._actionRCPT(str2, callback);
            });
            this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
          }
        } else {
          curRecipient = this._envelope.rcptQueue.shift();
          this._recipientQueue.push(curRecipient);
          this._responseActions.push((str2) => {
            this._actionRCPT(str2, callback);
          });
          this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
        }
      }
    }
    _actionRCPT(str, callback) {
      let message, err, curRecipient = this._recipientQueue.shift();
      if (Number(str.charAt(0)) !== 2) {
        if (this._usingSmtpUtf8 && /^553 /.test(str) && /[\x80-\uFFFF]/.test(curRecipient)) {
          message = "Internationalized mailbox name not allowed";
        } else {
          message = "Recipient command failed";
        }
        this._envelope.rejected.push(curRecipient);
        err = this._formatError(message, "EENVELOPE", str, "RCPT TO");
        err.recipient = curRecipient;
        this._envelope.rejectedErrors.push(err);
      } else {
        this._envelope.accepted.push(curRecipient);
      }
      if (!this._envelope.rcptQueue.length && !this._recipientQueue.length) {
        if (this._envelope.rejected.length < this._envelope.to.length) {
          this._responseActions.push((str2) => {
            this._actionDATA(str2, callback);
          });
          this._sendCommand("DATA");
        } else {
          err = this._formatError("Can't send mail - all recipients were rejected", "EENVELOPE", str, "RCPT TO");
          err.rejected = this._envelope.rejected;
          err.rejectedErrors = this._envelope.rejectedErrors;
          return callback(err);
        }
      } else if (this._envelope.rcptQueue.length) {
        curRecipient = this._envelope.rcptQueue.shift();
        this._recipientQueue.push(curRecipient);
        this._responseActions.push((str2) => {
          this._actionRCPT(str2, callback);
        });
        this._sendCommand("RCPT TO:<" + curRecipient + ">" + this._getDsnRcptToArgs());
      }
    }
    _actionDATA(str, callback) {
      if (!/^[23]/.test(str)) {
        return callback(this._formatError("Data command failed", "EENVELOPE", str, "DATA"));
      }
      let response = {
        accepted: this._envelope.accepted,
        rejected: this._envelope.rejected
      };
      if (this._ehloLines && this._ehloLines.length) {
        response.ehlo = this._ehloLines;
      }
      if (this._envelope.rejectedErrors.length) {
        response.rejectedErrors = this._envelope.rejectedErrors;
      }
      callback(null, response);
    }
    _actionSMTPStream(str, callback) {
      if (Number(str.charAt(0)) !== 2) {
        return callback(this._formatError("Message failed", "EMESSAGE", str, "DATA"));
      } else {
        return callback(null, str);
      }
    }
    _actionLMTPStream(recipient, final, str, callback) {
      let err;
      if (Number(str.charAt(0)) !== 2) {
        err = this._formatError("Message failed for recipient " + recipient, "EMESSAGE", str, "DATA");
        err.recipient = recipient;
        this._envelope.rejected.push(recipient);
        this._envelope.rejectedErrors.push(err);
        for (let i = 0, len = this._envelope.accepted.length;i < len; i++) {
          if (this._envelope.accepted[i] === recipient) {
            this._envelope.accepted.splice(i, 1);
          }
        }
      }
      if (final) {
        return callback(null, str);
      }
    }
    _handleXOauth2Token(isRetry, callback) {
      this._auth.oauth2.getToken(isRetry, (err, accessToken) => {
        if (err) {
          this.logger.info({
            tnx: "smtp",
            username: this._auth.user,
            action: "authfail",
            method: this._authMethod
          }, "User %s failed to authenticate", JSON.stringify(this._auth.user));
          return callback(this._formatError(err, "EAUTH", false, "AUTH XOAUTH2"));
        }
        this._responseActions.push((str) => {
          this._actionAUTHComplete(str, isRetry, callback);
        });
        this._sendCommand("AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token(accessToken), "AUTH XOAUTH2 " + this._auth.oauth2.buildXOAuth2Token("/* secret */"));
      });
    }
    _isDestroyedMessage(command) {
      if (this._destroyed) {
        return "Cannot " + command + " - smtp connection is already destroyed.";
      }
      if (this._socket) {
        if (this._socket.destroyed) {
          return "Cannot " + command + " - smtp connection socket is already destroyed.";
        }
        if (!this._socket.writable) {
          return "Cannot " + command + " - smtp connection socket is already half-closed.";
        }
      }
    }
    _getHostname() {
      let defaultHostname;
      try {
        defaultHostname = os2.hostname() || "";
      } catch (err) {
        defaultHostname = "localhost";
      }
      if (!defaultHostname || defaultHostname.indexOf(".") < 0) {
        defaultHostname = "[127.0.0.1]";
      }
      if (defaultHostname.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
        defaultHostname = "[" + defaultHostname + "]";
      }
      return defaultHostname;
    }
  }
  module.exports = SMTPConnection;
});

// node_modules/nodemailer/lib/xoauth2/index.js
var require_xoauth2 = __commonJS((exports, module) => {
  var Stream3 = import.meta.require("stream").Stream;
  var nmfetch = require_fetch();
  var crypto3 = import.meta.require("crypto");
  var shared = require_shared();

  class XOAuth2 extends Stream3 {
    constructor(options, logger3) {
      super();
      this.options = options || {};
      if (options && options.serviceClient) {
        if (!options.privateKey || !options.user) {
          setImmediate(() => this.emit("error", new Error('Options "privateKey" and "user" are required for service account!')));
          return;
        }
        let serviceRequestTimeout = Math.min(Math.max(Number(this.options.serviceRequestTimeout) || 0, 0), 3600);
        this.options.serviceRequestTimeout = serviceRequestTimeout || 5 * 60;
      }
      this.logger = shared.getLogger({
        logger: logger3
      }, {
        component: this.options.component || "OAuth2"
      });
      this.provisionCallback = typeof this.options.provisionCallback === "function" ? this.options.provisionCallback : false;
      this.options.accessUrl = this.options.accessUrl || "https://accounts.google.com/o/oauth2/token";
      this.options.customHeaders = this.options.customHeaders || {};
      this.options.customParams = this.options.customParams || {};
      this.accessToken = this.options.accessToken || false;
      if (this.options.expires && Number(this.options.expires)) {
        this.expires = this.options.expires;
      } else {
        let timeout = Math.max(Number(this.options.timeout) || 0, 0);
        this.expires = timeout && Date.now() + timeout * 1000 || 0;
      }
    }
    getToken(renew, callback) {
      if (!renew && this.accessToken && (!this.expires || this.expires > Date.now())) {
        return callback(null, this.accessToken);
      }
      let generateCallback = (...args) => {
        if (args[0]) {
          this.logger.error({
            err: args[0],
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Failed generating new Access Token for %s", this.options.user);
        } else {
          this.logger.info({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "renew"
          }, "Generated new Access Token for %s", this.options.user);
        }
        callback(...args);
      };
      if (this.provisionCallback) {
        this.provisionCallback(this.options.user, !!renew, (err, accessToken, expires) => {
          if (!err && accessToken) {
            this.accessToken = accessToken;
            this.expires = expires || 0;
          }
          generateCallback(err, accessToken);
        });
      } else {
        this.generateToken(generateCallback);
      }
    }
    updateToken(accessToken, timeout) {
      this.accessToken = accessToken;
      timeout = Math.max(Number(timeout) || 0, 0);
      this.expires = timeout && Date.now() + timeout * 1000 || 0;
      this.emit("token", {
        user: this.options.user,
        accessToken: accessToken || "",
        expires: this.expires
      });
    }
    generateToken(callback) {
      let urlOptions;
      let loggedUrlOptions;
      if (this.options.serviceClient) {
        let iat = Math.floor(Date.now() / 1000);
        let tokenData = {
          iss: this.options.serviceClient,
          scope: this.options.scope || "https://mail.google.com/",
          sub: this.options.user,
          aud: this.options.accessUrl,
          iat,
          exp: iat + this.options.serviceRequestTimeout
        };
        let token;
        try {
          token = this.jwtSignRS256(tokenData);
        } catch (err) {
          return callback(new Error("Can't generate token. Check your auth options"));
        }
        urlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: token
        };
        loggedUrlOptions = {
          grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
          assertion: tokenData
        };
      } else {
        if (!this.options.refreshToken) {
          return callback(new Error("Can't create new access token for user"));
        }
        urlOptions = {
          client_id: this.options.clientId || "",
          client_secret: this.options.clientSecret || "",
          refresh_token: this.options.refreshToken,
          grant_type: "refresh_token"
        };
        loggedUrlOptions = {
          client_id: this.options.clientId || "",
          client_secret: (this.options.clientSecret || "").substr(0, 6) + "...",
          refresh_token: (this.options.refreshToken || "").substr(0, 6) + "...",
          grant_type: "refresh_token"
        };
      }
      Object.keys(this.options.customParams).forEach((key) => {
        urlOptions[key] = this.options.customParams[key];
        loggedUrlOptions[key] = this.options.customParams[key];
      });
      this.logger.debug({
        tnx: "OAUTH2",
        user: this.options.user,
        action: "generate"
      }, "Requesting token using: %s", JSON.stringify(loggedUrlOptions));
      this.postRequest(this.options.accessUrl, urlOptions, this.options, (error22, body) => {
        let data;
        if (error22) {
          return callback(error22);
        }
        try {
          data = JSON.parse(body.toString());
        } catch (E) {
          return callback(E);
        }
        if (!data || typeof data !== "object") {
          this.logger.debug({
            tnx: "OAUTH2",
            user: this.options.user,
            action: "post"
          }, "Response: %s", (body || "").toString());
          return callback(new Error("Invalid authentication response"));
        }
        let logData = {};
        Object.keys(data).forEach((key) => {
          if (key !== "access_token") {
            logData[key] = data[key];
          } else {
            logData[key] = (data[key] || "").toString().substr(0, 6) + "...";
          }
        });
        this.logger.debug({
          tnx: "OAUTH2",
          user: this.options.user,
          action: "post"
        }, "Response: %s", JSON.stringify(logData));
        if (data.error) {
          let errorMessage = data.error;
          if (data.error_description) {
            errorMessage += ": " + data.error_description;
          }
          if (data.error_uri) {
            errorMessage += " (" + data.error_uri + ")";
          }
          return callback(new Error(errorMessage));
        }
        if (data.access_token) {
          this.updateToken(data.access_token, data.expires_in);
          return callback(null, this.accessToken);
        }
        return callback(new Error("No access token"));
      });
    }
    buildXOAuth2Token(accessToken) {
      let authData = ["user=" + (this.options.user || ""), "auth=Bearer " + (accessToken || this.accessToken), "", ""];
      return Buffer.from(authData.join("\x01"), "utf-8").toString("base64");
    }
    postRequest(url, payload, params, callback) {
      let returned = false;
      let chunks = [];
      let chunklen = 0;
      let req = nmfetch(url, {
        method: "post",
        headers: params.customHeaders,
        body: payload,
        allowErrorResponse: true
      });
      req.on("readable", () => {
        let chunk;
        while ((chunk = req.read()) !== null) {
          chunks.push(chunk);
          chunklen += chunk.length;
        }
      });
      req.once("error", (err) => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(err);
      });
      req.once("end", () => {
        if (returned) {
          return;
        }
        returned = true;
        return callback(null, Buffer.concat(chunks, chunklen));
      });
    }
    toBase64URL(data) {
      if (typeof data === "string") {
        data = Buffer.from(data);
      }
      return data.toString("base64").replace(/[=]+/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    jwtSignRS256(payload) {
      payload = ['{"alg":"RS256","typ":"JWT"}', JSON.stringify(payload)].map((val) => this.toBase64URL(val)).join(".");
      let signature = crypto3.createSign("RSA-SHA256").update(payload).sign(this.options.privateKey);
      return payload + "." + this.toBase64URL(signature);
    }
  }
  module.exports = XOAuth2;
});

// node_modules/nodemailer/lib/smtp-pool/pool-resource.js
var require_pool_resource = __commonJS((exports, module) => {
  var SMTPConnection = require_smtp_connection();
  var assign = require_shared().assign;
  var XOAuth2 = require_xoauth2();
  var EventEmitter = import.meta.require("events");

  class PoolResource extends EventEmitter {
    constructor(pool) {
      super();
      this.pool = pool;
      this.options = pool.options;
      this.logger = this.pool.logger;
      if (this.options.auth) {
        switch ((this.options.auth.type || "").toString().toUpperCase()) {
          case "OAUTH2": {
            let oauth2 = new XOAuth2(this.options.auth, this.logger);
            oauth2.provisionCallback = this.pool.mailer && this.pool.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
            this.auth = {
              type: "OAUTH2",
              user: this.options.auth.user,
              oauth2,
              method: "XOAUTH2"
            };
            oauth2.on("token", (token) => this.pool.mailer.emit("token", token));
            oauth2.on("error", (err) => this.emit("error", err));
            break;
          }
          default:
            if (!this.options.auth.user && !this.options.auth.pass) {
              break;
            }
            this.auth = {
              type: (this.options.auth.type || "").toString().toUpperCase() || "LOGIN",
              user: this.options.auth.user,
              credentials: {
                user: this.options.auth.user || "",
                pass: this.options.auth.pass,
                options: this.options.auth.options
              },
              method: (this.options.auth.method || "").trim().toUpperCase() || this.options.authMethod || false
            };
        }
      }
      this._connection = false;
      this._connected = false;
      this.messages = 0;
      this.available = true;
    }
    connect(callback) {
      this.pool.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        this.connection = new SMTPConnection(options);
        this.connection.once("error", (err2) => {
          this.emit("error", err2);
          if (returned) {
            return;
          }
          returned = true;
          return callback(err2);
        });
        this.connection.once("end", () => {
          this.close();
          if (returned) {
            return;
          }
          returned = true;
          let timer2 = setTimeout(() => {
            if (returned) {
              return;
            }
            let err2 = new Error("Unexpected socket close");
            if (this.connection && this.connection._socket && this.connection._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer2.unref();
          } catch (E) {
          }
        });
        this.connection.connect(() => {
          if (returned) {
            return;
          }
          if (this.auth && (this.connection.allowsAuth || options.forceAuth)) {
            this.connection.login(this.auth, (err2) => {
              if (returned) {
                return;
              }
              returned = true;
              if (err2) {
                this.connection.close();
                this.emit("error", err2);
                return callback(err2);
              }
              this._connected = true;
              callback(null, true);
            });
          } else {
            returned = true;
            this._connected = true;
            return callback(null, true);
          }
        });
      });
    }
    send(mail, callback) {
      if (!this._connected) {
        return this.connect((err) => {
          if (err) {
            return callback(err);
          }
          return this.send(mail, callback);
        });
      }
      let envelope = mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId,
        cid: this.id
      }, "Sending message %s using #%s to <%s>", messageId, this.id, recipients.join(", "));
      if (mail.data.dsn) {
        envelope.dsn = mail.data.dsn;
      }
      this.connection.send(envelope, mail.message.createReadStream(), (err, info) => {
        this.messages++;
        if (err) {
          this.connection.close();
          this.emit("error", err);
          return callback(err);
        }
        info.envelope = {
          from: envelope.from,
          to: envelope.to
        };
        info.messageId = messageId;
        setImmediate(() => {
          let err2;
          if (this.messages >= this.options.maxMessages) {
            err2 = new Error("Resource exhausted");
            err2.code = "EMAXLIMIT";
            this.connection.close();
            this.emit("error", err2);
          } else {
            this.pool._checkRateLimit(() => {
              this.available = true;
              this.emit("available");
            });
          }
        });
        callback(null, info);
      });
    }
    close() {
      this._connected = false;
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      if (this.connection) {
        this.connection.close();
      }
      this.emit("close");
    }
  }
  module.exports = PoolResource;
});

// node_modules/nodemailer/lib/well-known/services.json
var require_services = __commonJS((exports, module) => {
  module.exports = {
    "1und1": {
      host: "smtp.1und1.de",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    },
    Aliyun: {
      domains: ["aliyun.com"],
      host: "smtp.aliyun.com",
      port: 465,
      secure: true
    },
    AOL: {
      domains: ["aol.com"],
      host: "smtp.aol.com",
      port: 587
    },
    Bluewin: {
      host: "smtpauths.bluewin.ch",
      domains: ["bluewin.ch"],
      port: 465
    },
    DebugMail: {
      host: "debugmail.io",
      port: 25
    },
    DynectEmail: {
      aliases: ["Dynect"],
      host: "smtp.dynect.net",
      port: 25
    },
    Ethereal: {
      aliases: ["ethereal.email"],
      host: "smtp.ethereal.email",
      port: 587
    },
    FastMail: {
      domains: ["fastmail.fm"],
      host: "smtp.fastmail.com",
      port: 465,
      secure: true
    },
    "Forward Email": {
      aliases: ["FE", "ForwardEmail"],
      domains: ["forwardemail.net"],
      host: "smtp.forwardemail.net",
      port: 465,
      secure: true
    },
    GandiMail: {
      aliases: ["Gandi", "Gandi Mail"],
      host: "mail.gandi.net",
      port: 587
    },
    Gmail: {
      aliases: ["Google Mail"],
      domains: ["gmail.com", "googlemail.com"],
      host: "smtp.gmail.com",
      port: 465,
      secure: true
    },
    Godaddy: {
      host: "smtpout.secureserver.net",
      port: 25
    },
    GodaddyAsia: {
      host: "smtp.asia.secureserver.net",
      port: 25
    },
    GodaddyEurope: {
      host: "smtp.europe.secureserver.net",
      port: 25
    },
    "hot.ee": {
      host: "mail.hot.ee"
    },
    Hotmail: {
      aliases: ["Outlook", "Outlook.com", "Hotmail.com"],
      domains: ["hotmail.com", "outlook.com"],
      host: "smtp-mail.outlook.com",
      port: 587
    },
    iCloud: {
      aliases: ["Me", "Mac"],
      domains: ["me.com", "mac.com"],
      host: "smtp.mail.me.com",
      port: 587
    },
    Infomaniak: {
      host: "mail.infomaniak.com",
      domains: ["ik.me", "ikmail.com", "etik.com"],
      port: 587
    },
    "mail.ee": {
      host: "smtp.mail.ee"
    },
    "Mail.ru": {
      host: "smtp.mail.ru",
      port: 465,
      secure: true
    },
    "Mailcatch.app": {
      host: "sandbox-smtp.mailcatch.app",
      port: 2525
    },
    Maildev: {
      port: 1025,
      ignoreTLS: true
    },
    Mailgun: {
      host: "smtp.mailgun.org",
      port: 465,
      secure: true
    },
    Mailjet: {
      host: "in.mailjet.com",
      port: 587
    },
    Mailosaur: {
      host: "mailosaur.io",
      port: 25
    },
    Mailtrap: {
      host: "smtp.mailtrap.io",
      port: 2525
    },
    Mandrill: {
      host: "smtp.mandrillapp.com",
      port: 587
    },
    Naver: {
      host: "smtp.naver.com",
      port: 587
    },
    One: {
      host: "send.one.com",
      port: 465,
      secure: true
    },
    OpenMailBox: {
      aliases: ["OMB", "openmailbox.org"],
      host: "smtp.openmailbox.org",
      port: 465,
      secure: true
    },
    Outlook365: {
      host: "smtp.office365.com",
      port: 587,
      secure: false
    },
    OhMySMTP: {
      host: "smtp.ohmysmtp.com",
      port: 587,
      secure: false
    },
    Postmark: {
      aliases: ["PostmarkApp"],
      host: "smtp.postmarkapp.com",
      port: 2525
    },
    "qiye.aliyun": {
      host: "smtp.mxhichina.com",
      port: "465",
      secure: true
    },
    QQ: {
      domains: ["qq.com"],
      host: "smtp.qq.com",
      port: 465,
      secure: true
    },
    QQex: {
      aliases: ["QQ Enterprise"],
      domains: ["exmail.qq.com"],
      host: "smtp.exmail.qq.com",
      port: 465,
      secure: true
    },
    SendCloud: {
      host: "smtp.sendcloud.net",
      port: 2525
    },
    SendGrid: {
      host: "smtp.sendgrid.net",
      port: 587
    },
    SendinBlue: {
      aliases: ["Brevo"],
      host: "smtp-relay.brevo.com",
      port: 587
    },
    SendPulse: {
      host: "smtp-pulse.com",
      port: 465,
      secure: true
    },
    SES: {
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-EAST-1": {
      host: "email-smtp.us-east-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-US-WEST-2": {
      host: "email-smtp.us-west-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-EU-WEST-1": {
      host: "email-smtp.eu-west-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTH-1": {
      host: "email-smtp.ap-south-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-1": {
      host: "email-smtp.ap-northeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-2": {
      host: "email-smtp.ap-northeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-NORTHEAST-3": {
      host: "email-smtp.ap-northeast-3.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-1": {
      host: "email-smtp.ap-southeast-1.amazonaws.com",
      port: 465,
      secure: true
    },
    "SES-AP-SOUTHEAST-2": {
      host: "email-smtp.ap-southeast-2.amazonaws.com",
      port: 465,
      secure: true
    },
    Sparkpost: {
      aliases: ["SparkPost", "SparkPost Mail"],
      domains: ["sparkpost.com"],
      host: "smtp.sparkpostmail.com",
      port: 587,
      secure: false
    },
    Tipimail: {
      host: "smtp.tipimail.com",
      port: 587
    },
    Yahoo: {
      domains: ["yahoo.com"],
      host: "smtp.mail.yahoo.com",
      port: 465,
      secure: true
    },
    Yandex: {
      domains: ["yandex.ru"],
      host: "smtp.yandex.ru",
      port: 465,
      secure: true
    },
    Zoho: {
      host: "smtp.zoho.com",
      port: 465,
      secure: true,
      authMethod: "LOGIN"
    },
    "126": {
      host: "smtp.126.com",
      port: 465,
      secure: true
    },
    "163": {
      host: "smtp.163.com",
      port: 465,
      secure: true
    }
  };
});

// node_modules/nodemailer/lib/well-known/index.js
var require_well_known = __commonJS((exports, module) => {
  var normalizeKey = function(key) {
    return key.replace(/[^a-zA-Z0-9.-]/g, "").toLowerCase();
  };
  var normalizeService = function(service) {
    let filter = ["domains", "aliases"];
    let response = {};
    Object.keys(service).forEach((key) => {
      if (filter.indexOf(key) < 0) {
        response[key] = service[key];
      }
    });
    return response;
  };
  var services = require_services();
  var normalized = {};
  Object.keys(services).forEach((key) => {
    let service = services[key];
    normalized[normalizeKey(key)] = normalizeService(service);
    [].concat(service.aliases || []).forEach((alias3) => {
      normalized[normalizeKey(alias3)] = normalizeService(service);
    });
    [].concat(service.domains || []).forEach((domain) => {
      normalized[normalizeKey(domain)] = normalizeService(service);
    });
  });
  module.exports = function(key) {
    key = normalizeKey(key.split("@").pop());
    return normalized[key] || false;
  };
});

// node_modules/nodemailer/lib/smtp-pool/index.js
var require_smtp_pool = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var PoolResource = require_pool_resource();
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared();
  var packageData = require_package();

  class SMTPPool extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.options.maxConnections = this.options.maxConnections || 5;
      this.options.maxMessages = this.options.maxMessages || 100;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-pool"
      });
      let connection6 = new SMTPConnection(this.options);
      this.name = "SMTP (pool)";
      this.version = packageData.version + "[client:" + connection6.version + "]";
      this._rateLimit = {
        counter: 0,
        timeout: null,
        waiting: [],
        checkpoint: false,
        delta: Number(this.options.rateDelta) || 1000,
        limit: Number(this.options.rateLimit) || 0
      };
      this._closed = false;
      this._queue = [];
      this._connections = [];
      this._connectionCounter = 0;
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    send(mail, callback) {
      if (this._closed) {
        return false;
      }
      this._queue.push({
        mail,
        requeueAttempts: 0,
        callback
      });
      if (this.idling && this._queue.length >= this.options.maxConnections) {
        this.idling = false;
      }
      setImmediate(() => this._processMessages());
      return true;
    }
    close() {
      let connection6;
      let len = this._connections.length;
      this._closed = true;
      clearTimeout(this._rateLimit.timeout);
      if (!len && !this._queue.length) {
        return;
      }
      for (let i = len - 1;i >= 0; i--) {
        if (this._connections[i] && this._connections[i].available) {
          connection6 = this._connections[i];
          connection6.close();
          this.logger.info({
            tnx: "connection",
            cid: connection6.id,
            action: "removed"
          }, "Connection #%s removed", connection6.id);
        }
      }
      if (len && !this._connections.length) {
        this.logger.debug({
          tnx: "connection"
        }, "All connections removed");
      }
      if (!this._queue.length) {
        return;
      }
      let invokeCallbacks = () => {
        if (!this._queue.length) {
          this.logger.debug({
            tnx: "connection"
          }, "Pending queue entries cleared");
          return;
        }
        let entry = this._queue.shift();
        if (entry && typeof entry.callback === "function") {
          try {
            entry.callback(new Error("Connection pool was closed"));
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection6.id
            }, "Callback error for #%s: %s", connection6.id, E.message);
          }
        }
        setImmediate(invokeCallbacks);
      };
      setImmediate(invokeCallbacks);
    }
    _processMessages() {
      let connection6;
      let i, len;
      if (this._closed) {
        return;
      }
      if (!this._queue.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      for (i = 0, len = this._connections.length;i < len; i++) {
        if (this._connections[i].available) {
          connection6 = this._connections[i];
          break;
        }
      }
      if (!connection6 && this._connections.length < this.options.maxConnections) {
        connection6 = this._createConnection();
      }
      if (!connection6) {
        this.idling = false;
        return;
      }
      if (!this.idling && this._queue.length < this.options.maxConnections) {
        this.idling = true;
        this.emit("idle");
      }
      let entry = connection6.queueEntry = this._queue.shift();
      entry.messageId = (connection6.queueEntry.mail.message.getHeader("message-id") || "").replace(/[<>\s]/g, "");
      connection6.available = false;
      this.logger.debug({
        tnx: "pool",
        cid: connection6.id,
        messageId: entry.messageId,
        action: "assign"
      }, "Assigned message <%s> to #%s (%s)", entry.messageId, connection6.id, connection6.messages + 1);
      if (this._rateLimit.limit) {
        this._rateLimit.counter++;
        if (!this._rateLimit.checkpoint) {
          this._rateLimit.checkpoint = Date.now();
        }
      }
      connection6.send(entry.mail, (err, info) => {
        if (entry === connection6.queueEntry) {
          try {
            entry.callback(err, info);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection6.id
            }, "Callback error for #%s: %s", connection6.id, E.message);
          }
          connection6.queueEntry = false;
        }
      });
    }
    _createConnection() {
      let connection6 = new PoolResource(this);
      connection6.id = ++this._connectionCounter;
      this.logger.info({
        tnx: "pool",
        cid: connection6.id,
        action: "conection"
      }, "Created new pool resource #%s", connection6.id);
      connection6.on("available", () => {
        this.logger.debug({
          tnx: "connection",
          cid: connection6.id,
          action: "available"
        }, "Connection #%s became available", connection6.id);
        if (this._closed) {
          this.close();
        } else {
          this._processMessages();
        }
      });
      connection6.once("error", (err) => {
        if (err.code !== "EMAXLIMIT") {
          this.logger.error({
            err,
            tnx: "pool",
            cid: connection6.id
          }, "Pool Error for #%s: %s", connection6.id, err.message);
        } else {
          this.logger.debug({
            tnx: "pool",
            cid: connection6.id,
            action: "maxlimit"
          }, "Max messages limit exchausted for #%s", connection6.id);
        }
        if (connection6.queueEntry) {
          try {
            connection6.queueEntry.callback(err);
          } catch (E) {
            this.logger.error({
              err: E,
              tnx: "callback",
              cid: connection6.id
            }, "Callback error for #%s: %s", connection6.id, E.message);
          }
          connection6.queueEntry = false;
        }
        this._removeConnection(connection6);
        this._continueProcessing();
      });
      connection6.once("close", () => {
        this.logger.info({
          tnx: "connection",
          cid: connection6.id,
          action: "closed"
        }, "Connection #%s was closed", connection6.id);
        this._removeConnection(connection6);
        if (connection6.queueEntry) {
          setTimeout(() => {
            if (connection6.queueEntry) {
              if (this._shouldRequeuOnConnectionClose(connection6.queueEntry)) {
                this._requeueEntryOnConnectionClose(connection6);
              } else {
                this._failDeliveryOnConnectionClose(connection6);
              }
            }
            this._continueProcessing();
          }, 50);
        } else {
          this._continueProcessing();
        }
      });
      this._connections.push(connection6);
      return connection6;
    }
    _shouldRequeuOnConnectionClose(queueEntry) {
      if (this.options.maxRequeues === undefined || this.options.maxRequeues < 0) {
        return true;
      }
      return queueEntry.requeueAttempts < this.options.maxRequeues;
    }
    _failDeliveryOnConnectionClose(connection6) {
      if (connection6.queueEntry && connection6.queueEntry.callback) {
        try {
          connection6.queueEntry.callback(new Error("Reached maximum number of retries after connection was closed"));
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "callback",
            messageId: connection6.queueEntry.messageId,
            cid: connection6.id
          }, "Callback error for #%s: %s", connection6.id, E.message);
        }
        connection6.queueEntry = false;
      }
    }
    _requeueEntryOnConnectionClose(connection6) {
      connection6.queueEntry.requeueAttempts = connection6.queueEntry.requeueAttempts + 1;
      this.logger.debug({
        tnx: "pool",
        cid: connection6.id,
        messageId: connection6.queueEntry.messageId,
        action: "requeue"
      }, "Re-queued message <%s> for #%s. Attempt: #%s", connection6.queueEntry.messageId, connection6.id, connection6.queueEntry.requeueAttempts);
      this._queue.unshift(connection6.queueEntry);
      connection6.queueEntry = false;
    }
    _continueProcessing() {
      if (this._closed) {
        this.close();
      } else {
        setTimeout(() => this._processMessages(), 100);
      }
    }
    _removeConnection(connection6) {
      let index = this._connections.indexOf(connection6);
      if (index !== -1) {
        this._connections.splice(index, 1);
      }
    }
    _checkRateLimit(callback) {
      if (!this._rateLimit.limit) {
        return callback();
      }
      let now = Date.now();
      if (this._rateLimit.counter < this._rateLimit.limit) {
        return callback();
      }
      this._rateLimit.waiting.push(callback);
      if (this._rateLimit.checkpoint <= now - this._rateLimit.delta) {
        return this._clearRateLimit();
      } else if (!this._rateLimit.timeout) {
        this._rateLimit.timeout = setTimeout(() => this._clearRateLimit(), this._rateLimit.delta - (now - this._rateLimit.checkpoint));
        this._rateLimit.checkpoint = now;
      }
    }
    _clearRateLimit() {
      clearTimeout(this._rateLimit.timeout);
      this._rateLimit.timeout = null;
      this._rateLimit.counter = 0;
      this._rateLimit.checkpoint = false;
      while (this._rateLimit.waiting.length) {
        let cb = this._rateLimit.waiting.shift();
        setImmediate(cb);
      }
    }
    isIdle() {
      return this.idling;
    }
    verify(callback) {
      let promise5;
      if (!callback) {
        promise5 = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      let auth = new PoolResource(this).auth;
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection6 = new SMTPConnection(options);
        let returned = false;
        connection6.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection6.close();
          return callback(err2);
        });
        connection6.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection6.quit();
          return callback(null, true);
        };
        connection6.connect(() => {
          if (returned) {
            return;
          }
          if (auth && (connection6.allowsAuth || options.forceAuth)) {
            connection6.login(auth, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection6.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!auth && connection6.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection6.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise5;
    }
  }
  module.exports = SMTPPool;
});

// node_modules/nodemailer/lib/smtp-transport/index.js
var require_smtp_transport = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var SMTPConnection = require_smtp_connection();
  var wellKnown = require_well_known();
  var shared = require_shared();
  var XOAuth2 = require_xoauth2();
  var packageData = require_package();

  class SMTPTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      if (typeof options === "string") {
        options = {
          url: options
        };
      }
      let urlData;
      let service = options.service;
      if (typeof options.getSocket === "function") {
        this.getSocket = options.getSocket;
      }
      if (options.url) {
        urlData = shared.parseConnectionUrl(options.url);
        service = service || urlData.service;
      }
      this.options = shared.assign(false, options, urlData, service && wellKnown(service));
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "smtp-transport"
      });
      let connection6 = new SMTPConnection(this.options);
      this.name = "SMTP";
      this.version = packageData.version + "[client:" + connection6.version + "]";
      if (this.options.auth) {
        this.auth = this.getAuth({});
      }
    }
    getSocket(options, callback) {
      return setImmediate(() => callback(null, false));
    }
    getAuth(authOpts) {
      if (!authOpts) {
        return this.auth;
      }
      let hasAuth = false;
      let authData = {};
      if (this.options.auth && typeof this.options.auth === "object") {
        Object.keys(this.options.auth).forEach((key) => {
          hasAuth = true;
          authData[key] = this.options.auth[key];
        });
      }
      if (authOpts && typeof authOpts === "object") {
        Object.keys(authOpts).forEach((key) => {
          hasAuth = true;
          authData[key] = authOpts[key];
        });
      }
      if (!hasAuth) {
        return false;
      }
      switch ((authData.type || "").toString().toUpperCase()) {
        case "OAUTH2": {
          if (!authData.service && !authData.user) {
            return false;
          }
          let oauth2 = new XOAuth2(authData, this.logger);
          oauth2.provisionCallback = this.mailer && this.mailer.get("oauth2_provision_cb") || oauth2.provisionCallback;
          oauth2.on("token", (token) => this.mailer.emit("token", token));
          oauth2.on("error", (err) => this.emit("error", err));
          return {
            type: "OAUTH2",
            user: authData.user,
            oauth2,
            method: "XOAUTH2"
          };
        }
        default:
          return {
            type: (authData.type || "").toString().toUpperCase() || "LOGIN",
            user: authData.user,
            credentials: {
              user: authData.user || "",
              pass: authData.pass,
              options: authData.options
            },
            method: (authData.method || "").trim().toUpperCase() || this.options.authMethod || false
          };
      }
    }
    send(mail, callback) {
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let returned = false;
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection6 = new SMTPConnection(options);
        connection6.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection6.close();
          return callback(err2);
        });
        connection6.once("end", () => {
          if (returned) {
            return;
          }
          let timer2 = setTimeout(() => {
            if (returned) {
              return;
            }
            returned = true;
            let err2 = new Error("Unexpected socket close");
            if (connection6 && connection6._socket && connection6._socket.upgrading) {
              err2.code = "ETLS";
            }
            callback(err2);
          }, 1000);
          try {
            timer2.unref();
          } catch (E) {
          }
        });
        let sendMessage = () => {
          let envelope = mail.message.getEnvelope();
          let messageId = mail.message.messageId();
          let recipients = [].concat(envelope.to || []);
          if (recipients.length > 3) {
            recipients.push("...and " + recipients.splice(2).length + " more");
          }
          if (mail.data.dsn) {
            envelope.dsn = mail.data.dsn;
          }
          this.logger.info({
            tnx: "send",
            messageId
          }, "Sending message %s to <%s>", messageId, recipients.join(", "));
          connection6.send(envelope, mail.message.createReadStream(), (err2, info) => {
            returned = true;
            connection6.close();
            if (err2) {
              this.logger.error({
                err: err2,
                tnx: "send"
              }, "Send error for %s: %s", messageId, err2.message);
              return callback(err2);
            }
            info.envelope = {
              from: envelope.from,
              to: envelope.to
            };
            info.messageId = messageId;
            try {
              return callback(null, info);
            } catch (E) {
              this.logger.error({
                err: E,
                tnx: "callback"
              }, "Callback error for %s: %s", messageId, E.message);
            }
          });
        };
        connection6.connect(() => {
          if (returned) {
            return;
          }
          let auth = this.getAuth(mail.data.auth);
          if (auth && (connection6.allowsAuth || options.forceAuth)) {
            connection6.login(auth, (err2) => {
              if (auth && auth !== this.auth && auth.oauth2) {
                auth.oauth2.removeAllListeners();
              }
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection6.close();
                return callback(err2);
              }
              sendMessage();
            });
          } else {
            sendMessage();
          }
        });
      });
    }
    verify(callback) {
      let promise5;
      if (!callback) {
        promise5 = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      this.getSocket(this.options, (err, socketOptions) => {
        if (err) {
          return callback(err);
        }
        let options = this.options;
        if (socketOptions && socketOptions.connection) {
          this.logger.info({
            tnx: "proxy",
            remoteAddress: socketOptions.connection.remoteAddress,
            remotePort: socketOptions.connection.remotePort,
            destHost: options.host || "",
            destPort: options.port || "",
            action: "connected"
          }, "Using proxied socket from %s:%s to %s:%s", socketOptions.connection.remoteAddress, socketOptions.connection.remotePort, options.host || "", options.port || "");
          options = shared.assign(false, options);
          Object.keys(socketOptions).forEach((key) => {
            options[key] = socketOptions[key];
          });
        }
        let connection6 = new SMTPConnection(options);
        let returned = false;
        connection6.once("error", (err2) => {
          if (returned) {
            return;
          }
          returned = true;
          connection6.close();
          return callback(err2);
        });
        connection6.once("end", () => {
          if (returned) {
            return;
          }
          returned = true;
          return callback(new Error("Connection closed"));
        });
        let finalize = () => {
          if (returned) {
            return;
          }
          returned = true;
          connection6.quit();
          return callback(null, true);
        };
        connection6.connect(() => {
          if (returned) {
            return;
          }
          let authData = this.getAuth({});
          if (authData && (connection6.allowsAuth || options.forceAuth)) {
            connection6.login(authData, (err2) => {
              if (returned) {
                return;
              }
              if (err2) {
                returned = true;
                connection6.close();
                return callback(err2);
              }
              finalize();
            });
          } else if (!authData && connection6.allowsAuth && options.forceAuth) {
            let err2 = new Error("Authentication info was not provided");
            err2.code = "NoAuth";
            returned = true;
            connection6.close();
            return callback(err2);
          } else {
            finalize();
          }
        });
      });
      return promise5;
    }
    close() {
      if (this.auth && this.auth.oauth2) {
        this.auth.oauth2.removeAllListeners();
      }
      this.emit("close");
    }
  }
  module.exports = SMTPTransport;
});

// node_modules/nodemailer/lib/sendmail-transport/index.js
var require_sendmail_transport = __commonJS((exports, module) => {
  var spawn = import.meta.require("child_process").spawn;
  var packageData = require_package();
  var shared = require_shared();

  class SendmailTransport {
    constructor(options) {
      options = options || {};
      this._spawn = spawn;
      this.options = options || {};
      this.name = "Sendmail";
      this.version = packageData.version;
      this.path = "sendmail";
      this.args = false;
      this.winbreak = false;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "sendmail"
      });
      if (options) {
        if (typeof options === "string") {
          this.path = options;
        } else if (typeof options === "object") {
          if (options.path) {
            this.path = options.path;
          }
          if (Array.isArray(options.args)) {
            this.args = options.args;
          }
          this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
        }
      }
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let args;
      let sendmail;
      let returned;
      const hasInvalidAddresses = [].concat(envelope.from || []).concat(envelope.to || []).some((addr) => /^-/.test(addr));
      if (hasInvalidAddresses) {
        return done(new Error("Can not send mail. Invalid envelope addresses."));
      }
      if (this.args) {
        args = ["-i"].concat(this.args).concat(envelope.to);
      } else {
        args = ["-i"].concat(envelope.from ? ["-f", envelope.from] : []).concat(envelope.to);
      }
      let callback = (err) => {
        if (returned) {
          return;
        }
        returned = true;
        if (typeof done === "function") {
          if (err) {
            return done(err);
          } else {
            return done(null, {
              envelope: mail.data.envelope || mail.message.getEnvelope(),
              messageId,
              response: "Messages queued for delivery"
            });
          }
        }
      };
      try {
        sendmail = this._spawn(this.path, args);
      } catch (E) {
        this.logger.error({
          err: E,
          tnx: "spawn",
          messageId
        }, "Error occurred while spawning sendmail. %s", E.message);
        return callback(E);
      }
      if (sendmail) {
        sendmail.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "spawn",
            messageId
          }, "Error occurred when sending message %s. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("exit", (code) => {
          if (!code) {
            return callback();
          }
          let err;
          if (code === 127) {
            err = new Error("Sendmail command not found, process exited with code " + code);
          } else {
            err = new Error("Sendmail exited with code " + code);
          }
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error sending message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        sendmail.once("close", callback);
        sendmail.stdin.on("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when piping message %s to sendmail. %s", messageId, err.message);
          callback(err);
        });
        let recipients = [].concat(envelope.to || []);
        if (recipients.length > 3) {
          recipients.push("...and " + recipients.splice(2).length + " more");
        }
        this.logger.info({
          tnx: "send",
          messageId
        }, "Sending message %s to <%s>", messageId, recipients.join(", "));
        let sourceStream = mail.message.createReadStream();
        sourceStream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "stdin",
            messageId
          }, "Error occurred when generating message %s. %s", messageId, err.message);
          sendmail.kill("SIGINT");
          callback(err);
        });
        sourceStream.pipe(sendmail.stdin);
      } else {
        return callback(new Error("sendmail was not found"));
      }
    }
  }
  module.exports = SendmailTransport;
});

// node_modules/nodemailer/lib/stream-transport/index.js
var require_stream_transport = __commonJS((exports, module) => {
  var packageData = require_package();
  var shared = require_shared();

  class StreamTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "StreamTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "stream-transport"
      });
      this.winbreak = ["win", "windows", "dos", "\r\n"].includes((options.newline || "").toString().toLowerCase());
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s> using %s line breaks", messageId, recipients.join(", "), this.winbreak ? "<CR><LF>" : "<LF>");
      setImmediate(() => {
        let stream;
        try {
          stream = mail.message.createReadStream();
        } catch (E) {
          this.logger.error({
            err: E,
            tnx: "send",
            messageId
          }, "Creating send stream failed for %s. %s", messageId, E.message);
          return done(E);
        }
        if (!this.options.buffer) {
          stream.once("error", (err) => {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed creating message for %s. %s", messageId, err.message);
          });
          return done(null, {
            envelope: mail.data.envelope || mail.message.getEnvelope(),
            messageId,
            message: stream
          });
        }
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        stream.once("error", (err) => {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          return done(err);
        });
        stream.on("end", () => done(null, {
          envelope: mail.data.envelope || mail.message.getEnvelope(),
          messageId,
          message: Buffer.concat(chunks, chunklen)
        }));
      });
    }
  }
  module.exports = StreamTransport;
});

// node_modules/nodemailer/lib/json-transport/index.js
var require_json_transport = __commonJS((exports, module) => {
  var packageData = require_package();
  var shared = require_shared();

  class JSONTransport {
    constructor(options) {
      options = options || {};
      this.options = options || {};
      this.name = "JSONTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "json-transport"
      });
    }
    send(mail, done) {
      mail.message.keepBcc = true;
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Composing JSON structure of %s to <%s>", messageId, recipients.join(", "));
      setImmediate(() => {
        mail.normalize((err, data) => {
          if (err) {
            this.logger.error({
              err,
              tnx: "send",
              messageId
            }, "Failed building JSON structure for %s. %s", messageId, err.message);
            return done(err);
          }
          delete data.envelope;
          delete data.normalizedHeaders;
          return done(null, {
            envelope,
            messageId,
            message: this.options.skipEncoding ? data : JSON.stringify(data)
          });
        });
      });
    }
  }
  module.exports = JSONTransport;
});

// node_modules/nodemailer/lib/ses-transport/index.js
var require_ses_transport = __commonJS((exports, module) => {
  var EventEmitter = import.meta.require("events");
  var packageData = require_package();
  var shared = require_shared();
  var LeWindows = require_le_windows();

  class SESTransport extends EventEmitter {
    constructor(options) {
      super();
      options = options || {};
      this.options = options || {};
      this.ses = this.options.SES;
      this.name = "SESTransport";
      this.version = packageData.version;
      this.logger = shared.getLogger(this.options, {
        component: this.options.component || "ses-transport"
      });
      this.maxConnections = Number(this.options.maxConnections) || Infinity;
      this.connections = 0;
      this.sendingRate = Number(this.options.sendingRate) || Infinity;
      this.sendingRateTTL = null;
      this.rateInterval = 1000;
      this.rateMessages = [];
      this.pending = [];
      this.idling = true;
      setImmediate(() => {
        if (this.idling) {
          this.emit("idle");
        }
      });
    }
    send(mail, callback) {
      if (this.connections >= this.maxConnections) {
        this.idling = false;
        return this.pending.push({
          mail,
          callback
        });
      }
      if (!this._checkSendingRate()) {
        this.idling = false;
        return this.pending.push({
          mail,
          callback
        });
      }
      this._send(mail, (...args) => {
        setImmediate(() => callback(...args));
        this._sent();
      });
    }
    _checkRatedQueue() {
      if (this.connections >= this.maxConnections || !this._checkSendingRate()) {
        return;
      }
      if (!this.pending.length) {
        if (!this.idling) {
          this.idling = true;
          this.emit("idle");
        }
        return;
      }
      let next = this.pending.shift();
      this._send(next.mail, (...args) => {
        setImmediate(() => next.callback(...args));
        this._sent();
      });
    }
    _checkSendingRate() {
      clearTimeout(this.sendingRateTTL);
      let now = Date.now();
      let oldest = false;
      for (let i = this.rateMessages.length - 1;i >= 0; i--) {
        if (this.rateMessages[i].ts >= now - this.rateInterval && (!oldest || this.rateMessages[i].ts < oldest)) {
          oldest = this.rateMessages[i].ts;
        }
        if (this.rateMessages[i].ts < now - this.rateInterval && !this.rateMessages[i].pending) {
          this.rateMessages.splice(i, 1);
        }
      }
      if (this.rateMessages.length < this.sendingRate) {
        return true;
      }
      let delay = Math.max(oldest + 1001, now + 20);
      this.sendingRateTTL = setTimeout(() => this._checkRatedQueue(), now - delay);
      try {
        this.sendingRateTTL.unref();
      } catch (E) {
      }
      return false;
    }
    _sent() {
      this.connections--;
      this._checkRatedQueue();
    }
    isIdle() {
      return this.idling;
    }
    _send(mail, callback) {
      let statObject = {
        ts: Date.now(),
        pending: true
      };
      this.connections++;
      this.rateMessages.push(statObject);
      let envelope = mail.data.envelope || mail.message.getEnvelope();
      let messageId = mail.message.messageId();
      let recipients = [].concat(envelope.to || []);
      if (recipients.length > 3) {
        recipients.push("...and " + recipients.splice(2).length + " more");
      }
      this.logger.info({
        tnx: "send",
        messageId
      }, "Sending message %s to <%s>", messageId, recipients.join(", "));
      let getRawMessage = (next) => {
        if (!mail.data._dkim) {
          mail.data._dkim = {};
        }
        if (mail.data._dkim.skipFields && typeof mail.data._dkim.skipFields === "string") {
          mail.data._dkim.skipFields += ":date:message-id";
        } else {
          mail.data._dkim.skipFields = "date:message-id";
        }
        let sourceStream = mail.message.createReadStream();
        let stream = sourceStream.pipe(new LeWindows);
        let chunks = [];
        let chunklen = 0;
        stream.on("readable", () => {
          let chunk;
          while ((chunk = stream.read()) !== null) {
            chunks.push(chunk);
            chunklen += chunk.length;
          }
        });
        sourceStream.once("error", (err) => stream.emit("error", err));
        stream.once("error", (err) => {
          next(err);
        });
        stream.once("end", () => next(null, Buffer.concat(chunks, chunklen)));
      };
      setImmediate(() => getRawMessage((err, raw2) => {
        if (err) {
          this.logger.error({
            err,
            tnx: "send",
            messageId
          }, "Failed creating message for %s. %s", messageId, err.message);
          statObject.pending = false;
          return callback(err);
        }
        let sesMessage = {
          RawMessage: {
            Data: raw2
          },
          Source: envelope.from,
          Destinations: envelope.to
        };
        Object.keys(mail.data.ses || {}).forEach((key) => {
          sesMessage[key] = mail.data.ses[key];
        });
        let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
        let aws = this.ses.aws || {};
        let getRegion = (cb) => {
          if (ses.config && typeof ses.config.region === "function") {
            return ses.config.region().then((region) => cb(null, region)).catch((err2) => cb(err2));
          }
          return cb(null, ses.config && ses.config.region || "us-east-1");
        };
        getRegion((err2, region) => {
          if (err2 || !region) {
            region = "us-east-1";
          }
          let sendPromise;
          if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
            sendPromise = ses.send(new aws.SendRawEmailCommand(sesMessage));
          } else {
            sendPromise = ses.sendRawEmail(sesMessage).promise();
          }
          sendPromise.then((data) => {
            if (region === "us-east-1") {
              region = "email";
            }
            statObject.pending = false;
            callback(null, {
              envelope: {
                from: envelope.from,
                to: envelope.to
              },
              messageId: "<" + data.MessageId + (!/@/.test(data.MessageId) ? "@" + region + ".amazonses.com" : "") + ">",
              response: data.MessageId,
              raw: raw2
            });
          }).catch((err3) => {
            this.logger.error({
              err: err3,
              tnx: "send"
            }, "Send error for %s: %s", messageId, err3.message);
            statObject.pending = false;
            callback(err3);
          });
        });
      }));
    }
    verify(callback) {
      let promise5;
      let ses = (this.ses.aws ? this.ses.ses : this.ses) || {};
      let aws = this.ses.aws || {};
      const sesMessage = {
        RawMessage: {
          Data: "From: invalid@invalid\r\nTo: invalid@invalid\r\n Subject: Invalid\r\n\r\nInvalid"
        },
        Source: "invalid@invalid",
        Destinations: ["invalid@invalid"]
      };
      if (!callback) {
        promise5 = new Promise((resolve, reject) => {
          callback = shared.callbackPromise(resolve, reject);
        });
      }
      const cb = (err) => {
        if (err && (err.code || err.Code) !== "InvalidParameterValue") {
          return callback(err);
        }
        return callback(null, true);
      };
      if (typeof ses.send === "function" && aws.SendRawEmailCommand) {
        sesMessage.RawMessage.Data = Buffer.from(sesMessage.RawMessage.Data);
        ses.send(new aws.SendRawEmailCommand(sesMessage), cb);
      } else {
        ses.sendRawEmail(sesMessage, cb);
      }
      return promise5;
    }
  }
  module.exports = SESTransport;
});

// node_modules/nodemailer/lib/nodemailer.js
var require_nodemailer = __commonJS((exports, module) => {
  var Mailer = require_mailer();
  var shared = require_shared();
  var SMTPPool = require_smtp_pool();
  var SMTPTransport = require_smtp_transport();
  var SendmailTransport = require_sendmail_transport();
  var StreamTransport = require_stream_transport();
  var JSONTransport = require_json_transport();
  var SESTransport = require_ses_transport();
  var nmfetch = require_fetch();
  var packageData = require_package();
  var ETHEREAL_API = (process.env.ETHEREAL_API || "https://api.nodemailer.com").replace(/\/+$/, "");
  var ETHEREAL_WEB = (process.env.ETHEREAL_WEB || "https://ethereal.email").replace(/\/+$/, "");
  var ETHEREAL_CACHE = ["true", "yes", "y", "1"].includes((process.env.ETHEREAL_CACHE || "yes").toString().trim().toLowerCase());
  var testAccount = false;
  exports.createTransport = function(transporter, defaults) {
    let urlConfig;
    let options;
    let mailer;
    if (typeof transporter === "object" && typeof transporter.send !== "function" || typeof transporter === "string" && /^(smtps?|direct):/i.test(transporter)) {
      if (urlConfig = typeof transporter === "string" ? transporter : transporter.url) {
        options = shared.parseConnectionUrl(urlConfig);
      } else {
        options = transporter;
      }
      if (options.pool) {
        transporter = new SMTPPool(options);
      } else if (options.sendmail) {
        transporter = new SendmailTransport(options);
      } else if (options.streamTransport) {
        transporter = new StreamTransport(options);
      } else if (options.jsonTransport) {
        transporter = new JSONTransport(options);
      } else if (options.SES) {
        transporter = new SESTransport(options);
      } else {
        transporter = new SMTPTransport(options);
      }
    }
    mailer = new Mailer(transporter, options, defaults);
    return mailer;
  };
  exports.createTestAccount = function(apiUrl, callback) {
    let promise5;
    if (!callback && typeof apiUrl === "function") {
      callback = apiUrl;
      apiUrl = false;
    }
    if (!callback) {
      promise5 = new Promise((resolve, reject) => {
        callback = shared.callbackPromise(resolve, reject);
      });
    }
    if (ETHEREAL_CACHE && testAccount) {
      setImmediate(() => callback(null, testAccount));
      return promise5;
    }
    apiUrl = apiUrl || ETHEREAL_API;
    let chunks = [];
    let chunklen = 0;
    let req = nmfetch(apiUrl + "/user", {
      contentType: "application/json",
      method: "POST",
      body: Buffer.from(JSON.stringify({
        requestor: packageData.name,
        version: packageData.version
      }))
    });
    req.on("readable", () => {
      let chunk;
      while ((chunk = req.read()) !== null) {
        chunks.push(chunk);
        chunklen += chunk.length;
      }
    });
    req.once("error", (err) => callback(err));
    req.once("end", () => {
      let res = Buffer.concat(chunks, chunklen);
      let data;
      let err;
      try {
        data = JSON.parse(res.toString());
      } catch (E) {
        err = E;
      }
      if (err) {
        return callback(err);
      }
      if (data.status !== "success" || data.error) {
        return callback(new Error(data.error || "Request failed"));
      }
      delete data.status;
      testAccount = data;
      callback(null, testAccount);
    });
    return promise5;
  };
  exports.getTestMessageUrl = function(info) {
    if (!info || !info.response) {
      return false;
    }
    let infoProps = new Map;
    info.response.replace(/\[([^\]]+)\]$/, (m2, props) => {
      props.replace(/\b([A-Z0-9]+)=([^\s]+)/g, (m3, key, value15) => {
        infoProps.set(key, value15);
      });
    });
    if (infoProps.has("STATUS") && infoProps.has("MSGID")) {
      return (testAccount.web || ETHEREAL_WEB) + "/message/" + infoProps.get("MSGID");
    }
    return false;
  };
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS((exports, module) => {
  (function(t, e2) {
    typeof exports == "object" && typeof module != "undefined" ? module.exports = e2() : typeof define == "function" && define.amd ? define(e2) : (t = typeof globalThis != "undefined" ? globalThis : t || self).dayjs = e2();
  })(exports, function() {
    var t = 1000, e2 = 60000, n2 = 3600000, r2 = "millisecond", i = "second", s2 = "minute", u2 = "hour", a2 = "day", o2 = "week", c2 = "month", f = "quarter", h2 = "year", d2 = "date", l2 = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y2 = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e3 = ["th", "st", "nd", "rd"], n3 = t2 % 100;
      return "[" + t2 + (e3[(n3 - 20) % 10] || e3[n3] || e3[0]) + "]";
    } }, m2 = function(t2, e3, n3) {
      var r3 = String(t2);
      return !r3 || r3.length >= e3 ? t2 : "" + Array(e3 + 1 - r3.length).join(n3) + t2;
    }, v2 = { s: m2, z: function(t2) {
      var e3 = -t2.utcOffset(), n3 = Math.abs(e3), r3 = Math.floor(n3 / 60), i2 = n3 % 60;
      return (e3 <= 0 ? "+" : "-") + m2(r3, 2, "0") + ":" + m2(i2, 2, "0");
    }, m: function t(e3, n3) {
      if (e3.date() < n3.date())
        return -t(n3, e3);
      var r3 = 12 * (n3.year() - e3.year()) + (n3.month() - e3.month()), i2 = e3.clone().add(r3, c2), s3 = n3 - i2 < 0, u3 = e3.clone().add(r3 + (s3 ? -1 : 1), c2);
      return +(-(r3 + (n3 - i2) / (s3 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c2, y: h2, w: o2, d: a2, D: d2, h: u2, m: s2, s: i, ms: r2, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return t2 === undefined;
    } }, g = "en", D = {};
    D[g] = M;
    var p2 = "$isDayjsObject", S = function(t2) {
      return t2 instanceof _ || !(!t2 || !t2[p2]);
    }, w = function t(e3, n3, r3) {
      var i2;
      if (!e3)
        return g;
      if (typeof e3 == "string") {
        var s3 = e3.toLowerCase();
        D[s3] && (i2 = s3), n3 && (D[s3] = n3, i2 = s3);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t(u3[0]);
      } else {
        var a3 = e3.name;
        D[a3] = e3, i2 = a3;
      }
      return !r3 && i2 && (g = i2), i2 || !r3 && g;
    }, O = function(t2, e3) {
      if (S(t2))
        return t2.clone();
      var n3 = typeof e3 == "object" ? e3 : {};
      return n3.date = t2, n3.args = arguments, new _(n3);
    }, b3 = v2;
    b3.l = w, b3.i = S, b3.w = function(t2, e3) {
      return O(t2, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var _ = function() {
      function M2(t2) {
        this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p2] = true;
      }
      var m3 = M2.prototype;
      return m3.parse = function(t2) {
        this.$d = function(t3) {
          var { date: e3, utc: n3 } = t3;
          if (e3 === null)
            return new Date(NaN);
          if (b3.u(e3))
            return new Date;
          if (e3 instanceof Date)
            return new Date(e3);
          if (typeof e3 == "string" && !/Z$/i.test(e3)) {
            var r3 = e3.match($);
            if (r3) {
              var i2 = r3[2] - 1 || 0, s3 = (r3[7] || "0").substring(0, 3);
              return n3 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s3);
            }
          }
          return new Date(e3);
        }(t2), this.init();
      }, m3.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m3.$utils = function() {
        return b3;
      }, m3.isValid = function() {
        return !(this.$d.toString() === l2);
      }, m3.isSame = function(t2, e3) {
        var n3 = O(t2);
        return this.startOf(e3) <= n3 && n3 <= this.endOf(e3);
      }, m3.isAfter = function(t2, e3) {
        return O(t2) < this.startOf(e3);
      }, m3.isBefore = function(t2, e3) {
        return this.endOf(e3) < O(t2);
      }, m3.$g = function(t2, e3, n3) {
        return b3.u(t2) ? this[e3] : this.set(n3, t2);
      }, m3.unix = function() {
        return Math.floor(this.valueOf() / 1000);
      }, m3.valueOf = function() {
        return this.$d.getTime();
      }, m3.startOf = function(t2, e3) {
        var n3 = this, r3 = !!b3.u(e3) || e3, f2 = b3.p(t2), l3 = function(t3, e4) {
          var i2 = b3.w(n3.$u ? Date.UTC(n3.$y, e4, t3) : new Date(n3.$y, e4, t3), n3);
          return r3 ? i2 : i2.endOf(a2);
        }, $2 = function(t3, e4) {
          return b3.w(n3.toDate()[t3].apply(n3.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n3);
        }, y3 = this.$W, M3 = this.$M, m4 = this.$D, v3 = "set" + (this.$u ? "UTC" : "");
        switch (f2) {
          case h2:
            return r3 ? l3(1, 0) : l3(31, 11);
          case c2:
            return r3 ? l3(1, M3) : l3(0, M3 + 1);
          case o2:
            var g2 = this.$locale().weekStart || 0, D2 = (y3 < g2 ? y3 + 7 : y3) - g2;
            return l3(r3 ? m4 - D2 : m4 + (6 - D2), M3);
          case a2:
          case d2:
            return $2(v3 + "Hours", 0);
          case u2:
            return $2(v3 + "Minutes", 1);
          case s2:
            return $2(v3 + "Seconds", 2);
          case i:
            return $2(v3 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m3.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m3.$set = function(t2, e3) {
        var n3, o3 = b3.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l3 = (n3 = {}, n3[a2] = f2 + "Date", n3[d2] = f2 + "Date", n3[c2] = f2 + "Month", n3[h2] = f2 + "FullYear", n3[u2] = f2 + "Hours", n3[s2] = f2 + "Minutes", n3[i] = f2 + "Seconds", n3[r2] = f2 + "Milliseconds", n3)[o3], $2 = o3 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o3 === c2 || o3 === h2) {
          var y3 = this.clone().set(d2, 1);
          y3.$d[l3]($2), y3.init(), this.$d = y3.set(d2, Math.min(this.$D, y3.daysInMonth())).$d;
        } else
          l3 && this.$d[l3]($2);
        return this.init(), this;
      }, m3.set = function(t2, e3) {
        return this.clone().$set(t2, e3);
      }, m3.get = function(t2) {
        return this[b3.p(t2)]();
      }, m3.add = function(r3, f2) {
        var d3, l3 = this;
        r3 = Number(r3);
        var $2 = b3.p(f2), y3 = function(t2) {
          var e3 = O(l3);
          return b3.w(e3.date(e3.date() + Math.round(t2 * r3)), l3);
        };
        if ($2 === c2)
          return this.set(c2, this.$M + r3);
        if ($2 === h2)
          return this.set(h2, this.$y + r3);
        if ($2 === a2)
          return y3(1);
        if ($2 === o2)
          return y3(7);
        var M3 = (d3 = {}, d3[s2] = e2, d3[u2] = n2, d3[i] = t, d3)[$2] || 1, m4 = this.$d.getTime() + r3 * M3;
        return b3.w(m4, this);
      }, m3.subtract = function(t2, e3) {
        return this.add(-1 * t2, e3);
      }, m3.format = function(t2) {
        var e3 = this, n3 = this.$locale();
        if (!this.isValid())
          return n3.invalidDate || l2;
        var r3 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b3.z(this), s3 = this.$H, u3 = this.$m, a3 = this.$M, o3 = n3.weekdays, c3 = n3.months, f2 = n3.meridiem, h3 = function(t3, n4, i3, s4) {
          return t3 && (t3[n4] || t3(e3, r3)) || i3[n4].slice(0, s4);
        }, d3 = function(t3) {
          return b3.s(s3 % 12 || 12, t3, "0");
        }, $2 = f2 || function(t3, e4, n4) {
          var r4 = t3 < 12 ? "AM" : "PM";
          return n4 ? r4.toLowerCase() : r4;
        };
        return r3.replace(y2, function(t3, r4) {
          return r4 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return b3.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return b3.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n3.monthsShort, a3, c3, 3);
              case "MMMM":
                return h3(c3, a3);
              case "D":
                return e3.$D;
              case "DD":
                return b3.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n3.weekdaysMin, e3.$W, o3, 2);
              case "ddd":
                return h3(n3.weekdaysShort, e3.$W, o3, 3);
              case "dddd":
                return o3[e3.$W];
              case "H":
                return String(s3);
              case "HH":
                return b3.s(s3, 2, "0");
              case "h":
                return d3(1);
              case "hh":
                return d3(2);
              case "a":
                return $2(s3, u3, true);
              case "A":
                return $2(s3, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return b3.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return b3.s(e3.$s, 2, "0");
              case "SSS":
                return b3.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m3.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m3.diff = function(r3, d3, l3) {
        var $2, y3 = this, M3 = b3.p(d3), m4 = O(r3), v3 = (m4.utcOffset() - this.utcOffset()) * e2, g2 = this - m4, D2 = function() {
          return b3.m(y3, m4);
        };
        switch (M3) {
          case h2:
            $2 = D2() / 12;
            break;
          case c2:
            $2 = D2();
            break;
          case f:
            $2 = D2() / 3;
            break;
          case o2:
            $2 = (g2 - v3) / 604800000;
            break;
          case a2:
            $2 = (g2 - v3) / 86400000;
            break;
          case u2:
            $2 = g2 / n2;
            break;
          case s2:
            $2 = g2 / e2;
            break;
          case i:
            $2 = g2 / t;
            break;
          default:
            $2 = g2;
        }
        return l3 ? $2 : b3.a($2);
      }, m3.daysInMonth = function() {
        return this.endOf(c2).$D;
      }, m3.$locale = function() {
        return D[this.$L];
      }, m3.locale = function(t2, e3) {
        if (!t2)
          return this.$L;
        var n3 = this.clone(), r3 = w(t2, e3, true);
        return r3 && (n3.$L = r3), n3;
      }, m3.clone = function() {
        return b3.w(this.$d, this);
      }, m3.toDate = function() {
        return new Date(this.valueOf());
      }, m3.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m3.toISOString = function() {
        return this.$d.toISOString();
      }, m3.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), k = _.prototype;
    return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s2], ["$H", u2], ["$W", a2], ["$M", c2], ["$y", h2], ["$D", d2]].forEach(function(t2) {
      k[t2[1]] = function(e3) {
        return this.$g(e3, t2[0], t2[1]);
      };
    }), O.extend = function(t2, e3) {
      return t2.$i || (t2(e3, _, O), t2.$i = true), O;
    }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
      return O(1000 * t2);
    }, O.en = D[g], O.Ls = D, O.p = {}, O;
  });
});

// node_modules/lodash.clonedeep/index.js
var require_lodash5 = __commonJS((exports, module) => {
  var addMapEntry = function(map3, pair) {
    map3.set(pair[0], pair[1]);
    return map3;
  };
  var addSetEntry = function(set2, value15) {
    set2.add(value15);
    return set2;
  };
  var arrayEach = function(array6, iteratee) {
    var index = -1, length = array6 ? array6.length : 0;
    while (++index < length) {
      if (iteratee(array6[index], index, array6) === false) {
        break;
      }
    }
    return array6;
  };
  var arrayPush = function(array6, values2) {
    var index = -1, length = values2.length, offset = array6.length;
    while (++index < length) {
      array6[offset + index] = values2[index];
    }
    return array6;
  };
  var arrayReduce = function(array6, iteratee, accumulator, initAccum) {
    var index = -1, length = array6 ? array6.length : 0;
    if (initAccum && length) {
      accumulator = array6[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array6[index], index, array6);
    }
    return accumulator;
  };
  var baseTimes = function(n2, iteratee) {
    var index = -1, result2 = Array(n2);
    while (++index < n2) {
      result2[index] = iteratee(index);
    }
    return result2;
  };
  var getValue = function(object13, key) {
    return object13 == null ? undefined : object13[key];
  };
  var isHostObject = function(value15) {
    var result2 = false;
    if (value15 != null && typeof value15.toString != "function") {
      try {
        result2 = !!(value15 + "");
      } catch (e2) {
      }
    }
    return result2;
  };
  var mapToArray = function(map3) {
    var index = -1, result2 = Array(map3.size);
    map3.forEach(function(value15, key) {
      result2[++index] = [key, value15];
    });
    return result2;
  };
  var overArg = function(func, transform7) {
    return function(arg) {
      return func(transform7(arg));
    };
  };
  var setToArray = function(set2) {
    var index = -1, result2 = Array(set2.size);
    set2.forEach(function(value15) {
      result2[++index] = value15;
    });
    return result2;
  };
  var Hash3 = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var hashClear = function() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  };
  var hashDelete = function(key) {
    return this.has(key) && delete this.__data__[key];
  };
  var hashGet = function(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result2 = data[key];
      return result2 === HASH_UNDEFINED ? undefined : result2;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  };
  var hashHas = function(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  };
  var hashSet = function(key, value15) {
    var data = this.__data__;
    data[key] = nativeCreate && value15 === undefined ? HASH_UNDEFINED : value15;
    return this;
  };
  var ListCache = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var listCacheClear = function() {
    this.__data__ = [];
  };
  var listCacheDelete = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  };
  var listCacheGet = function(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
  };
  var listCacheHas = function(key) {
    return assocIndexOf(this.__data__, key) > -1;
  };
  var listCacheSet = function(key, value15) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value15]);
    } else {
      data[index][1] = value15;
    }
    return this;
  };
  var MapCache = function(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  };
  var mapCacheClear = function() {
    this.__data__ = {
      hash: new Hash3,
      map: new (Map2 || ListCache),
      string: new Hash3
    };
  };
  var mapCacheDelete = function(key) {
    return getMapData(this, key)["delete"](key);
  };
  var mapCacheGet = function(key) {
    return getMapData(this, key).get(key);
  };
  var mapCacheHas = function(key) {
    return getMapData(this, key).has(key);
  };
  var mapCacheSet = function(key, value15) {
    getMapData(this, key).set(key, value15);
    return this;
  };
  var Stack = function(entries) {
    this.__data__ = new ListCache(entries);
  };
  var stackClear = function() {
    this.__data__ = new ListCache;
  };
  var stackDelete = function(key) {
    return this.__data__["delete"](key);
  };
  var stackGet = function(key) {
    return this.__data__.get(key);
  };
  var stackHas = function(key) {
    return this.__data__.has(key);
  };
  var stackSet = function(key, value15) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value15]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value15);
    return this;
  };
  var arrayLikeKeys = function(value15, inherited) {
    var result2 = isArray(value15) || isArguments(value15) ? baseTimes(value15.length, String) : [];
    var length = result2.length, skipIndexes = !!length;
    for (var key in value15) {
      if ((inherited || hasOwnProperty.call(value15, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result2.push(key);
      }
    }
    return result2;
  };
  var assignValue = function(object13, key, value15) {
    var objValue = object13[key];
    if (!(hasOwnProperty.call(object13, key) && eq2(objValue, value15)) || value15 === undefined && !(key in object13)) {
      object13[key] = value15;
    }
  };
  var assocIndexOf = function(array6, key) {
    var length = array6.length;
    while (length--) {
      if (eq2(array6[length][0], key)) {
        return length;
      }
    }
    return -1;
  };
  var baseAssign = function(object13, source) {
    return object13 && copyObject(source, keys(source), object13);
  };
  var baseClone = function(value15, isDeep, isFull, customizer, key, object13, stack) {
    var result2;
    if (customizer) {
      result2 = object13 ? customizer(value15, key, object13, stack) : customizer(value15);
    }
    if (result2 !== undefined) {
      return result2;
    }
    if (!isObject2(value15)) {
      return value15;
    }
    var isArr = isArray(value15);
    if (isArr) {
      result2 = initCloneArray(value15);
      if (!isDeep) {
        return copyArray(value15, result2);
      }
    } else {
      var tag = getTag(value15), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer(value15)) {
        return cloneBuffer(value15, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object13) {
        if (isHostObject(value15)) {
          return object13 ? value15 : {};
        }
        result2 = initCloneObject(isFunc ? {} : value15);
        if (!isDeep) {
          return copySymbols(value15, baseAssign(result2, value15));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object13 ? value15 : {};
        }
        result2 = initCloneByTag(value15, tag, baseClone, isDeep);
      }
    }
    stack || (stack = new Stack);
    var stacked = stack.get(value15);
    if (stacked) {
      return stacked;
    }
    stack.set(value15, result2);
    if (!isArr) {
      var props = isFull ? getAllKeys(value15) : keys(value15);
    }
    arrayEach(props || value15, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value15[key2];
      }
      assignValue(result2, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value15, stack));
    });
    return result2;
  };
  var baseCreate = function(proto) {
    return isObject2(proto) ? objectCreate(proto) : {};
  };
  var baseGetAllKeys = function(object13, keysFunc, symbolsFunc) {
    var result2 = keysFunc(object13);
    return isArray(object13) ? result2 : arrayPush(result2, symbolsFunc(object13));
  };
  var baseGetTag = function(value15) {
    return objectToString.call(value15);
  };
  var baseIsNative = function(value15) {
    if (!isObject2(value15) || isMasked(value15)) {
      return false;
    }
    var pattern3 = isFunction(value15) || isHostObject(value15) ? reIsNative : reIsHostCtor;
    return pattern3.test(toSource(value15));
  };
  var baseKeys = function(object13) {
    if (!isPrototype(object13)) {
      return nativeKeys(object13);
    }
    var result2 = [];
    for (var key in Object(object13)) {
      if (hasOwnProperty.call(object13, key) && key != "constructor") {
        result2.push(key);
      }
    }
    return result2;
  };
  var cloneBuffer = function(buffer2, isDeep) {
    if (isDeep) {
      return buffer2.slice();
    }
    var result2 = new buffer2.constructor(buffer2.length);
    buffer2.copy(result2);
    return result2;
  };
  var cloneArrayBuffer = function(arrayBuffer) {
    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
    return result2;
  };
  var cloneDataView = function(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  };
  var cloneMap = function(map3, isDeep, cloneFunc) {
    var array6 = isDeep ? cloneFunc(mapToArray(map3), true) : mapToArray(map3);
    return arrayReduce(array6, addMapEntry, new map3.constructor);
  };
  var cloneRegExp = function(regexp4) {
    var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
    result2.lastIndex = regexp4.lastIndex;
    return result2;
  };
  var cloneSet = function(set2, isDeep, cloneFunc) {
    var array6 = isDeep ? cloneFunc(setToArray(set2), true) : setToArray(set2);
    return arrayReduce(array6, addSetEntry, new set2.constructor);
  };
  var cloneSymbol = function(symbol5) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol5)) : {};
  };
  var cloneTypedArray = function(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  };
  var copyArray = function(source, array6) {
    var index = -1, length = source.length;
    array6 || (array6 = Array(length));
    while (++index < length) {
      array6[index] = source[index];
    }
    return array6;
  };
  var copyObject = function(source, props, object13, customizer) {
    object13 || (object13 = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object13[key], source[key], key, object13, source) : undefined;
      assignValue(object13, key, newValue === undefined ? source[key] : newValue);
    }
    return object13;
  };
  var copySymbols = function(source, object13) {
    return copyObject(source, getSymbols(source), object13);
  };
  var getAllKeys = function(object13) {
    return baseGetAllKeys(object13, keys, getSymbols);
  };
  var getMapData = function(map3, key) {
    var data = map3.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  };
  var getNative = function(object13, key) {
    var value15 = getValue(object13, key);
    return baseIsNative(value15) ? value15 : undefined;
  };
  var initCloneArray = function(array6) {
    var length = array6.length, result2 = array6.constructor(length);
    if (length && typeof array6[0] == "string" && hasOwnProperty.call(array6, "index")) {
      result2.index = array6.index;
      result2.input = array6.input;
    }
    return result2;
  };
  var initCloneObject = function(object13) {
    return typeof object13.constructor == "function" && !isPrototype(object13) ? baseCreate(getPrototype(object13)) : {};
  };
  var initCloneByTag = function(object13, tag, cloneFunc, isDeep) {
    var Ctor = object13.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object13);
      case boolTag:
      case dateTag:
        return new Ctor(+object13);
      case dataViewTag:
        return cloneDataView(object13, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object13, isDeep);
      case mapTag:
        return cloneMap(object13, isDeep, cloneFunc);
      case numberTag:
      case stringTag:
        return new Ctor(object13);
      case regexpTag:
        return cloneRegExp(object13);
      case setTag:
        return cloneSet(object13, isDeep, cloneFunc);
      case symbolTag:
        return cloneSymbol(object13);
    }
  };
  var isIndex = function(value15, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value15 == "number" || reIsUint.test(value15)) && (value15 > -1 && value15 % 1 == 0 && value15 < length);
  };
  var isKeyable = function(value15) {
    var type75 = typeof value15;
    return type75 == "string" || type75 == "number" || type75 == "symbol" || type75 == "boolean" ? value15 !== "__proto__" : value15 === null;
  };
  var isMasked = function(func) {
    return !!maskSrcKey && maskSrcKey in func;
  };
  var isPrototype = function(value15) {
    var Ctor = value15 && value15.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value15 === proto;
  };
  var toSource = function(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e2) {
      }
      try {
        return func + "";
      } catch (e2) {
      }
    }
    return "";
  };
  var cloneDeep = function(value15) {
    return baseClone(value15, true, true);
  };
  var eq2 = function(value15, other) {
    return value15 === other || value15 !== value15 && other !== other;
  };
  var isArguments = function(value15) {
    return isArrayLikeObject(value15) && hasOwnProperty.call(value15, "callee") && (!propertyIsEnumerable.call(value15, "callee") || objectToString.call(value15) == argsTag);
  };
  var isArrayLike = function(value15) {
    return value15 != null && isLength(value15.length) && !isFunction(value15);
  };
  var isArrayLikeObject = function(value15) {
    return isObjectLike2(value15) && isArrayLike(value15);
  };
  var isFunction = function(value15) {
    var tag = isObject2(value15) ? objectToString.call(value15) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value15) {
    return typeof value15 == "number" && value15 > -1 && value15 % 1 == 0 && value15 <= MAX_SAFE_INTEGER;
  };
  var isObject2 = function(value15) {
    var type75 = typeof value15;
    return !!value15 && (type75 == "object" || type75 == "function");
  };
  var isObjectLike2 = function(value15) {
    return !!value15 && typeof value15 == "object";
  };
  var keys = function(object13) {
    return isArrayLike(object13) ? arrayLikeKeys(object13) : baseKeys(object13);
  };
  var stubArray = function() {
    return [];
  };
  var stubFalse = function() {
    return false;
  };
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reFlags = /\w*$/;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
  var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid2 ? "Symbol(src)_1." + uid2 : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : undefined;
  var Symbol3 = root.Symbol;
  var Uint8Array3 = root.Uint8Array;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined;
  var nativeKeys = overArg(Object.keys, Object);
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise3 = getNative(root, "Promise");
  var Set5 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise3);
  var setCtorString = toSource(Set5);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol3 ? Symbol3.prototype : undefined;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
  Hash3.prototype.clear = hashClear;
  Hash3.prototype["delete"] = hashDelete;
  Hash3.prototype.get = hashGet;
  Hash3.prototype.has = hashHas;
  Hash3.prototype.set = hashSet;
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2) != mapTag || Promise3 && getTag(Promise3.resolve()) != promiseTag || Set5 && getTag(new Set5) != setTag || WeakMap2 && getTag(new WeakMap2) != weakMapTag) {
    getTag = function(value15) {
      var result2 = objectToString.call(value15), Ctor = result2 == objectTag ? value15.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : undefined;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result2;
    };
  }
  var isArray = Array.isArray;
  var isBuffer = nativeIsBuffer || stubFalse;
  module.exports = cloneDeep;
});

// node_modules/@sinclair/typebox/build/import/value/guard/guard.mjs
function IsAsyncIterator(value) {
  return IsObject(value) && Symbol.asyncIterator in value;
}
function IsIterator(value) {
  return IsObject(value) && Symbol.iterator in value;
}
function IsStandardObject(value) {
  return IsObject(value) && !IsArray(value) && IsFunction(value.constructor) && value.constructor.name === "Object";
}
function IsPromise(value) {
  return value instanceof Promise;
}
function IsDate(value) {
  return value instanceof Date && Number.isFinite(value.getTime());
}
function IsTypedArray(value) {
  return ArrayBuffer.isView(value);
}
function IsUint8Array(value) {
  return value instanceof globalThis.Uint8Array;
}
function HasPropertyKey(value, key) {
  return key in value;
}
function IsObject(value) {
  return value !== null && typeof value === "object";
}
function IsArray(value) {
  return Array.isArray(value) && !ArrayBuffer.isView(value);
}
function IsUndefined(value) {
  return value === undefined;
}
function IsNull(value) {
  return value === null;
}
function IsBoolean(value) {
  return typeof value === "boolean";
}
function IsNumber(value) {
  return typeof value === "number";
}
function IsInteger(value) {
  return IsNumber(value) && Number.isInteger(value);
}
function IsBigInt(value) {
  return typeof value === "bigint";
}
function IsString(value) {
  return typeof value === "string";
}
function IsFunction(value) {
  return typeof value === "function";
}
function IsSymbol(value) {
  return typeof value === "symbol";
}
function IsValueType(value) {
  return IsBigInt(value) || IsBoolean(value) || IsNull(value) || IsNumber(value) || IsString(value) || IsSymbol(value) || IsUndefined(value);
}
// node_modules/@sinclair/typebox/build/import/system/policy.mjs
var TypeSystemPolicy;
(function(TypeSystemPolicy2) {
  TypeSystemPolicy2.ExactOptionalPropertyTypes = false;
  TypeSystemPolicy2.AllowArrayObject = false;
  TypeSystemPolicy2.AllowNaN = false;
  TypeSystemPolicy2.AllowNullVoid = false;
  function IsExactOptionalProperty(value, key) {
    return TypeSystemPolicy2.ExactOptionalPropertyTypes ? key in value : value[key] !== undefined;
  }
  TypeSystemPolicy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value) {
    const isObject = IsObject(value);
    return TypeSystemPolicy2.AllowArrayObject ? isObject : isObject && !IsArray(value);
  }
  TypeSystemPolicy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value) {
    return IsObjectLike(value) && !(value instanceof Date) && !(value instanceof Uint8Array);
  }
  TypeSystemPolicy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value) {
    const isNumber = IsNumber(value);
    return TypeSystemPolicy2.AllowNaN ? isNumber : isNumber && Number.isFinite(value);
  }
  TypeSystemPolicy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value) {
    const isUndefined = IsUndefined(value);
    return TypeSystemPolicy2.AllowNullVoid ? isUndefined || value === null : isUndefined;
  }
  TypeSystemPolicy2.IsVoidLike = IsVoidLike;
})(TypeSystemPolicy || (TypeSystemPolicy = {}));
// node_modules/@sinclair/typebox/build/import/type/registry/format.mjs
var exports_format = {};
__export(exports_format, {
  Set: () => {
    {
      return Set2;
    }
  },
  Has: () => {
    {
      return Has;
    }
  },
  Get: () => {
    {
      return Get;
    }
  },
  Entries: () => {
    {
      return Entries;
    }
  },
  Delete: () => {
    {
      return Delete;
    }
  },
  Clear: () => {
    {
      return Clear;
    }
  }
});
function Entries() {
  return new Map(map);
}
function Clear() {
  return map.clear();
}
function Delete(format) {
  return map.delete(format);
}
function Has(format) {
  return map.has(format);
}
function Set2(format, func) {
  map.set(format, func);
}
function Get(format) {
  return map.get(format);
}
var map = new Map;
// node_modules/@sinclair/typebox/build/import/type/registry/type.mjs
var exports_type = {};
__export(exports_type, {
  Set: () => {
    {
      return Set3;
    }
  },
  Has: () => {
    {
      return Has2;
    }
  },
  Get: () => {
    {
      return Get2;
    }
  },
  Entries: () => {
    {
      return Entries2;
    }
  },
  Delete: () => {
    {
      return Delete2;
    }
  },
  Clear: () => {
    {
      return Clear2;
    }
  }
});
function Entries2() {
  return new Map(map2);
}
function Clear2() {
  return map2.clear();
}
function Delete2(kind) {
  return map2.delete(kind);
}
function Has2(kind) {
  return map2.has(kind);
}
function Set3(kind, func) {
  map2.set(kind, func);
}
function Get2(kind) {
  return map2.get(kind);
}
var map2 = new Map;
// node_modules/@sinclair/typebox/build/import/type/symbols/symbols.mjs
var TransformKind = Symbol.for("TypeBox.Transform");
var ReadonlyKind = Symbol.for("TypeBox.Readonly");
var OptionalKind = Symbol.for("TypeBox.Optional");
var Hint = Symbol.for("TypeBox.Hint");
var Kind = Symbol.for("TypeBox.Kind");
// node_modules/@sinclair/typebox/build/import/type/unsafe/unsafe.mjs
function Unsafe(options = {}) {
  return {
    ...options,
    [Kind]: options[Kind] ?? "Unsafe"
  };
}
// node_modules/@sinclair/typebox/build/import/type/error/error.mjs
class TypeBoxError extends Error {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/system/system.mjs
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate type kind '${kind}' detected`);
  }
}

class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(kind) {
    super(`Duplicate string format '${kind}' detected`);
  }
}
var TypeSystem;
(function(TypeSystem2) {
  function Type(kind, check) {
    if (exports_type.Has(kind))
      throw new TypeSystemDuplicateTypeKind(kind);
    exports_type.Set(kind, check);
    return (options = {}) => Unsafe({ ...options, [Kind]: kind });
  }
  TypeSystem2.Type = Type;
  function Format(format, check) {
    if (exports_format.Has(format))
      throw new TypeSystemDuplicateFormat(format);
    exports_format.Set(format, check);
    return format;
  }
  TypeSystem2.Format = Format;
})(TypeSystem || (TypeSystem = {}));
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped-result.mjs
function MappedResult(properties) {
  return {
    [Kind]: "MappedResult",
    properties
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/value.mjs
var exports_value = {};
__export(exports_value, {
  IsUndefined: () => {
    {
      return IsUndefined2;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array2;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol2;
    }
  },
  IsString: () => {
    {
      return IsString2;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp;
    }
  },
  IsObject: () => {
    {
      return IsObject2;
    }
  },
  IsNumber: () => {
    {
      return IsNumber2;
    }
  },
  IsNull: () => {
    {
      return IsNull2;
    }
  },
  IsIterator: () => {
    {
      return IsIterator2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction2;
    }
  },
  IsDate: () => {
    {
      return IsDate2;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean2;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt2;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator2;
    }
  },
  IsArray: () => {
    {
      return IsArray2;
    }
  }
});
function IsAsyncIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.asyncIterator in value;
}
function IsArray2(value) {
  return Array.isArray(value);
}
function IsBigInt2(value) {
  return typeof value === "bigint";
}
function IsBoolean2(value) {
  return typeof value === "boolean";
}
function IsDate2(value) {
  return value instanceof globalThis.Date;
}
function IsFunction2(value) {
  return typeof value === "function";
}
function IsIterator2(value) {
  return IsObject2(value) && !IsArray2(value) && !IsUint8Array2(value) && Symbol.iterator in value;
}
function IsNull2(value) {
  return value === null;
}
function IsNumber2(value) {
  return typeof value === "number";
}
function IsObject2(value) {
  return typeof value === "object" && value !== null;
}
function IsRegExp(value) {
  return value instanceof globalThis.RegExp;
}
function IsString2(value) {
  return typeof value === "string";
}
function IsSymbol2(value) {
  return typeof value === "symbol";
}
function IsUint8Array2(value) {
  return value instanceof globalThis.Uint8Array;
}
function IsUndefined2(value) {
  return value === undefined;
}

// node_modules/@sinclair/typebox/build/import/type/clone/value.mjs
var ArrayType = function(value) {
  return value.map((value2) => Visit(value2));
};
var DateType = function(value) {
  return new Date(value.getTime());
};
var Uint8ArrayType = function(value) {
  return new Uint8Array(value);
};
var RegExpType = function(value) {
  return new RegExp(value.source, value.flags);
};
var ObjectType = function(value) {
  const clonedProperties = Object.getOwnPropertyNames(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  const clonedSymbols = Object.getOwnPropertySymbols(value).reduce((acc, key) => ({ ...acc, [key]: Visit(value[key]) }), {});
  return { ...clonedProperties, ...clonedSymbols };
};
var Visit = function(value) {
  return IsArray2(value) ? ArrayType(value) : IsDate2(value) ? DateType(value) : IsUint8Array2(value) ? Uint8ArrayType(value) : IsRegExp(value) ? RegExpType(value) : IsObject2(value) ? ObjectType(value) : value;
};
function Clone(value) {
  return Visit(value);
}

// node_modules/@sinclair/typebox/build/import/type/clone/type.mjs
function CloneRest(schemas) {
  return schemas.map((schema) => CloneType(schema));
}
function CloneType(schema, options = {}) {
  return { ...Clone(schema), ...options };
}

// node_modules/@sinclair/typebox/build/import/type/discard/discard.mjs
var DiscardKey = function(value2, key) {
  const { [key]: _, ...rest } = value2;
  return rest;
};
function Discard(value2, keys) {
  return keys.reduce((acc, key) => DiscardKey(acc, key), value2);
}
// node_modules/@sinclair/typebox/build/import/type/array/array.mjs
function Array2(schema, options = {}) {
  return {
    ...options,
    [Kind]: "Array",
    type: "array",
    items: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/async-iterator/async-iterator.mjs
function AsyncIterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "AsyncIterator",
    type: "AsyncIterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/constructor/constructor.mjs
function Constructor(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Constructor",
    type: "Constructor",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/function/function.mjs
function Function2(parameters, returns, options) {
  return {
    ...options,
    [Kind]: "Function",
    type: "Function",
    parameters: CloneRest(parameters),
    returns: CloneType(returns)
  };
}
// node_modules/@sinclair/typebox/build/import/type/never/never.mjs
function Never(options = {}) {
  return {
    ...options,
    [Kind]: "Never",
    not: {}
  };
}
// node_modules/@sinclair/typebox/build/import/type/guard/type.mjs
var exports_type2 = {};
__export(exports_type2, {
  TypeGuardUnknownTypeError: () => {
    {
      return TypeGuardUnknownTypeError;
    }
  },
  IsVoid: () => {
    {
      return IsVoid;
    }
  },
  IsUnsafe: () => {
    {
      return IsUnsafe;
    }
  },
  IsUnknown: () => {
    {
      return IsUnknown;
    }
  },
  IsUnionLiteral: () => {
    {
      return IsUnionLiteral;
    }
  },
  IsUnion: () => {
    {
      return IsUnion;
    }
  },
  IsUndefined: () => {
    {
      return IsUndefined3;
    }
  },
  IsUint8Array: () => {
    {
      return IsUint8Array3;
    }
  },
  IsTuple: () => {
    {
      return IsTuple;
    }
  },
  IsTransform: () => {
    {
      return IsTransform;
    }
  },
  IsThis: () => {
    {
      return IsThis;
    }
  },
  IsTemplateLiteral: () => {
    {
      return IsTemplateLiteral;
    }
  },
  IsSymbol: () => {
    {
      return IsSymbol3;
    }
  },
  IsString: () => {
    {
      return IsString3;
    }
  },
  IsSchema: () => {
    {
      return IsSchema;
    }
  },
  IsRegExp: () => {
    {
      return IsRegExp2;
    }
  },
  IsRef: () => {
    {
      return IsRef;
    }
  },
  IsRecursive: () => {
    {
      return IsRecursive;
    }
  },
  IsRecord: () => {
    {
      return IsRecord;
    }
  },
  IsReadonly: () => {
    {
      return IsReadonly;
    }
  },
  IsProperties: () => {
    {
      return IsProperties;
    }
  },
  IsPromise: () => {
    {
      return IsPromise2;
    }
  },
  IsOptional: () => {
    {
      return IsOptional;
    }
  },
  IsObject: () => {
    {
      return IsObject3;
    }
  },
  IsNumber: () => {
    {
      return IsNumber3;
    }
  },
  IsNull: () => {
    {
      return IsNull3;
    }
  },
  IsNot: () => {
    {
      return IsNot;
    }
  },
  IsNever: () => {
    {
      return IsNever;
    }
  },
  IsMappedResult: () => {
    {
      return IsMappedResult;
    }
  },
  IsMappedKey: () => {
    {
      return IsMappedKey;
    }
  },
  IsLiteralValue: () => {
    {
      return IsLiteralValue;
    }
  },
  IsLiteralString: () => {
    {
      return IsLiteralString;
    }
  },
  IsLiteralNumber: () => {
    {
      return IsLiteralNumber;
    }
  },
  IsLiteralBoolean: () => {
    {
      return IsLiteralBoolean;
    }
  },
  IsLiteral: () => {
    {
      return IsLiteral;
    }
  },
  IsKindOf: () => {
    {
      return IsKindOf;
    }
  },
  IsKind: () => {
    {
      return IsKind;
    }
  },
  IsIterator: () => {
    {
      return IsIterator3;
    }
  },
  IsIntersect: () => {
    {
      return IsIntersect;
    }
  },
  IsInteger: () => {
    {
      return IsInteger2;
    }
  },
  IsFunction: () => {
    {
      return IsFunction3;
    }
  },
  IsDate: () => {
    {
      return IsDate3;
    }
  },
  IsConstructor: () => {
    {
      return IsConstructor;
    }
  },
  IsBoolean: () => {
    {
      return IsBoolean3;
    }
  },
  IsBigInt: () => {
    {
      return IsBigInt3;
    }
  },
  IsAsyncIterator: () => {
    {
      return IsAsyncIterator3;
    }
  },
  IsArray: () => {
    {
      return IsArray3;
    }
  },
  IsAny: () => {
    {
      return IsAny;
    }
  }
});
var IsPattern = function(value2) {
  try {
    new RegExp(value2);
    return true;
  } catch {
    return false;
  }
};
var IsControlCharacterFree = function(value2) {
  if (!IsString2(value2))
    return false;
  for (let i = 0;i < value2.length; i++) {
    const code = value2.charCodeAt(i);
    if (code >= 7 && code <= 13 || code === 27 || code === 127) {
      return false;
    }
  }
  return true;
};
var IsAdditionalProperties = function(value2) {
  return IsOptionalBoolean(value2) || IsSchema(value2);
};
var IsOptionalBigInt = function(value2) {
  return IsUndefined2(value2) || IsBigInt2(value2);
};
var IsOptionalNumber = function(value2) {
  return IsUndefined2(value2) || IsNumber2(value2);
};
var IsOptionalBoolean = function(value2) {
  return IsUndefined2(value2) || IsBoolean2(value2);
};
var IsOptionalString = function(value2) {
  return IsUndefined2(value2) || IsString2(value2);
};
var IsOptionalPattern = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2) && IsPattern(value2);
};
var IsOptionalFormat = function(value2) {
  return IsUndefined2(value2) || IsString2(value2) && IsControlCharacterFree(value2);
};
var IsOptionalSchema = function(value2) {
  return IsUndefined2(value2) || IsSchema(value2);
};
function IsReadonly(value2) {
  return IsObject2(value2) && value2[ReadonlyKind] === "Readonly";
}
function IsOptional(value2) {
  return IsObject2(value2) && value2[OptionalKind] === "Optional";
}
function IsAny(value2) {
  return IsKindOf(value2, "Any") && IsOptionalString(value2.$id);
}
function IsArray3(value2) {
  return IsKindOf(value2, "Array") && value2.type === "array" && IsOptionalString(value2.$id) && IsSchema(value2.items) && IsOptionalNumber(value2.minItems) && IsOptionalNumber(value2.maxItems) && IsOptionalBoolean(value2.uniqueItems) && IsOptionalSchema(value2.contains) && IsOptionalNumber(value2.minContains) && IsOptionalNumber(value2.maxContains);
}
function IsAsyncIterator3(value2) {
  return IsKindOf(value2, "AsyncIterator") && value2.type === "AsyncIterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsBigInt3(value2) {
  return IsKindOf(value2, "BigInt") && value2.type === "bigint" && IsOptionalString(value2.$id) && IsOptionalBigInt(value2.exclusiveMaximum) && IsOptionalBigInt(value2.exclusiveMinimum) && IsOptionalBigInt(value2.maximum) && IsOptionalBigInt(value2.minimum) && IsOptionalBigInt(value2.multipleOf);
}
function IsBoolean3(value2) {
  return IsKindOf(value2, "Boolean") && value2.type === "boolean" && IsOptionalString(value2.$id);
}
function IsConstructor(value2) {
  return IsKindOf(value2, "Constructor") && value2.type === "Constructor" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsDate3(value2) {
  return IsKindOf(value2, "Date") && value2.type === "Date" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximumTimestamp) && IsOptionalNumber(value2.exclusiveMinimumTimestamp) && IsOptionalNumber(value2.maximumTimestamp) && IsOptionalNumber(value2.minimumTimestamp) && IsOptionalNumber(value2.multipleOfTimestamp);
}
function IsFunction3(value2) {
  return IsKindOf(value2, "Function") && value2.type === "Function" && IsOptionalString(value2.$id) && IsArray2(value2.parameters) && value2.parameters.every((schema) => IsSchema(schema)) && IsSchema(value2.returns);
}
function IsInteger2(value2) {
  return IsKindOf(value2, "Integer") && value2.type === "integer" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsProperties(value2) {
  return IsObject2(value2) && Object.entries(value2).every(([key, schema]) => IsControlCharacterFree(key) && IsSchema(schema));
}
function IsIntersect(value2) {
  return IsKindOf(value2, "Intersect") && (IsString2(value2.type) && value2.type !== "object" ? false : true) && IsArray2(value2.allOf) && value2.allOf.every((schema) => IsSchema(schema) && !IsTransform(schema)) && IsOptionalString(value2.type) && (IsOptionalBoolean(value2.unevaluatedProperties) || IsOptionalSchema(value2.unevaluatedProperties)) && IsOptionalString(value2.$id);
}
function IsIterator3(value2) {
  return IsKindOf(value2, "Iterator") && value2.type === "Iterator" && IsOptionalString(value2.$id) && IsSchema(value2.items);
}
function IsKindOf(value2, kind) {
  return IsObject2(value2) && Kind in value2 && value2[Kind] === kind;
}
function IsLiteralString(value2) {
  return IsLiteral(value2) && IsString2(value2.const);
}
function IsLiteralNumber(value2) {
  return IsLiteral(value2) && IsNumber2(value2.const);
}
function IsLiteralBoolean(value2) {
  return IsLiteral(value2) && IsBoolean2(value2.const);
}
function IsLiteral(value2) {
  return IsKindOf(value2, "Literal") && IsOptionalString(value2.$id) && IsLiteralValue(value2.const);
}
function IsLiteralValue(value2) {
  return IsBoolean2(value2) || IsNumber2(value2) || IsString2(value2);
}
function IsMappedKey(value2) {
  return IsKindOf(value2, "MappedKey") && IsArray2(value2.keys) && value2.keys.every((key) => IsNumber2(key) || IsString2(key));
}
function IsMappedResult(value2) {
  return IsKindOf(value2, "MappedResult") && IsProperties(value2.properties);
}
function IsNever(value2) {
  return IsKindOf(value2, "Never") && IsObject2(value2.not) && Object.getOwnPropertyNames(value2.not).length === 0;
}
function IsNot(value2) {
  return IsKindOf(value2, "Not") && IsSchema(value2.not);
}
function IsNull3(value2) {
  return IsKindOf(value2, "Null") && value2.type === "null" && IsOptionalString(value2.$id);
}
function IsNumber3(value2) {
  return IsKindOf(value2, "Number") && value2.type === "number" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.exclusiveMaximum) && IsOptionalNumber(value2.exclusiveMinimum) && IsOptionalNumber(value2.maximum) && IsOptionalNumber(value2.minimum) && IsOptionalNumber(value2.multipleOf);
}
function IsObject3(value2) {
  return IsKindOf(value2, "Object") && value2.type === "object" && IsOptionalString(value2.$id) && IsProperties(value2.properties) && IsAdditionalProperties(value2.additionalProperties) && IsOptionalNumber(value2.minProperties) && IsOptionalNumber(value2.maxProperties);
}
function IsPromise2(value2) {
  return IsKindOf(value2, "Promise") && value2.type === "Promise" && IsOptionalString(value2.$id) && IsSchema(value2.item);
}
function IsRecord(value2) {
  return IsKindOf(value2, "Record") && value2.type === "object" && IsOptionalString(value2.$id) && IsAdditionalProperties(value2.additionalProperties) && IsObject2(value2.patternProperties) && ((schema) => {
    const keys = Object.getOwnPropertyNames(schema.patternProperties);
    return keys.length === 1 && IsPattern(keys[0]) && IsObject2(schema.patternProperties) && IsSchema(schema.patternProperties[keys[0]]);
  })(value2);
}
function IsRecursive(value2) {
  return IsObject2(value2) && Hint in value2 && value2[Hint] === "Recursive";
}
function IsRef(value2) {
  return IsKindOf(value2, "Ref") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsRegExp2(value2) {
  return IsKindOf(value2, "RegExp") && IsOptionalString(value2.$id) && IsString2(value2.source) && IsString2(value2.flags) && IsOptionalNumber(value2.maxLength) && IsOptionalNumber(value2.minLength);
}
function IsString3(value2) {
  return IsKindOf(value2, "String") && value2.type === "string" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minLength) && IsOptionalNumber(value2.maxLength) && IsOptionalPattern(value2.pattern) && IsOptionalFormat(value2.format);
}
function IsSymbol3(value2) {
  return IsKindOf(value2, "Symbol") && value2.type === "symbol" && IsOptionalString(value2.$id);
}
function IsTemplateLiteral(value2) {
  return IsKindOf(value2, "TemplateLiteral") && value2.type === "string" && IsString2(value2.pattern) && value2.pattern[0] === "^" && value2.pattern[value2.pattern.length - 1] === "$";
}
function IsThis(value2) {
  return IsKindOf(value2, "This") && IsOptionalString(value2.$id) && IsString2(value2.$ref);
}
function IsTransform(value2) {
  return IsObject2(value2) && TransformKind in value2;
}
function IsTuple(value2) {
  return IsKindOf(value2, "Tuple") && value2.type === "array" && IsOptionalString(value2.$id) && IsNumber2(value2.minItems) && IsNumber2(value2.maxItems) && value2.minItems === value2.maxItems && (IsUndefined2(value2.items) && IsUndefined2(value2.additionalItems) && value2.minItems === 0 || IsArray2(value2.items) && value2.items.every((schema) => IsSchema(schema)));
}
function IsUndefined3(value2) {
  return IsKindOf(value2, "Undefined") && value2.type === "undefined" && IsOptionalString(value2.$id);
}
function IsUnionLiteral(value2) {
  return IsUnion(value2) && value2.anyOf.every((schema) => IsLiteralString(schema) || IsLiteralNumber(schema));
}
function IsUnion(value2) {
  return IsKindOf(value2, "Union") && IsOptionalString(value2.$id) && IsObject2(value2) && IsArray2(value2.anyOf) && value2.anyOf.every((schema) => IsSchema(schema));
}
function IsUint8Array3(value2) {
  return IsKindOf(value2, "Uint8Array") && value2.type === "Uint8Array" && IsOptionalString(value2.$id) && IsOptionalNumber(value2.minByteLength) && IsOptionalNumber(value2.maxByteLength);
}
function IsUnknown(value2) {
  return IsKindOf(value2, "Unknown") && IsOptionalString(value2.$id);
}
function IsUnsafe(value2) {
  return IsKindOf(value2, "Unsafe");
}
function IsVoid(value2) {
  return IsKindOf(value2, "Void") && value2.type === "void" && IsOptionalString(value2.$id);
}
function IsKind(value2) {
  return IsObject2(value2) && Kind in value2 && IsString2(value2[Kind]) && !KnownTypes.includes(value2[Kind]);
}
function IsSchema(value2) {
  return IsObject2(value2) && (IsAny(value2) || IsArray3(value2) || IsBoolean3(value2) || IsBigInt3(value2) || IsAsyncIterator3(value2) || IsConstructor(value2) || IsDate3(value2) || IsFunction3(value2) || IsInteger2(value2) || IsIntersect(value2) || IsIterator3(value2) || IsLiteral(value2) || IsMappedKey(value2) || IsMappedResult(value2) || IsNever(value2) || IsNot(value2) || IsNull3(value2) || IsNumber3(value2) || IsObject3(value2) || IsPromise2(value2) || IsRecord(value2) || IsRef(value2) || IsRegExp2(value2) || IsString3(value2) || IsSymbol3(value2) || IsTemplateLiteral(value2) || IsThis(value2) || IsTuple(value2) || IsUndefined3(value2) || IsUnion(value2) || IsUint8Array3(value2) || IsUnknown(value2) || IsUnsafe(value2) || IsVoid(value2) || IsKind(value2));
}

class TypeGuardUnknownTypeError extends TypeBoxError {
}
var KnownTypes = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void"
];

// node_modules/@sinclair/typebox/build/import/type/optional/optional.mjs
var RemoveOptional = function(schema) {
  return Discard(CloneType(schema), [OptionalKind]);
};
var AddOptional = function(schema) {
  return { ...CloneType(schema), [OptionalKind]: "Optional" };
};
var OptionalWithFlag = function(schema, F) {
  return F === false ? RemoveOptional(schema) : AddOptional(schema);
};
function Optional(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? OptionalFromMappedResult(schema, F) : OptionalWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/optional/optional-from-mapped-result.mjs
var FromProperties = function(P, F) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Optional(P[K2], F) };
  }, {});
};
var FromMappedResult = function(R, F) {
  return FromProperties(R.properties, F);
};
function OptionalFromMappedResult(R, F) {
  const P = FromMappedResult(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-create.mjs
function IntersectCreate(T, options) {
  const allObjects = T.every((schema) => IsObject3(schema));
  const clonedUnevaluatedProperties = IsSchema(options.unevaluatedProperties) ? { unevaluatedProperties: CloneType(options.unevaluatedProperties) } : {};
  return options.unevaluatedProperties === false || IsSchema(options.unevaluatedProperties) || allObjects ? { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", type: "object", allOf: CloneRest(T) } : { ...options, ...clonedUnevaluatedProperties, [Kind]: "Intersect", allOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/intersect/intersect-evaluated.mjs
var IsIntersectOptional = function(T) {
  return T.every((L) => IsOptional(L));
};
var RemoveOptionalFromType = function(T) {
  return Discard(T, [OptionalKind]);
};
var RemoveOptionalFromRest = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType(L) : L);
};
var ResolveIntersect = function(T, options) {
  return IsIntersectOptional(T) ? Optional(IntersectCreate(RemoveOptionalFromRest(T), options)) : IntersectCreate(RemoveOptionalFromRest(T), options);
};
function IntersectEvaluated(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return ResolveIntersect(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/intersect/intersect.mjs
function Intersect(T, options = {}) {
  if (T.length === 0)
    return Never(options);
  if (T.length === 1)
    return CloneType(T[0], options);
  if (T.some((schema) => IsTransform(schema)))
    throw new Error("Cannot intersect transform types");
  return IntersectCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union-create.mjs
function UnionCreate(T, options) {
  return { ...options, [Kind]: "Union", anyOf: CloneRest(T) };
}

// node_modules/@sinclair/typebox/build/import/type/union/union-evaluated.mjs
var IsUnionOptional = function(T) {
  return T.some((L) => IsOptional(L));
};
var RemoveOptionalFromRest2 = function(T) {
  return T.map((L) => IsOptional(L) ? RemoveOptionalFromType2(L) : L);
};
var RemoveOptionalFromType2 = function(T) {
  return Discard(T, [OptionalKind]);
};
var ResolveUnion = function(T, options) {
  return IsUnionOptional(T) ? Optional(UnionCreate(RemoveOptionalFromRest2(T), options)) : UnionCreate(RemoveOptionalFromRest2(T), options);
};
function UnionEvaluated(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : ResolveUnion(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/union/union.mjs
function Union(T, options = {}) {
  return T.length === 0 ? Never(options) : T.length === 1 ? CloneType(T[0], options) : UnionCreate(T, options);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/parse.mjs
var IsNonEscaped = function(pattern, index, char) {
  return pattern[index] === char && pattern.charCodeAt(index - 1) !== 92;
};
var IsOpenParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, "(");
};
var IsCloseParen = function(pattern, index) {
  return IsNonEscaped(pattern, index, ")");
};
var IsSeparator = function(pattern, index) {
  return IsNonEscaped(pattern, index, "|");
};
var IsGroup = function(pattern) {
  if (!(IsOpenParen(pattern, 0) && IsCloseParen(pattern, pattern.length - 1)))
    return false;
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (count === 0 && index !== pattern.length - 1)
      return false;
  }
  return true;
};
var InGroup = function(pattern) {
  return pattern.slice(1, pattern.length - 1);
};
var IsPrecedenceOr = function(pattern) {
  let count = 0;
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0)
      return true;
  }
  return false;
};
var IsPrecedenceAnd = function(pattern) {
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      return true;
  }
  return false;
};
var Or = function(pattern) {
  let [count, start] = [0, 0];
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index))
      count += 1;
    if (IsCloseParen(pattern, index))
      count -= 1;
    if (IsSeparator(pattern, index) && count === 0) {
      const range2 = pattern.slice(start, index);
      if (range2.length > 0)
        expressions.push(TemplateLiteralParse(range2));
      start = index + 1;
    }
  }
  const range = pattern.slice(start);
  if (range.length > 0)
    expressions.push(TemplateLiteralParse(range));
  if (expressions.length === 0)
    return { type: "const", const: "" };
  if (expressions.length === 1)
    return expressions[0];
  return { type: "or", expr: expressions };
};
var And = function(pattern) {
  function Group(value2, index) {
    if (!IsOpenParen(value2, index))
      throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let count = 0;
    for (let scan = index;scan < value2.length; scan++) {
      if (IsOpenParen(value2, scan))
        count += 1;
      if (IsCloseParen(value2, scan))
        count -= 1;
      if (count === 0)
        return [index, scan];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(pattern2, index) {
    for (let scan = index;scan < pattern2.length; scan++) {
      if (IsOpenParen(pattern2, scan))
        return [index, scan];
    }
    return [index, pattern2.length];
  }
  const expressions = [];
  for (let index = 0;index < pattern.length; index++) {
    if (IsOpenParen(pattern, index)) {
      const [start, end] = Group(pattern, index);
      const range = pattern.slice(start, end + 1);
      expressions.push(TemplateLiteralParse(range));
      index = end;
    } else {
      const [start, end] = Range(pattern, index);
      const range = pattern.slice(start, end);
      if (range.length > 0)
        expressions.push(TemplateLiteralParse(range));
      index = end - 1;
    }
  }
  return expressions.length === 0 ? { type: "const", const: "" } : expressions.length === 1 ? expressions[0] : { type: "and", expr: expressions };
};
function TemplateLiteralParse(pattern) {
  return IsGroup(pattern) ? TemplateLiteralParse(InGroup(pattern)) : IsPrecedenceOr(pattern) ? Or(pattern) : IsPrecedenceAnd(pattern) ? And(pattern) : { type: "const", const: pattern };
}
function TemplateLiteralParseExact(pattern) {
  return TemplateLiteralParse(pattern.slice(1, pattern.length - 1));
}

class TemplateLiteralParserError extends TypeBoxError {
}

// node_modules/@sinclair/typebox/build/import/type/template-literal/finite.mjs
var IsNumberExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "0" && expression.expr[1].type === "const" && expression.expr[1].const === "[1-9][0-9]*";
};
var IsBooleanExpression = function(expression) {
  return expression.type === "or" && expression.expr.length === 2 && expression.expr[0].type === "const" && expression.expr[0].const === "true" && expression.expr[1].type === "const" && expression.expr[1].const === "false";
};
var IsStringExpression = function(expression) {
  return expression.type === "const" && expression.const === ".*";
};
function IsTemplateLiteralExpressionFinite(expression) {
  return IsNumberExpression(expression) || IsStringExpression(expression) ? false : IsBooleanExpression(expression) ? true : expression.type === "and" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "or" ? expression.expr.every((expr) => IsTemplateLiteralExpressionFinite(expr)) : expression.type === "const" ? true : (() => {
    throw new TemplateLiteralFiniteError(`Unknown expression type`);
  })();
}
function IsTemplateLiteralFinite(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression);
}

class TemplateLiteralFiniteError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/generate.mjs
function* GenerateReduce(buffer) {
  if (buffer.length === 1)
    return yield* buffer[0];
  for (const left of buffer[0]) {
    for (const right of GenerateReduce(buffer.slice(1))) {
      yield `${left}${right}`;
    }
  }
}
function* GenerateAnd(expression) {
  return yield* GenerateReduce(expression.expr.map((expr) => [...TemplateLiteralExpressionGenerate(expr)]));
}
function* GenerateOr(expression) {
  for (const expr of expression.expr)
    yield* TemplateLiteralExpressionGenerate(expr);
}
function* GenerateConst(expression) {
  return yield expression.const;
}
function* TemplateLiteralExpressionGenerate(expression) {
  return expression.type === "and" ? yield* GenerateAnd(expression) : expression.type === "or" ? yield* GenerateOr(expression) : expression.type === "const" ? yield* GenerateConst(expression) : (() => {
    throw new TemplateLiteralGenerateError("Unknown expression");
  })();
}
function TemplateLiteralGenerate(schema) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  return IsTemplateLiteralExpressionFinite(expression) ? [...TemplateLiteralExpressionGenerate(expression)] : [];
}

class TemplateLiteralGenerateError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/literal/literal.mjs
function Literal(value2, options = {}) {
  return {
    ...options,
    [Kind]: "Literal",
    const: value2,
    type: typeof value2
  };
}
// node_modules/@sinclair/typebox/build/import/type/boolean/boolean.mjs
function Boolean2(options = {}) {
  return {
    ...options,
    [Kind]: "Boolean",
    type: "boolean"
  };
}
// node_modules/@sinclair/typebox/build/import/type/bigint/bigint.mjs
function BigInt2(options = {}) {
  return {
    ...options,
    [Kind]: "BigInt",
    type: "bigint"
  };
}
// node_modules/@sinclair/typebox/build/import/type/number/number.mjs
function Number2(options = {}) {
  return {
    ...options,
    [Kind]: "Number",
    type: "number"
  };
}
// node_modules/@sinclair/typebox/build/import/type/string/string.mjs
function String2(options = {}) {
  return { ...options, [Kind]: "String", type: "string" };
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/syntax.mjs
function* FromUnion(syntax) {
  const trim = syntax.trim().replace(/"|'/g, "");
  return trim === "boolean" ? yield Boolean2() : trim === "number" ? yield Number2() : trim === "bigint" ? yield BigInt2() : trim === "string" ? yield String2() : yield (() => {
    const literals = trim.split("|").map((literal3) => Literal(literal3.trim()));
    return literals.length === 0 ? Never() : literals.length === 1 ? literals[0] : UnionEvaluated(literals);
  })();
}
function* FromTerminal(syntax) {
  if (syntax[1] !== "{") {
    const L = Literal("$");
    const R = FromSyntax(syntax.slice(1));
    return yield* [L, ...R];
  }
  for (let i = 2;i < syntax.length; i++) {
    if (syntax[i] === "}") {
      const L = FromUnion(syntax.slice(2, i));
      const R = FromSyntax(syntax.slice(i + 1));
      return yield* [...L, ...R];
    }
  }
  yield Literal(syntax);
}
function* FromSyntax(syntax) {
  for (let i = 0;i < syntax.length; i++) {
    if (syntax[i] === "$") {
      const L = Literal(syntax.slice(0, i));
      const R = FromTerminal(syntax.slice(i));
      return yield* [L, ...R];
    }
  }
  yield Literal(syntax);
}
function TemplateLiteralSyntax(syntax) {
  return [...FromSyntax(syntax)];
}
// node_modules/@sinclair/typebox/build/import/type/patterns/patterns.mjs
var PatternBoolean = "(true|false)";
var PatternNumber = "(0|[1-9][0-9]*)";
var PatternString = "(.*)";
var PatternBooleanExact = `^${PatternBoolean}\$`;
var PatternNumberExact = `^${PatternNumber}\$`;
var PatternStringExact = `^${PatternString}\$`;
// node_modules/@sinclair/typebox/build/import/type/template-literal/pattern.mjs
var Escape = function(value2) {
  return value2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var Visit2 = function(schema, acc) {
  return IsTemplateLiteral(schema) ? schema.pattern.slice(1, schema.pattern.length - 1) : IsUnion(schema) ? `(${schema.anyOf.map((schema2) => Visit2(schema2, acc)).join("|")})` : IsNumber3(schema) ? `${acc}${PatternNumber}` : IsInteger2(schema) ? `${acc}${PatternNumber}` : IsBigInt3(schema) ? `${acc}${PatternNumber}` : IsString3(schema) ? `${acc}${PatternString}` : IsLiteral(schema) ? `${acc}${Escape(schema.const.toString())}` : IsBoolean3(schema) ? `${acc}${PatternBoolean}` : (() => {
    throw new TemplateLiteralPatternError(`Unexpected Kind '${schema[Kind]}'`);
  })();
};
function TemplateLiteralPattern(kinds) {
  return `^${kinds.map((schema) => Visit2(schema, "")).join("")}$`;
}

class TemplateLiteralPatternError extends TypeBoxError {
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/union.mjs
function TemplateLiteralToUnion(schema) {
  const R = TemplateLiteralGenerate(schema);
  const L = R.map((S) => Literal(S));
  return UnionEvaluated(L);
}
// node_modules/@sinclair/typebox/build/import/type/template-literal/template-literal.mjs
function TemplateLiteral(unresolved, options = {}) {
  const pattern2 = IsString2(unresolved) ? TemplateLiteralPattern(TemplateLiteralSyntax(unresolved)) : TemplateLiteralPattern(unresolved);
  return { ...options, [Kind]: "TemplateLiteral", type: "string", pattern: pattern2 };
}
// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-property-keys.mjs
var FromTemplateLiteral = function(T) {
  const R = TemplateLiteralGenerate(T);
  return R.map((S) => S.toString());
};
var FromUnion2 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, ...IndexPropertyKeys(L)];
  }, []);
};
var FromLiteral = function(T) {
  return [T.toString()];
};
function IndexPropertyKeys(T) {
  return [...new Set(IsTemplateLiteral(T) ? FromTemplateLiteral(T) : IsUnion(T) ? FromUnion2(T.anyOf) : IsLiteral(T) ? FromLiteral(T.const) : IsNumber3(T) ? ["[number]"] : IsInteger2(T) ? ["[number]"] : [])];
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-result.mjs
var FromProperties2 = function(T, P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Index(T, IndexPropertyKeys(P[K2]), options) };
  }, {});
};
var FromMappedResult2 = function(T, R, options) {
  return FromProperties2(T, R.properties, options);
};
function IndexFromMappedResult(T, R, options) {
  const P = FromMappedResult2(T, R, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed.mjs
var FromRest = function(T, K) {
  return T.map((L) => IndexFromPropertyKey(L, K));
};
var FromIntersectRest = function(T) {
  return T.filter((L) => !IsNever(L));
};
var FromIntersect = function(T, K) {
  return IntersectEvaluated(FromIntersectRest(FromRest(T, K)));
};
var FromUnionRest = function(T) {
  return T;
};
var FromUnion3 = function(T, K) {
  return UnionEvaluated(FromUnionRest(FromRest(T, K)));
};
var FromTuple = function(T, K) {
  return K in T ? T[K] : K === "[number]" ? UnionEvaluated(T) : Never();
};
var FromArray = function(T, K) {
  return K === "[number]" ? T : Never();
};
var FromProperty = function(T, K) {
  return K in T ? T[K] : Never();
};
function IndexFromPropertyKey(T, K) {
  return IsIntersect(T) ? FromIntersect(T.allOf, K) : IsUnion(T) ? FromUnion3(T.anyOf, K) : IsTuple(T) ? FromTuple(T.items ?? [], K) : IsArray3(T) ? FromArray(T.items, K) : IsObject3(T) ? FromProperty(T.properties, K) : Never();
}
function IndexFromPropertyKeys(T, K) {
  return K.map((L) => IndexFromPropertyKey(T, L));
}
var FromSchema = function(T, K) {
  return UnionEvaluated(IndexFromPropertyKeys(T, K));
};
function Index(T, K, options = {}) {
  return IsMappedResult(K) ? CloneType(IndexFromMappedResult(T, K, options)) : IsMappedKey(K) ? CloneType(IndexFromMappedKey(T, K, options)) : IsSchema(K) ? CloneType(FromSchema(T, IndexPropertyKeys(K)), options) : CloneType(FromSchema(T, K), options);
}

// node_modules/@sinclair/typebox/build/import/type/indexed/indexed-from-mapped-key.mjs
var MappedIndexPropertyKey = function(T, K, options) {
  return { [K]: Index(T, [K], options) };
};
var MappedIndexPropertyKeys = function(T, K, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIndexPropertyKey(T, L, options) };
  }, {});
};
var MappedIndexProperties = function(T, K, options) {
  return MappedIndexPropertyKeys(T, K.keys, options);
};
function IndexFromMappedKey(T, K, options) {
  const P = MappedIndexProperties(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/iterator/iterator.mjs
function Iterator(items, options = {}) {
  return {
    ...options,
    [Kind]: "Iterator",
    type: "Iterator",
    items: CloneType(items)
  };
}
// node_modules/@sinclair/typebox/build/import/type/object/object.mjs
var _Object = function(properties, options = {}) {
  const propertyKeys = globalThis.Object.getOwnPropertyNames(properties);
  const optionalKeys = propertyKeys.filter((key) => IsOptional(properties[key]));
  const requiredKeys = propertyKeys.filter((name) => !optionalKeys.includes(name));
  const clonedAdditionalProperties = IsSchema(options.additionalProperties) ? { additionalProperties: CloneType(options.additionalProperties) } : {};
  const clonedProperties = propertyKeys.reduce((acc, key) => ({ ...acc, [key]: CloneType(properties[key]) }), {});
  return requiredKeys.length > 0 ? { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties, required: requiredKeys } : { ...options, ...clonedAdditionalProperties, [Kind]: "Object", type: "object", properties: clonedProperties };
};
var Object2 = _Object;
// node_modules/@sinclair/typebox/build/import/type/promise/promise.mjs
function Promise2(item, options = {}) {
  return {
    ...options,
    [Kind]: "Promise",
    type: "Promise",
    item: CloneType(item)
  };
}
// node_modules/@sinclair/typebox/build/import/type/readonly/readonly.mjs
var RemoveReadonly = function(schema) {
  return Discard(CloneType(schema), [ReadonlyKind]);
};
var AddReadonly = function(schema) {
  return { ...CloneType(schema), [ReadonlyKind]: "Readonly" };
};
var ReadonlyWithFlag = function(schema, F) {
  return F === false ? RemoveReadonly(schema) : AddReadonly(schema);
};
function Readonly(schema, enable) {
  const F = enable ?? true;
  return IsMappedResult(schema) ? ReadonlyFromMappedResult(schema, F) : ReadonlyWithFlag(schema, F);
}

// node_modules/@sinclair/typebox/build/import/type/readonly/readonly-from-mapped-result.mjs
var FromProperties3 = function(K, F) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Readonly(K[K2], F) };
  }, {});
};
var FromMappedResult3 = function(R, F) {
  return FromProperties3(R.properties, F);
};
function ReadonlyFromMappedResult(R, F) {
  const P = FromMappedResult3(R, F);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/tuple/tuple.mjs
function Tuple(items, options = {}) {
  const [additionalItems, minItems, maxItems] = [false, items.length, items.length];
  return items.length > 0 ? { ...options, [Kind]: "Tuple", type: "array", items: CloneRest(items), additionalItems, minItems, maxItems } : { ...options, [Kind]: "Tuple", type: "array", minItems, maxItems };
}
// node_modules/@sinclair/typebox/build/import/type/sets/set.mjs
function SetIncludes(T, S) {
  return T.includes(S);
}
function SetDistinct(T) {
  return [...new Set(T)];
}
function SetIntersect(T, S) {
  return T.filter((L) => S.includes(L));
}
var SetIntersectManyResolve = function(T, Init) {
  return T.reduce((Acc, L) => {
    return SetIntersect(Acc, L);
  }, Init);
};
function SetIntersectMany(T) {
  return T.length === 1 ? T[0] : T.length > 1 ? SetIntersectManyResolve(T.slice(1), T[0]) : [];
}
function SetUnionMany(T) {
  return T.reduce((Acc, L) => [...Acc, ...L], []);
}
// node_modules/@sinclair/typebox/build/import/type/mapped/mapped.mjs
var FromMappedResult4 = function(K, P) {
  return K in P ? FromSchemaType(K, P[K]) : MappedResult(P);
};
var MappedKeyToKnownMappedResultProperties = function(K) {
  return { [K]: Literal(K) };
};
var MappedKeyToUnknownMappedResultProperties = function(P) {
  return P.reduce((Acc, L) => {
    return { ...Acc, [L]: Literal(L) };
  }, {});
};
var MappedKeyToMappedResultProperties = function(K, P) {
  return SetIncludes(P, K) ? MappedKeyToKnownMappedResultProperties(K) : MappedKeyToUnknownMappedResultProperties(P);
};
var FromMappedKey = function(K, P) {
  const R = MappedKeyToMappedResultProperties(K, P);
  return FromMappedResult4(K, R);
};
var FromRest2 = function(K, T) {
  return T.map((L) => FromSchemaType(K, L));
};
var FromProperties4 = function(K, T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K2) => {
    return { ...Acc, [K2]: FromSchemaType(K, T[K2]) };
  }, {});
};
var FromSchemaType = function(K, T) {
  return IsOptional(T) ? Optional(FromSchemaType(K, Discard(T, [OptionalKind]))) : IsReadonly(T) ? Readonly(FromSchemaType(K, Discard(T, [ReadonlyKind]))) : IsMappedResult(T) ? FromMappedResult4(K, T.properties) : IsMappedKey(T) ? FromMappedKey(K, T.keys) : IsConstructor(T) ? Constructor(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsFunction3(T) ? Function2(FromRest2(K, T.parameters), FromSchemaType(K, T.returns)) : IsAsyncIterator3(T) ? AsyncIterator(FromSchemaType(K, T.items)) : IsIterator3(T) ? Iterator(FromSchemaType(K, T.items)) : IsIntersect(T) ? Intersect(FromRest2(K, T.allOf)) : IsUnion(T) ? Union(FromRest2(K, T.anyOf)) : IsTuple(T) ? Tuple(FromRest2(K, T.items ?? [])) : IsObject3(T) ? Object2(FromProperties4(K, T.properties)) : IsArray3(T) ? Array2(FromSchemaType(K, T.items)) : IsPromise2(T) ? Promise2(FromSchemaType(K, T.item)) : T;
};
function MappedFunctionReturnType(K, T, Acc = {}) {
  return K.reduce((Acc2, L) => {
    return { ...Acc2, [L]: FromSchemaType(L, T) };
  }, {});
}
function Mapped(key, map3, options = {}) {
  const K = IsSchema(key) ? IndexPropertyKeys(key) : key;
  const RT = map3({ [Kind]: "MappedKey", keys: K });
  const R = MappedFunctionReturnType(K, RT);
  return CloneType(Object2(R), options);
}
// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-property-keys.mjs
var FromRest3 = function(T) {
  return T.reduce((Acc, L) => {
    return [...Acc, KeyOfPropertyKeys(L)];
  }, []);
};
var FromIntersect2 = function(T) {
  const C = FromRest3(T);
  const R = SetUnionMany(C);
  return R;
};
var FromUnion4 = function(T) {
  const C = FromRest3(T);
  const R = SetIntersectMany(C);
  return R;
};
var FromTuple2 = function(T) {
  return T.map((_, I) => I.toString());
};
var FromArray2 = function(_) {
  return ["[number]"];
};
var FromProperties5 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T);
};
var FromPatternProperties = function(patternProperties) {
  if (!includePatternProperties)
    return [];
  const patternPropertyKeys = globalThis.Object.getOwnPropertyNames(patternProperties);
  return patternPropertyKeys.map((key) => {
    return key[0] === "^" && key[key.length - 1] === "$" ? key.slice(1, key.length - 1) : key;
  });
};
function KeyOfPropertyKeys(T) {
  return IsIntersect(T) ? FromIntersect2(T.allOf) : IsUnion(T) ? FromUnion4(T.anyOf) : IsTuple(T) ? FromTuple2(T.items ?? []) : IsArray3(T) ? FromArray2(T.items) : IsObject3(T) ? FromProperties5(T.properties) : IsRecord(T) ? FromPatternProperties(T.patternProperties) : [];
}
function KeyOfPattern(schema) {
  includePatternProperties = true;
  const keys = KeyOfPropertyKeys(schema);
  includePatternProperties = false;
  const pattern3 = keys.map((key) => `(${key})`);
  return `^(${pattern3.join("|")})\$`;
}
var includePatternProperties = false;

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof.mjs
function KeyOfPropertyKeysToRest(T) {
  return T.map((L) => L === "[number]" ? Number2() : Literal(L));
}
function KeyOf(T, options = {}) {
  if (IsMappedResult(T)) {
    return KeyOfFromMappedResult(T, options);
  } else {
    const K = KeyOfPropertyKeys(T);
    const S = KeyOfPropertyKeysToRest(K);
    const U = UnionEvaluated(S);
    return CloneType(U, options);
  }
}

// node_modules/@sinclair/typebox/build/import/type/keyof/keyof-from-mapped-result.mjs
var FromProperties6 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: KeyOf(K[K2], options) };
  }, {});
};
var FromMappedResult5 = function(R, options) {
  return FromProperties6(R.properties, options);
};
function KeyOfFromMappedResult(R, options) {
  const P = FromMappedResult5(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-undefined.mjs
var Intersect2 = function(schema) {
  return schema.allOf.every((schema2) => ExtendsUndefinedCheck(schema2));
};
var Union2 = function(schema) {
  return schema.anyOf.some((schema2) => ExtendsUndefinedCheck(schema2));
};
var Not = function(schema) {
  return !ExtendsUndefinedCheck(schema.not);
};
function ExtendsUndefinedCheck(schema) {
  return schema[Kind] === "Intersect" ? Intersect2(schema) : schema[Kind] === "Union" ? Union2(schema) : schema[Kind] === "Not" ? Not(schema) : schema[Kind] === "Undefined" ? true : false;
}

// node_modules/@sinclair/typebox/build/import/errors/function.mjs
function DefaultErrorFunction(error8) {
  switch (error8.errorType) {
    case ValueErrorType.ArrayContains:
      return "Expected array to contain at least one matching value";
    case ValueErrorType.ArrayMaxContains:
      return `Expected array to contain no more than ${error8.schema.maxContains} matching values`;
    case ValueErrorType.ArrayMinContains:
      return `Expected array to contain at least ${error8.schema.minContains} matching values`;
    case ValueErrorType.ArrayMaxItems:
      return `Expected array length to be less or equal to ${error8.schema.maxItems}`;
    case ValueErrorType.ArrayMinItems:
      return `Expected array length to be greater or equal to ${error8.schema.minItems}`;
    case ValueErrorType.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case ValueErrorType.Array:
      return "Expected array";
    case ValueErrorType.AsyncIterator:
      return "Expected AsyncIterator";
    case ValueErrorType.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.BigIntMaximum:
      return `Expected bigint to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.BigInt:
      return "Expected bigint";
    case ValueErrorType.Boolean:
      return "Expected boolean";
    case ValueErrorType.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${error8.schema.exclusiveMinimumTimestamp}`;
    case ValueErrorType.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${error8.schema.exclusiveMaximumTimestamp}`;
    case ValueErrorType.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${error8.schema.minimumTimestamp}`;
    case ValueErrorType.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${error8.schema.maximumTimestamp}`;
    case ValueErrorType.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${error8.schema.multipleOfTimestamp}`;
    case ValueErrorType.Date:
      return "Expected Date";
    case ValueErrorType.Function:
      return "Expected function";
    case ValueErrorType.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.IntegerMaximum:
      return `Expected integer to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.IntegerMinimum:
      return `Expected integer to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Integer:
      return "Expected integer";
    case ValueErrorType.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case ValueErrorType.Intersect:
      return "Expected all values to match";
    case ValueErrorType.Iterator:
      return "Expected Iterator";
    case ValueErrorType.Literal:
      return `Expected ${typeof error8.schema.const === "string" ? `'${error8.schema.const}'` : error8.schema.const}`;
    case ValueErrorType.Never:
      return "Never";
    case ValueErrorType.Not:
      return "Value should not match";
    case ValueErrorType.Null:
      return "Expected null";
    case ValueErrorType.NumberExclusiveMaximum:
      return `Expected number to be less than ${error8.schema.exclusiveMaximum}`;
    case ValueErrorType.NumberExclusiveMinimum:
      return `Expected number to be greater than ${error8.schema.exclusiveMinimum}`;
    case ValueErrorType.NumberMaximum:
      return `Expected number to be less or equal to ${error8.schema.maximum}`;
    case ValueErrorType.NumberMinimum:
      return `Expected number to be greater or equal to ${error8.schema.minimum}`;
    case ValueErrorType.NumberMultipleOf:
      return `Expected number to be a multiple of ${error8.schema.multipleOf}`;
    case ValueErrorType.Number:
      return "Expected number";
    case ValueErrorType.Object:
      return "Expected object";
    case ValueErrorType.ObjectAdditionalProperties:
      return "Unexpected property";
    case ValueErrorType.ObjectMaxProperties:
      return `Expected object to have no more than ${error8.schema.maxProperties} properties`;
    case ValueErrorType.ObjectMinProperties:
      return `Expected object to have at least ${error8.schema.minProperties} properties`;
    case ValueErrorType.ObjectRequiredProperty:
      return "Required property";
    case ValueErrorType.Promise:
      return "Expected Promise";
    case ValueErrorType.RegExp:
      return "Expected string to match regular expression";
    case ValueErrorType.StringFormatUnknown:
      return `Unknown format '${error8.schema.format}'`;
    case ValueErrorType.StringFormat:
      return `Expected string to match '${error8.schema.format}' format`;
    case ValueErrorType.StringMaxLength:
      return `Expected string length less or equal to ${error8.schema.maxLength}`;
    case ValueErrorType.StringMinLength:
      return `Expected string length greater or equal to ${error8.schema.minLength}`;
    case ValueErrorType.StringPattern:
      return `Expected string to match '${error8.schema.pattern}'`;
    case ValueErrorType.String:
      return "Expected string";
    case ValueErrorType.Symbol:
      return "Expected symbol";
    case ValueErrorType.TupleLength:
      return `Expected tuple to have ${error8.schema.maxItems || 0} elements`;
    case ValueErrorType.Tuple:
      return "Expected tuple";
    case ValueErrorType.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${error8.schema.maxByteLength}`;
    case ValueErrorType.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${error8.schema.minByteLength}`;
    case ValueErrorType.Uint8Array:
      return "Expected Uint8Array";
    case ValueErrorType.Undefined:
      return "Expected undefined";
    case ValueErrorType.Union:
      return "Expected union value";
    case ValueErrorType.Void:
      return "Expected void";
    case ValueErrorType.Kind:
      return `Expected kind '${error8.schema[Kind]}'`;
    default:
      return "Unknown error type";
  }
}
function GetErrorFunction() {
  return errorFunction;
}
var errorFunction = DefaultErrorFunction;

// node_modules/@sinclair/typebox/build/import/value/deref/deref.mjs
function Deref(schema, references) {
  const index = references.findIndex((target) => target.$id === schema.$ref);
  if (index === -1)
    throw new TypeDereferenceError(schema);
  return references[index];
}

class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unable to dereference schema with \$id '${schema.$id}'`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/hash/hash.mjs
function* NumberToBytes(value3) {
  const byteCount = value3 === 0 ? 1 : Math.ceil(Math.floor(Math.log2(value3) + 1) / 8);
  for (let i = 0;i < byteCount; i++) {
    yield value3 >> 8 * (byteCount - 1 - i) & 255;
  }
}
var ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Array);
  for (const item of value3) {
    Visit3(item);
  }
};
var BooleanType = function(value3) {
  FNV1A64(ByteMarker.Boolean);
  FNV1A64(value3 ? 1 : 0);
};
var BigIntType = function(value3) {
  FNV1A64(ByteMarker.BigInt);
  F64In.setBigInt64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var DateType2 = function(value3) {
  FNV1A64(ByteMarker.Date);
  Visit3(value3.getTime());
};
var NullType = function(value3) {
  FNV1A64(ByteMarker.Null);
};
var NumberType = function(value3) {
  FNV1A64(ByteMarker.Number);
  F64In.setFloat64(0, value3);
  for (const byte of F64Out) {
    FNV1A64(byte);
  }
};
var ObjectType2 = function(value3) {
  FNV1A64(ByteMarker.Object);
  for (const key of globalThis.Object.keys(value3).sort()) {
    Visit3(key);
    Visit3(value3[key]);
  }
};
var StringType = function(value3) {
  FNV1A64(ByteMarker.String);
  for (let i = 0;i < value3.length; i++) {
    for (const byte of NumberToBytes(value3.charCodeAt(i))) {
      FNV1A64(byte);
    }
  }
};
var SymbolType = function(value3) {
  FNV1A64(ByteMarker.Symbol);
  Visit3(value3.description);
};
var Uint8ArrayType2 = function(value3) {
  FNV1A64(ByteMarker.Uint8Array);
  for (let i = 0;i < value3.length; i++) {
    FNV1A64(value3[i]);
  }
};
var UndefinedType = function(value3) {
  return FNV1A64(ByteMarker.Undefined);
};
var Visit3 = function(value3) {
  if (IsArray(value3))
    return ArrayType2(value3);
  if (IsBoolean(value3))
    return BooleanType(value3);
  if (IsBigInt(value3))
    return BigIntType(value3);
  if (IsDate(value3))
    return DateType2(value3);
  if (IsNull(value3))
    return NullType(value3);
  if (IsNumber(value3))
    return NumberType(value3);
  if (IsStandardObject(value3))
    return ObjectType2(value3);
  if (IsString(value3))
    return StringType(value3);
  if (IsSymbol(value3))
    return SymbolType(value3);
  if (IsUint8Array(value3))
    return Uint8ArrayType2(value3);
  if (IsUndefined(value3))
    return UndefinedType(value3);
  throw new ValueHashError(value3);
};
var FNV1A64 = function(byte) {
  Accumulator = Accumulator ^ Bytes[byte];
  Accumulator = Accumulator * Prime % Size;
};
function Hash(value3) {
  Accumulator = BigInt("14695981039346656037");
  Visit3(value3);
  return Accumulator;
}

class ValueHashError extends TypeBoxError {
  value;
  constructor(value3) {
    super(`Unable to hash value`);
    this.value = value3;
  }
}
var ByteMarker;
(function(ByteMarker2) {
  ByteMarker2[ByteMarker2["Undefined"] = 0] = "Undefined";
  ByteMarker2[ByteMarker2["Null"] = 1] = "Null";
  ByteMarker2[ByteMarker2["Boolean"] = 2] = "Boolean";
  ByteMarker2[ByteMarker2["Number"] = 3] = "Number";
  ByteMarker2[ByteMarker2["String"] = 4] = "String";
  ByteMarker2[ByteMarker2["Object"] = 5] = "Object";
  ByteMarker2[ByteMarker2["Array"] = 6] = "Array";
  ByteMarker2[ByteMarker2["Date"] = 7] = "Date";
  ByteMarker2[ByteMarker2["Uint8Array"] = 8] = "Uint8Array";
  ByteMarker2[ByteMarker2["Symbol"] = 9] = "Symbol";
  ByteMarker2[ByteMarker2["BigInt"] = 10] = "BigInt";
})(ByteMarker || (ByteMarker = {}));
var Accumulator = BigInt("14695981039346656037");
var [Prime, Size] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
var Bytes = Array.from({ length: 256 }).map((_, i) => BigInt(i));
var F64 = new Float64Array(1);
var F64In = new DataView(F64.buffer);
var F64Out = new Uint8Array(F64.buffer);
// node_modules/@sinclair/typebox/build/import/errors/errors.mjs
var EscapeKey = function(key) {
  return key.replace(/~/g, "~0").replace(/\//g, "~1");
};
var IsDefined = function(value3) {
  return value3 !== undefined;
};
var Create = function(errorType, schema, path, value3) {
  return { type: errorType, schema, path, value: value3, message: GetErrorFunction()({ errorType, path, schema, value: value3 }) };
};
function* FromAny(schema, references, path, value3) {
}
function* FromArray3(schema, references, path, value3) {
  if (!IsArray(value3)) {
    return yield Create(ValueErrorType.Array, schema, path, value3);
  }
  if (IsDefined(schema.minItems) && !(value3.length >= schema.minItems)) {
    yield Create(ValueErrorType.ArrayMinItems, schema, path, value3);
  }
  if (IsDefined(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    yield Create(ValueErrorType.ArrayMaxItems, schema, path, value3);
  }
  for (let i = 0;i < value3.length; i++) {
    yield* Visit4(schema.items, references, `${path}/${i}`, value3[i]);
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    yield Create(ValueErrorType.ArrayUniqueItems, schema, path, value3);
  }
  if (!(IsDefined(schema.contains) || IsDefined(schema.minContains) || IsDefined(schema.maxContains))) {
    return;
  }
  const containsSchema = IsDefined(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4, index) => Visit4(containsSchema, references, `${path}${index}`, value4).next().done === true ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    yield Create(ValueErrorType.ArrayContains, schema, path, value3);
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    yield Create(ValueErrorType.ArrayMinContains, schema, path, value3);
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    yield Create(ValueErrorType.ArrayMaxContains, schema, path, value3);
  }
}
function* FromAsyncIterator(schema, references, path, value3) {
  if (!IsAsyncIterator(value3))
    yield Create(ValueErrorType.AsyncIterator, schema, path, value3);
}
function* FromBigInt(schema, references, path, value3) {
  if (!IsBigInt(value3))
    return yield Create(ValueErrorType.BigInt, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.BigIntExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.BigIntExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.BigIntMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.BigIntMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    yield Create(ValueErrorType.BigIntMultipleOf, schema, path, value3);
  }
}
function* FromBoolean(schema, references, path, value3) {
  if (!IsBoolean(value3))
    yield Create(ValueErrorType.Boolean, schema, path, value3);
}
function* FromConstructor(schema, references, path, value3) {
  yield* Visit4(schema.returns, references, path, value3.prototype);
}
function* FromDate(schema, references, path, value3) {
  if (!IsDate(value3))
    return yield Create(ValueErrorType.Date, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    yield Create(ValueErrorType.DateExclusiveMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    yield Create(ValueErrorType.DateMaximumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    yield Create(ValueErrorType.DateMinimumTimestamp, schema, path, value3);
  }
  if (IsDefined(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    yield Create(ValueErrorType.DateMultipleOfTimestamp, schema, path, value3);
  }
}
function* FromFunction(schema, references, path, value3) {
  if (!IsFunction(value3))
    yield Create(ValueErrorType.Function, schema, path, value3);
}
function* FromInteger(schema, references, path, value3) {
  if (!IsInteger(value3))
    return yield Create(ValueErrorType.Integer, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.IntegerExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.IntegerExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.IntegerMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.IntegerMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.IntegerMultipleOf, schema, path, value3);
  }
}
function* FromIntersect3(schema, references, path, value3) {
  for (const inner of schema.allOf) {
    const next = Visit4(inner, references, path, value3).next();
    if (!next.done) {
      yield Create(ValueErrorType.Intersect, schema, path, value3);
      yield next.value;
    }
  }
  if (schema.unevaluatedProperties === false) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        yield Create(ValueErrorType.IntersectUnevaluatedProperties, schema, `${path}/${valueKey}`, value3);
      }
    }
  }
  if (typeof schema.unevaluatedProperties === "object") {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    for (const valueKey of Object.getOwnPropertyNames(value3)) {
      if (!keyCheck.test(valueKey)) {
        const next = Visit4(schema.unevaluatedProperties, references, `${path}/${valueKey}`, value3[valueKey]).next();
        if (!next.done)
          yield next.value;
      }
    }
  }
}
function* FromIterator(schema, references, path, value3) {
  if (!IsIterator(value3))
    yield Create(ValueErrorType.Iterator, schema, path, value3);
}
function* FromLiteral2(schema, references, path, value3) {
  if (!(value3 === schema.const))
    yield Create(ValueErrorType.Literal, schema, path, value3);
}
function* FromNever(schema, references, path, value3) {
  yield Create(ValueErrorType.Never, schema, path, value3);
}
function* FromNot(schema, references, path, value3) {
  if (Visit4(schema.not, references, path, value3).next().done === true)
    yield Create(ValueErrorType.Not, schema, path, value3);
}
function* FromNull(schema, references, path, value3) {
  if (!IsNull(value3))
    yield Create(ValueErrorType.Null, schema, path, value3);
}
function* FromNumber(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return yield Create(ValueErrorType.Number, schema, path, value3);
  if (IsDefined(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    yield Create(ValueErrorType.NumberExclusiveMaximum, schema, path, value3);
  }
  if (IsDefined(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    yield Create(ValueErrorType.NumberExclusiveMinimum, schema, path, value3);
  }
  if (IsDefined(schema.maximum) && !(value3 <= schema.maximum)) {
    yield Create(ValueErrorType.NumberMaximum, schema, path, value3);
  }
  if (IsDefined(schema.minimum) && !(value3 >= schema.minimum)) {
    yield Create(ValueErrorType.NumberMinimum, schema, path, value3);
  }
  if (IsDefined(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    yield Create(ValueErrorType.NumberMultipleOf, schema, path, value3);
  }
}
function* FromObject(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const requiredKeys = Array.isArray(schema.required) ? schema.required : [];
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  const unknownKeys = Object.getOwnPropertyNames(value3);
  for (const requiredKey of requiredKeys) {
    if (unknownKeys.includes(requiredKey))
      continue;
    yield Create(ValueErrorType.ObjectRequiredProperty, schema.properties[requiredKey], `${path}/${EscapeKey(requiredKey)}`, undefined);
  }
  if (schema.additionalProperties === false) {
    for (const valueKey of unknownKeys) {
      if (!knownKeys.includes(valueKey)) {
        yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
      }
    }
  }
  if (typeof schema.additionalProperties === "object") {
    for (const valueKey of unknownKeys) {
      if (knownKeys.includes(valueKey))
        continue;
      yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(valueKey)}`, value3[valueKey]);
    }
  }
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      if (ExtendsUndefinedCheck(schema) && !(knownKey in value3)) {
        yield Create(ValueErrorType.ObjectRequiredProperty, property, `${path}/${EscapeKey(knownKey)}`, undefined);
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey)) {
        yield* Visit4(property, references, `${path}/${EscapeKey(knownKey)}`, value3[knownKey]);
      }
    }
  }
}
function* FromPromise(schema, references, path, value3) {
  if (!IsPromise(value3))
    yield Create(ValueErrorType.Promise, schema, path, value3);
}
function* FromRecord(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3))
    return yield Create(ValueErrorType.Object, schema, path, value3);
  if (IsDefined(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    yield Create(ValueErrorType.ObjectMinProperties, schema, path, value3);
  }
  if (IsDefined(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    yield Create(ValueErrorType.ObjectMaxProperties, schema, path, value3);
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  for (const [propertyKey, propertyValue] of Object.entries(value3)) {
    if (regex.test(propertyKey))
      yield* Visit4(patternSchema, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
  }
  if (typeof schema.additionalProperties === "object") {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (!regex.test(propertyKey))
        yield* Visit4(schema.additionalProperties, references, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
  if (schema.additionalProperties === false) {
    for (const [propertyKey, propertyValue] of Object.entries(value3)) {
      if (regex.test(propertyKey))
        continue;
      return yield Create(ValueErrorType.ObjectAdditionalProperties, schema, `${path}/${EscapeKey(propertyKey)}`, propertyValue);
    }
  }
}
function* FromRef(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromRegExp(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  const regex = new RegExp(schema.source, schema.flags);
  if (!regex.test(value3)) {
    return yield Create(ValueErrorType.RegExp, schema, path, value3);
  }
}
function* FromString(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  if (IsDefined(schema.minLength) && !(value3.length >= schema.minLength)) {
    yield Create(ValueErrorType.StringMinLength, schema, path, value3);
  }
  if (IsDefined(schema.maxLength) && !(value3.length <= schema.maxLength)) {
    yield Create(ValueErrorType.StringMaxLength, schema, path, value3);
  }
  if (IsString(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3)) {
      yield Create(ValueErrorType.StringPattern, schema, path, value3);
    }
  }
  if (IsString(schema.format)) {
    if (!exports_format.Has(schema.format)) {
      yield Create(ValueErrorType.StringFormatUnknown, schema, path, value3);
    } else {
      const format = exports_format.Get(schema.format);
      if (!format(value3)) {
        yield Create(ValueErrorType.StringFormat, schema, path, value3);
      }
    }
  }
}
function* FromSymbol(schema, references, path, value3) {
  if (!IsSymbol(value3))
    yield Create(ValueErrorType.Symbol, schema, path, value3);
}
function* FromTemplateLiteral2(schema, references, path, value3) {
  if (!IsString(value3))
    return yield Create(ValueErrorType.String, schema, path, value3);
  const regex = new RegExp(schema.pattern);
  if (!regex.test(value3)) {
    yield Create(ValueErrorType.StringPattern, schema, path, value3);
  }
}
function* FromThis(schema, references, path, value3) {
  yield* Visit4(Deref(schema, references), references, path, value3);
}
function* FromTuple3(schema, references, path, value3) {
  if (!IsArray(value3))
    return yield Create(ValueErrorType.Tuple, schema, path, value3);
  if (schema.items === undefined && !(value3.length === 0)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!(value3.length === schema.maxItems)) {
    return yield Create(ValueErrorType.TupleLength, schema, path, value3);
  }
  if (!schema.items) {
    return;
  }
  for (let i = 0;i < schema.items.length; i++) {
    yield* Visit4(schema.items[i], references, `${path}/${i}`, value3[i]);
  }
}
function* FromUndefined(schema, references, path, value3) {
  if (!IsUndefined(value3))
    yield Create(ValueErrorType.Undefined, schema, path, value3);
}
function* FromUnion5(schema, references, path, value3) {
  let count = 0;
  for (const subschema of schema.anyOf) {
    const errors2 = [...Visit4(subschema, references, path, value3)];
    if (errors2.length === 0)
      return;
    count += errors2.length;
  }
  if (count > 0) {
    yield Create(ValueErrorType.Union, schema, path, value3);
  }
}
function* FromUint8Array(schema, references, path, value3) {
  if (!IsUint8Array(value3))
    return yield Create(ValueErrorType.Uint8Array, schema, path, value3);
  if (IsDefined(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMaxByteLength, schema, path, value3);
  }
  if (IsDefined(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    yield Create(ValueErrorType.Uint8ArrayMinByteLength, schema, path, value3);
  }
}
function* FromUnknown(schema, references, path, value3) {
}
function* FromVoid(schema, references, path, value3) {
  if (!TypeSystemPolicy.IsVoidLike(value3))
    yield Create(ValueErrorType.Void, schema, path, value3);
}
function* FromKind(schema, references, path, value3) {
  const check = exports_type.Get(schema[Kind]);
  if (!check(schema, value3))
    yield Create(ValueErrorType.Kind, schema, path, value3);
}
function* Visit4(schema, references, path, value3) {
  const references_ = IsDefined(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return yield* FromAny(schema_, references_, path, value3);
    case "Array":
      return yield* FromArray3(schema_, references_, path, value3);
    case "AsyncIterator":
      return yield* FromAsyncIterator(schema_, references_, path, value3);
    case "BigInt":
      return yield* FromBigInt(schema_, references_, path, value3);
    case "Boolean":
      return yield* FromBoolean(schema_, references_, path, value3);
    case "Constructor":
      return yield* FromConstructor(schema_, references_, path, value3);
    case "Date":
      return yield* FromDate(schema_, references_, path, value3);
    case "Function":
      return yield* FromFunction(schema_, references_, path, value3);
    case "Integer":
      return yield* FromInteger(schema_, references_, path, value3);
    case "Intersect":
      return yield* FromIntersect3(schema_, references_, path, value3);
    case "Iterator":
      return yield* FromIterator(schema_, references_, path, value3);
    case "Literal":
      return yield* FromLiteral2(schema_, references_, path, value3);
    case "Never":
      return yield* FromNever(schema_, references_, path, value3);
    case "Not":
      return yield* FromNot(schema_, references_, path, value3);
    case "Null":
      return yield* FromNull(schema_, references_, path, value3);
    case "Number":
      return yield* FromNumber(schema_, references_, path, value3);
    case "Object":
      return yield* FromObject(schema_, references_, path, value3);
    case "Promise":
      return yield* FromPromise(schema_, references_, path, value3);
    case "Record":
      return yield* FromRecord(schema_, references_, path, value3);
    case "Ref":
      return yield* FromRef(schema_, references_, path, value3);
    case "RegExp":
      return yield* FromRegExp(schema_, references_, path, value3);
    case "String":
      return yield* FromString(schema_, references_, path, value3);
    case "Symbol":
      return yield* FromSymbol(schema_, references_, path, value3);
    case "TemplateLiteral":
      return yield* FromTemplateLiteral2(schema_, references_, path, value3);
    case "This":
      return yield* FromThis(schema_, references_, path, value3);
    case "Tuple":
      return yield* FromTuple3(schema_, references_, path, value3);
    case "Undefined":
      return yield* FromUndefined(schema_, references_, path, value3);
    case "Union":
      return yield* FromUnion5(schema_, references_, path, value3);
    case "Uint8Array":
      return yield* FromUint8Array(schema_, references_, path, value3);
    case "Unknown":
      return yield* FromUnknown(schema_, references_, path, value3);
    case "Void":
      return yield* FromVoid(schema_, references_, path, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueErrorsUnknownTypeError(schema);
      return yield* FromKind(schema_, references_, path, value3);
  }
}
function Errors(...args) {
  const iterator3 = args.length === 3 ? Visit4(args[0], args[1], "", args[2]) : Visit4(args[0], [], "", args[1]);
  return new ValueErrorIterator(iterator3);
}
var ValueErrorType;
(function(ValueErrorType2) {
  ValueErrorType2[ValueErrorType2["ArrayContains"] = 0] = "ArrayContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxContains"] = 1] = "ArrayMaxContains";
  ValueErrorType2[ValueErrorType2["ArrayMaxItems"] = 2] = "ArrayMaxItems";
  ValueErrorType2[ValueErrorType2["ArrayMinContains"] = 3] = "ArrayMinContains";
  ValueErrorType2[ValueErrorType2["ArrayMinItems"] = 4] = "ArrayMinItems";
  ValueErrorType2[ValueErrorType2["ArrayUniqueItems"] = 5] = "ArrayUniqueItems";
  ValueErrorType2[ValueErrorType2["Array"] = 6] = "Array";
  ValueErrorType2[ValueErrorType2["AsyncIterator"] = 7] = "AsyncIterator";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMaximum"] = 8] = "BigIntExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["BigIntExclusiveMinimum"] = 9] = "BigIntExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMaximum"] = 10] = "BigIntMaximum";
  ValueErrorType2[ValueErrorType2["BigIntMinimum"] = 11] = "BigIntMinimum";
  ValueErrorType2[ValueErrorType2["BigIntMultipleOf"] = 12] = "BigIntMultipleOf";
  ValueErrorType2[ValueErrorType2["BigInt"] = 13] = "BigInt";
  ValueErrorType2[ValueErrorType2["Boolean"] = 14] = "Boolean";
  ValueErrorType2[ValueErrorType2["DateExclusiveMaximumTimestamp"] = 15] = "DateExclusiveMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateExclusiveMinimumTimestamp"] = 16] = "DateExclusiveMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMaximumTimestamp"] = 17] = "DateMaximumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMinimumTimestamp"] = 18] = "DateMinimumTimestamp";
  ValueErrorType2[ValueErrorType2["DateMultipleOfTimestamp"] = 19] = "DateMultipleOfTimestamp";
  ValueErrorType2[ValueErrorType2["Date"] = 20] = "Date";
  ValueErrorType2[ValueErrorType2["Function"] = 21] = "Function";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMaximum"] = 22] = "IntegerExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["IntegerExclusiveMinimum"] = 23] = "IntegerExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMaximum"] = 24] = "IntegerMaximum";
  ValueErrorType2[ValueErrorType2["IntegerMinimum"] = 25] = "IntegerMinimum";
  ValueErrorType2[ValueErrorType2["IntegerMultipleOf"] = 26] = "IntegerMultipleOf";
  ValueErrorType2[ValueErrorType2["Integer"] = 27] = "Integer";
  ValueErrorType2[ValueErrorType2["IntersectUnevaluatedProperties"] = 28] = "IntersectUnevaluatedProperties";
  ValueErrorType2[ValueErrorType2["Intersect"] = 29] = "Intersect";
  ValueErrorType2[ValueErrorType2["Iterator"] = 30] = "Iterator";
  ValueErrorType2[ValueErrorType2["Kind"] = 31] = "Kind";
  ValueErrorType2[ValueErrorType2["Literal"] = 32] = "Literal";
  ValueErrorType2[ValueErrorType2["Never"] = 33] = "Never";
  ValueErrorType2[ValueErrorType2["Not"] = 34] = "Not";
  ValueErrorType2[ValueErrorType2["Null"] = 35] = "Null";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMaximum"] = 36] = "NumberExclusiveMaximum";
  ValueErrorType2[ValueErrorType2["NumberExclusiveMinimum"] = 37] = "NumberExclusiveMinimum";
  ValueErrorType2[ValueErrorType2["NumberMaximum"] = 38] = "NumberMaximum";
  ValueErrorType2[ValueErrorType2["NumberMinimum"] = 39] = "NumberMinimum";
  ValueErrorType2[ValueErrorType2["NumberMultipleOf"] = 40] = "NumberMultipleOf";
  ValueErrorType2[ValueErrorType2["Number"] = 41] = "Number";
  ValueErrorType2[ValueErrorType2["ObjectAdditionalProperties"] = 42] = "ObjectAdditionalProperties";
  ValueErrorType2[ValueErrorType2["ObjectMaxProperties"] = 43] = "ObjectMaxProperties";
  ValueErrorType2[ValueErrorType2["ObjectMinProperties"] = 44] = "ObjectMinProperties";
  ValueErrorType2[ValueErrorType2["ObjectRequiredProperty"] = 45] = "ObjectRequiredProperty";
  ValueErrorType2[ValueErrorType2["Object"] = 46] = "Object";
  ValueErrorType2[ValueErrorType2["Promise"] = 47] = "Promise";
  ValueErrorType2[ValueErrorType2["RegExp"] = 48] = "RegExp";
  ValueErrorType2[ValueErrorType2["StringFormatUnknown"] = 49] = "StringFormatUnknown";
  ValueErrorType2[ValueErrorType2["StringFormat"] = 50] = "StringFormat";
  ValueErrorType2[ValueErrorType2["StringMaxLength"] = 51] = "StringMaxLength";
  ValueErrorType2[ValueErrorType2["StringMinLength"] = 52] = "StringMinLength";
  ValueErrorType2[ValueErrorType2["StringPattern"] = 53] = "StringPattern";
  ValueErrorType2[ValueErrorType2["String"] = 54] = "String";
  ValueErrorType2[ValueErrorType2["Symbol"] = 55] = "Symbol";
  ValueErrorType2[ValueErrorType2["TupleLength"] = 56] = "TupleLength";
  ValueErrorType2[ValueErrorType2["Tuple"] = 57] = "Tuple";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMaxByteLength"] = 58] = "Uint8ArrayMaxByteLength";
  ValueErrorType2[ValueErrorType2["Uint8ArrayMinByteLength"] = 59] = "Uint8ArrayMinByteLength";
  ValueErrorType2[ValueErrorType2["Uint8Array"] = 60] = "Uint8Array";
  ValueErrorType2[ValueErrorType2["Undefined"] = 61] = "Undefined";
  ValueErrorType2[ValueErrorType2["Union"] = 62] = "Union";
  ValueErrorType2[ValueErrorType2["Void"] = 63] = "Void";
})(ValueErrorType || (ValueErrorType = {}));

class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super("Unknown type");
    this.schema = schema;
  }
}

class ValueErrorIterator {
  iterator;
  constructor(iterator3) {
    this.iterator = iterator3;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const next = this.iterator.next();
    return next.done ? undefined : next.value;
  }
}
// node_modules/@sinclair/typebox/build/import/type/any/any.mjs
function Any(options = {}) {
  return { ...options, [Kind]: "Any" };
}
// node_modules/@sinclair/typebox/build/import/type/unknown/unknown.mjs
function Unknown(options = {}) {
  return {
    ...options,
    [Kind]: "Unknown"
  };
}
// node_modules/@sinclair/typebox/build/import/type/extends/extends-check.mjs
var IntoBooleanResult = function(result) {
  return result === ExtendsResult.False ? result : ExtendsResult.True;
};
var Throw = function(message) {
  throw new ExtendsResolverError(message);
};
var IsStructuralRight = function(right) {
  return exports_type2.IsNever(right) || exports_type2.IsIntersect(right) || exports_type2.IsUnion(right) || exports_type2.IsUnknown(right) || exports_type2.IsAny(right);
};
var StructuralRight = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : Throw("StructuralRight");
};
var FromAnyRight = function(left, right) {
  return ExtendsResult.True;
};
var FromAny2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) && right.anyOf.some((schema) => exports_type2.IsAny(schema) || exports_type2.IsUnknown(schema)) ? ExtendsResult.True : exports_type2.IsUnion(right) ? ExtendsResult.Union : exports_type2.IsUnknown(right) ? ExtendsResult.True : exports_type2.IsAny(right) ? ExtendsResult.True : ExtendsResult.Union;
};
var FromArrayRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromArray4 = function(left, right) {
  return exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsArray(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromAsyncIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsAsyncIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromBigInt2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBigInt(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBooleanRight = function(left, right) {
  return exports_type2.IsLiteralBoolean(left) ? ExtendsResult.True : exports_type2.IsBoolean(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromBoolean2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsBoolean(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromConstructor2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsConstructor(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromDate2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsDate(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromFunction2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsFunction(right) ? ExtendsResult.False : left.parameters.length > right.parameters.length ? ExtendsResult.False : !left.parameters.every((schema, index) => IntoBooleanResult(Visit5(right.parameters[index], schema)) === ExtendsResult.True) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.returns, right.returns));
};
var FromIntegerRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsNumber(left.const) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromInteger2 = function(left, right) {
  return exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : ExtendsResult.False;
};
var FromIntersectRight = function(left, right) {
  return right.allOf.every((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIntersect4 = function(left, right) {
  return left.allOf.some((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromIterator2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : !exports_type2.IsIterator(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.items, right.items));
};
var FromLiteral3 = function(left, right) {
  return exports_type2.IsLiteral(right) && right.const === left.const ? ExtendsResult.True : IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : ExtendsResult.False;
};
var FromNeverRight = function(left, right) {
  return ExtendsResult.False;
};
var FromNever2 = function(left, right) {
  return ExtendsResult.True;
};
var UnwrapTNot = function(schema) {
  let [current, depth] = [schema, 0];
  while (true) {
    if (!exports_type2.IsNot(current))
      break;
    current = current.not;
    depth += 1;
  }
  return depth % 2 === 0 ? current : Unknown();
};
var FromNot2 = function(left, right) {
  return exports_type2.IsNot(left) ? Visit5(UnwrapTNot(left), right) : exports_type2.IsNot(right) ? Visit5(left, UnwrapTNot(right)) : Throw("Invalid fallthrough for Not");
};
var FromNull2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsNull(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumberRight = function(left, right) {
  return exports_type2.IsLiteralNumber(left) ? ExtendsResult.True : exports_type2.IsNumber(left) || exports_type2.IsInteger(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromNumber2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsInteger(right) || exports_type2.IsNumber(right) ? ExtendsResult.True : ExtendsResult.False;
};
var IsObjectPropertyCount = function(schema, count) {
  return Object.getOwnPropertyNames(schema.properties).length === count;
};
var IsObjectStringLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectSymbolLike = function(schema) {
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "description" in schema.properties && exports_type2.IsUnion(schema.properties.description) && schema.properties.description.anyOf.length === 2 && (exports_type2.IsString(schema.properties.description.anyOf[0]) && exports_type2.IsUndefined(schema.properties.description.anyOf[1]) || exports_type2.IsString(schema.properties.description.anyOf[1]) && exports_type2.IsUndefined(schema.properties.description.anyOf[0]));
};
var IsObjectNumberLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBooleanLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectBigIntLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectDateLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectUint8ArrayLike = function(schema) {
  return IsObjectArrayLike(schema);
};
var IsObjectFunctionLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectConstructorLike = function(schema) {
  return IsObjectPropertyCount(schema, 0);
};
var IsObjectArrayLike = function(schema) {
  const length = Number2();
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "length" in schema.properties && IntoBooleanResult(Visit5(schema.properties["length"], length)) === ExtendsResult.True;
};
var IsObjectPromiseLike = function(schema) {
  const then = Function2([Any()], Any());
  return IsObjectPropertyCount(schema, 0) || IsObjectPropertyCount(schema, 1) && "then" in schema.properties && IntoBooleanResult(Visit5(schema.properties["then"], then)) === ExtendsResult.True;
};
var Property = function(left, right) {
  return Visit5(left, right) === ExtendsResult.False ? ExtendsResult.False : exports_type2.IsOptional(left) && !exports_type2.IsOptional(right) ? ExtendsResult.False : ExtendsResult.True;
};
var FromObjectRight = function(left, right) {
  return exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : exports_type2.IsNever(left) || exports_type2.IsLiteralString(left) && IsObjectStringLike(right) || exports_type2.IsLiteralNumber(left) && IsObjectNumberLike(right) || exports_type2.IsLiteralBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsBigInt(left) && IsObjectBigIntLike(right) || exports_type2.IsString(left) && IsObjectStringLike(right) || exports_type2.IsSymbol(left) && IsObjectSymbolLike(right) || exports_type2.IsNumber(left) && IsObjectNumberLike(right) || exports_type2.IsInteger(left) && IsObjectNumberLike(right) || exports_type2.IsBoolean(left) && IsObjectBooleanLike(right) || exports_type2.IsUint8Array(left) && IsObjectUint8ArrayLike(right) || exports_type2.IsDate(left) && IsObjectDateLike(right) || exports_type2.IsConstructor(left) && IsObjectConstructorLike(right) || exports_type2.IsFunction(left) && IsObjectFunctionLike(right) ? ExtendsResult.True : exports_type2.IsRecord(left) && exports_type2.IsString(RecordKey(left)) ? (() => {
    return right[Hint] === "Record" ? ExtendsResult.True : ExtendsResult.False;
  })() : exports_type2.IsRecord(left) && exports_type2.IsNumber(RecordKey(left)) ? (() => {
    return IsObjectPropertyCount(right, 0) ? ExtendsResult.True : ExtendsResult.False;
  })() : ExtendsResult.False;
};
var FromObject2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : !exports_type2.IsObject(right) ? ExtendsResult.False : (() => {
    for (const key of Object.getOwnPropertyNames(right.properties)) {
      if (!(key in left.properties) && !exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.False;
      }
      if (exports_type2.IsOptional(right.properties[key])) {
        return ExtendsResult.True;
      }
      if (Property(left.properties[key], right.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })();
};
var FromPromise2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectPromiseLike(right) ? ExtendsResult.True : !exports_type2.IsPromise(right) ? ExtendsResult.False : IntoBooleanResult(Visit5(left.item, right.item));
};
var RecordKey = function(schema) {
  return PatternNumberExact in schema.patternProperties ? Number2() : (PatternStringExact in schema.patternProperties) ? String2() : Throw("Unknown record key pattern");
};
var RecordValue = function(schema) {
  return PatternNumberExact in schema.patternProperties ? schema.patternProperties[PatternNumberExact] : (PatternStringExact in schema.patternProperties) ? schema.patternProperties[PatternStringExact] : Throw("Unable to get record value schema");
};
var FromRecordRight = function(left, right) {
  const [Key, Value] = [RecordKey(right), RecordValue(right)];
  return exports_type2.IsLiteralString(left) && exports_type2.IsNumber(Key) && IntoBooleanResult(Visit5(left, Value)) === ExtendsResult.True ? ExtendsResult.True : exports_type2.IsUint8Array(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsString(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsArray(left) && exports_type2.IsNumber(Key) ? Visit5(left, Value) : exports_type2.IsObject(left) ? (() => {
    for (const key of Object.getOwnPropertyNames(left.properties)) {
      if (Property(Value, left.properties[key]) === ExtendsResult.False) {
        return ExtendsResult.False;
      }
    }
    return ExtendsResult.True;
  })() : ExtendsResult.False;
};
var FromRecord2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : !exports_type2.IsRecord(right) ? ExtendsResult.False : Visit5(RecordValue(left), RecordValue(right));
};
var FromRegExp2 = function(left, right) {
  const L = exports_type2.IsRegExp(left) ? String2() : left;
  const R = exports_type2.IsRegExp(right) ? String2() : right;
  return Visit5(L, R);
};
var FromStringRight = function(left, right) {
  return exports_type2.IsLiteral(left) && exports_value.IsString(left.const) ? ExtendsResult.True : exports_type2.IsString(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromString2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsString(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromSymbol2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsSymbol(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromTemplateLiteral3 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) ? Visit5(TemplateLiteralToUnion(left), right) : exports_type2.IsTemplateLiteral(right) ? Visit5(left, TemplateLiteralToUnion(right)) : Throw("Invalid fallthrough for TemplateLiteral");
};
var IsArrayOfTuple = function(left, right) {
  return exports_type2.IsArray(right) && left.items !== undefined && left.items.every((schema) => Visit5(schema, right.items) === ExtendsResult.True);
};
var FromTupleRight = function(left, right) {
  return exports_type2.IsNever(left) ? ExtendsResult.True : exports_type2.IsUnknown(left) ? ExtendsResult.False : exports_type2.IsAny(left) ? ExtendsResult.Union : ExtendsResult.False;
};
var FromTuple4 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) && IsObjectArrayLike(right) ? ExtendsResult.True : exports_type2.IsArray(right) && IsArrayOfTuple(left, right) ? ExtendsResult.True : !exports_type2.IsTuple(right) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) || !exports_value.IsUndefined(left.items) && exports_value.IsUndefined(right.items) ? ExtendsResult.False : exports_value.IsUndefined(left.items) && !exports_value.IsUndefined(right.items) ? ExtendsResult.True : left.items.every((schema, index) => Visit5(schema, right.items[index]) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUint8Array2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsUint8Array(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUndefined2 = function(left, right) {
  return IsStructuralRight(right) ? StructuralRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsRecord(right) ? FromRecordRight(left, right) : exports_type2.IsVoid(right) ? FromVoidRight(left, right) : exports_type2.IsUndefined(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnionRight = function(left, right) {
  return right.anyOf.some((schema) => Visit5(left, schema) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnion6 = function(left, right) {
  return left.anyOf.every((schema) => Visit5(schema, right) === ExtendsResult.True) ? ExtendsResult.True : ExtendsResult.False;
};
var FromUnknownRight = function(left, right) {
  return ExtendsResult.True;
};
var FromUnknown2 = function(left, right) {
  return exports_type2.IsNever(right) ? FromNeverRight(left, right) : exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsString(right) ? FromStringRight(left, right) : exports_type2.IsNumber(right) ? FromNumberRight(left, right) : exports_type2.IsInteger(right) ? FromIntegerRight(left, right) : exports_type2.IsBoolean(right) ? FromBooleanRight(left, right) : exports_type2.IsArray(right) ? FromArrayRight(left, right) : exports_type2.IsTuple(right) ? FromTupleRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsUnknown(right) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoidRight = function(left, right) {
  return exports_type2.IsUndefined(left) ? ExtendsResult.True : exports_type2.IsUndefined(left) ? ExtendsResult.True : ExtendsResult.False;
};
var FromVoid2 = function(left, right) {
  return exports_type2.IsIntersect(right) ? FromIntersectRight(left, right) : exports_type2.IsUnion(right) ? FromUnionRight(left, right) : exports_type2.IsUnknown(right) ? FromUnknownRight(left, right) : exports_type2.IsAny(right) ? FromAnyRight(left, right) : exports_type2.IsObject(right) ? FromObjectRight(left, right) : exports_type2.IsVoid(right) ? ExtendsResult.True : ExtendsResult.False;
};
var Visit5 = function(left, right) {
  return exports_type2.IsTemplateLiteral(left) || exports_type2.IsTemplateLiteral(right) ? FromTemplateLiteral3(left, right) : exports_type2.IsRegExp(left) || exports_type2.IsRegExp(right) ? FromRegExp2(left, right) : exports_type2.IsNot(left) || exports_type2.IsNot(right) ? FromNot2(left, right) : exports_type2.IsAny(left) ? FromAny2(left, right) : exports_type2.IsArray(left) ? FromArray4(left, right) : exports_type2.IsBigInt(left) ? FromBigInt2(left, right) : exports_type2.IsBoolean(left) ? FromBoolean2(left, right) : exports_type2.IsAsyncIterator(left) ? FromAsyncIterator2(left, right) : exports_type2.IsConstructor(left) ? FromConstructor2(left, right) : exports_type2.IsDate(left) ? FromDate2(left, right) : exports_type2.IsFunction(left) ? FromFunction2(left, right) : exports_type2.IsInteger(left) ? FromInteger2(left, right) : exports_type2.IsIntersect(left) ? FromIntersect4(left, right) : exports_type2.IsIterator(left) ? FromIterator2(left, right) : exports_type2.IsLiteral(left) ? FromLiteral3(left, right) : exports_type2.IsNever(left) ? FromNever2(left, right) : exports_type2.IsNull(left) ? FromNull2(left, right) : exports_type2.IsNumber(left) ? FromNumber2(left, right) : exports_type2.IsObject(left) ? FromObject2(left, right) : exports_type2.IsRecord(left) ? FromRecord2(left, right) : exports_type2.IsString(left) ? FromString2(left, right) : exports_type2.IsSymbol(left) ? FromSymbol2(left, right) : exports_type2.IsTuple(left) ? FromTuple4(left, right) : exports_type2.IsPromise(left) ? FromPromise2(left, right) : exports_type2.IsUint8Array(left) ? FromUint8Array2(left, right) : exports_type2.IsUndefined(left) ? FromUndefined2(left, right) : exports_type2.IsUnion(left) ? FromUnion6(left, right) : exports_type2.IsUnknown(left) ? FromUnknown2(left, right) : exports_type2.IsVoid(left) ? FromVoid2(left, right) : Throw(`Unknown left type operand '${left[Kind]}'`);
};
function ExtendsCheck(left, right) {
  return Visit5(left, right);
}

class ExtendsResolverError extends TypeBoxError {
}
var ExtendsResult;
(function(ExtendsResult2) {
  ExtendsResult2[ExtendsResult2["Union"] = 0] = "Union";
  ExtendsResult2[ExtendsResult2["True"] = 1] = "True";
  ExtendsResult2[ExtendsResult2["False"] = 2] = "False";
})(ExtendsResult || (ExtendsResult = {}));
// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-result.mjs
var FromProperties7 = function(P, Right, True, False, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extends(P[K2], Right, True, False, options) };
  }, {});
};
var FromMappedResult6 = function(Left, Right, True, False, options) {
  return FromProperties7(Left.properties, Right, True, False, options);
};
function ExtendsFromMappedResult(Left, Right, True, False, options) {
  const P = FromMappedResult6(Left, Right, True, False, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends.mjs
var ExtendsResolve = function(left, right, trueType, falseType) {
  const R = ExtendsCheck(left, right);
  return R === ExtendsResult.Union ? Union([trueType, falseType]) : R === ExtendsResult.True ? trueType : falseType;
};
function Extends(L, R, T, F, options = {}) {
  return IsMappedResult(L) ? ExtendsFromMappedResult(L, R, T, F, options) : IsMappedKey(L) ? CloneType(ExtendsFromMappedKey(L, R, T, F, options)) : CloneType(ExtendsResolve(L, R, T, F), options);
}

// node_modules/@sinclair/typebox/build/import/type/extends/extends-from-mapped-key.mjs
var FromPropertyKey = function(K, U, L, R, options) {
  return {
    [K]: Extends(Literal(K), U, L, R, options)
  };
};
var FromPropertyKeys = function(K, U, L, R, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey(LK, U, L, R, options) };
  }, {});
};
var FromMappedKey2 = function(K, U, L, R, options) {
  return FromPropertyKeys(K.keys, U, L, R, options);
};
function ExtendsFromMappedKey(T, U, L, R, options) {
  const P = FromMappedKey2(T, U, L, R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/value/check/check.mjs
var IsAnyOrUnknown = function(schema) {
  return schema[Kind] === "Any" || schema[Kind] === "Unknown";
};
var IsDefined2 = function(value3) {
  return value3 !== undefined;
};
var FromAny3 = function(schema, references, value3) {
  return true;
};
var FromArray5 = function(schema, references, value3) {
  if (!IsArray(value3))
    return false;
  if (IsDefined2(schema.minItems) && !(value3.length >= schema.minItems)) {
    return false;
  }
  if (IsDefined2(schema.maxItems) && !(value3.length <= schema.maxItems)) {
    return false;
  }
  if (!value3.every((value4) => Visit6(schema.items, references, value4))) {
    return false;
  }
  if (schema.uniqueItems === true && !function() {
    const set2 = new Set;
    for (const element of value3) {
      const hashed = Hash(element);
      if (set2.has(hashed)) {
        return false;
      } else {
        set2.add(hashed);
      }
    }
    return true;
  }()) {
    return false;
  }
  if (!(IsDefined2(schema.contains) || IsNumber(schema.minContains) || IsNumber(schema.maxContains))) {
    return true;
  }
  const containsSchema = IsDefined2(schema.contains) ? schema.contains : Never();
  const containsCount = value3.reduce((acc, value4) => Visit6(containsSchema, references, value4) ? acc + 1 : acc, 0);
  if (containsCount === 0) {
    return false;
  }
  if (IsNumber(schema.minContains) && containsCount < schema.minContains) {
    return false;
  }
  if (IsNumber(schema.maxContains) && containsCount > schema.maxContains) {
    return false;
  }
  return true;
};
var FromAsyncIterator3 = function(schema, references, value3) {
  return IsAsyncIterator(value3);
};
var FromBigInt3 = function(schema, references, value3) {
  if (!IsBigInt(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
};
var FromBoolean3 = function(schema, references, value3) {
  return IsBoolean(value3);
};
var FromConstructor3 = function(schema, references, value3) {
  return Visit6(schema.returns, references, value3.prototype);
};
var FromDate3 = function(schema, references, value3) {
  if (!IsDate(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximumTimestamp) && !(value3.getTime() < schema.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimumTimestamp) && !(value3.getTime() > schema.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.maximumTimestamp) && !(value3.getTime() <= schema.maximumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.minimumTimestamp) && !(value3.getTime() >= schema.minimumTimestamp)) {
    return false;
  }
  if (IsDefined2(schema.multipleOfTimestamp) && !(value3.getTime() % schema.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
};
var FromFunction3 = function(schema, references, value3) {
  return IsFunction(value3);
};
var FromInteger3 = function(schema, references, value3) {
  if (!IsInteger(value3)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromIntersect5 = function(schema, references, value3) {
  const check1 = schema.allOf.every((schema2) => Visit6(schema2, references, value3));
  if (schema.unevaluatedProperties === false) {
    const keyPattern = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyPattern.test(key));
    return check1 && check2;
  } else if (IsSchema(schema.unevaluatedProperties)) {
    const keyCheck = new RegExp(KeyOfPattern(schema));
    const check2 = Object.getOwnPropertyNames(value3).every((key) => keyCheck.test(key) || Visit6(schema.unevaluatedProperties, references, value3[key]));
    return check1 && check2;
  } else {
    return check1;
  }
};
var FromIterator3 = function(schema, references, value3) {
  return IsIterator(value3);
};
var FromLiteral4 = function(schema, references, value3) {
  return value3 === schema.const;
};
var FromNever3 = function(schema, references, value3) {
  return false;
};
var FromNot3 = function(schema, references, value3) {
  return !Visit6(schema.not, references, value3);
};
var FromNull3 = function(schema, references, value3) {
  return IsNull(value3);
};
var FromNumber3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsNumberLike(value3))
    return false;
  if (IsDefined2(schema.exclusiveMaximum) && !(value3 < schema.exclusiveMaximum)) {
    return false;
  }
  if (IsDefined2(schema.exclusiveMinimum) && !(value3 > schema.exclusiveMinimum)) {
    return false;
  }
  if (IsDefined2(schema.minimum) && !(value3 >= schema.minimum)) {
    return false;
  }
  if (IsDefined2(schema.maximum) && !(value3 <= schema.maximum)) {
    return false;
  }
  if (IsDefined2(schema.multipleOf) && !(value3 % schema.multipleOf === 0)) {
    return false;
  }
  return true;
};
var FromObject3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsObjectLike(value3))
    return false;
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const knownKeys = Object.getOwnPropertyNames(schema.properties);
  for (const knownKey of knownKeys) {
    const property = schema.properties[knownKey];
    if (schema.required && schema.required.includes(knownKey)) {
      if (!Visit6(property, references, value3[knownKey])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(property) || IsAnyOrUnknown(property)) && !(knownKey in value3)) {
        return false;
      }
    } else {
      if (TypeSystemPolicy.IsExactOptionalProperty(value3, knownKey) && !Visit6(property, references, value3[knownKey])) {
        return false;
      }
    }
  }
  if (schema.additionalProperties === false) {
    const valueKeys = Object.getOwnPropertyNames(value3);
    if (schema.required && schema.required.length === knownKeys.length && valueKeys.length === knownKeys.length) {
      return true;
    } else {
      return valueKeys.every((valueKey) => knownKeys.includes(valueKey));
    }
  } else if (typeof schema.additionalProperties === "object") {
    const valueKeys = Object.getOwnPropertyNames(value3);
    return valueKeys.every((key) => knownKeys.includes(key) || Visit6(schema.additionalProperties, references, value3[key]));
  } else {
    return true;
  }
};
var FromPromise3 = function(schema, references, value3) {
  return IsPromise(value3);
};
var FromRecord3 = function(schema, references, value3) {
  if (!TypeSystemPolicy.IsRecordLike(value3)) {
    return false;
  }
  if (IsDefined2(schema.minProperties) && !(Object.getOwnPropertyNames(value3).length >= schema.minProperties)) {
    return false;
  }
  if (IsDefined2(schema.maxProperties) && !(Object.getOwnPropertyNames(value3).length <= schema.maxProperties)) {
    return false;
  }
  const [patternKey, patternSchema] = Object.entries(schema.patternProperties)[0];
  const regex = new RegExp(patternKey);
  const check1 = Object.entries(value3).every(([key, value4]) => {
    return regex.test(key) ? Visit6(patternSchema, references, value4) : true;
  });
  const check2 = typeof schema.additionalProperties === "object" ? Object.entries(value3).every(([key, value4]) => {
    return !regex.test(key) ? Visit6(schema.additionalProperties, references, value4) : true;
  }) : true;
  const check3 = schema.additionalProperties === false ? Object.getOwnPropertyNames(value3).every((key) => {
    return regex.test(key);
  }) : true;
  return check1 && check2 && check3;
};
var FromRef2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromRegExp3 = function(schema, references, value3) {
  const regex = new RegExp(schema.source, schema.flags);
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  return regex.test(value3);
};
var FromString3 = function(schema, references, value3) {
  if (!IsString(value3)) {
    return false;
  }
  if (IsDefined2(schema.minLength)) {
    if (!(value3.length >= schema.minLength))
      return false;
  }
  if (IsDefined2(schema.maxLength)) {
    if (!(value3.length <= schema.maxLength))
      return false;
  }
  if (IsDefined2(schema.pattern)) {
    const regex = new RegExp(schema.pattern);
    if (!regex.test(value3))
      return false;
  }
  if (IsDefined2(schema.format)) {
    if (!exports_format.Has(schema.format))
      return false;
    const func = exports_format.Get(schema.format);
    return func(value3);
  }
  return true;
};
var FromSymbol3 = function(schema, references, value3) {
  return IsSymbol(value3);
};
var FromTemplateLiteral4 = function(schema, references, value3) {
  return IsString(value3) && new RegExp(schema.pattern).test(value3);
};
var FromThis2 = function(schema, references, value3) {
  return Visit6(Deref(schema, references), references, value3);
};
var FromTuple5 = function(schema, references, value3) {
  if (!IsArray(value3)) {
    return false;
  }
  if (schema.items === undefined && !(value3.length === 0)) {
    return false;
  }
  if (!(value3.length === schema.maxItems)) {
    return false;
  }
  if (!schema.items) {
    return true;
  }
  for (let i = 0;i < schema.items.length; i++) {
    if (!Visit6(schema.items[i], references, value3[i]))
      return false;
  }
  return true;
};
var FromUndefined3 = function(schema, references, value3) {
  return IsUndefined(value3);
};
var FromUnion7 = function(schema, references, value3) {
  return schema.anyOf.some((inner) => Visit6(inner, references, value3));
};
var FromUint8Array3 = function(schema, references, value3) {
  if (!IsUint8Array(value3)) {
    return false;
  }
  if (IsDefined2(schema.maxByteLength) && !(value3.length <= schema.maxByteLength)) {
    return false;
  }
  if (IsDefined2(schema.minByteLength) && !(value3.length >= schema.minByteLength)) {
    return false;
  }
  return true;
};
var FromUnknown3 = function(schema, references, value3) {
  return true;
};
var FromVoid3 = function(schema, references, value3) {
  return TypeSystemPolicy.IsVoidLike(value3);
};
var FromKind2 = function(schema, references, value3) {
  if (!exports_type.Has(schema[Kind]))
    return false;
  const func = exports_type.Get(schema[Kind]);
  return func(schema, value3);
};
var Visit6 = function(schema, references, value3) {
  const references_ = IsDefined2(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny3(schema_, references_, value3);
    case "Array":
      return FromArray5(schema_, references_, value3);
    case "AsyncIterator":
      return FromAsyncIterator3(schema_, references_, value3);
    case "BigInt":
      return FromBigInt3(schema_, references_, value3);
    case "Boolean":
      return FromBoolean3(schema_, references_, value3);
    case "Constructor":
      return FromConstructor3(schema_, references_, value3);
    case "Date":
      return FromDate3(schema_, references_, value3);
    case "Function":
      return FromFunction3(schema_, references_, value3);
    case "Integer":
      return FromInteger3(schema_, references_, value3);
    case "Intersect":
      return FromIntersect5(schema_, references_, value3);
    case "Iterator":
      return FromIterator3(schema_, references_, value3);
    case "Literal":
      return FromLiteral4(schema_, references_, value3);
    case "Never":
      return FromNever3(schema_, references_, value3);
    case "Not":
      return FromNot3(schema_, references_, value3);
    case "Null":
      return FromNull3(schema_, references_, value3);
    case "Number":
      return FromNumber3(schema_, references_, value3);
    case "Object":
      return FromObject3(schema_, references_, value3);
    case "Promise":
      return FromPromise3(schema_, references_, value3);
    case "Record":
      return FromRecord3(schema_, references_, value3);
    case "Ref":
      return FromRef2(schema_, references_, value3);
    case "RegExp":
      return FromRegExp3(schema_, references_, value3);
    case "String":
      return FromString3(schema_, references_, value3);
    case "Symbol":
      return FromSymbol3(schema_, references_, value3);
    case "TemplateLiteral":
      return FromTemplateLiteral4(schema_, references_, value3);
    case "This":
      return FromThis2(schema_, references_, value3);
    case "Tuple":
      return FromTuple5(schema_, references_, value3);
    case "Undefined":
      return FromUndefined3(schema_, references_, value3);
    case "Union":
      return FromUnion7(schema_, references_, value3);
    case "Uint8Array":
      return FromUint8Array3(schema_, references_, value3);
    case "Unknown":
      return FromUnknown3(schema_, references_, value3);
    case "Void":
      return FromVoid3(schema_, references_, value3);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCheckUnknownTypeError(schema_);
      return FromKind2(schema_, references_, value3);
  }
};
function Check(...args) {
  return args.length === 3 ? Visit6(args[0], args[1], args[2]) : Visit6(args[0], [], args[1]);
}

class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema) {
    super(`Unknown type`);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clone/clone.mjs
var ObjectType3 = function(value3) {
  const keys = [...Object.getOwnPropertyNames(value3), ...Object.getOwnPropertySymbols(value3)];
  return keys.reduce((acc, key) => ({ ...acc, [key]: Clone2(value3[key]) }), {});
};
var ArrayType3 = function(value3) {
  return value3.map((element) => Clone2(element));
};
var TypedArrayType = function(value3) {
  return value3.slice();
};
var DateType3 = function(value3) {
  return new Date(value3.toISOString());
};
var ValueType = function(value3) {
  return value3;
};
function Clone2(value3) {
  if (IsArray(value3))
    return ArrayType3(value3);
  if (IsDate(value3))
    return DateType3(value3);
  if (IsStandardObject(value3))
    return ObjectType3(value3);
  if (IsTypedArray(value3))
    return TypedArrayType(value3);
  if (IsValueType(value3))
    return ValueType(value3);
  throw new Error("ValueClone: Unable to clone value");
}
// node_modules/@sinclair/typebox/build/import/value/create/create.mjs
var FromDefault = function(value3) {
  return typeof value3 === "function" ? value3 : Clone2(value3);
};
var FromAny4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromArray6 = function(schema, references) {
  if (schema.uniqueItems === true && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in schema && !HasPropertyKey(schema, "default")) {
    throw new ValueCreateError(schema, "Array with the contains constraint requires a default value");
  } else if ("default" in schema) {
    return FromDefault(schema.default);
  } else if (schema.minItems !== undefined) {
    return Array.from({ length: schema.minItems }).map((item) => {
      return Visit7(schema.items, references);
    });
  } else {
    return [];
  }
};
var FromAsyncIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return async function* () {
    }();
  }
};
var FromBigInt4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return BigInt(0);
  }
};
var FromBoolean4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return false;
  }
};
var FromConstructor4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = Visit7(schema.returns, references);
    if (typeof value3 === "object" && !Array.isArray(value3)) {
      return class {
        constructor() {
          for (const [key, val] of Object.entries(value3)) {
            const self2 = this;
            self2[key] = val;
          }
        }
      };
    } else {
      return class {
      };
    }
  }
};
var FromDate4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimumTimestamp !== undefined) {
    return new Date(schema.minimumTimestamp);
  } else {
    return new Date;
  }
};
var FromFunction4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return () => Visit7(schema.returns, references);
  }
};
var FromInteger4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromIntersect6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const value3 = schema.allOf.reduce((acc, schema2) => {
      const next = Visit7(schema2, references);
      return typeof next === "object" ? { ...acc, ...next } : next;
    }, {});
    if (!Check(schema, references, value3))
      throw new ValueCreateError(schema, "Intersect produced invalid value. Consider using a default value.");
    return value3;
  }
};
var FromIterator4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return function* () {
    }();
  }
};
var FromLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return schema.const;
  }
};
var FromNever4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Never types cannot be created. Consider using a default value.");
  }
};
var FromNot4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "Not types must have a default value");
  }
};
var FromNull4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return null;
  }
};
var FromNumber4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minimum !== undefined) {
    return schema.minimum;
  } else {
    return 0;
  }
};
var FromObject4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    const required = new Set(schema.required);
    return FromDefault(schema.default) || Object.entries(schema.properties).reduce((acc, [key, schema2]) => {
      return required.has(key) ? { ...acc, [key]: Visit7(schema2, references) } : { ...acc };
    }, {});
  }
};
var FromPromise4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Promise.resolve(Visit7(schema.item, references));
  }
};
var FromRecord4 = function(schema, references) {
  const [keyPattern, valueSchema] = Object.entries(schema.patternProperties)[0];
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (!(keyPattern === PatternStringExact || keyPattern === PatternNumberExact)) {
    const propertyKeys = keyPattern.slice(1, keyPattern.length - 1).split("|");
    return propertyKeys.reduce((acc, key) => {
      return { ...acc, [key]: Visit7(valueSchema, references) };
    }, {});
  } else {
    return {};
  }
};
var FromRef3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromRegExp4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new ValueCreateError(schema, "RegExp types cannot be created. Consider using a default value.");
  }
};
var FromString4 = function(schema, references) {
  if (schema.pattern !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with patterns must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else if (schema.format !== undefined) {
    if (!HasPropertyKey(schema, "default")) {
      throw new ValueCreateError(schema, "String types with formats must specify a default value");
    } else {
      return FromDefault(schema.default);
    }
  } else {
    if (HasPropertyKey(schema, "default")) {
      return FromDefault(schema.default);
    } else if (schema.minLength !== undefined) {
      return Array.from({ length: schema.minLength }).map(() => " ").join("");
    } else {
      return "";
    }
  }
};
var FromSymbol4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if ("value" in schema) {
    return Symbol.for(schema.value);
  } else {
    return Symbol();
  }
};
var FromTemplateLiteral5 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (!IsTemplateLiteralFinite(schema))
    throw new ValueCreateError(schema, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const generated = TemplateLiteralGenerate(schema);
  return generated[0];
};
var FromThis3 = function(schema, references) {
  if (recursiveDepth++ > recursiveMaxDepth)
    throw new ValueCreateError(schema, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return Visit7(Deref(schema, references), references);
  }
};
var FromTuple6 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  }
  if (schema.items === undefined) {
    return [];
  } else {
    return Array.from({ length: schema.minItems }).map((_, index) => Visit7(schema.items[index], references));
  }
};
var FromUndefined4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromUnion8 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return Visit7(schema.anyOf[0], references);
  }
};
var FromUint8Array4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else if (schema.minByteLength !== undefined) {
    return new Uint8Array(schema.minByteLength);
  } else {
    return new Uint8Array(0);
  }
};
var FromUnknown4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return {};
  }
};
var FromVoid4 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    return;
  }
};
var FromKind3 = function(schema, references) {
  if (HasPropertyKey(schema, "default")) {
    return FromDefault(schema.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
};
var Visit7 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Any":
      return FromAny4(schema_, references_);
    case "Array":
      return FromArray6(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator4(schema_, references_);
    case "BigInt":
      return FromBigInt4(schema_, references_);
    case "Boolean":
      return FromBoolean4(schema_, references_);
    case "Constructor":
      return FromConstructor4(schema_, references_);
    case "Date":
      return FromDate4(schema_, references_);
    case "Function":
      return FromFunction4(schema_, references_);
    case "Integer":
      return FromInteger4(schema_, references_);
    case "Intersect":
      return FromIntersect6(schema_, references_);
    case "Iterator":
      return FromIterator4(schema_, references_);
    case "Literal":
      return FromLiteral5(schema_, references_);
    case "Never":
      return FromNever4(schema_, references_);
    case "Not":
      return FromNot4(schema_, references_);
    case "Null":
      return FromNull4(schema_, references_);
    case "Number":
      return FromNumber4(schema_, references_);
    case "Object":
      return FromObject4(schema_, references_);
    case "Promise":
      return FromPromise4(schema_, references_);
    case "Record":
      return FromRecord4(schema_, references_);
    case "Ref":
      return FromRef3(schema_, references_);
    case "RegExp":
      return FromRegExp4(schema_, references_);
    case "String":
      return FromString4(schema_, references_);
    case "Symbol":
      return FromSymbol4(schema_, references_);
    case "TemplateLiteral":
      return FromTemplateLiteral5(schema_, references_);
    case "This":
      return FromThis3(schema_, references_);
    case "Tuple":
      return FromTuple6(schema_, references_);
    case "Undefined":
      return FromUndefined4(schema_, references_);
    case "Union":
      return FromUnion8(schema_, references_);
    case "Uint8Array":
      return FromUint8Array4(schema_, references_);
    case "Unknown":
      return FromUnknown4(schema_, references_);
    case "Void":
      return FromVoid4(schema_, references_);
    default:
      if (!exports_type.Has(schema_[Kind]))
        throw new ValueCreateError(schema_, "Unknown type");
      return FromKind3(schema_, references_);
  }
};
function Create2(...args) {
  recursiveDepth = 0;
  return args.length === 2 ? Visit7(args[0], args[1]) : Visit7(args[0], []);
}

class ValueCreateError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
var recursiveMaxDepth = 512;
var recursiveDepth = 0;
// node_modules/@sinclair/typebox/build/import/value/cast/cast.mjs
var ScoreUnion = function(schema, references, value3) {
  if (schema[Kind] === "Object" && typeof value3 === "object" && !IsNull(value3)) {
    const object3 = schema;
    const keys = Object.getOwnPropertyNames(value3);
    const entries = Object.entries(object3.properties);
    const [point, max] = [1 / entries.length, entries.length];
    return entries.reduce((acc, [key, schema2]) => {
      const literal7 = schema2[Kind] === "Literal" && schema2.const === value3[key] ? max : 0;
      const checks = Check(schema2, references, value3[key]) ? point : 0;
      const exists = keys.includes(key) ? point : 0;
      return acc + (literal7 + checks + exists);
    }, 0);
  } else {
    return Check(schema, references, value3) ? 1 : 0;
  }
};
var SelectUnion = function(union9, references, value3) {
  let [select, best] = [union9.anyOf[0], 0];
  for (const schema of union9.anyOf) {
    const score = ScoreUnion(schema, references, value3);
    if (score > best) {
      select = schema;
      best = score;
    }
  }
  return select;
};
var CastUnion = function(union9, references, value3) {
  if ("default" in union9) {
    return typeof value3 === "function" ? union9.default : Clone2(union9.default);
  } else {
    const schema = SelectUnion(union9, references, value3);
    return Cast(schema, references, value3);
  }
};
var DefaultClone = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : Create2(schema, references);
};
var Default = function(schema, references, value3) {
  return Check(schema, references, value3) ? value3 : Create2(schema, references);
};
var FromArray7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  const created = IsArray(value3) ? Clone2(value3) : Create2(schema, references);
  const minimum = IsNumber(schema.minItems) && created.length < schema.minItems ? [...created, ...Array.from({ length: schema.minItems - created.length }, () => null)] : created;
  const maximum = IsNumber(schema.maxItems) && minimum.length > schema.maxItems ? minimum.slice(0, schema.maxItems) : minimum;
  const casted = maximum.map((value4) => Visit8(schema.items, references, value4));
  if (schema.uniqueItems !== true)
    return casted;
  const unique = [...new Set(casted)];
  if (!Check(schema, references, unique))
    throw new ValueCastError(schema, "Array cast produced invalid data due to uniqueItems constraint");
  return unique;
};
var FromConstructor5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Create2(schema, references);
  const required = new Set(schema.returns.required || []);
  const result = function() {
  };
  for (const [key, property] of Object.entries(schema.returns.properties)) {
    if (!required.has(key) && value3.prototype[key] === undefined)
      continue;
    result.prototype[key] = Visit8(property, references, value3.prototype[key]);
  }
  return result;
};
var FromIntersect7 = function(schema, references, value3) {
  const created = Create2(schema, references);
  const mapped9 = IsStandardObject(created) && IsStandardObject(value3) ? { ...created, ...value3 } : value3;
  return Check(schema, references, mapped9) ? mapped9 : Create2(schema, references);
};
var FromNever5 = function(schema, references, value3) {
  throw new ValueCastError(schema, "Never types cannot be cast");
};
var FromObject5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return value3;
  if (value3 === null || typeof value3 !== "object")
    return Create2(schema, references);
  const required = new Set(schema.required || []);
  const result = {};
  for (const [key, property] of Object.entries(schema.properties)) {
    if (!required.has(key) && value3[key] === undefined)
      continue;
    result[key] = Visit8(property, references, value3[key]);
  }
  if (typeof schema.additionalProperties === "object") {
    const propertyNames = Object.getOwnPropertyNames(schema.properties);
    for (const propertyName of Object.getOwnPropertyNames(value3)) {
      if (propertyNames.includes(propertyName))
        continue;
      result[propertyName] = Visit8(schema.additionalProperties, references, value3[propertyName]);
    }
  }
  return result;
};
var FromRecord5 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (value3 === null || typeof value3 !== "object" || Array.isArray(value3) || value3 instanceof Date)
    return Create2(schema, references);
  const subschemaPropertyName = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const subschema = schema.patternProperties[subschemaPropertyName];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit8(subschema, references, propValue);
  }
  return result;
};
var FromRef4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromThis4 = function(schema, references, value3) {
  return Visit8(Deref(schema, references), references, value3);
};
var FromTuple7 = function(schema, references, value3) {
  if (Check(schema, references, value3))
    return Clone2(value3);
  if (!IsArray(value3))
    return Create2(schema, references);
  if (schema.items === undefined)
    return [];
  return schema.items.map((schema2, index) => Visit8(schema2, references, value3[index]));
};
var FromUnion9 = function(schema, references, value3) {
  return Check(schema, references, value3) ? Clone2(value3) : CastUnion(schema, references, value3);
};
var Visit8 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray7(schema_, references_, value3);
    case "Constructor":
      return FromConstructor5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect7(schema_, references_, value3);
    case "Never":
      return FromNever5(schema_, references_, value3);
    case "Object":
      return FromObject5(schema_, references_, value3);
    case "Record":
      return FromRecord5(schema_, references_, value3);
    case "Ref":
      return FromRef4(schema_, references_, value3);
    case "This":
      return FromThis4(schema_, references_, value3);
    case "Tuple":
      return FromTuple7(schema_, references_, value3);
    case "Union":
      return FromUnion9(schema_, references_, value3);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(schema, references, value3);
    default:
      return Default(schema_, references_, value3);
  }
};
function Cast(...args) {
  return args.length === 3 ? Visit8(args[0], args[1], args[2]) : Visit8(args[0], [], args[1]);
}

class ValueCastError extends TypeBoxError {
  schema;
  constructor(schema, message) {
    super(message);
    this.schema = schema;
  }
}
// node_modules/@sinclair/typebox/build/import/value/clean/clean.mjs
var IsCheckable = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var FromArray8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  return value3.map((value4) => Visit9(schema.items, references, value4));
};
var FromIntersect8 = function(schema, references, value3) {
  const unevaluatedProperties = schema.unevaluatedProperties;
  const intersections = schema.allOf.map((schema2) => Visit9(schema2, references, Clone2(value3)));
  const composite = intersections.reduce((acc, value4) => IsObject(value4) ? { ...acc, ...value4 } : value4, {});
  if (!IsObject(value3) || !IsObject(composite) || !IsSchema(unevaluatedProperties))
    return composite;
  const knownkeys = KeyOfPropertyKeys(schema);
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (knownkeys.includes(key))
      continue;
    if (Check(unevaluatedProperties, references, value3[key])) {
      composite[key] = Visit9(unevaluatedProperties, references, value3[key]);
    }
  }
  return composite;
};
var FromObject6 = function(schema, references, value3) {
  if (!IsObject(value3) || IsArray(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  for (const key of Object.getOwnPropertyNames(value3)) {
    if (key in schema.properties) {
      value3[key] = Visit9(schema.properties[key], references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRecord6 = function(schema, references, value3) {
  if (!IsObject(value3))
    return value3;
  const additionalProperties = schema.additionalProperties;
  const propertyKeys = Object.keys(value3);
  const [propertyKey, propertySchema] = Object.entries(schema.patternProperties)[0];
  const propertyKeyTest = new RegExp(propertyKey);
  for (const key of propertyKeys) {
    if (propertyKeyTest.test(key)) {
      value3[key] = Visit9(propertySchema, references, value3[key]);
      continue;
    }
    if (IsSchema(additionalProperties) && Check(additionalProperties, references, value3[key])) {
      value3[key] = Visit9(additionalProperties, references, value3[key]);
      continue;
    }
    delete value3[key];
  }
  return value3;
};
var FromRef5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromThis5 = function(schema, references, value3) {
  return Visit9(Deref(schema, references), references, value3);
};
var FromTuple8 = function(schema, references, value3) {
  if (!IsArray(value3))
    return value3;
  if (IsUndefined(schema.items))
    return [];
  const length = Math.min(value3.length, schema.items.length);
  for (let i = 0;i < length; i++) {
    value3[i] = Visit9(schema.items[i], references, value3[i]);
  }
  return value3.length > length ? value3.slice(0, length) : value3;
};
var FromUnion10 = function(schema, references, value3) {
  for (const inner of schema.anyOf) {
    if (IsCheckable(inner) && Check(inner, value3)) {
      return Visit9(inner, references, value3);
    }
  }
  return value3;
};
var Visit9 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray8(schema_, references_, value3);
    case "Intersect":
      return FromIntersect8(schema_, references_, value3);
    case "Object":
      return FromObject6(schema_, references_, value3);
    case "Record":
      return FromRecord6(schema_, references_, value3);
    case "Ref":
      return FromRef5(schema_, references_, value3);
    case "This":
      return FromThis5(schema_, references_, value3);
    case "Tuple":
      return FromTuple8(schema_, references_, value3);
    case "Union":
      return FromUnion10(schema_, references_, value3);
    default:
      return value3;
  }
};
function Clean(...args) {
  return args.length === 3 ? Visit9(args[0], args[1], args[2]) : Visit9(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/type/composite/composite.mjs
var CompositeKeys = function(T) {
  return T.reduce((Acc, L) => {
    return SetDistinct([...Acc, ...KeyOfPropertyKeys(L)]);
  }, []);
};
var FilterNever = function(T) {
  return T.filter((L) => !IsNever(L));
};
var CompositeProperty = function(T, K) {
  return T.reduce((Acc, L) => {
    return FilterNever([...Acc, ...IndexFromPropertyKeys(L, [K])]);
  }, []);
};
var CompositeProperties = function(T, K) {
  return K.reduce((Acc, L) => {
    return { ...Acc, [L]: IntersectEvaluated(CompositeProperty(T, L)) };
  }, {});
};
function Composite(T, options = {}) {
  const K = CompositeKeys(T);
  const P = CompositeProperties(T, K);
  const R = Object2(P, options);
  return R;
}
// node_modules/@sinclair/typebox/build/import/value/convert/convert.mjs
var IsStringNumeric = function(value3) {
  return IsString(value3) && !isNaN(value3) && !isNaN(parseFloat(value3));
};
var IsValueToString = function(value3) {
  return IsBigInt(value3) || IsBoolean(value3) || IsNumber(value3);
};
var IsValueTrue = function(value3) {
  return value3 === true || IsNumber(value3) && value3 === 1 || IsBigInt(value3) && value3 === BigInt("1") || IsString(value3) && (value3.toLowerCase() === "true" || value3 === "1");
};
var IsValueFalse = function(value3) {
  return value3 === false || IsNumber(value3) && (value3 === 0 || Object.is(value3, -0)) || IsBigInt(value3) && value3 === BigInt("0") || IsString(value3) && (value3.toLowerCase() === "false" || value3 === "0" || value3 === "-0");
};
var IsTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateTimeStringWithTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(value3);
};
var IsDateTimeStringWithoutTimeZone = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(value3);
};
var IsDateString = function(value3) {
  return IsString(value3) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(value3);
};
var TryConvertLiteralString = function(value3, target) {
  const conversion = TryConvertString(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralNumber = function(value3, target) {
  const conversion = TryConvertNumber(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteralBoolean = function(value3, target) {
  const conversion = TryConvertBoolean(value3);
  return conversion === target ? conversion : value3;
};
var TryConvertLiteral = function(schema, value3) {
  return IsString(schema.const) ? TryConvertLiteralString(value3, schema.const) : IsNumber(schema.const) ? TryConvertLiteralNumber(value3, schema.const) : IsBoolean(schema.const) ? TryConvertLiteralBoolean(value3, schema.const) : Clone2(value3);
};
var TryConvertBoolean = function(value3) {
  return IsValueTrue(value3) ? true : IsValueFalse(value3) ? false : value3;
};
var TryConvertBigInt = function(value3) {
  return IsStringNumeric(value3) ? BigInt(parseInt(value3)) : IsNumber(value3) ? BigInt(value3 | 0) : IsValueFalse(value3) ? BigInt(0) : IsValueTrue(value3) ? BigInt(1) : value3;
};
var TryConvertString = function(value3) {
  return IsValueToString(value3) ? value3.toString() : IsSymbol(value3) && value3.description !== undefined ? value3.description.toString() : value3;
};
var TryConvertNumber = function(value3) {
  return IsStringNumeric(value3) ? parseFloat(value3) : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertInteger = function(value3) {
  return IsStringNumeric(value3) ? parseInt(value3) : IsNumber(value3) ? value3 | 0 : IsValueTrue(value3) ? 1 : IsValueFalse(value3) ? 0 : value3;
};
var TryConvertNull = function(value3) {
  return IsString(value3) && value3.toLowerCase() === "null" ? null : value3;
};
var TryConvertUndefined = function(value3) {
  return IsString(value3) && value3 === "undefined" ? undefined : value3;
};
var TryConvertDate = function(value3) {
  return IsDate(value3) ? value3 : IsNumber(value3) ? new Date(value3) : IsValueTrue(value3) ? new Date(1) : IsValueFalse(value3) ? new Date(0) : IsStringNumeric(value3) ? new Date(parseInt(value3)) : IsTimeStringWithoutTimeZone(value3) ? new Date(`1970-01-01T${value3}.000Z`) : IsTimeStringWithTimeZone(value3) ? new Date(`1970-01-01T${value3}`) : IsDateTimeStringWithoutTimeZone(value3) ? new Date(`${value3}.000Z`) : IsDateTimeStringWithTimeZone(value3) ? new Date(value3) : IsDateString(value3) ? new Date(`${value3}T00:00:00.000Z`) : value3;
};
var Default2 = function(value3) {
  return value3;
};
var FromArray9 = function(schema, references, value3) {
  if (IsArray(value3)) {
    return value3.map((value4) => Visit10(schema.items, references, value4));
  }
  return value3;
};
var FromBigInt5 = function(schema, references, value3) {
  return TryConvertBigInt(value3);
};
var FromBoolean5 = function(schema, references, value3) {
  return TryConvertBoolean(value3);
};
var FromDate5 = function(schema, references, value3) {
  return TryConvertDate(value3);
};
var FromInteger5 = function(schema, references, value3) {
  return TryConvertInteger(value3);
};
var FromIntersect9 = function(schema, references, value3) {
  const allObjects = schema.allOf.every((schema2) => IsObject3(schema2));
  if (allObjects)
    return Visit10(Composite(schema.allOf), references, value3);
  return Visit10(schema.allOf[0], references, value3);
};
var FromLiteral6 = function(schema, references, value3) {
  return TryConvertLiteral(schema, value3);
};
var FromNull5 = function(schema, references, value3) {
  return TryConvertNull(value3);
};
var FromNumber5 = function(schema, references, value3) {
  return TryConvertNumber(value3);
};
var FromObject7 = function(schema, references, value3) {
  const isConvertable = IsObject(value3);
  if (!isConvertable)
    return value3;
  return Object.getOwnPropertyNames(schema.properties).reduce((value4, key) => {
    return !IsUndefined(value4[key]) ? { ...value4, [key]: Visit10(schema.properties[key], references, value4[key]) } : { ...value4 };
  }, value3);
};
var FromRecord7 = function(schema, references, value3) {
  const propertyKey = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[propertyKey];
  const result = {};
  for (const [propKey, propValue] of Object.entries(value3)) {
    result[propKey] = Visit10(property, references, propValue);
  }
  return result;
};
var FromRef6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromString5 = function(schema, references, value3) {
  return TryConvertString(value3);
};
var FromSymbol5 = function(schema, references, value3) {
  return IsString(value3) || IsNumber(value3) ? Symbol(value3) : value3;
};
var FromThis6 = function(schema, references, value3) {
  return Visit10(Deref(schema, references), references, value3);
};
var FromTuple9 = function(schema, references, value3) {
  const isConvertable = IsArray(value3) && !IsUndefined(schema.items);
  if (!isConvertable)
    return value3;
  return value3.map((value4, index) => {
    return index < schema.items.length ? Visit10(schema.items[index], references, value4) : value4;
  });
};
var FromUndefined5 = function(schema, references, value3) {
  return TryConvertUndefined(value3);
};
var FromUnion11 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    const converted = Visit10(subschema, references, value3);
    if (Check(subschema, references, converted)) {
      return converted;
    }
  }
  return value3;
};
var Visit10 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray9(schema_, references_, value3);
    case "BigInt":
      return FromBigInt5(schema_, references_, value3);
    case "Boolean":
      return FromBoolean5(schema_, references_, value3);
    case "Date":
      return FromDate5(schema_, references_, value3);
    case "Integer":
      return FromInteger5(schema_, references_, value3);
    case "Intersect":
      return FromIntersect9(schema_, references_, value3);
    case "Literal":
      return FromLiteral6(schema_, references_, value3);
    case "Null":
      return FromNull5(schema_, references_, value3);
    case "Number":
      return FromNumber5(schema_, references_, value3);
    case "Object":
      return FromObject7(schema_, references_, value3);
    case "Record":
      return FromRecord7(schema_, references_, value3);
    case "Ref":
      return FromRef6(schema_, references_, value3);
    case "String":
      return FromString5(schema_, references_, value3);
    case "Symbol":
      return FromSymbol5(schema_, references_, value3);
    case "This":
      return FromThis6(schema_, references_, value3);
    case "Tuple":
      return FromTuple9(schema_, references_, value3);
    case "Undefined":
      return FromUndefined5(schema_, references_, value3);
    case "Union":
      return FromUnion11(schema_, references_, value3);
    default:
      return Default2(value3);
  }
};
function Convert(...args) {
  return args.length === 3 ? Visit10(args[0], args[1], args[2]) : Visit10(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/default/default.mjs
var ValueOrDefault = function(schema, value3) {
  return value3 === undefined && "default" in schema ? Clone2(schema.default) : value3;
};
var IsCheckable2 = function(schema) {
  return IsSchema(schema) && schema[Kind] !== "Unsafe";
};
var IsDefaultSchema = function(value3) {
  return IsSchema(value3) && "default" in value3;
};
var FromArray10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted))
    return defaulted;
  for (let i = 0;i < defaulted.length; i++) {
    defaulted[i] = Visit11(schema.items, references, defaulted[i]);
  }
  return defaulted;
};
var FromIntersect10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  return schema.allOf.reduce((acc, schema2) => {
    const next = Visit11(schema2, references, defaulted);
    return IsObject(next) ? { ...acc, ...next } : next;
  }, {});
};
var FromObject8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const knownPropertyKeys = Object.getOwnPropertyNames(schema.properties);
  for (const key of knownPropertyKeys) {
    if (!IsDefaultSchema(schema.properties[key]))
      continue;
    defaulted[key] = Visit11(schema.properties[key], references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKeys.includes(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRecord8 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsObject(defaulted))
    return defaulted;
  const additionalPropertiesSchema = schema.additionalProperties;
  const [propertyKeyPattern, propertySchema] = Object.entries(schema.patternProperties)[0];
  const knownPropertyKey = new RegExp(propertyKeyPattern);
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (!(knownPropertyKey.test(key) && IsDefaultSchema(propertySchema)))
      continue;
    defaulted[key] = Visit11(propertySchema, references, defaulted[key]);
  }
  if (!IsDefaultSchema(additionalPropertiesSchema))
    return defaulted;
  for (const key of Object.getOwnPropertyNames(defaulted)) {
    if (knownPropertyKey.test(key))
      continue;
    defaulted[key] = Visit11(additionalPropertiesSchema, references, defaulted[key]);
  }
  return defaulted;
};
var FromRef7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, ValueOrDefault(schema, value3));
};
var FromThis7 = function(schema, references, value3) {
  return Visit11(Deref(schema, references), references, value3);
};
var FromTuple10 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  if (!IsArray(defaulted) || IsUndefined(schema.items))
    return defaulted;
  const [items, max] = [schema.items, Math.max(schema.items.length, defaulted.length)];
  for (let i = 0;i < max; i++) {
    if (i < items.length)
      defaulted[i] = Visit11(items[i], references, defaulted[i]);
  }
  return defaulted;
};
var FromUnion12 = function(schema, references, value3) {
  const defaulted = ValueOrDefault(schema, value3);
  for (const inner of schema.anyOf) {
    const result = Visit11(inner, references, defaulted);
    if (IsCheckable2(inner) && Check(inner, result)) {
      return result;
    }
  }
  return defaulted;
};
var Visit11 = function(schema, references, value3) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema_[Kind]) {
    case "Array":
      return FromArray10(schema_, references_, value3);
    case "Intersect":
      return FromIntersect10(schema_, references_, value3);
    case "Object":
      return FromObject8(schema_, references_, value3);
    case "Record":
      return FromRecord8(schema_, references_, value3);
    case "Ref":
      return FromRef7(schema_, references_, value3);
    case "This":
      return FromThis7(schema_, references_, value3);
    case "Tuple":
      return FromTuple10(schema_, references_, value3);
    case "Union":
      return FromUnion12(schema_, references_, value3);
    default:
      return ValueOrDefault(schema_, value3);
  }
};
function Default3(...args) {
  return args.length === 3 ? Visit11(args[0], args[1], args[2]) : Visit11(args[0], [], args[1]);
}
// node_modules/@sinclair/typebox/build/import/value/pointer/pointer.mjs
var exports_pointer = {};
__export(exports_pointer, {
  ValuePointerRootSetError: () => {
    {
      return ValuePointerRootSetError;
    }
  },
  ValuePointerRootDeleteError: () => {
    {
      return ValuePointerRootDeleteError;
    }
  },
  Set: () => {
    {
      return Set4;
    }
  },
  Has: () => {
    {
      return Has3;
    }
  },
  Get: () => {
    {
      return Get3;
    }
  },
  Format: () => {
    {
      return Format;
    }
  },
  Delete: () => {
    {
      return Delete3;
    }
  }
});
var Escape2 = function(component) {
  return component.indexOf("~") === -1 ? component : component.replace(/~1/g, "/").replace(/~0/g, "~");
};
function* Format(pointer) {
  if (pointer === "")
    return;
  let [start, end] = [0, 0];
  for (let i = 0;i < pointer.length; i++) {
    const char = pointer.charAt(i);
    if (char === "/") {
      if (i === 0) {
        start = i + 1;
      } else {
        end = i;
        yield Escape2(pointer.slice(start, end));
        start = i + 1;
      }
    } else {
      end = i;
    }
  }
  yield Escape2(pointer.slice(start));
}
function Set4(value3, pointer, update) {
  if (pointer === "")
    throw new ValuePointerRootSetError(value3, pointer, update);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      next[component] = {};
    owner = next;
    next = next[component];
    key = component;
  }
  owner[key] = update;
}
function Delete3(value3, pointer) {
  if (pointer === "")
    throw new ValuePointerRootDeleteError(value3, pointer);
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined || next[component] === null)
      return;
    owner = next;
    next = next[component];
    key = component;
  }
  if (Array.isArray(owner)) {
    const index = parseInt(key);
    owner.splice(index, 1);
  } else {
    delete owner[key];
  }
}
function Has3(value3, pointer) {
  if (pointer === "")
    return true;
  let [owner, next, key] = [null, value3, ""];
  for (const component of Format(pointer)) {
    if (next[component] === undefined)
      return false;
    owner = next;
    next = next[component];
    key = component;
  }
  return Object.getOwnPropertyNames(owner).includes(key);
}
function Get3(value3, pointer) {
  if (pointer === "")
    return value3;
  let current = value3;
  for (const component of Format(pointer)) {
    if (current[component] === undefined)
      return;
    current = current[component];
  }
  return current;
}

class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(value3, path, update) {
    super("Cannot set root value");
    this.value = value3;
    this.path = path;
    this.update = update;
  }
}

class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(value3, path) {
    super("Cannot delete root value");
    this.value = value3;
    this.path = path;
  }
}
// node_modules/@sinclair/typebox/build/import/value/delta/delta.mjs
var CreateUpdate = function(path, value3) {
  return { type: "update", path, value: value3 };
};
var CreateInsert = function(path, value3) {
  return { type: "insert", path, value: value3 };
};
var CreateDelete = function(path) {
  return { type: "delete", path };
};
function* ObjectType4(path, current, next) {
  if (!IsStandardObject(next))
    return yield CreateUpdate(path, next);
  const currentKeys = [...globalThis.Object.keys(current), ...globalThis.Object.getOwnPropertySymbols(current)];
  const nextKeys = [...globalThis.Object.keys(next), ...globalThis.Object.getOwnPropertySymbols(next)];
  for (const key of currentKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && nextKeys.includes(key))
      yield CreateUpdate(`${path}/${globalThis.String(key)}`, undefined);
  }
  for (const key of nextKeys) {
    if (IsUndefined(current[key]) || IsUndefined(next[key]))
      continue;
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    yield* Visit12(`${path}/${globalThis.String(key)}`, current[key], next[key]);
  }
  for (const key of nextKeys) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(current[key]))
      yield CreateInsert(`${path}/${globalThis.String(key)}`, next[key]);
  }
  for (const key of currentKeys.reverse()) {
    if (IsSymbol(key))
      throw new ValueDeltaSymbolError(key);
    if (IsUndefined(next[key]) && !nextKeys.includes(key))
      yield CreateDelete(`${path}/${globalThis.String(key)}`);
  }
}
function* ArrayType4(path, current, next) {
  if (!IsArray(next))
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
  for (let i = 0;i < next.length; i++) {
    if (i < current.length)
      continue;
    yield CreateInsert(`${path}/${i}`, next[i]);
  }
  for (let i = current.length - 1;i >= 0; i--) {
    if (i < next.length)
      continue;
    yield CreateDelete(`${path}/${i}`);
  }
}
function* TypedArrayType2(path, current, next) {
  if (!IsTypedArray(next) || current.length !== next.length || globalThis.Object.getPrototypeOf(current).constructor.name !== globalThis.Object.getPrototypeOf(next).constructor.name)
    return yield CreateUpdate(path, next);
  for (let i = 0;i < Math.min(current.length, next.length); i++) {
    yield* Visit12(`${path}/${i}`, current[i], next[i]);
  }
}
function* ValueType2(path, current, next) {
  if (current === next)
    return;
  yield CreateUpdate(path, next);
}
function* Visit12(path, current, next) {
  if (IsStandardObject(current))
    return yield* ObjectType4(path, current, next);
  if (IsArray(current))
    return yield* ArrayType4(path, current, next);
  if (IsTypedArray(current))
    return yield* TypedArrayType2(path, current, next);
  if (IsValueType(current))
    return yield* ValueType2(path, current, next);
  throw new ValueDeltaError(current, "Unable to create diff edits for unknown value");
}
function Diff(current, next) {
  return [...Visit12("", current, next)];
}
var IsRootUpdate = function(edits) {
  return edits.length > 0 && edits[0].path === "" && edits[0].type === "update";
};
var IsIdentity = function(edits) {
  return edits.length === 0;
};
function Patch(current, edits) {
  if (IsRootUpdate(edits)) {
    return Clone2(edits[0].value);
  }
  if (IsIdentity(edits)) {
    return Clone2(current);
  }
  const clone8 = Clone2(current);
  for (const edit of edits) {
    switch (edit.type) {
      case "insert": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "update": {
        exports_pointer.Set(clone8, edit.path, edit.value);
        break;
      }
      case "delete": {
        exports_pointer.Delete(clone8, edit.path);
        break;
      }
    }
  }
  return clone8;
}
var Insert = Object2({
  type: Literal("insert"),
  path: String2(),
  value: Unknown()
});
var Update = Object2({
  type: Literal("update"),
  path: String2(),
  value: Unknown()
});
var Delete4 = Object2({
  type: Literal("delete"),
  path: String2()
});
var Edit = Union([Insert, Update, Delete4]);

class ValueDeltaError extends TypeBoxError {
  value;
  constructor(value3, message) {
    super(message);
    this.value = value3;
  }
}

class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(value3) {
    super(value3, "Cannot diff objects with symbol keys");
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/equal/equal.mjs
var ObjectType5 = function(left, right) {
  if (!IsStandardObject(right))
    return false;
  const leftKeys = [...Object.keys(left), ...Object.getOwnPropertySymbols(left)];
  const rightKeys = [...Object.keys(right), ...Object.getOwnPropertySymbols(right)];
  if (leftKeys.length !== rightKeys.length)
    return false;
  return leftKeys.every((key) => Equal(left[key], right[key]));
};
var DateType4 = function(left, right) {
  return IsDate(right) && left.getTime() === right.getTime();
};
var ArrayType5 = function(left, right) {
  if (!IsArray(right) || left.length !== right.length)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var TypedArrayType3 = function(left, right) {
  if (!IsTypedArray(right) || left.length !== right.length || Object.getPrototypeOf(left).constructor.name !== Object.getPrototypeOf(right).constructor.name)
    return false;
  return left.every((value3, index) => Equal(value3, right[index]));
};
var ValueType3 = function(left, right) {
  return left === right;
};
function Equal(left, right) {
  if (IsStandardObject(left))
    return ObjectType5(left, right);
  if (IsDate(left))
    return DateType4(left, right);
  if (IsTypedArray(left))
    return TypedArrayType3(left, right);
  if (IsArray(left))
    return ArrayType5(left, right);
  if (IsValueType(left))
    return ValueType3(left, right);
  throw new Error("ValueEquals: Unable to compare value");
}
// node_modules/@sinclair/typebox/build/import/value/mutate/mutate.mjs
var ObjectType6 = function(root, path, current, next) {
  if (!IsStandardObject(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    const currentKeys = Object.keys(current);
    const nextKeys = Object.keys(next);
    for (const currentKey of currentKeys) {
      if (!nextKeys.includes(currentKey)) {
        delete current[currentKey];
      }
    }
    for (const nextKey of nextKeys) {
      if (!currentKeys.includes(nextKey)) {
        current[nextKey] = null;
      }
    }
    for (const nextKey of nextKeys) {
      Visit13(root, `${path}/${nextKey}`, current[nextKey], next[nextKey]);
    }
  }
};
var ArrayType6 = function(root, path, current, next) {
  if (!IsArray(current)) {
    exports_pointer.Set(root, path, Clone2(next));
  } else {
    for (let index = 0;index < next.length; index++) {
      Visit13(root, `${path}/${index}`, current[index], next[index]);
    }
    current.splice(next.length);
  }
};
var TypedArrayType4 = function(root, path, current, next) {
  if (IsTypedArray(current) && current.length === next.length) {
    for (let i = 0;i < current.length; i++) {
      current[i] = next[i];
    }
  } else {
    exports_pointer.Set(root, path, Clone2(next));
  }
};
var ValueType4 = function(root, path, current, next) {
  if (current === next)
    return;
  exports_pointer.Set(root, path, next);
};
var Visit13 = function(root, path, current, next) {
  if (IsArray(next))
    return ArrayType6(root, path, current, next);
  if (IsTypedArray(next))
    return TypedArrayType4(root, path, current, next);
  if (IsStandardObject(next))
    return ObjectType6(root, path, current, next);
  if (IsValueType(next))
    return ValueType4(root, path, current, next);
};
var IsNonMutableValue = function(value3) {
  return IsTypedArray(value3) || IsValueType(value3);
};
var IsMismatchedValue = function(current, next) {
  return IsStandardObject(current) && IsArray(next) || IsArray(current) && IsStandardObject(next);
};
function Mutate(current, next) {
  if (IsNonMutableValue(current) || IsNonMutableValue(next))
    throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(current, next))
    throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  Visit13(current, "", current, next);
}

class ValueMutateError extends TypeBoxError {
  constructor(message) {
    super(message);
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/decode.mjs
var Default4 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Decode(value3) : value3;
  } catch (error19) {
    throw new TransformDecodeError(schema, value3, error19);
  }
};
var FromArray11 = function(schema, references, value3) {
  return IsArray(value3) ? Default4(schema, value3.map((value4) => Visit14(schema.items, references, value4))) : Default4(schema, value3);
};
var FromIntersect11 = function(schema, references, value3) {
  if (!IsStandardObject(value3) || IsValueType(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(Index(schema, [key]), references, value4[key]) } : value4;
  }, value3);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromNot5 = function(schema, references, value3) {
  return Default4(schema, Visit14(schema.not, references, value3));
};
var FromObject9 = function(schema, references, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, value3);
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit14(schema.properties[key], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRecord9 = function(schema, references, value3) {
  if (!IsStandardObject(value3))
    return Default4(schema, value3);
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit14(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, value3);
  if (!IsSchema(schema.additionalProperties)) {
    return Default4(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  const unknownProperties = unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default4(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
  return Default4(schema, unknownProperties);
};
var FromRef8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromThis8 = function(schema, references, value3) {
  const target = Deref(schema, references);
  return Default4(schema, Visit14(target, references, value3));
};
var FromTuple11 = function(schema, references, value3) {
  return IsArray(value3) && IsArray(schema.items) ? Default4(schema, schema.items.map((schema2, index) => Visit14(schema2, references, value3[index]))) : Default4(schema, value3);
};
var FromUnion13 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const decoded = Visit14(subschema, references, value3);
    return Default4(schema, decoded);
  }
  return Default4(schema, value3);
};
var Visit14 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray11(schema_, references_, value3);
    case "Intersect":
      return FromIntersect11(schema_, references_, value3);
    case "Not":
      return FromNot5(schema_, references_, value3);
    case "Object":
      return FromObject9(schema_, references_, value3);
    case "Record":
      return FromRecord9(schema_, references_, value3);
    case "Ref":
      return FromRef8(schema_, references_, value3);
    case "Symbol":
      return Default4(schema_, value3);
    case "This":
      return FromThis8(schema_, references_, value3);
    case "Tuple":
      return FromTuple11(schema_, references_, value3);
    case "Union":
      return FromUnion13(schema_, references_, value3);
    default:
      return Default4(schema_, value3);
  }
};
function TransformDecode(schema, references, value3) {
  return Visit14(schema, references, value3);
}

class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error19) {
    super(`Unable to decode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error19;
  }
}

class TransformDecodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error19) {
    super(`${error19 instanceof Error ? error19.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/encode.mjs
var Default5 = function(schema, value3) {
  try {
    return IsTransform(schema) ? schema[TransformKind].Encode(value3) : value3;
  } catch (error20) {
    throw new TransformEncodeError(schema, value3, error20);
  }
};
var FromArray12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  return IsArray(defaulted) ? defaulted.map((value4) => Visit15(schema.items, references, value4)) : defaulted;
};
var FromIntersect12 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsStandardObject(value3) || IsValueType(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in defaulted ? { ...value4, [key]: Visit15(Index(schema, [key]), references, value4[key]) } : value4;
  }, defaulted);
  if (!IsTransform(schema.unevaluatedProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const unevaluatedProperties = schema.unevaluatedProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(unevaluatedProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromNot6 = function(schema, references, value3) {
  return Default5(schema.not, Default5(schema, value3));
};
var FromObject10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const knownKeys = KeyOfPropertyKeys(schema);
  const knownProperties = knownKeys.reduce((value4, key) => {
    return key in value4 ? { ...value4, [key]: Visit15(schema.properties[key], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return knownProperties;
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.includes(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRecord10 = function(schema, references, value3) {
  const defaulted = Default5(schema, value3);
  if (!IsStandardObject(value3))
    return defaulted;
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const knownKeys = new RegExp(pattern3);
  const knownProperties = Object.getOwnPropertyNames(value3).reduce((value4, key) => {
    return knownKeys.test(key) ? { ...value4, [key]: Visit15(schema.patternProperties[pattern3], references, value4[key]) } : value4;
  }, defaulted);
  if (!IsSchema(schema.additionalProperties)) {
    return Default5(schema, knownProperties);
  }
  const unknownKeys = Object.getOwnPropertyNames(knownProperties);
  const additionalProperties = schema.additionalProperties;
  return unknownKeys.reduce((value4, key) => {
    return !knownKeys.test(key) ? { ...value4, [key]: Default5(additionalProperties, value4[key]) } : value4;
  }, knownProperties);
};
var FromRef9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromThis9 = function(schema, references, value3) {
  const target = Deref(schema, references);
  const resolved = Visit15(target, references, value3);
  return Default5(schema, resolved);
};
var FromTuple12 = function(schema, references, value3) {
  const value1 = Default5(schema, value3);
  return IsArray(schema.items) ? schema.items.map((schema2, index) => Visit15(schema2, references, value1[index])) : [];
};
var FromUnion14 = function(schema, references, value3) {
  for (const subschema of schema.anyOf) {
    if (!Check(subschema, references, value3))
      continue;
    const value1 = Visit15(subschema, references, value3);
    return Default5(schema, value1);
  }
  for (const subschema of schema.anyOf) {
    const value1 = Visit15(subschema, references, value3);
    if (!Check(schema, references, value1))
      continue;
    return Default5(schema, value1);
  }
  return Default5(schema, value3);
};
var Visit15 = function(schema, references, value3) {
  const references_ = typeof schema.$id === "string" ? [...references, schema] : references;
  const schema_ = schema;
  switch (schema[Kind]) {
    case "Array":
      return FromArray12(schema_, references_, value3);
    case "Intersect":
      return FromIntersect12(schema_, references_, value3);
    case "Not":
      return FromNot6(schema_, references_, value3);
    case "Object":
      return FromObject10(schema_, references_, value3);
    case "Record":
      return FromRecord10(schema_, references_, value3);
    case "Ref":
      return FromRef9(schema_, references_, value3);
    case "This":
      return FromThis9(schema_, references_, value3);
    case "Tuple":
      return FromTuple12(schema_, references_, value3);
    case "Union":
      return FromUnion14(schema_, references_, value3);
    default:
      return Default5(schema_, value3);
  }
};
function TransformEncode(schema, references, value3) {
  return Visit15(schema, references, value3);
}

class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(schema, value3, error20) {
    super(`Unable to encode due to invalid value`);
    this.schema = schema;
    this.value = value3;
    this.error = error20;
  }
}

class TransformEncodeError extends TypeBoxError {
  schema;
  value;
  constructor(schema, value3, error20) {
    super(`${error20 instanceof Error ? error20.message : "Unknown error"}`);
    this.schema = schema;
    this.value = value3;
  }
}
// node_modules/@sinclair/typebox/build/import/value/transform/has.mjs
var FromArray13 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromAsyncIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromConstructor6 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromFunction5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.returns, references) || schema.parameters.some((schema2) => Visit16(schema2, references));
};
var FromIntersect13 = function(schema, references) {
  return IsTransform(schema) || IsTransform(schema.unevaluatedProperties) || schema.allOf.some((schema2) => Visit16(schema2, references));
};
var FromIterator5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.items, references);
};
var FromNot7 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.not, references);
};
var FromObject11 = function(schema, references) {
  return IsTransform(schema) || Object.values(schema.properties).some((schema2) => Visit16(schema2, references)) || IsSchema(schema.additionalProperties) && Visit16(schema.additionalProperties, references);
};
var FromPromise5 = function(schema, references) {
  return IsTransform(schema) || Visit16(schema.item, references);
};
var FromRecord11 = function(schema, references) {
  const pattern3 = Object.getOwnPropertyNames(schema.patternProperties)[0];
  const property = schema.patternProperties[pattern3];
  return IsTransform(schema) || Visit16(property, references) || IsSchema(schema.additionalProperties) && IsTransform(schema.additionalProperties);
};
var FromRef10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromThis10 = function(schema, references) {
  if (IsTransform(schema))
    return true;
  return Visit16(Deref(schema, references), references);
};
var FromTuple13 = function(schema, references) {
  return IsTransform(schema) || !IsUndefined(schema.items) && schema.items.some((schema2) => Visit16(schema2, references));
};
var FromUnion15 = function(schema, references) {
  return IsTransform(schema) || schema.anyOf.some((schema2) => Visit16(schema2, references));
};
var Visit16 = function(schema, references) {
  const references_ = IsString(schema.$id) ? [...references, schema] : references;
  const schema_ = schema;
  if (schema.$id && visited.has(schema.$id))
    return false;
  if (schema.$id)
    visited.add(schema.$id);
  switch (schema[Kind]) {
    case "Array":
      return FromArray13(schema_, references_);
    case "AsyncIterator":
      return FromAsyncIterator5(schema_, references_);
    case "Constructor":
      return FromConstructor6(schema_, references_);
    case "Function":
      return FromFunction5(schema_, references_);
    case "Intersect":
      return FromIntersect13(schema_, references_);
    case "Iterator":
      return FromIterator5(schema_, references_);
    case "Not":
      return FromNot7(schema_, references_);
    case "Object":
      return FromObject11(schema_, references_);
    case "Promise":
      return FromPromise5(schema_, references_);
    case "Record":
      return FromRecord11(schema_, references_);
    case "Ref":
      return FromRef10(schema_, references_);
    case "This":
      return FromThis10(schema_, references_);
    case "Tuple":
      return FromTuple13(schema_, references_);
    case "Union":
      return FromUnion15(schema_, references_);
    default:
      return IsTransform(schema);
  }
};
function HasTransform(schema, references) {
  visited.clear();
  return Visit16(schema, references);
}
var visited = new Set;
// node_modules/@sinclair/typebox/build/import/value/value/value.mjs
var exports_value2 = {};
__export(exports_value2, {
  Patch: () => {
    {
      return Patch2;
    }
  },
  Mutate: () => {
    {
      return Mutate2;
    }
  },
  Hash: () => {
    {
      return Hash2;
    }
  },
  Errors: () => {
    {
      return Errors2;
    }
  },
  Equal: () => {
    {
      return Equal2;
    }
  },
  Encode: () => {
    {
      return Encode;
    }
  },
  Diff: () => {
    {
      return Diff2;
    }
  },
  Default: () => {
    {
      return Default6;
    }
  },
  Decode: () => {
    {
      return Decode;
    }
  },
  Create: () => {
    {
      return Create3;
    }
  },
  Convert: () => {
    {
      return Convert2;
    }
  },
  Clone: () => {
    {
      return Clone3;
    }
  },
  Clean: () => {
    {
      return Clean2;
    }
  },
  Check: () => {
    {
      return Check2;
    }
  },
  Cast: () => {
    {
      return Cast2;
    }
  }
});
function Cast2(...args) {
  return Cast.apply(Cast, args);
}
function Create3(...args) {
  return Create2.apply(Create2, args);
}
function Check2(...args) {
  return Check.apply(Check, args);
}
function Clean2(...args) {
  return Clean.apply(Clean, args);
}
function Convert2(...args) {
  return Convert.apply(Convert, args);
}
function Clone3(value3) {
  return Clone2(value3);
}
function Decode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  if (!Check2(schema, references, value3))
    throw new TransformDecodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return TransformDecode(schema, references, value3);
}
function Default6(...args) {
  return Default3.apply(Default3, args);
}
function Encode(...args) {
  const [schema, references, value3] = args.length === 3 ? [args[0], args[1], args[2]] : [args[0], [], args[1]];
  const encoded = TransformEncode(schema, references, value3);
  if (!Check2(schema, references, encoded))
    throw new TransformEncodeCheckError(schema, value3, Errors2(schema, references, value3).First());
  return encoded;
}
function Errors2(...args) {
  return Errors.apply(Errors, args);
}
function Equal2(left, right) {
  return Equal(left, right);
}
function Diff2(current, next) {
  return Diff(current, next);
}
function Hash2(value3) {
  return Hash(value3);
}
function Patch2(current, edits) {
  return Patch(current, edits);
}
function Mutate2(current, next) {
  Mutate(current, next);
}
// node_modules/@sinclair/typebox/build/import/type/awaited/awaited.mjs
var FromRest4 = function(T) {
  return T.map((L) => AwaitedResolve(L));
};
var FromIntersect14 = function(T) {
  return Intersect(FromRest4(T));
};
var FromUnion16 = function(T) {
  return Union(FromRest4(T));
};
var FromPromise6 = function(T) {
  return AwaitedResolve(T);
};
var AwaitedResolve = function(T) {
  return IsIntersect(T) ? FromIntersect14(T.allOf) : IsUnion(T) ? FromUnion16(T.anyOf) : IsPromise2(T) ? FromPromise6(T.item) : T;
};
function Awaited(T, options = {}) {
  return CloneType(AwaitedResolve(T), options);
}
// node_modules/@sinclair/typebox/build/import/type/date/date.mjs
function Date2(options = {}) {
  return {
    ...options,
    [Kind]: "Date",
    type: "Date"
  };
}
// node_modules/@sinclair/typebox/build/import/type/null/null.mjs
function Null(options = {}) {
  return {
    ...options,
    [Kind]: "Null",
    type: "null"
  };
}
// node_modules/@sinclair/typebox/build/import/type/symbol/symbol.mjs
function Symbol2(options) {
  return { ...options, [Kind]: "Symbol", type: "symbol" };
}
// node_modules/@sinclair/typebox/build/import/type/undefined/undefined.mjs
function Undefined(options = {}) {
  return { ...options, [Kind]: "Undefined", type: "undefined" };
}
// node_modules/@sinclair/typebox/build/import/type/uint8array/uint8array.mjs
function Uint8Array2(options = {}) {
  return { ...options, [Kind]: "Uint8Array", type: "Uint8Array" };
}
// node_modules/@sinclair/typebox/build/import/type/const/const.mjs
var FromArray14 = function(T) {
  return T.map((L) => FromValue(L, false));
};
var FromProperties8 = function(value5) {
  return globalThis.Object.getOwnPropertyNames(value5).reduce((acc, key) => {
    return { ...acc, [key]: Readonly(FromValue(value5[key], false)) };
  }, {});
};
var ConditionalReadonly = function(T, root) {
  return root === true ? T : Readonly(T);
};
var FromValue = function(value5, root) {
  return IsAsyncIterator2(value5) ? ConditionalReadonly(Any(), root) : IsIterator2(value5) ? ConditionalReadonly(Any(), root) : IsArray2(value5) ? Readonly(Tuple(FromArray14(value5))) : IsUint8Array2(value5) ? Uint8Array2() : IsDate2(value5) ? Date2() : IsObject2(value5) ? ConditionalReadonly(Object2(FromProperties8(value5)), root) : IsFunction2(value5) ? ConditionalReadonly(Function2([], Unknown()), root) : IsUndefined2(value5) ? Undefined() : IsNull2(value5) ? Null() : IsSymbol2(value5) ? Symbol2() : IsBigInt2(value5) ? BigInt2() : IsNumber2(value5) ? Literal(value5) : IsBoolean2(value5) ? Literal(value5) : IsString2(value5) ? Literal(value5) : Object2({});
};
function Const(T, options = {}) {
  return CloneType(FromValue(T, true), options);
}
// node_modules/@sinclair/typebox/build/import/type/constructor-parameters/constructor-parameters.mjs
function ConstructorParameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/deref/deref.mjs
var FromRest5 = function(schema, references) {
  return schema.map((schema2) => Deref2(schema2, references));
};
var FromProperties9 = function(properties, references) {
  return globalThis.Object.getOwnPropertyNames(properties).reduce((acc, key) => {
    return { ...acc, [key]: Deref2(properties[key], references) };
  }, {});
};
var FromConstructor7 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromFunction6 = function(schema, references) {
  schema.parameters = FromRest5(schema.parameters, references);
  schema.returns = Deref2(schema.returns, references);
  return schema;
};
var FromIntersect15 = function(schema, references) {
  schema.allOf = FromRest5(schema.allOf, references);
  return schema;
};
var FromUnion17 = function(schema, references) {
  schema.anyOf = FromRest5(schema.anyOf, references);
  return schema;
};
var FromTuple14 = function(schema, references) {
  if (IsUndefined2(schema.items))
    return schema;
  schema.items = FromRest5(schema.items, references);
  return schema;
};
var FromArray15 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromObject12 = function(schema, references) {
  schema.properties = FromProperties9(schema.properties, references);
  return schema;
};
var FromPromise7 = function(schema, references) {
  schema.item = Deref2(schema.item, references);
  return schema;
};
var FromAsyncIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromIterator6 = function(schema, references) {
  schema.items = Deref2(schema.items, references);
  return schema;
};
var FromRef11 = function(schema, references) {
  const target = references.find((remote) => remote.$id === schema.$ref);
  if (target === undefined)
    throw Error(`Unable to dereference schema with \$id ${schema.$ref}`);
  const discard8 = Discard(target, ["$id"]);
  return Deref2(discard8, references);
};
var DerefResolve = function(schema, references) {
  return IsConstructor(schema) ? FromConstructor7(schema, references) : IsFunction3(schema) ? FromFunction6(schema, references) : IsIntersect(schema) ? FromIntersect15(schema, references) : IsUnion(schema) ? FromUnion17(schema, references) : IsTuple(schema) ? FromTuple14(schema, references) : IsArray3(schema) ? FromArray15(schema, references) : IsObject3(schema) ? FromObject12(schema, references) : IsPromise2(schema) ? FromPromise7(schema, references) : IsAsyncIterator3(schema) ? FromAsyncIterator6(schema, references) : IsIterator3(schema) ? FromIterator6(schema, references) : IsRef(schema) ? FromRef11(schema, references) : schema;
};
function Deref2(schema, references) {
  return DerefResolve(CloneType(schema), CloneRest(references));
}
// node_modules/@sinclair/typebox/build/import/type/enum/enum.mjs
function Enum(item, options = {}) {
  if (IsUndefined2(item))
    throw new Error("Enum undefined or empty");
  const values1 = globalThis.Object.getOwnPropertyNames(item).filter((key) => isNaN(key)).map((key) => item[key]);
  const values2 = [...new Set(values1)];
  const anyOf = values2.map((value7) => Literal(value7));
  return Union(anyOf, { ...options, [Hint]: "Enum" });
}
// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-template-literal.mjs
function ExcludeFromTemplateLiteral(L, R) {
  return Exclude(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude.mjs
var ExcludeRest = function(L, R) {
  const excluded = L.filter((inner) => ExtendsCheck(inner, R) === ExtendsResult.False);
  return excluded.length === 1 ? excluded[0] : Union(excluded);
};
function Exclude(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExcludeFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExcludeFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExcludeRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? Never() : L, options);
}

// node_modules/@sinclair/typebox/build/import/type/exclude/exclude-from-mapped-result.mjs
var FromProperties10 = function(P, U) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Exclude(P[K2], U) };
  }, {});
};
var FromMappedResult7 = function(R, T) {
  return FromProperties10(R.properties, T);
};
function ExcludeFromMappedResult(R, T) {
  const P = FromMappedResult7(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-template-literal.mjs
function ExtractFromTemplateLiteral(L, R) {
  return Extract(TemplateLiteralToUnion(L), R);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract.mjs
var ExtractRest = function(L, R) {
  const extracted = L.filter((inner) => ExtendsCheck(inner, R) !== ExtendsResult.False);
  return extracted.length === 1 ? extracted[0] : Union(extracted);
};
function Extract(L, R, options = {}) {
  if (IsTemplateLiteral(L))
    return CloneType(ExtractFromTemplateLiteral(L, R), options);
  if (IsMappedResult(L))
    return CloneType(ExtractFromMappedResult(L, R), options);
  return CloneType(IsUnion(L) ? ExtractRest(L.anyOf, R) : ExtendsCheck(L, R) !== ExtendsResult.False ? L : Never(), options);
}

// node_modules/@sinclair/typebox/build/import/type/extract/extract-from-mapped-result.mjs
var FromProperties11 = function(P, T) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Extract(P[K2], T) };
  }, {});
};
var FromMappedResult8 = function(R, T) {
  return FromProperties11(R.properties, T);
};
function ExtractFromMappedResult(R, T) {
  const P = FromMappedResult8(R, T);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/instance-type/instance-type.mjs
function InstanceType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/integer/integer.mjs
function Integer(options = {}) {
  return {
    ...options,
    [Kind]: "Integer",
    type: "integer"
  };
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic-from-mapped-key.mjs
var MappedIntrinsicPropertyKey = function(K, M, options) {
  return {
    [K]: Intrinsic(Literal(K), M, options)
  };
};
var MappedIntrinsicPropertyKeys = function(K, M, options) {
  return K.reduce((Acc, L) => {
    return { ...Acc, ...MappedIntrinsicPropertyKey(L, M, options) };
  }, {});
};
var MappedIntrinsicProperties = function(T, M, options) {
  return MappedIntrinsicPropertyKeys(T["keys"], M, options);
};
function IntrinsicFromMappedKey(T, M, options) {
  const P = MappedIntrinsicProperties(T, M, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/intrinsic.mjs
var ApplyUncapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toLowerCase(), rest].join("");
};
var ApplyCapitalize = function(value7) {
  const [first, rest] = [value7.slice(0, 1), value7.slice(1)];
  return [first.toUpperCase(), rest].join("");
};
var ApplyUppercase = function(value7) {
  return value7.toUpperCase();
};
var ApplyLowercase = function(value7) {
  return value7.toLowerCase();
};
var FromTemplateLiteral6 = function(schema, mode, options) {
  const expression = TemplateLiteralParseExact(schema.pattern);
  const finite3 = IsTemplateLiteralExpressionFinite(expression);
  if (!finite3)
    return { ...schema, pattern: FromLiteralValue(schema.pattern, mode) };
  const strings = [...TemplateLiteralExpressionGenerate(expression)];
  const literals = strings.map((value7) => Literal(value7));
  const mapped12 = FromRest6(literals, mode);
  const union15 = Union(mapped12);
  return TemplateLiteral([union15], options);
};
var FromLiteralValue = function(value7, mode) {
  return typeof value7 === "string" ? mode === "Uncapitalize" ? ApplyUncapitalize(value7) : mode === "Capitalize" ? ApplyCapitalize(value7) : mode === "Uppercase" ? ApplyUppercase(value7) : mode === "Lowercase" ? ApplyLowercase(value7) : value7 : value7.toString();
};
var FromRest6 = function(T, M) {
  return T.map((L) => Intrinsic(L, M));
};
function Intrinsic(schema, mode, options = {}) {
  return IsMappedKey(schema) ? IntrinsicFromMappedKey(schema, mode, options) : IsTemplateLiteral(schema) ? FromTemplateLiteral6(schema, mode, schema) : IsUnion(schema) ? Union(FromRest6(schema.anyOf, mode), options) : IsLiteral(schema) ? Literal(FromLiteralValue(schema.const, mode), options) : schema;
}

// node_modules/@sinclair/typebox/build/import/type/intrinsic/capitalize.mjs
function Capitalize(T, options = {}) {
  return Intrinsic(T, "Capitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/lowercase.mjs
function Lowercase(T, options = {}) {
  return Intrinsic(T, "Lowercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uncapitalize.mjs
function Uncapitalize(T, options = {}) {
  return Intrinsic(T, "Uncapitalize", options);
}
// node_modules/@sinclair/typebox/build/import/type/intrinsic/uppercase.mjs
function Uppercase(T, options = {}) {
  return Intrinsic(T, "Uppercase", options);
}
// node_modules/@sinclair/typebox/build/import/type/not/not.mjs
function Not2(schema, options) {
  return {
    ...options,
    [Kind]: "Not",
    not: CloneType(schema)
  };
}
// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-result.mjs
var FromProperties12 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Omit(P[K2], K, options) };
  }, {});
};
var FromMappedResult9 = function(R, K, options) {
  return FromProperties12(R.properties, K, options);
};
function OmitFromMappedResult(R, K, options) {
  const P = FromMappedResult9(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit.mjs
var FromIntersect16 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromUnion18 = function(T, K) {
  return T.map((T2) => OmitResolve(T2, K));
};
var FromProperty2 = function(T, K) {
  const { [K]: _, ...R } = T;
  return R;
};
var FromProperties13 = function(T, K) {
  return K.reduce((T2, K2) => {
    return FromProperty2(T2, K2);
  }, T);
};
var OmitResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect16(T.allOf, K)) : IsUnion(T) ? Union(FromUnion18(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties13(T.properties, K)) : Object2({});
};
function Omit(T, K, options = {}) {
  if (IsMappedKey(K))
    return OmitFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return OmitFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(OmitResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/omit/omit-from-mapped-key.mjs
var FromPropertyKey2 = function(T, K, options) {
  return {
    [K]: Omit(T, [K], options)
  };
};
var FromPropertyKeys2 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey2(T, LK, options) };
  }, {});
};
var FromMappedKey3 = function(T, K, options) {
  return FromPropertyKeys2(T, K.keys, options);
};
function OmitFromMappedKey(T, K, options) {
  const P = FromMappedKey3(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/parameters/parameters.mjs
function Parameters(schema, options = {}) {
  return Tuple(CloneRest(schema.parameters), { ...options });
}
// node_modules/@sinclair/typebox/build/import/type/partial/partial.mjs
var FromRest7 = function(T) {
  return T.map((L) => PartialResolve(L));
};
var FromProperties14 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Optional(T[K]) };
  }, {});
};
var PartialResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest7(T.allOf)) : IsUnion(T) ? Union(FromRest7(T.anyOf)) : IsObject3(T) ? Object2(FromProperties14(T.properties)) : Object2({});
};
function Partial(T, options = {}) {
  if (IsMappedResult(T))
    return PartialFromMappedResult(T, options);
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PartialResolve(T), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/partial/partial-from-mapped-result.mjs
var FromProperties15 = function(K, options) {
  return globalThis.Object.getOwnPropertyNames(K).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Partial(K[K2], options) };
  }, {});
};
var FromMappedResult10 = function(R, options) {
  return FromProperties15(R.properties, options);
};
function PartialFromMappedResult(R, options) {
  const P = FromMappedResult10(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-result.mjs
var FromProperties16 = function(P, K, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Pick(P[K2], K, options) };
  }, {});
};
var FromMappedResult11 = function(R, K, options) {
  return FromProperties16(R.properties, K, options);
};
function PickFromMappedResult(R, K, options) {
  const P = FromMappedResult11(R, K, options);
  return MappedResult(P);
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick.mjs
var FromIntersect17 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromUnion19 = function(T, K) {
  return T.map((T2) => PickResolve(T2, K));
};
var FromProperties17 = function(T, K) {
  return K.reduce((Acc, K2) => {
    return K2 in T ? { ...Acc, [K2]: T[K2] } : Acc;
  }, {});
};
var PickResolve = function(T, K) {
  return IsIntersect(T) ? Intersect(FromIntersect17(T.allOf, K)) : IsUnion(T) ? Union(FromUnion19(T.anyOf, K)) : IsObject3(T) ? Object2(FromProperties17(T.properties, K)) : Object2({});
};
function Pick(T, K, options = {}) {
  if (IsMappedKey(K))
    return PickFromMappedKey(T, K, options);
  if (IsMappedResult(T))
    return PickFromMappedResult(T, K, options);
  const I = IsSchema(K) ? IndexPropertyKeys(K) : K;
  const D = Discard(T, [TransformKind, "$id", "required"]);
  const R = CloneType(PickResolve(T, I), options);
  return { ...D, ...R };
}

// node_modules/@sinclair/typebox/build/import/type/pick/pick-from-mapped-key.mjs
var FromPropertyKey3 = function(T, K, options) {
  return {
    [K]: Pick(T, [K], options)
  };
};
var FromPropertyKeys3 = function(T, K, options) {
  return K.reduce((Acc, LK) => {
    return { ...Acc, ...FromPropertyKey3(T, LK, options) };
  }, {});
};
var FromMappedKey4 = function(T, K, options) {
  return FromPropertyKeys3(T, K.keys, options);
};
function PickFromMappedKey(T, K, options) {
  const P = FromMappedKey4(T, K, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/readonly-optional/readonly-optional.mjs
function ReadonlyOptional(schema) {
  return Readonly(Optional(schema));
}
// node_modules/@sinclair/typebox/build/import/type/record/record.mjs
var RecordCreateFromPattern = function(pattern3, T, options) {
  return {
    ...options,
    [Kind]: "Record",
    type: "object",
    patternProperties: { [pattern3]: CloneType(T) }
  };
};
var RecordCreateFromKeys = function(K, T, options) {
  const P = K.reduce((Acc, K2) => ({ ...Acc, [K2]: CloneType(T) }), {});
  return Object2(P, { ...options, [Hint]: "Record" });
};
var FromTemplateLiteralKey = function(K, T, options) {
  return IsTemplateLiteralFinite(K) ? RecordCreateFromKeys(IndexPropertyKeys(K), T, options) : RecordCreateFromPattern(K.pattern, T, options);
};
var FromUnionKey = function(K, T, options) {
  return RecordCreateFromKeys(IndexPropertyKeys(Union(K)), T, options);
};
var FromLiteralKey = function(K, T, options) {
  return RecordCreateFromKeys([K.toString()], T, options);
};
var FromRegExpKey = function(K, T, options) {
  return RecordCreateFromPattern(K.source, T, options);
};
var FromStringKey = function(K, T, options) {
  const pattern3 = IsUndefined2(K.pattern) ? PatternStringExact : K.pattern;
  return RecordCreateFromPattern(pattern3, T, options);
};
var FromIntegerKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
var FromNumberKey = function(_, T, options) {
  return RecordCreateFromPattern(PatternNumberExact, T, options);
};
function Record(K, T, options = {}) {
  return IsUnion(K) ? FromUnionKey(K.anyOf, T, options) : IsTemplateLiteral(K) ? FromTemplateLiteralKey(K, T, options) : IsLiteral(K) ? FromLiteralKey(K.const, T, options) : IsInteger2(K) ? FromIntegerKey(K, T, options) : IsNumber3(K) ? FromNumberKey(K, T, options) : IsRegExp2(K) ? FromRegExpKey(K, T, options) : IsString3(K) ? FromStringKey(K, T, options) : Never(options);
}
// node_modules/@sinclair/typebox/build/import/type/recursive/recursive.mjs
function Recursive(callback, options = {}) {
  if (IsUndefined2(options.$id))
    options.$id = `T${Ordinal++}`;
  const thisType = callback({ [Kind]: "This", $ref: `${options.$id}` });
  thisType.$id = options.$id;
  return CloneType({ ...options, [Hint]: "Recursive", ...thisType });
}
var Ordinal = 0;
// node_modules/@sinclair/typebox/build/import/type/ref/ref.mjs
function Ref(unresolved, options = {}) {
  if (IsString2(unresolved))
    return { ...options, [Kind]: "Ref", $ref: unresolved };
  if (IsUndefined2(unresolved.$id))
    throw new Error("Reference target type must specify an $id");
  return {
    ...options,
    [Kind]: "Ref",
    $ref: unresolved.$id
  };
}
// node_modules/@sinclair/typebox/build/import/type/regexp/regexp.mjs
function RegExp2(unresolved, options = {}) {
  const expr = IsString2(unresolved) ? new globalThis.RegExp(unresolved) : unresolved;
  return { ...options, [Kind]: "RegExp", type: "RegExp", source: expr.source, flags: expr.flags };
}
// node_modules/@sinclair/typebox/build/import/type/required/required.mjs
var FromRest8 = function(T) {
  return T.map((L) => RequiredResolve(L));
};
var FromProperties18 = function(T) {
  return globalThis.Object.getOwnPropertyNames(T).reduce((Acc, K) => {
    return { ...Acc, [K]: Discard(T[K], [OptionalKind]) };
  }, {});
};
var RequiredResolve = function(T) {
  return IsIntersect(T) ? Intersect(FromRest8(T.allOf)) : IsUnion(T) ? Union(FromRest8(T.anyOf)) : IsObject3(T) ? Object2(FromProperties18(T.properties)) : Object2({});
};
function Required(T, options = {}) {
  if (IsMappedResult(T)) {
    return RequiredFromMappedResult(T, options);
  } else {
    const D = Discard(T, [TransformKind, "$id", "required"]);
    const R = CloneType(RequiredResolve(T), options);
    return { ...D, ...R };
  }
}

// node_modules/@sinclair/typebox/build/import/type/required/required-from-mapped-result.mjs
var FromProperties19 = function(P, options) {
  return globalThis.Object.getOwnPropertyNames(P).reduce((Acc, K2) => {
    return { ...Acc, [K2]: Required(P[K2], options) };
  }, {});
};
var FromMappedResult12 = function(R, options) {
  return FromProperties19(R.properties, options);
};
function RequiredFromMappedResult(R, options) {
  const P = FromMappedResult12(R, options);
  return MappedResult(P);
}
// node_modules/@sinclair/typebox/build/import/type/rest/rest.mjs
var RestResolve = function(T) {
  return IsIntersect(T) ? [...T.allOf] : IsUnion(T) ? [...T.anyOf] : IsTuple(T) ? [...T.items ?? []] : [];
};
function Rest(T) {
  return CloneRest(RestResolve(T));
}
// node_modules/@sinclair/typebox/build/import/type/return-type/return-type.mjs
function ReturnType(schema, options = {}) {
  return CloneType(schema.returns, options);
}
// node_modules/@sinclair/typebox/build/import/type/strict/strict.mjs
function Strict(schema2) {
  return JSON.parse(JSON.stringify(schema2));
}
// node_modules/@sinclair/typebox/build/import/type/transform/transform.mjs
function Transform(schema2) {
  return new TransformDecodeBuilder(schema2);
}

class TransformDecodeBuilder {
  schema;
  constructor(schema2) {
    this.schema = schema2;
  }
  Decode(decode2) {
    return new TransformEncodeBuilder(this.schema, decode2);
  }
}

class TransformEncodeBuilder {
  schema;
  decode;
  constructor(schema2, decode2) {
    this.schema = schema2;
    this.decode = decode2;
  }
  EncodeTransform(encode2, schema2) {
    const Encode2 = (value11) => schema2[TransformKind].Encode(encode2(value11));
    const Decode2 = (value11) => this.decode(schema2[TransformKind].Decode(value11));
    const Codec = { Encode: Encode2, Decode: Decode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  EncodeSchema(encode2, schema2) {
    const Codec = { Decode: this.decode, Encode: encode2 };
    return { ...schema2, [TransformKind]: Codec };
  }
  Encode(encode2) {
    const schema2 = CloneType(this.schema);
    return IsTransform(schema2) ? this.EncodeTransform(encode2, schema2) : this.EncodeSchema(encode2, schema2);
  }
}
// node_modules/@sinclair/typebox/build/import/type/void/void.mjs
function Void(options = {}) {
  return {
    ...options,
    [Kind]: "Void",
    type: "void"
  };
}
// node_modules/@sinclair/typebox/build/import/type/type/type.mjs
var exports_type3 = {};
__export(exports_type3, {
  Void: () => {
    {
      return Void;
    }
  },
  Uppercase: () => {
    {
      return Uppercase;
    }
  },
  Unsafe: () => {
    {
      return Unsafe;
    }
  },
  Unknown: () => {
    {
      return Unknown;
    }
  },
  Union: () => {
    {
      return Union;
    }
  },
  Undefined: () => {
    {
      return Undefined;
    }
  },
  Uncapitalize: () => {
    {
      return Uncapitalize;
    }
  },
  Uint8Array: () => {
    {
      return Uint8Array2;
    }
  },
  Tuple: () => {
    {
      return Tuple;
    }
  },
  Transform: () => {
    {
      return Transform;
    }
  },
  TemplateLiteral: () => {
    {
      return TemplateLiteral;
    }
  },
  Symbol: () => {
    {
      return Symbol2;
    }
  },
  String: () => {
    {
      return String2;
    }
  },
  Strict: () => {
    {
      return Strict;
    }
  },
  ReturnType: () => {
    {
      return ReturnType;
    }
  },
  Rest: () => {
    {
      return Rest;
    }
  },
  Required: () => {
    {
      return Required;
    }
  },
  RegExp: () => {
    {
      return RegExp2;
    }
  },
  Ref: () => {
    {
      return Ref;
    }
  },
  Recursive: () => {
    {
      return Recursive;
    }
  },
  Record: () => {
    {
      return Record;
    }
  },
  ReadonlyOptional: () => {
    {
      return ReadonlyOptional;
    }
  },
  Readonly: () => {
    {
      return Readonly;
    }
  },
  Promise: () => {
    {
      return Promise2;
    }
  },
  Pick: () => {
    {
      return Pick;
    }
  },
  Partial: () => {
    {
      return Partial;
    }
  },
  Parameters: () => {
    {
      return Parameters;
    }
  },
  Optional: () => {
    {
      return Optional;
    }
  },
  Omit: () => {
    {
      return Omit;
    }
  },
  Object: () => {
    {
      return Object2;
    }
  },
  Number: () => {
    {
      return Number2;
    }
  },
  Null: () => {
    {
      return Null;
    }
  },
  Not: () => {
    {
      return Not2;
    }
  },
  Never: () => {
    {
      return Never;
    }
  },
  Mapped: () => {
    {
      return Mapped;
    }
  },
  Lowercase: () => {
    {
      return Lowercase;
    }
  },
  Literal: () => {
    {
      return Literal;
    }
  },
  KeyOf: () => {
    {
      return KeyOf;
    }
  },
  Iterator: () => {
    {
      return Iterator;
    }
  },
  Intersect: () => {
    {
      return Intersect;
    }
  },
  Integer: () => {
    {
      return Integer;
    }
  },
  InstanceType: () => {
    {
      return InstanceType;
    }
  },
  Index: () => {
    {
      return Index;
    }
  },
  Function: () => {
    {
      return Function2;
    }
  },
  Extract: () => {
    {
      return Extract;
    }
  },
  Extends: () => {
    {
      return Extends;
    }
  },
  Exclude: () => {
    {
      return Exclude;
    }
  },
  Enum: () => {
    {
      return Enum;
    }
  },
  Deref: () => {
    {
      return Deref2;
    }
  },
  Date: () => {
    {
      return Date2;
    }
  },
  ConstructorParameters: () => {
    {
      return ConstructorParameters;
    }
  },
  Constructor: () => {
    {
      return Constructor;
    }
  },
  Const: () => {
    {
      return Const;
    }
  },
  Composite: () => {
    {
      return Composite;
    }
  },
  Capitalize: () => {
    {
      return Capitalize;
    }
  },
  Boolean: () => {
    {
      return Boolean2;
    }
  },
  BigInt: () => {
    {
      return BigInt2;
    }
  },
  Awaited: () => {
    {
      return Awaited;
    }
  },
  AsyncIterator: () => {
    {
      return AsyncIterator;
    }
  },
  Array: () => {
    {
      return Array2;
    }
  },
  Any: () => {
    {
      return Any;
    }
  }
});

// node_modules/@sinclair/typebox/build/import/type/type/index.mjs
var Type = exports_type3;
// node_modules/@sinclair/typebox/build/import/compiler/compiler.mjs
class TypeCheck {
  schema;
  references;
  checkFunc;
  code;
  hasTransform;
  constructor(schema3, references, checkFunc, code) {
    this.schema = schema3;
    this.references = references;
    this.checkFunc = checkFunc;
    this.code = code;
    this.hasTransform = HasTransform(schema3, references);
  }
  Code() {
    return this.code;
  }
  Errors(value11) {
    return Errors(this.schema, this.references, value11);
  }
  Check(value11) {
    return this.checkFunc(value11);
  }
  Decode(value11) {
    if (!this.checkFunc(value11))
      throw new TransformDecodeCheckError(this.schema, value11, this.Errors(value11).First());
    return this.hasTransform ? TransformDecode(this.schema, this.references, value11) : value11;
  }
  Encode(value11) {
    const encoded = this.hasTransform ? TransformEncode(this.schema, this.references, value11) : value11;
    if (!this.checkFunc(encoded))
      throw new TransformEncodeCheckError(this.schema, value11, this.Errors(value11).First());
    return encoded;
  }
}
var Character;
(function(Character2) {
  function DollarSign(code) {
    return code === 36;
  }
  Character2.DollarSign = DollarSign;
  function IsUnderscore(code) {
    return code === 95;
  }
  Character2.IsUnderscore = IsUnderscore;
  function IsAlpha(code) {
    return code >= 65 && code <= 90 || code >= 97 && code <= 122;
  }
  Character2.IsAlpha = IsAlpha;
  function IsNumeric(code) {
    return code >= 48 && code <= 57;
  }
  Character2.IsNumeric = IsNumeric;
})(Character || (Character = {}));
var MemberExpression;
(function(MemberExpression2) {
  function IsFirstCharacterNumeric(value11) {
    if (value11.length === 0)
      return false;
    return Character.IsNumeric(value11.charCodeAt(0));
  }
  function IsAccessor(value11) {
    if (IsFirstCharacterNumeric(value11))
      return false;
    for (let i = 0;i < value11.length; i++) {
      const code = value11.charCodeAt(i);
      const check11 = Character.IsAlpha(code) || Character.IsNumeric(code) || Character.DollarSign(code) || Character.IsUnderscore(code);
      if (!check11)
        return false;
    }
    return true;
  }
  function EscapeHyphen(key) {
    return key.replace(/'/g, "\\'");
  }
  function Encode2(object13, key) {
    return IsAccessor(key) ? `${object13}.${key}` : `${object13}['${EscapeHyphen(key)}']`;
  }
  MemberExpression2.Encode = Encode2;
})(MemberExpression || (MemberExpression = {}));
var Identifier;
(function(Identifier2) {
  function Encode2($id) {
    const buffer = [];
    for (let i = 0;i < $id.length; i++) {
      const code = $id.charCodeAt(i);
      if (Character.IsNumeric(code) || Character.IsAlpha(code)) {
        buffer.push($id.charAt(i));
      } else {
        buffer.push(`_${code}_`);
      }
    }
    return buffer.join("").replace(/__/g, "_");
  }
  Identifier2.Encode = Encode2;
})(Identifier || (Identifier = {}));
var LiteralString;
(function(LiteralString2) {
  function Escape3(content) {
    return content.replace(/'/g, "\\'");
  }
  LiteralString2.Escape = Escape3;
})(LiteralString || (LiteralString = {}));

class TypeCompilerUnknownTypeError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Unknown type");
    this.schema = schema3;
  }
}

class TypeCompilerTypeGuardError extends TypeBoxError {
  schema;
  constructor(schema3) {
    super("Preflight validation check failed to guard for the given schema");
    this.schema = schema3;
  }
}
var Policy;
(function(Policy2) {
  function IsExactOptionalProperty(value11, key, expression) {
    return TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${key}' in ${value11} ? ${expression} : true)` : `(${MemberExpression.Encode(value11, key)} !== undefined ? ${expression} : true)`;
  }
  Policy2.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}))` : `(typeof ${value11} === 'object' && ${value11} !== null)`;
  }
  Policy2.IsObjectLike = IsObjectLike;
  function IsRecordLike(value11) {
    return !TypeSystemPolicy.AllowArrayObject ? `(typeof ${value11} === 'object' && ${value11} !== null && !Array.isArray(${value11}) && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))` : `(typeof ${value11} === 'object' && ${value11} !== null && !(${value11} instanceof Date) && !(${value11} instanceof Uint8Array))`;
  }
  Policy2.IsRecordLike = IsRecordLike;
  function IsNumberLike(value11) {
    return !TypeSystemPolicy.AllowNaN ? `(typeof ${value11} === 'number' && Number.isFinite(${value11}))` : `typeof ${value11} === 'number'`;
  }
  Policy2.IsNumberLike = IsNumberLike;
  function IsVoidLike(value11) {
    return TypeSystemPolicy.AllowNullVoid ? `(${value11} === undefined || ${value11} === null)` : `${value11} === undefined`;
  }
  Policy2.IsVoidLike = IsVoidLike;
})(Policy || (Policy = {}));
var TypeCompiler;
(function(TypeCompiler2) {
  function IsAnyOrUnknown2(schema3) {
    return schema3[Kind] === "Any" || schema3[Kind] === "Unknown";
  }
  function* FromAny5(schema3, references, value11) {
    yield "true";
  }
  function* FromArray16(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    const [parameter, accumulator] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
    if (IsNumber(schema3.maxItems))
      yield `${value11}.length <= ${schema3.maxItems}`;
    if (IsNumber(schema3.minItems))
      yield `${value11}.length >= ${schema3.minItems}`;
    const elementExpression = CreateExpression(schema3.items, references, "value");
    yield `${value11}.every((${parameter}) => ${elementExpression})`;
    if (IsSchema(schema3.contains) || IsNumber(schema3.minContains) || IsNumber(schema3.maxContains)) {
      const containsSchema = IsSchema(schema3.contains) ? schema3.contains : Never();
      const checkExpression = CreateExpression(containsSchema, references, "value");
      const checkMinContains = IsNumber(schema3.minContains) ? [`(count >= ${schema3.minContains})`] : [];
      const checkMaxContains = IsNumber(schema3.maxContains) ? [`(count <= ${schema3.maxContains})`] : [];
      const checkCount = `const count = value.reduce((${accumulator}, ${parameter}) => ${checkExpression} ? acc + 1 : acc, 0)`;
      const check11 = [`(count > 0)`, ...checkMinContains, ...checkMaxContains].join(" && ");
      yield `((${parameter}) => { ${checkCount}; return ${check11}})(${value11})`;
    }
    if (schema3.uniqueItems === true) {
      const check11 = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
      const block = `const set = new Set(); for(const element of value) { ${check11} }`;
      yield `((${parameter}) => { ${block} )(${value11})`;
    }
  }
  function* FromAsyncIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.asyncIterator in ${value11})`;
  }
  function* FromBigInt6(schema3, references, value11) {
    yield `(typeof ${value11} === 'bigint')`;
    if (IsBigInt(schema3.exclusiveMaximum))
      yield `${value11} < BigInt(${schema3.exclusiveMaximum})`;
    if (IsBigInt(schema3.exclusiveMinimum))
      yield `${value11} > BigInt(${schema3.exclusiveMinimum})`;
    if (IsBigInt(schema3.maximum))
      yield `${value11} <= BigInt(${schema3.maximum})`;
    if (IsBigInt(schema3.minimum))
      yield `${value11} >= BigInt(${schema3.minimum})`;
    if (IsBigInt(schema3.multipleOf))
      yield `(${value11} % BigInt(${schema3.multipleOf})) === 0`;
  }
  function* FromBoolean6(schema3, references, value11) {
    yield `(typeof ${value11} === 'boolean')`;
  }
  function* FromConstructor8(schema3, references, value11) {
    yield* Visit17(schema3.returns, references, `${value11}.prototype`);
  }
  function* FromDate6(schema3, references, value11) {
    yield `(${value11} instanceof Date) && Number.isFinite(${value11}.getTime())`;
    if (IsNumber(schema3.exclusiveMaximumTimestamp))
      yield `${value11}.getTime() < ${schema3.exclusiveMaximumTimestamp}`;
    if (IsNumber(schema3.exclusiveMinimumTimestamp))
      yield `${value11}.getTime() > ${schema3.exclusiveMinimumTimestamp}`;
    if (IsNumber(schema3.maximumTimestamp))
      yield `${value11}.getTime() <= ${schema3.maximumTimestamp}`;
    if (IsNumber(schema3.minimumTimestamp))
      yield `${value11}.getTime() >= ${schema3.minimumTimestamp}`;
    if (IsNumber(schema3.multipleOfTimestamp))
      yield `(${value11}.getTime() % ${schema3.multipleOfTimestamp}) === 0`;
  }
  function* FromFunction7(schema3, references, value11) {
    yield `(typeof ${value11} === 'function')`;
  }
  function* FromInteger6(schema3, references, value11) {
    yield `(typeof ${value11} === 'number' && Number.isInteger(${value11}))`;
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromIntersect18(schema3, references, value11) {
    const check1 = schema3.allOf.map((schema4) => CreateExpression(schema4, references, value11)).join(" && ");
    if (schema3.unevaluatedProperties === false) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key))`;
      yield `(${check1} && ${check22})`;
    } else if (IsSchema(schema3.unevaluatedProperties)) {
      const keyCheck = CreateVariable(`${new RegExp(KeyOfPattern(schema3))};`);
      const check22 = `Object.getOwnPropertyNames(${value11}).every(key => ${keyCheck}.test(key) || ${CreateExpression(schema3.unevaluatedProperties, references, `${value11}[key]`)})`;
      yield `(${check1} && ${check22})`;
    } else {
      yield `(${check1})`;
    }
  }
  function* FromIterator7(schema3, references, value11) {
    yield `(typeof value === 'object' && Symbol.iterator in ${value11})`;
  }
  function* FromLiteral7(schema3, references, value11) {
    if (typeof schema3.const === "number" || typeof schema3.const === "boolean") {
      yield `(${value11} === ${schema3.const})`;
    } else {
      yield `(${value11} === '${LiteralString.Escape(schema3.const)}')`;
    }
  }
  function* FromNever6(schema3, references, value11) {
    yield `false`;
  }
  function* FromNot8(schema3, references, value11) {
    const expression = CreateExpression(schema3.not, references, value11);
    yield `(!${expression})`;
  }
  function* FromNull6(schema3, references, value11) {
    yield `(${value11} === null)`;
  }
  function* FromNumber6(schema3, references, value11) {
    yield Policy.IsNumberLike(value11);
    if (IsNumber(schema3.exclusiveMaximum))
      yield `${value11} < ${schema3.exclusiveMaximum}`;
    if (IsNumber(schema3.exclusiveMinimum))
      yield `${value11} > ${schema3.exclusiveMinimum}`;
    if (IsNumber(schema3.maximum))
      yield `${value11} <= ${schema3.maximum}`;
    if (IsNumber(schema3.minimum))
      yield `${value11} >= ${schema3.minimum}`;
    if (IsNumber(schema3.multipleOf))
      yield `(${value11} % ${schema3.multipleOf}) === 0`;
  }
  function* FromObject13(schema3, references, value11) {
    yield Policy.IsObjectLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const knownKeys = Object.getOwnPropertyNames(schema3.properties);
    for (const knownKey of knownKeys) {
      const memberExpression = MemberExpression.Encode(value11, knownKey);
      const property = schema3.properties[knownKey];
      if (schema3.required && schema3.required.includes(knownKey)) {
        yield* Visit17(property, references, memberExpression);
        if (ExtendsUndefinedCheck(property) || IsAnyOrUnknown2(property))
          yield `('${knownKey}' in ${value11})`;
      } else {
        const expression = CreateExpression(property, references, memberExpression);
        yield Policy.IsExactOptionalProperty(value11, knownKey, expression);
      }
    }
    if (schema3.additionalProperties === false) {
      if (schema3.required && schema3.required.length === knownKeys.length) {
        yield `Object.getOwnPropertyNames(${value11}).length === ${knownKeys.length}`;
      } else {
        const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
        yield `Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key))`;
      }
    }
    if (typeof schema3.additionalProperties === "object") {
      const expression = CreateExpression(schema3.additionalProperties, references, `${value11}[key]`);
      const keys = `[${knownKeys.map((key) => `'${key}'`).join(", ")}]`;
      yield `(Object.getOwnPropertyNames(${value11}).every(key => ${keys}.includes(key) || ${expression}))`;
    }
  }
  function* FromPromise8(schema3, references, value11) {
    yield `(typeof value === 'object' && typeof ${value11}.then === 'function')`;
  }
  function* FromRecord12(schema3, references, value11) {
    yield Policy.IsRecordLike(value11);
    if (IsNumber(schema3.minProperties))
      yield `Object.getOwnPropertyNames(${value11}).length >= ${schema3.minProperties}`;
    if (IsNumber(schema3.maxProperties))
      yield `Object.getOwnPropertyNames(${value11}).length <= ${schema3.maxProperties}`;
    const [patternKey, patternSchema] = Object.entries(schema3.patternProperties)[0];
    const variable = CreateVariable(`${new RegExp(patternKey)}`);
    const check1 = CreateExpression(patternSchema, references, "value");
    const check22 = IsSchema(schema3.additionalProperties) ? CreateExpression(schema3.additionalProperties, references, value11) : schema3.additionalProperties === false ? "false" : "true";
    const expression = `(${variable}.test(key) ? ${check1} : ${check22})`;
    yield `(Object.entries(${value11}).every(([key, value]) => ${expression}))`;
  }
  function* FromRef12(schema3, references, value11) {
    const target = Deref(schema3, references);
    if (state.functions.has(schema3.$ref))
      return yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
    yield* Visit17(target, references, value11);
  }
  function* FromRegExp5(schema3, references, value11) {
    const variable = CreateVariable(`${new RegExp(schema3.source, schema3.flags)};`);
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    yield `${variable}.test(${value11})`;
  }
  function* FromString6(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    if (IsNumber(schema3.maxLength))
      yield `${value11}.length <= ${schema3.maxLength}`;
    if (IsNumber(schema3.minLength))
      yield `${value11}.length >= ${schema3.minLength}`;
    if (schema3.pattern !== undefined) {
      const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
      yield `${variable}.test(${value11})`;
    }
    if (schema3.format !== undefined) {
      yield `format('${schema3.format}', ${value11})`;
    }
  }
  function* FromSymbol6(schema3, references, value11) {
    yield `(typeof ${value11} === 'symbol')`;
  }
  function* FromTemplateLiteral7(schema3, references, value11) {
    yield `(typeof ${value11} === 'string')`;
    const variable = CreateVariable(`${new RegExp(schema3.pattern)};`);
    yield `${variable}.test(${value11})`;
  }
  function* FromThis11(schema3, references, value11) {
    yield `${CreateFunctionName(schema3.$ref)}(${value11})`;
  }
  function* FromTuple15(schema3, references, value11) {
    yield `Array.isArray(${value11})`;
    if (schema3.items === undefined)
      return yield `${value11}.length === 0`;
    yield `(${value11}.length === ${schema3.maxItems})`;
    for (let i = 0;i < schema3.items.length; i++) {
      const expression = CreateExpression(schema3.items[i], references, `${value11}[${i}]`);
      yield `${expression}`;
    }
  }
  function* FromUndefined6(schema3, references, value11) {
    yield `${value11} === undefined`;
  }
  function* FromUnion20(schema3, references, value11) {
    const expressions = schema3.anyOf.map((schema4) => CreateExpression(schema4, references, value11));
    yield `(${expressions.join(" || ")})`;
  }
  function* FromUint8Array5(schema3, references, value11) {
    yield `${value11} instanceof Uint8Array`;
    if (IsNumber(schema3.maxByteLength))
      yield `(${value11}.length <= ${schema3.maxByteLength})`;
    if (IsNumber(schema3.minByteLength))
      yield `(${value11}.length >= ${schema3.minByteLength})`;
  }
  function* FromUnknown5(schema3, references, value11) {
    yield "true";
  }
  function* FromVoid5(schema3, references, value11) {
    yield Policy.IsVoidLike(value11);
  }
  function* FromKind4(schema3, references, value11) {
    const instance = state.instances.size;
    state.instances.set(instance, schema3);
    yield `kind('${schema3[Kind]}', ${instance}, ${value11})`;
  }
  function* Visit17(schema3, references, value11, useHoisting = true) {
    const references_ = IsString(schema3.$id) ? [...references, schema3] : references;
    const schema_ = schema3;
    if (useHoisting && IsString(schema3.$id)) {
      const functionName = CreateFunctionName(schema3.$id);
      if (state.functions.has(functionName)) {
        return yield `${functionName}(${value11})`;
      } else {
        const functionCode = CreateFunction(functionName, schema3, references, "value", false);
        state.functions.set(functionName, functionCode);
        return yield `${functionName}(${value11})`;
      }
    }
    switch (schema_[Kind]) {
      case "Any":
        return yield* FromAny5(schema_, references_, value11);
      case "Array":
        return yield* FromArray16(schema_, references_, value11);
      case "AsyncIterator":
        return yield* FromAsyncIterator7(schema_, references_, value11);
      case "BigInt":
        return yield* FromBigInt6(schema_, references_, value11);
      case "Boolean":
        return yield* FromBoolean6(schema_, references_, value11);
      case "Constructor":
        return yield* FromConstructor8(schema_, references_, value11);
      case "Date":
        return yield* FromDate6(schema_, references_, value11);
      case "Function":
        return yield* FromFunction7(schema_, references_, value11);
      case "Integer":
        return yield* FromInteger6(schema_, references_, value11);
      case "Intersect":
        return yield* FromIntersect18(schema_, references_, value11);
      case "Iterator":
        return yield* FromIterator7(schema_, references_, value11);
      case "Literal":
        return yield* FromLiteral7(schema_, references_, value11);
      case "Never":
        return yield* FromNever6(schema_, references_, value11);
      case "Not":
        return yield* FromNot8(schema_, references_, value11);
      case "Null":
        return yield* FromNull6(schema_, references_, value11);
      case "Number":
        return yield* FromNumber6(schema_, references_, value11);
      case "Object":
        return yield* FromObject13(schema_, references_, value11);
      case "Promise":
        return yield* FromPromise8(schema_, references_, value11);
      case "Record":
        return yield* FromRecord12(schema_, references_, value11);
      case "Ref":
        return yield* FromRef12(schema_, references_, value11);
      case "RegExp":
        return yield* FromRegExp5(schema_, references_, value11);
      case "String":
        return yield* FromString6(schema_, references_, value11);
      case "Symbol":
        return yield* FromSymbol6(schema_, references_, value11);
      case "TemplateLiteral":
        return yield* FromTemplateLiteral7(schema_, references_, value11);
      case "This":
        return yield* FromThis11(schema_, references_, value11);
      case "Tuple":
        return yield* FromTuple15(schema_, references_, value11);
      case "Undefined":
        return yield* FromUndefined6(schema_, references_, value11);
      case "Union":
        return yield* FromUnion20(schema_, references_, value11);
      case "Uint8Array":
        return yield* FromUint8Array5(schema_, references_, value11);
      case "Unknown":
        return yield* FromUnknown5(schema_, references_, value11);
      case "Void":
        return yield* FromVoid5(schema_, references_, value11);
      default:
        if (!exports_type.Has(schema_[Kind]))
          throw new TypeCompilerUnknownTypeError(schema3);
        return yield* FromKind4(schema_, references_, value11);
    }
  }
  const state = {
    language: "javascript",
    functions: new Map,
    variables: new Map,
    instances: new Map
  };
  function CreateExpression(schema3, references, value11, useHoisting = true) {
    return `(${[...Visit17(schema3, references, value11, useHoisting)].join(" && ")})`;
  }
  function CreateFunctionName($id) {
    return `check_${Identifier.Encode($id)}`;
  }
  function CreateVariable(expression) {
    const variableName = `local_${state.variables.size}`;
    state.variables.set(variableName, `const ${variableName} = ${expression}`);
    return variableName;
  }
  function CreateFunction(name, schema3, references, value11, useHoisting = true) {
    const [newline, pad] = ["\n", (length) => "".padStart(length, " ")];
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const expression = [...Visit17(schema3, references, value11, useHoisting)].map((expression2) => `${pad(4)}${expression2}`).join(` &&${newline}`);
    return `function ${name}(${parameter})${returns} {${newline}${pad(2)}return (${newline}${expression}${newline}${pad(2)})\n}`;
  }
  function CreateParameter(name, type75) {
    const annotation = state.language === "typescript" ? `: ${type75}` : "";
    return `${name}${annotation}`;
  }
  function CreateReturns(type75) {
    return state.language === "typescript" ? `: ${type75}` : "";
  }
  function Build(schema3, references, options) {
    const functionCode = CreateFunction("check", schema3, references, "value");
    const parameter = CreateParameter("value", "any");
    const returns = CreateReturns("boolean");
    const functions = [...state.functions.values()];
    const variables = [...state.variables.values()];
    const checkFunction = IsString(schema3.$id) ? `return function check(${parameter})${returns} {\n  return ${CreateFunctionName(schema3.$id)}(value)\n}` : `return ${functionCode}`;
    return [...variables, ...functions, checkFunction].join("\n");
  }
  function Code(...args) {
    const defaults = { language: "javascript" };
    const [schema3, references, options] = args.length === 2 && IsArray(args[1]) ? [args[0], args[1], defaults] : args.length === 2 && !IsArray(args[1]) ? [args[0], [], args[1]] : args.length === 3 ? [args[0], args[1], args[2]] : args.length === 1 ? [args[0], [], defaults] : [null, [], defaults];
    state.language = options.language;
    state.variables.clear();
    state.functions.clear();
    state.instances.clear();
    if (!IsSchema(schema3))
      throw new TypeCompilerTypeGuardError(schema3);
    for (const schema4 of references)
      if (!IsSchema(schema4))
        throw new TypeCompilerTypeGuardError(schema4);
    return Build(schema3, references, options);
  }
  TypeCompiler2.Code = Code;
  function Compile(schema3, references = []) {
    const generatedCode = Code(schema3, references, { language: "javascript" });
    const compiledFunction = globalThis.Function("kind", "format", "hash", generatedCode);
    const instances = new Map(state.instances);
    function typeRegistryFunction(kind, instance, value11) {
      if (!exports_type.Has(kind) || !instances.has(instance))
        return false;
      const checkFunc = exports_type.Get(kind);
      const schema4 = instances.get(instance);
      return checkFunc(schema4, value11);
    }
    function formatRegistryFunction(format, value11) {
      if (!exports_format.Has(format))
        return false;
      const checkFunc = exports_format.Get(format);
      return checkFunc(value11);
    }
    function hashFunction(value11) {
      return Hash(value11);
    }
    const checkFunction = compiledFunction(typeRegistryFunction, formatRegistryFunction, hashFunction);
    return new TypeCheck(schema3, references, checkFunction, generatedCode);
  }
  TypeCompiler2.Compile = Compile;
})(TypeCompiler || (TypeCompiler = {}));
// node_modules/elysia/dist/bun/index.js
var X$ = Object.create;
var { defineProperty: z1, getPrototypeOf: W$, getOwnPropertyNames: J$ } = Object;
var Q$ = Object.prototype.hasOwnProperty;
var T0 = ($, Z, X) => {
  X = $ != null ? X$(W$($)) : {};
  const W = Z || !$ || !$.__esModule ? z1(X, "default", { value: $, enumerable: true }) : X;
  for (let J of J$($))
    if (!Q$.call(W, J))
      z1(W, J, { get: () => $[J], enumerable: true });
  return W;
};
var J0 = ($, Z) => () => (Z || $((Z = { exports: {} }).exports, Z), Z.exports);
var I1 = J0((k$, i0) => {
  var z0 = function() {
  }, B$ = function($, Z, X) {
    this.fn = $, this.context = Z, this.once = X || false;
  }, O1 = function($, Z, X, W, J) {
    if (typeof X !== "function")
      throw new TypeError("The listener must be a function");
    var Y = new B$(X, W || $, J), Q = f ? f + Z : Z;
    if (!$._events[Q])
      $._events[Q] = Y, $._eventsCount++;
    else if (!$._events[Q].fn)
      $._events[Q].push(Y);
    else
      $._events[Q] = [$._events[Q], Y];
    return $;
  }, E0 = function($, Z) {
    if (--$._eventsCount === 0)
      $._events = new z0;
    else
      delete $._events[Z];
  }, g = function() {
    this._events = new z0, this._eventsCount = 0;
  }, Y$ = Object.prototype.hasOwnProperty, f = "~";
  if (Object.create) {
    if (z0.prototype = Object.create(null), !new z0().__proto__)
      f = false;
  }
  g.prototype.eventNames = function $() {
    var Z = [], X, W;
    if (this._eventsCount === 0)
      return Z;
    for (W in X = this._events)
      if (Y$.call(X, W))
        Z.push(f ? W.slice(1) : W);
    if (Object.getOwnPropertySymbols)
      return Z.concat(Object.getOwnPropertySymbols(X));
    return Z;
  };
  g.prototype.listeners = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return [];
    if (W.fn)
      return [W.fn];
    for (var J = 0, Y = W.length, Q = new Array(Y);J < Y; J++)
      Q[J] = W[J].fn;
    return Q;
  };
  g.prototype.listenerCount = function $(Z) {
    var X = f ? f + Z : Z, W = this._events[X];
    if (!W)
      return 0;
    if (W.fn)
      return 1;
    return W.length;
  };
  g.prototype.emit = function $(Z, X, W, J, Y, Q) {
    var _ = f ? f + Z : Z;
    if (!this._events[_])
      return false;
    var B = this._events[_], K = arguments.length, G, M;
    if (B.fn) {
      if (B.once)
        this.removeListener(Z, B.fn, undefined, true);
      switch (K) {
        case 1:
          return B.fn.call(B.context), true;
        case 2:
          return B.fn.call(B.context, X), true;
        case 3:
          return B.fn.call(B.context, X, W), true;
        case 4:
          return B.fn.call(B.context, X, W, J), true;
        case 5:
          return B.fn.call(B.context, X, W, J, Y), true;
        case 6:
          return B.fn.call(B.context, X, W, J, Y, Q), true;
      }
      for (M = 1, G = new Array(K - 1);M < K; M++)
        G[M - 1] = arguments[M];
      B.fn.apply(B.context, G);
    } else {
      var V = B.length, P;
      for (M = 0;M < V; M++) {
        if (B[M].once)
          this.removeListener(Z, B[M].fn, undefined, true);
        switch (K) {
          case 1:
            B[M].fn.call(B[M].context);
            break;
          case 2:
            B[M].fn.call(B[M].context, X);
            break;
          case 3:
            B[M].fn.call(B[M].context, X, W);
            break;
          case 4:
            B[M].fn.call(B[M].context, X, W, J);
            break;
          default:
            if (!G)
              for (P = 1, G = new Array(K - 1);P < K; P++)
                G[P - 1] = arguments[P];
            B[M].fn.apply(B[M].context, G);
        }
      }
    }
    return true;
  };
  g.prototype.on = function $(Z, X, W) {
    return O1(this, Z, X, W, false);
  };
  g.prototype.once = function $(Z, X, W) {
    return O1(this, Z, X, W, true);
  };
  g.prototype.removeListener = function $(Z, X, W, J) {
    var Y = f ? f + Z : Z;
    if (!this._events[Y])
      return this;
    if (!X)
      return E0(this, Y), this;
    var Q = this._events[Y];
    if (Q.fn) {
      if (Q.fn === X && (!J || Q.once) && (!W || Q.context === W))
        E0(this, Y);
    } else {
      for (var _ = 0, B = [], K = Q.length;_ < K; _++)
        if (Q[_].fn !== X || J && !Q[_].once || W && Q[_].context !== W)
          B.push(Q[_]);
      if (B.length)
        this._events[Y] = B.length === 1 ? B[0] : B;
      else
        E0(this, Y);
    }
    return this;
  };
  g.prototype.removeAllListeners = function $(Z) {
    var X;
    if (Z) {
      if (X = f ? f + Z : Z, this._events[X])
        E0(this, X);
    } else
      this._events = new z0, this._eventsCount = 0;
    return this;
  };
  g.prototype.off = g.prototype.removeListener;
  g.prototype.addListener = g.prototype.on;
  g.prefixed = f;
  g.EventEmitter = g;
  if (typeof i0 !== "undefined")
    i0.exports = g;
});
var X1 = J0((D6, H1) => {
  var A$ = function($) {
    var Z = $.indexOf("%");
    if (Z === -1)
      return $;
    var X = $.length, W = "", J = 0, Y = 0, Q = Z, _ = T1;
    while (Z > -1 && Z < X) {
      var B = E1($[Z + 1], 4), K = E1($[Z + 2], 0), G = B | K, M = Z1[G];
      if (_ = Z1[256 + _ + M], Y = Y << 6 | G & Z1[364 + M], _ === T1)
        W += $.slice(J, Q), W += Y <= 65535 ? String.fromCharCode(Y) : String.fromCharCode(55232 + (Y >> 10), 56320 + (Y & 1023)), Y = 0, J = Z + 3, Z = Q = $.indexOf("%", J);
      else if (_ === P$)
        return null;
      else {
        if (Z += 3, Z < X && $.charCodeAt(Z) === 37)
          continue;
        return null;
      }
    }
    return W + $.slice(J);
  }, E1 = function($, Z) {
    var X = V$[$];
    return X === undefined ? 255 : X << Z;
  }, T1 = 12, P$ = 0, Z1 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 7, 7, 10, 9, 9, 9, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84, 96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 127, 63, 63, 63, 0, 31, 15, 15, 15, 7, 7, 7], V$ = { "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15 };
  H1.exports = A$;
});
var f1 = J0((G6, g1) => {
  var w$ = function($) {
    const Z = new x1;
    if (typeof $ !== "string")
      return Z;
    let X = $.length, W = "", J = "", Y = -1, Q = -1, _ = false, B = false, K = false, G = false, M = false, V = 0;
    for (let P = 0;P < X + 1; P++)
      if (V = P !== X ? $.charCodeAt(P) : 38, V === 38) {
        if (M = Q > Y, !M)
          Q = P;
        if (W = $.slice(Y + 1, Q), M || W.length > 0) {
          if (K)
            W = W.replace(L1, " ");
          if (_)
            W = b1(W) || W;
          if (M) {
            if (J = $.slice(Q + 1, P), G)
              J = J.replace(L1, " ");
            if (B)
              J = b1(J) || J;
          }
          const z = Z[W];
          if (z === undefined)
            Z[W] = J;
          else if (z.pop)
            z.push(J);
          else
            Z[W] = [z, J];
        }
        J = "", Y = P, Q = P, _ = false, B = false, K = false, G = false;
      } else if (V === 61)
        if (Q <= Y)
          Q = P;
        else
          B = true;
      else if (V === 43)
        if (Q > Y)
          G = true;
        else
          K = true;
      else if (V === 37)
        if (Q > Y)
          B = true;
        else
          _ = true;
    return Z;
  }, b1 = X1(), L1 = /\+/g, x1 = function() {
  };
  x1.prototype = Object.create(null);
  g1.exports = w$;
});
var v1 = J0((K6, y1) => {
  var R$ = function($) {
    const Z = $.length;
    if (Z === 0)
      return "";
    let X = "", W = 0, J = 0;
    $:
      for (;J < Z; J++) {
        let Y = $.charCodeAt(J);
        while (Y < 128) {
          if (C$[Y] !== 1) {
            if (W < J)
              X += $.slice(W, J);
            W = J + 1, X += i[Y];
          }
          if (++J === Z)
            break $;
          Y = $.charCodeAt(J);
        }
        if (W < J)
          X += $.slice(W, J);
        if (Y < 2048) {
          W = J + 1, X += i[192 | Y >> 6] + i[128 | Y & 63];
          continue;
        }
        if (Y < 55296 || Y >= 57344) {
          W = J + 1, X += i[224 | Y >> 12] + i[128 | Y >> 6 & 63] + i[128 | Y & 63];
          continue;
        }
        if (++J, J >= Z)
          throw new Error("URI malformed");
        const Q = $.charCodeAt(J) & 1023;
        W = J + 1, Y = 65536 + ((Y & 1023) << 10 | Q), X += i[240 | Y >> 18] + i[128 | Y >> 12 & 63] + i[128 | Y >> 6 & 63] + i[128 | Y & 63];
      }
    if (W === 0)
      return $;
    if (W < Z)
      return X + $.slice(W);
    return X;
  }, i = Array.from({ length: 256 }, ($, Z) => "%" + ((Z < 16 ? "0" : "") + Z.toString(16)).toUpperCase()), C$ = new Int8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0]);
  y1.exports = { encodeString: R$ };
});
var u1 = J0((z6, m1) => {
  var k1 = function($) {
    const Z = typeof $;
    if (Z === "string")
      return W1($);
    else if (Z === "bigint")
      return $.toString();
    else if (Z === "boolean")
      return $ ? "true" : "false";
    else if (Z === "number" && Number.isFinite($))
      return $ < 1000000000000000000000 ? "" + $ : W1("" + $);
    return "";
  }, S$ = function($) {
    let Z = "";
    if ($ === null || typeof $ !== "object")
      return Z;
    const X = "&", W = Object.keys($), J = W.length;
    let Y = 0;
    for (let Q = 0;Q < J; Q++) {
      const _ = W[Q], B = $[_], K = W1(_) + "=";
      if (Q)
        Z += X;
      if (Array.isArray(B)) {
        Y = B.length;
        for (let G = 0;G < Y; G++) {
          if (G)
            Z += X;
          Z += K, Z += k1(B[G]);
        }
      } else
        Z += K, Z += k1(B);
    }
    return Z;
  }, { encodeString: W1 } = v1();
  m1.exports = S$;
});
var J1 = J0((M6, F0) => {
  var h1 = f1(), c1 = u1(), d1 = { parse: h1, stringify: c1 };
  F0.exports = d1;
  F0.exports.default = d1;
  F0.exports.parse = h1;
  F0.exports.stringify = c1;
});
var Q0 = ($, Z) => ({ part: $, store: null, inert: Z !== undefined ? new Map(Z.map((X) => [X.part.charCodeAt(0), X])) : null, params: null, wildcardStore: null });
var M1 = ($, Z) => ({ ...$, part: Z });
var U1 = ($) => ({ paramName: $, store: null, inert: null });

class o {
  root = {};
  history = [];
  static regex = { static: /:.+?(?=\/|$)/, params: /:.+?(?=\/|$)/g };
  add($, Z, X) {
    if (typeof Z !== "string")
      throw new TypeError("Route path must be a string");
    if (Z === "")
      Z = "/";
    else if (Z[0] !== "/")
      Z = `/${Z}`;
    this.history.push([$, Z, X]);
    const W = Z[Z.length - 1] === "*";
    if (W)
      Z = Z.slice(0, -1);
    const J = Z.split(o.regex.static), Y = Z.match(o.regex.params) || [];
    if (J[J.length - 1] === "")
      J.pop();
    let Q;
    if (!this.root[$])
      Q = this.root[$] = Q0("/");
    else
      Q = this.root[$];
    let _ = 0;
    for (let B = 0;B < J.length; ++B) {
      let K = J[B];
      if (B > 0) {
        const G = Y[_++].slice(1);
        if (Q.params === null)
          Q.params = U1(G);
        else if (Q.params.paramName !== G)
          throw new Error(`Cannot create route "${Z}" with parameter "${G}" ` + "because a route already exists with a different parameter name " + `("${Q.params.paramName}") in the same location`);
        const M = Q.params;
        if (M.inert === null) {
          Q = M.inert = Q0(K);
          continue;
        }
        Q = M.inert;
      }
      for (let G = 0;; ) {
        if (G === K.length) {
          if (G < Q.part.length) {
            const M = M1(Q, Q.part.slice(G));
            Object.assign(Q, Q0(K, [M]));
          }
          break;
        }
        if (G === Q.part.length) {
          if (Q.inert === null)
            Q.inert = new Map;
          else if (Q.inert.has(K.charCodeAt(G))) {
            Q = Q.inert.get(K.charCodeAt(G)), K = K.slice(G), G = 0;
            continue;
          }
          const M = Q0(K.slice(G));
          Q.inert.set(K.charCodeAt(G), M), Q = M;
          break;
        }
        if (K[G] !== Q.part[G]) {
          const M = M1(Q, Q.part.slice(G)), V = Q0(K.slice(G));
          Object.assign(Q, Q0(Q.part.slice(0, G), [M, V])), Q = V;
          break;
        }
        ++G;
      }
    }
    if (_ < Y.length) {
      const B = Y[_].slice(1);
      if (Q.params === null)
        Q.params = U1(B);
      else if (Q.params.paramName !== B)
        throw new Error(`Cannot create route "${Z}" with parameter "${B}" ` + "because a route already exists with a different parameter name " + `("${Q.params.paramName}") in the same location`);
      if (Q.params.store === null)
        Q.params.store = X;
      return Q.params.store;
    }
    if (W) {
      if (Q.wildcardStore === null)
        Q.wildcardStore = X;
      return Q.wildcardStore;
    }
    if (Q.store === null)
      Q.store = X;
    return Q.store;
  }
  find($, Z) {
    const X = this.root[$];
    if (!X)
      return null;
    return p0(Z, Z.length, X, 0);
  }
}
var p0 = ($, Z, X, W) => {
  const J = X?.part, Y = W + J.length;
  if (J.length > 1) {
    if (Y > Z)
      return null;
    if (J.length < 15) {
      for (let Q = 1, _ = W + 1;Q < J.length; ++Q, ++_)
        if (J.charCodeAt(Q) !== $.charCodeAt(_))
          return null;
    } else if ($.substring(W, Y) !== J)
      return null;
  }
  if (Y === Z) {
    if (X.store !== null)
      return { store: X.store, params: {} };
    if (X.wildcardStore !== null)
      return { store: X.wildcardStore, params: { "*": "" } };
    return null;
  }
  if (X.inert !== null) {
    const Q = X.inert.get($.charCodeAt(Y));
    if (Q !== undefined) {
      const _ = p0($, Z, Q, Y);
      if (_ !== null)
        return _;
    }
  }
  if (X.params !== null) {
    const Q = X.params, _ = $.indexOf("/", Y);
    if (_ !== Y) {
      if (_ === -1 || _ >= Z) {
        if (Q.store !== null) {
          const B = {};
          return B[Q.paramName] = $.substring(Y, Z), { store: Q.store, params: B };
        }
      } else if (Q.inert !== null) {
        const B = p0($, Z, Q.inert, _);
        if (B !== null)
          return B.params[Q.paramName] = $.substring(Y, _), B;
      }
    }
  }
  if (X.wildcardStore !== null)
    return { store: X.wildcardStore, params: { "*": $.substring(Y, Z) } };
  return null;
};
var j1 = T0(I1(), 1);
var N1 = j1.default;
var H0 = () => {
  let $;
  return [new Promise((X) => {
    $ = X;
  }), $];
};
var s = () => {
  const [$, Z] = H0(), [X, W] = H0(), J = [], Y = [];
  return { signal: $, consume: (Q) => {
    switch (Q.type) {
      case "begin":
        if (Q.unit && J.length === 0)
          for (let _ = 0;_ < Q.unit; _++) {
            const [B, K] = H0(), [G, M] = H0();
            J.push(B), Y.push([(V) => {
              K({ children: [], end: G, name: V.name ?? "", skip: false, time: V.time });
            }, (V) => {
              M(V);
            }]);
          }
        Z({ children: J, end: X, name: Q.name ?? "", skip: false, time: Q.time });
        break;
      case "end":
        W(Q.time);
        break;
    }
  }, consumeChild(Q) {
    switch (Q.type) {
      case "begin":
        if (!Y[0])
          return;
        const [_] = Y[0];
        _({ children: [], end: X, name: Q.name ?? "", skip: false, time: Q.time });
        break;
      case "end":
        const B = Y.shift();
        if (!B)
          return;
        B[1](Q.time);
    }
  }, resolve() {
    Z({ children: [], end: new Promise((Q) => Q(0)), name: "", skip: true, time: 0 });
    for (let [Q, _] of Y)
      Q({ children: [], end: new Promise((B) => B(0)), name: "", skip: true, time: 0 }), _(0);
    W(0);
  } };
};
var F1 = ($, Z, X) => {
  return async function W(W) {
    if (W.event !== "request" || W.type !== "begin")
      return;
    const J = W.id, Y = $(), Q = s(), _ = s(), B = s(), K = s(), G = s(), M = s(), V = s(), P = s();
    Q.consume(W);
    const z = (A) => {
      if (A.id === J)
        switch (A.event) {
          case "request":
            Q.consume(A);
            break;
          case "request.unit":
            Q.consumeChild(A);
            break;
          case "parse":
            _.consume(A);
            break;
          case "parse.unit":
            _.consumeChild(A);
            break;
          case "transform":
            B.consume(A);
            break;
          case "transform.unit":
            B.consumeChild(A);
            break;
          case "beforeHandle":
            K.consume(A);
            break;
          case "beforeHandle.unit":
            K.consumeChild(A);
            break;
          case "handle":
            G.consume(A);
            break;
          case "afterHandle":
            M.consume(A);
            break;
          case "afterHandle.unit":
            M.consumeChild(A);
            break;
          case "error":
            V.consume(A);
            break;
          case "error.unit":
            V.consumeChild(A);
            break;
          case "response":
            if (A.type === "begin")
              Q.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), M.resolve(), V.resolve();
            else
              Y.off("event", z);
            P.consume(A);
            break;
          case "response.unit":
            P.consumeChild(A);
            break;
          case "exit":
            Q.resolve(), _.resolve(), B.resolve(), K.resolve(), G.resolve(), M.resolve(), V.resolve();
            break;
        }
    };
    Y.on("event", z), await X({ id: J, context: W.ctx, set: W.ctx?.set, store: W.ctx?.store, time: W.time, request: Q.signal, parse: _.signal, transform: B.signal, beforeHandle: K.signal, handle: G.signal, afterHandle: M.signal, error: V.signal, response: P.signal }), Y.emit(`res${J}.${Z}`, undefined);
  };
};
var D$ = function($, Z) {
  if (typeof $ !== "string")
    throw new TypeError("argument str must be a string");
  var X = {}, W = Z || {}, J = W.decode || K$, Y = 0;
  while (Y < $.length) {
    var Q = $.indexOf("=", Y);
    if (Q === -1)
      break;
    var _ = $.indexOf(";", Y);
    if (_ === -1)
      _ = $.length;
    else if (_ < Q) {
      Y = $.lastIndexOf(";", Q - 1) + 1;
      continue;
    }
    var B = $.slice(Y, Q).trim();
    if (X[B] === undefined) {
      var K = $.slice(Q + 1, _).trim();
      if (K.charCodeAt(0) === 34)
        K = K.slice(1, -1);
      X[B] = U$(K, J);
    }
    Y = _ + 1;
  }
  return X;
};
var G$ = function($, Z, X) {
  var W = X || {}, J = W.encode || z$;
  if (typeof J !== "function")
    throw new TypeError("option encode is invalid");
  if (!b0.test($))
    throw new TypeError("argument name is invalid");
  var Y = J(Z);
  if (Y && !b0.test(Y))
    throw new TypeError("argument val is invalid");
  var Q = $ + "=" + Y;
  if (W.maxAge != null) {
    var _ = W.maxAge - 0;
    if (isNaN(_) || !isFinite(_))
      throw new TypeError("option maxAge is invalid");
    Q += "; Max-Age=" + Math.floor(_);
  }
  if (W.domain) {
    if (!b0.test(W.domain))
      throw new TypeError("option domain is invalid");
    Q += "; Domain=" + W.domain;
  }
  if (W.path) {
    if (!b0.test(W.path))
      throw new TypeError("option path is invalid");
    Q += "; Path=" + W.path;
  }
  if (W.expires) {
    var B = W.expires;
    if (!M$(B) || isNaN(B.valueOf()))
      throw new TypeError("option expires is invalid");
    Q += "; Expires=" + B.toUTCString();
  }
  if (W.httpOnly)
    Q += "; HttpOnly";
  if (W.secure)
    Q += "; Secure";
  if (W.partitioned)
    Q += "; Partitioned";
  if (W.priority) {
    var K = typeof W.priority === "string" ? W.priority.toLowerCase() : W.priority;
    switch (K) {
      case "low":
        Q += "; Priority=Low";
        break;
      case "medium":
        Q += "; Priority=Medium";
        break;
      case "high":
        Q += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (W.sameSite) {
    var G = typeof W.sameSite === "string" ? W.sameSite.toLowerCase() : W.sameSite;
    switch (G) {
      case true:
        Q += "; SameSite=Strict";
        break;
      case "lax":
        Q += "; SameSite=Lax";
        break;
      case "strict":
        Q += "; SameSite=Strict";
        break;
      case "none":
        Q += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return Q;
};
var K$ = function($) {
  return $.indexOf("%") !== -1 ? decodeURIComponent($) : $;
};
var z$ = function($) {
  return encodeURIComponent($);
};
var M$ = function($) {
  return _$.call($) === "[object Date]" || $ instanceof Date;
};
var U$ = function($, Z) {
  try {
    return Z($);
  } catch (X) {
    return $;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var L0 = D$;
var x0 = G$;
var _$ = Object.prototype.toString;
var b0 = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

class m {
  $;
  Z;
  name;
  setter;
  constructor($, Z = {}) {
    this._value = $;
    this.property = Z;
  }
  get() {
    return this._value;
  }
  get value() {
    return this._value;
  }
  set value($) {
    if (typeof $ === "object") {
      if (JSON.stringify(this.value) === JSON.stringify($))
        return;
    } else if (this.value === $)
      return;
    this._value = $, this.sync();
  }
  add($) {
    const Z = Object.assign(this.property, typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $);
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  set($) {
    const Z = typeof $ === "function" ? $(Object.assign(this.property, this.value)) : $;
    if ("value" in Z)
      this._value = Z.value, delete Z.value;
    return this.property = Z, this.sync();
  }
  remove($) {
    if (this.value === undefined)
      return;
    this.set({ domain: $?.domain, expires: new Date(0), maxAge: 0, path: $?.path, sameSite: $?.sameSite, secure: $?.secure, value: "" });
  }
  get domain() {
    return this.property.domain;
  }
  set domain($) {
    if (this.property.domain === $)
      return;
    this.property.domain = $, this.sync();
  }
  get expires() {
    return this.property.expires;
  }
  set expires($) {
    if (this.property.expires?.getTime() === $?.getTime())
      return;
    this.property.expires = $, this.sync();
  }
  get httpOnly() {
    return this.property.httpOnly;
  }
  set httpOnly($) {
    if (this.property.domain === $)
      return;
    this.property.httpOnly = $, this.sync();
  }
  get maxAge() {
    return this.property.maxAge;
  }
  set maxAge($) {
    if (this.property.maxAge === $)
      return;
    this.property.maxAge = $, this.sync();
  }
  get path() {
    return this.property.path;
  }
  set path($) {
    if (this.property.path === $)
      return;
    this.property.path = $, this.sync();
  }
  get priority() {
    return this.property.priority;
  }
  set priority($) {
    if (this.property.priority === $)
      return;
    this.property.priority = $, this.sync();
  }
  get sameSite() {
    return this.property.sameSite;
  }
  set sameSite($) {
    if (this.property.sameSite === $)
      return;
    this.property.sameSite = $, this.sync();
  }
  get secure() {
    return this.property.secure;
  }
  set secure($) {
    if (this.property.secure === $)
      return;
    this.property.secure = $, this.sync();
  }
  toString() {
    return typeof this.value === "object" ? JSON.stringify(this.value) : this.value?.toString() ?? "";
  }
  sync() {
    if (!this.name || !this.setter)
      return this;
    if (!this.setter.cookie)
      this.setter.cookie = { [this.name]: Object.assign(this.property, { value: this.toString() }) };
    else
      this.setter.cookie[this.name] = Object.assign(this.property, { value: this.toString() });
    return this;
  }
}
var P1 = ($, Z, X) => new Proxy($, { get(W, J) {
  if (J in W)
    return W[J];
  const Y = new m(undefined, X ? { ...X } : undefined);
  return Y.setter = Z, Y.name = J, Y;
}, set(W, J, Y) {
  if (!(Y instanceof m))
    return false;
  if (!Z.cookie)
    Z.cookie = {};
  return Y.setter = Z, Y.name = J, Y.sync(), W[J] = Y, true;
} });
var g0 = async ($, Z, { secret: X, sign: W, ...J } = {}) => {
  if (!Z)
    return P1({}, $, J);
  const Y = {}, Q = typeof X === "string";
  if (W && W !== true && !Array.isArray(W))
    W = [W];
  const _ = Object.keys(L0(Z));
  for (let B = 0;B < _.length; B++) {
    const K = _[B];
    let G = L0(Z)[K];
    if (W === true || W?.includes(K)) {
      if (!X)
        throw new Error("No secret is provided to cookie plugin");
      if (Q) {
        if (G = await l0(G, X), G === false)
          throw new M0(K);
      } else {
        let P = true;
        for (let z = 0;z < X.length; z++) {
          const A = await l0(G, X[z]);
          if (A !== false) {
            G = A, P = false;
            break;
          }
        }
        if (P)
          throw new M0(K);
      }
    }
    if (G === undefined)
      continue;
    const M = G.charCodeAt(0);
    if (M === 123 || M === 91)
      try {
        const P = new m(JSON.parse(G));
        P.setter = $, P.name = K, Y[K] = P;
        continue;
      } catch {
      }
    if (f0(G))
      G = +G;
    else if (G === "true")
      G = true;
    else if (G === "false")
      G = false;
    const V = new m(G, J);
    V.setter = $, V.name = K, Y[K] = V;
  }
  return P1(Y, $);
};
var U0 = "toJSON" in new Headers;
var u = ($) => {
  for (let Z in $)
    return true;
  return false;
};
var O0 = ($, Z) => {
  const X = $.size;
  if (X && Z && Z.status !== 206 && Z.status !== 304 && Z.status !== 412 && Z.status !== 416 || !Z && X) {
    if (Z) {
      if (Z.headers instanceof Headers) {
        if (U0)
          Z.headers = Z.headers.toJSON();
        else
          for (let [W, J] of Z.headers.entries())
            if (W in Z.headers)
              Z.headers[W] = J;
      }
      return new Response($, { status: Z.status, headers: Object.assign({ "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` }, Z.headers) });
    }
    return new Response($, { headers: { "accept-ranges": "bytes", "content-range": `bytes 0-${X - 1}/${X}` } });
  }
  return new Response($);
};
var A1 = ($, Z) => {
  if (!$ || !Array.isArray(Z))
    return $;
  $.delete("Set-Cookie");
  for (let X = 0;X < Z.length; X++) {
    const W = Z[X].indexOf("=");
    $.append("Set-Cookie", `${Z[X].slice(0, W)}=${Z[X].slice(W + 1)}`);
  }
  return $;
};
var V1 = ($) => {
  if (!$ || typeof $ !== "object" || !u($))
    return;
  const Z = [];
  for (let [X, W] of Object.entries($)) {
    if (!X || !W)
      continue;
    if (Array.isArray(W.value))
      for (let J = 0;J < W.value.length; J++) {
        let Y = W.value[J];
        if (Y === undefined || Y === null)
          continue;
        if (typeof Y === "object")
          Y = JSON.stringify(Y);
        Z.push(x0(X, Y, W));
      }
    else {
      let J = W.value;
      if (J === undefined || J === null)
        continue;
      if (typeof J === "object")
        J = JSON.stringify(J);
      Z.push(x0(X, W.value, W));
    }
  }
  if (Z.length === 0)
    return;
  if (Z.length === 1)
    return Z[0];
  return Z;
};
var v = ($, Z) => {
  if ($?.[$.$passthrough])
    $ = $[$.$passthrough];
  if ($?.[c])
    Z.status = $[c], $ = $.response;
  if (u(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I0[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u(Z.cookie))
      Z.headers["Set-Cookie"] = V1(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = A1(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return new Response("", Z);
        return Response.json($, Z);
      case "Response":
        const X = { ...Z.headers };
        if (U0)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Y] of $.headers.entries())
            if (J in Z.headers)
              Z.headers[J] = Y;
        for (let J in X)
          $.headers.append(J, X[J]);
        return $;
      case "Error":
        return h($, Z);
      case "Promise":
        return $.then((J) => v(J, Z));
      case "Function":
        return v($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (U0)
            Z.headers = $.headers.toJSON();
          else
            for (let [Y, Q] of $.headers.entries())
              if (Y in Z.headers)
                Z.headers[Y] = Q;
          for (let Y in J)
            $.headers.append(Y, J[Y]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => v(J, Z));
        if ($ instanceof Error)
          return h($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Error":
        return h($, Z);
      case "Promise":
        return $.then((W) => {
          const J = l(W);
          if (J !== undefined)
            return J;
          return new Response("");
        });
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => v(W, Z));
        if ($ instanceof Error)
          return h($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var y = ($, Z) => {
  if ($ === undefined || $ === null)
    return;
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    Z.status = $[c], $ = $.response;
  if (u(Z.headers) || Z.status !== 200 || Z.redirect || Z.cookie) {
    if (typeof Z.status === "string")
      Z.status = I0[Z.status];
    if (Z.redirect) {
      if (Z.headers.Location = Z.redirect, !Z.status || Z.status < 300 || Z.status >= 400)
        Z.status = 302;
    }
    if (Z.cookie && u(Z.cookie))
      Z.headers["Set-Cookie"] = V1(Z.cookie);
    if (Z.headers["Set-Cookie"] && Array.isArray(Z.headers["Set-Cookie"]))
      Z.headers = A1(new Headers(Z.headers), Z.headers["Set-Cookie"]);
    switch ($?.constructor?.name) {
      case "String":
        return new Response($, Z);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return Response.json($, Z);
      case "ReadableStream":
        if (!Z.headers["content-type"]?.startsWith("text/event-stream"))
          Z.headers["content-type"] = "text/event-stream; charset=utf-8";
        return new Response($, Z);
      case undefined:
        if (!$)
          return;
        return Response.json($, Z);
      case "Response":
        const X = Object.assign({}, Z.headers);
        if (U0)
          Z.headers = $.headers.toJSON();
        else
          for (let [J, Y] of $.headers.entries())
            if (!(J in Z.headers))
              Z.headers[J] = Y;
        for (let J in X)
          $.headers.append(J, X[J]);
        if ($.status !== Z.status)
          Z.status = $.status;
        return $;
      case "Promise":
        return $.then((J) => {
          const Y = y(J, Z);
          if (Y !== undefined)
            return Y;
          return;
        });
      case "Error":
        return h($, Z);
      case "Function":
        return y($(), Z);
      case "Number":
      case "Boolean":
        return new Response($.toString(), Z);
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response) {
          const J = { ...Z.headers };
          if (U0)
            Z.headers = $.headers.toJSON();
          else
            for (let [Y, Q] of $.headers.entries())
              if (Y in Z.headers)
                Z.headers[Y] = Q;
          for (let Y in J)
            $.headers.append(Y, J[Y]);
          return $;
        }
        if ($ instanceof Promise)
          return $.then((J) => y(J, Z));
        if ($ instanceof Error)
          return h($, Z);
        const W = JSON.stringify($);
        if (W.charCodeAt(0) === 123) {
          if (!Z.headers["Content-Type"])
            Z.headers["Content-Type"] = "application/json";
          return new Response(JSON.stringify($), Z);
        }
        return new Response(W, Z);
    }
  } else
    switch ($?.constructor?.name) {
      case "String":
        return new Response($);
      case "Blob":
        return O0($, Z);
      case "Object":
      case "Array":
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "ReadableStream":
        return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
      case undefined:
        if (!$)
          return new Response("");
        return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
      case "Response":
        return $;
      case "Promise":
        return $.then((W) => {
          const J = y(W, Z);
          if (J !== undefined)
            return J;
          return;
        });
      case "Error":
        return h($, Z);
      case "Function":
        return l($());
      case "Number":
      case "Boolean":
        return new Response($.toString());
      case "Cookie":
        if ($ instanceof m)
          return new Response($.value, Z);
        return new Response($?.toString(), Z);
      default:
        if ($ instanceof Response)
          return new Response($.body, { headers: { "Content-Type": "application/json" } });
        if ($ instanceof Promise)
          return $.then((W) => y(W, Z));
        if ($ instanceof Error)
          return h($, Z);
        const X = JSON.stringify($);
        if (X.charCodeAt(0) === 123)
          return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
        return new Response(X);
    }
};
var l = ($) => {
  if ($?.$passthrough)
    $ = $[$.$passthrough];
  if ($?.[c])
    return v($.response, { status: $[c], headers: {} });
  switch ($?.constructor?.name) {
    case "String":
      return new Response($);
    case "Blob":
      return O0($);
    case "Object":
    case "Array":
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "ReadableStream":
      return new Response($, { headers: { "Content-Type": "text/event-stream; charset=utf-8" } });
    case undefined:
      if (!$)
        return new Response("");
      return new Response(JSON.stringify($), { headers: { "content-type": "application/json" } });
    case "Response":
      return $;
    case "Error":
      return h($);
    case "Promise":
      return $.then(l);
    case "Function":
      return l($());
    case "Number":
    case "Boolean":
      return new Response($.toString());
    default:
      if ($ instanceof Response)
        return new Response($.body, { headers: { "Content-Type": "application/json" } });
      if ($ instanceof Promise)
        return $.then(l);
      if ($ instanceof Error)
        return h($);
      const Z = JSON.stringify($);
      if (Z.charCodeAt(0) === 123)
        return new Response(JSON.stringify($), { headers: { "Content-Type": "application/json" } });
      return new Response(Z);
  }
};
var h = ($, Z) => new Response(JSON.stringify({ name: $?.name, message: $?.message, cause: $?.cause }), { status: Z?.status !== 200 ? Z?.status ?? 500 : 500, headers: Z?.headers });
var r0 = ($) => $ && typeof $ === "object" && !Array.isArray($);
var t0 = ($, Z) => {
  const X = new URL($);
  return X.pathname = Z, X.toString();
};
var O$ = ($) => typeof $ === "function" && /^\s*class\s+/.test($.toString()) || $.toString().startsWith("[object ") || u(Object.getPrototypeOf($));
var d = ($, Z, { skipKeys: X } = {}) => {
  if (r0($) && r0(Z))
    for (let [W, J] of Object.entries(Z)) {
      if (X?.includes(W))
        continue;
      if (!r0(J)) {
        $[W] = J;
        continue;
      }
      if (!(W in $)) {
        $[W] = J;
        continue;
      }
      if (O$(J)) {
        $[W] = J;
        continue;
      }
      $[W] = d($[W], J);
    }
  return $;
};
var C1 = ($, Z) => d($, Z, { skipKeys: ["properties"] });
var H = ($, Z) => {
  if (!$)
    return [];
  const X = [...Array.isArray($) ? $ : [$]], W = [];
  for (let J of X)
    if (J.$elysiaChecksum)
      W.push(J.$elysiaChecksum);
  for (let J of Array.isArray(Z) ? Z : [Z])
    if (!W.includes(J?.$elysiaChecksum))
      X.push(J);
  return X;
};
var I$ = ["start", "request", "parse", "transform", "resolve", "beforeHandle", "afterHandle", "onResponse", "mapResponse", "trace", "error", "stop", "body", "headers", "params", "query", "response", "type", "detail"];
var n = ($, Z) => {
  return { ...$, ...Z, body: Z?.body ?? $?.body, headers: Z?.headers ?? $?.headers, params: Z?.params ?? $?.params, query: Z?.query ?? $?.query, response: Z?.response ?? $?.response, type: $?.type || Z?.type, detail: d(Z?.detail ?? {}, $?.detail ?? {}), parse: H($?.parse ?? [], Z?.parse ?? []), transform: H($?.transform ?? [], Z?.transform ?? []), beforeHandle: H($?.beforeHandle ?? [], Z?.beforeHandle ?? []), afterHandle: H($?.afterHandle ?? [], Z?.afterHandle ?? []), onResponse: H($?.onResponse ?? [], Z?.onResponse ?? []), mapResponse: H($?.mapResponse ?? [], Z?.mapResponse ?? []), trace: H($?.trace ?? [], Z?.trace ?? []), error: H($?.error ?? [], Z?.error ?? []) };
};
var p = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $;
  if (J.type === "object" && "additionalProperties" in J === false)
    J.additionalProperties = X;
  if (W)
    return { schema: J, references: "", checkFunc: () => {
    }, code: "", Check: (Y) => exports_value2.Check(J, Y), Errors: (Y) => exports_value2.Errors(J, Y), Code: () => "" };
  return TypeCompiler.Compile(J, Object.values(Z));
};
var s0 = ($, { models: Z = {}, additionalProperties: X = false, dynamic: W = false }) => {
  if (!$)
    return;
  if (typeof $ === "string" && !($ in Z))
    return;
  const J = typeof $ === "string" ? Z[$] : $, Y = (_, B) => {
    if (W)
      return { schema: _, references: "", checkFunc: () => {
      }, code: "", Check: (K) => exports_value2.Check(_, K), Errors: (K) => exports_value2.Errors(_, K), Code: () => "" };
    return TypeCompiler.Compile(_, B);
  };
  if (Kind in J) {
    if ("additionalProperties" in J === false)
      J.additionalProperties = X;
    return { 200: Y(J, Object.values(Z)) };
  }
  const Q = {};
  return Object.keys(J).forEach((_) => {
    const B = J[+_];
    if (typeof B === "string") {
      if (B in Z) {
        const K = Z[B];
        K.type === "object" && "additionalProperties" in K, Q[+_] = Kind in K ? Y(K, Object.values(Z)) : K;
      }
      return;
    }
    if (B.type === "object" && "additionalProperties" in B === false)
      B.additionalProperties = X;
    Q[+_] = Kind in B ? Y(B, Object.values(Z)) : B;
  }), Q;
};
var j$ = typeof Bun !== "undefined";
var N$ = j$ && typeof Bun.hash === "function";
var j0 = ($) => {
  if (N$)
    return Bun.hash($);
  let Z = 9;
  for (let X = 0;X < $.length; )
    Z = Math.imul(Z ^ $.charCodeAt(X++), 387420489);
  return Z = Z ^ Z >>> 9;
};
var v0 = ($, Z, X) => {
  const W = (J) => {
    if (X && !J.$elysiaChecksum)
      J.$elysiaChecksum = X;
    return J;
  };
  return { ...$, ...Z, start: H($.start, ("start" in Z ? Z.start ?? [] : []).map(W)), request: H($.request, ("request" in Z ? Z.request ?? [] : []).map(W)), parse: H($.parse, "parse" in Z ? Z?.parse ?? [] : []).map(W), transform: H($.transform, (Z?.transform ?? []).map(W)), beforeHandle: H($.beforeHandle, (Z?.beforeHandle ?? []).map(W)), afterHandle: H($.afterHandle, (Z?.afterHandle ?? []).map(W)), mapResponse: H($.mapResponse, (Z?.mapResponse ?? []).map(W)), onResponse: H($.onResponse, (Z?.onResponse ?? []).map(W)), trace: $.trace, error: H($.error, (Z?.error ?? []).map(W)), stop: H($.stop, ("stop" in Z ? Z.stop ?? [] : []).map(W)) };
};
var R1 = ($, Z = true) => {
  if (!$)
    return $;
  if (typeof $ === "function") {
    if (Z)
      $.$elysiaHookType = "global";
    else
      $.$elysiaHookType = undefined;
    return $;
  }
  return $.map((X) => {
    if (Z)
      X.$elysiaHookType = "global";
    else
      X.$elysiaHookType = undefined;
    return X;
  });
};
var Y0 = ($) => {
  if (!$)
    return $;
  if (typeof $ === "function")
    return $.$elysiaHookType === "global" ? $ : undefined;
  return $.filter((Z) => Z.$elysiaHookType === "global");
};
var a0 = ($) => {
  return { ...$, type: $?.type, detail: $?.detail, parse: Y0($?.parse), transform: Y0($?.transform), beforeHandle: Y0($?.beforeHandle), afterHandle: Y0($?.afterHandle), onResponse: Y0($?.onResponse), error: Y0($?.error) };
};
var I0 = { Continue: 100, "Switching Protocols": 101, Processing: 102, "Early Hints": 103, OK: 200, Created: 201, Accepted: 202, "Non-Authoritative Information": 203, "No Content": 204, "Reset Content": 205, "Partial Content": 206, "Multi-Status": 207, "Already Reported": 208, "Multiple Choices": 300, "Moved Permanently": 301, Found: 302, "See Other": 303, "Not Modified": 304, "Temporary Redirect": 307, "Permanent Redirect": 308, "Bad Request": 400, Unauthorized: 401, "Payment Required": 402, Forbidden: 403, "Not Found": 404, "Method Not Allowed": 405, "Not Acceptable": 406, "Proxy Authentication Required": 407, "Request Timeout": 408, Conflict: 409, Gone: 410, "Length Required": 411, "Precondition Failed": 412, "Payload Too Large": 413, "URI Too Long": 414, "Unsupported Media Type": 415, "Range Not Satisfiable": 416, "Expectation Failed": 417, "I'm a teapot": 418, "Misdirected Request": 421, "Unprocessable Content": 422, Locked: 423, "Failed Dependency": 424, "Too Early": 425, "Upgrade Required": 426, "Precondition Required": 428, "Too Many Requests": 429, "Request Header Fields Too Large": 431, "Unavailable For Legal Reasons": 451, "Internal Server Error": 500, "Not Implemented": 501, "Bad Gateway": 502, "Service Unavailable": 503, "Gateway Timeout": 504, "HTTP Version Not Supported": 505, "Variant Also Negotiates": 506, "Insufficient Storage": 507, "Loop Detected": 508, "Not Extended": 510, "Network Authentication Required": 511 };
var B0 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = new TextEncoder, W = await crypto.subtle.importKey("raw", X.encode(Z), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]), J = await crypto.subtle.sign("HMAC", W, X.encode($)), Y = Array.from(new Uint8Array(J)), Q = btoa(String.fromCharCode(...Y));
  return `${$}.${Q.replace(/=+$/, "")}`;
};
var l0 = async ($, Z) => {
  if (typeof $ !== "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (Z === null)
    throw new TypeError("Secret key must be provided.");
  const X = $.slice(0, $.lastIndexOf("."));
  return await B0(X, Z) === $ ? X : false;
};
var o0 = ($, Z, X = Z) => {
  for (let [W, J] of Object.entries(Z ?? {})) {
    if (I$.includes(W) || !(W in $))
      continue;
    if (typeof $[W] === "function")
      $[W](J);
    else if (typeof $[W] === "object")
      o0($[W], J, X);
  }
};
var f0 = ($) => {
  if ($.length < 16)
    return $.trim().length !== 0 && !Number.isNaN(Number($));
  if ($.length === 16) {
    const Z = Number($);
    if (Z.toString() === $)
      return $.trim().length !== 0 && !Number.isNaN(Z);
  }
  return false;
};
var S1 = typeof Bun !== "undefined" ? Bun.env : typeof process !== "undefined" ? process?.env : undefined;
var _0 = Symbol("ElysiaErrorCode");
var c = Symbol("ElysiaResponse");
var N0 = (S1?.NODE_ENV ?? S1?.ENV) === "production";
class k0 extends Error {
  code = "INTERNAL_SERVER_ERROR";
  status = 500;
  constructor($) {
    super($ ?? "INTERNAL_SERVER_ERROR");
  }
}

class e extends Error {
  code = "NOT_FOUND";
  status = 404;
  constructor($) {
    super($ ?? "NOT_FOUND");
  }
}
class M0 extends Error {
  $;
  code = "INVALID_COOKIE_SIGNATURE";
  status = 400;
  constructor($, Z) {
    super(Z ?? `"${$}" has invalid cookie signature`);
    this.key = $;
  }
}

class q extends Error {
  $;
  Z;
  X;
  code = "VALIDATION";
  status = 400;
  constructor($, Z, X) {
    const W = N0 ? undefined : ("Errors" in Z) ? Z.Errors(X).First() : exports_value2.Errors(Z, X).First(), J = W?.schema.error ? typeof W.schema.error === "function" ? W.schema.error($, Z, X) : W.schema.error : undefined, Y = W?.path?.slice(1) || "root";
    let Q = "";
    if (J)
      Q = typeof J === "object" ? JSON.stringify(J) : J + "";
    else if (N0)
      Q = JSON.stringify({ type: $, message: W?.message });
    else
      Q = JSON.stringify({ type: $, at: Y, message: W?.message, expected: exports_value2.Create(Z.schema), found: X, errors: [...Z.Errors(X)] }, null, 2);
    super(Q);
    this.type = $;
    this.validator = Z;
    this.value = X;
    Object.setPrototypeOf(this, q.prototype);
  }
  get all() {
    return [...this.validator.Errors(this.value)];
  }
  static simplifyModel($) {
    const Z = "schema" in $ ? $.schema : $;
    try {
      return exports_value2.Create(Z);
    } catch {
      return Z;
    }
  }
  get model() {
    return q.simplifyModel(this.validator);
  }
  toResponse($) {
    return new Response(this.message, { status: 400, headers: $ });
  }
}
var $1 = { open($) {
  $.data.open?.($);
}, message($, Z) {
  $.data.message?.($, Z);
}, drain($) {
  $.data.drain?.($);
}, close($, Z, X) {
  $.data.close?.($, Z, X);
} };

class D0 {
  $;
  Z;
  validator;
  constructor($, Z) {
    this.raw = $;
    this.data = Z;
    if (this.validator = $.data.validator, $.data.id)
      this.id = $.data.id;
    else {
      const X = new Uint32Array(1);
      crypto.getRandomValues(X), this.id = X[0].toString();
    }
  }
  get id() {
    return this.raw.data.id;
  }
  set id($) {
    this.raw.data.id = $;
  }
  get publish() {
    return ($, Z = undefined, X) => {
      if (this.validator?.Check(Z) === false)
        throw new q("message", this.validator, Z);
      if (typeof Z === "object")
        Z = JSON.stringify(Z);
      return this.raw.publish($, Z, X), this;
    };
  }
  get send() {
    return ($) => {
      if (this.validator?.Check($) === false)
        throw new q("message", this.validator, $);
      if (Buffer.isBuffer($))
        return this.raw.send($), this;
      if (typeof $ === "object")
        $ = JSON.stringify($);
      return this.raw.send($), this;
    };
  }
  get subscribe() {
    return ($) => {
      return this.raw.subscribe($), this;
    };
  }
  get unsubscribe() {
    return ($) => {
      return this.raw.unsubscribe($), this;
    };
  }
  get cork() {
    return ($) => {
      return this.raw.cork($), this;
    };
  }
  get close() {
    return () => {
      return this.raw.close(), this;
    };
  }
  get terminate() {
    return this.raw.terminate.bind(this.raw);
  }
  get isSubscribed() {
    return this.raw.isSubscribed.bind(this.raw);
  }
  get remoteAddress() {
    return this.raw.remoteAddress;
  }
}
var p1 = T0(J1(), 1);
var i1 = T0(X1(), 1);
var q$ = new Headers().toJSON;
var l1 = new RegExp(" (\\w+) = context", "g");
var n1 = { value: 0 };
var r1 = ({ hasTrace: $, hasTraceSet: Z = false, addFn: X, condition: W = {} }) => {
  if ($)
    return X("\nconst reporter = getReporter()\n"), (J, { name: Y, attribute: Q = "", unit: _ = 0 } = {}) => {
      const B = J.indexOf("."), K = B === -1;
      if (J !== "request" && J !== "response" && !W[K ? J : J.slice(0, B)])
        return () => {
          if (Z && J === "afterHandle")
            X("\nawait traceDone\n");
        };
      if (K)
        Y ||= J;
      else
        Y ||= "anonymous";
      X("\n" + `reporter.emit('event', {
					id,
					event: '${J}',
					type: 'begin',
					name: '${Y}',
					time: performance.now(),
					${K ? `unit: ${_},` : ""}
					${Q}
				})`.replace(/(\t| |\n)/g, "") + "\n");
      let G = false;
      return () => {
        if (G)
          return;
        if (G = true, X("\n" + `reporter.emit('event', {
							id,
							event: '${J}',
							type: 'end',
							time: performance.now()
						})`.replace(/(\t| |\n)/g, "") + "\n"), Z && J === "afterHandle")
          X("\nawait traceDone\n");
      };
    };
  else
    return () => () => {
    };
};
var A0 = ($) => {
  const Z = $.indexOf(")");
  if ($.charCodeAt(Z + 2) === 61 && $.charCodeAt(Z + 5) !== 123)
    return true;
  return $.includes("return");
};
var T$ = ($, { injectResponse: Z = "" } = {}) => ({ composeValidation: (X, W = `c.${X}`) => $ ? `c.set.status = 400; throw new ValidationError(
'${X}',
${X},
${W}
)` : `c.set.status = 400; return new ValidationError(
	'${X}',
	${X},
	${W}
).toResponse(c.set.headers)`, composeResponseValidation: (X = "r") => {
  const W = $ ? `throw new ValidationError(
'response',
response[c.set.status],
${X}
)` : `return new ValidationError(
'response',
response[c.set.status],
${X}
).toResponse(c.set.headers)`;
  return `\n${Z}
		if(!(${X} instanceof Response) && response[c.set.status]?.Check(${X}) === false) {
	if(!(response instanceof Error))
		${W}
}\n`;
} });
var b = ($, Z) => {
  if (Z.startsWith("[object "))
    return false;
  if (Z = Z.trimStart(), Z = Z.replaceAll(/^async /g, ""), /^(\w+)\(/g.test(Z))
    Z = Z.slice(Z.indexOf("("));
  const X = Z.charCodeAt(0) === 40 || Z.startsWith("function") ? Z.slice(Z.indexOf("(") + 1, Z.indexOf(")")) : Z.slice(0, Z.indexOf("=") - 1);
  if (X === "")
    return false;
  const W = X.charCodeAt(0) === 123 ? X.indexOf("...") : -1;
  if (X.charCodeAt(0) === 123) {
    if (X.includes($))
      return true;
    if (W === -1)
      return false;
  }
  if (Z.match(new RegExp(`${X}(.${$}|\\["${$}"\\])`)))
    return true;
  const J = W !== -1 ? X.slice(W + 3, X.indexOf(" ", W + 3)) : undefined;
  if (Z.match(new RegExp(`${J}(.${$}|\\["${$}"\\])`)))
    return true;
  const Y = [X];
  if (J)
    Y.push(J);
  for (let _ of Z.matchAll(l1))
    Y.push(_[1]);
  const Q = new RegExp(`{.*?} = (${Y.join("|")})`, "g");
  for (let [_] of Z.matchAll(Q))
    if (_.includes(`{ ${$}`) || _.includes(`, ${$}`))
      return true;
  return false;
};
var V0 = ($) => {
  if ($ = $.trimStart(), $.startsWith("[object"))
    return false;
  if ($ = $.replaceAll(/^async /g, ""), /^(\w+)\(/g.test($))
    $ = $.slice($.indexOf("("));
  const Z = $.charCodeAt(0) === 40 || $.startsWith("function") ? $.slice($.indexOf("(") + 1, $.indexOf(")")) : $.slice(0, $.indexOf("=") - 1);
  if (Z === "")
    return false;
  const X = Z.charCodeAt(0) === 123 ? Z.indexOf("...") : -1, W = X !== -1 ? Z.slice(X + 3, Z.indexOf(" ", X + 3)) : undefined, J = [Z];
  if (W)
    J.push(W);
  for (let Q of $.matchAll(l1))
    J.push(Q[1]);
  for (let Q of J)
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Q}\\b[^)]*\\)`).test($))
      return true;
  const Y = new RegExp(`{.*?} = (${J.join("|")})`, "g");
  for (let [Q] of $.matchAll(Y))
    if (new RegExp(`\\b\\w+\\([^)]*\\b${Q}\\b[^)]*\\)`).test($))
      return true;
  return false;
};
var G0 = Symbol.for("TypeBox.Kind");
var m0 = ($, Z) => {
  if (!Z)
    return;
  if (G0 in Z && Z[G0] === $)
    return true;
  if (Z.type === "object") {
    const X = Z.properties;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if (J.type === "object") {
        if (m0($, J))
          return true;
      } else if (J.anyOf) {
        for (let Y = 0;Y < J.anyOf.length; Y++)
          if (m0($, J.anyOf[Y]))
            return true;
      }
      if (G0 in J && J[G0] === $)
        return true;
    }
    return false;
  }
  return Z.properties && G0 in Z.properties && Z.properties[G0] === $;
};
var $0 = ($, Z) => {
  if (!Z)
    return;
  if (Z.type === "object") {
    const X = Z.properties;
    if (!X)
      return false;
    for (let W of Object.keys(X)) {
      const J = X[W];
      if ($ in J)
        return true;
      if (J.type === "object") {
        if ($0($, J))
          return true;
      } else if (J.anyOf) {
        for (let Y = 0;Y < J.anyOf.length; Y++)
          if ($0($, J.anyOf[Y]))
            return true;
      }
    }
    return false;
  }
  return $ in Z;
};
var Q1 = Symbol.for("TypeBox.Transform");
var Z0 = ($) => {
  if (!$)
    return;
  if ($.type === "object" && $.properties) {
    const Z = $.properties;
    for (let X of Object.keys(Z)) {
      const W = Z[X];
      if (W.type === "object") {
        if (Z0(W))
          return true;
      } else if (W.anyOf) {
        for (let Y = 0;Y < W.anyOf.length; Y++)
          if (Z0(W.anyOf[Y]))
            return true;
      }
      if (Q1 in W)
        return true;
    }
    return false;
  }
  return Q1 in $ || $.properties && Q1 in $.properties;
};
var E$ = ($) => {
  if (!$)
    return;
  const Z = $?.schema;
  if (Z && "anyOf" in Z) {
    let X = false;
    const W = Z.anyOf[0].type;
    for (let J of Z.anyOf)
      if (J.type !== W) {
        X = true;
        break;
      }
    if (!X)
      return W;
  }
  return $.schema?.type;
};
var H$ = /(?:return|=>) \S+\(/g;
var L = ($) => {
  if ($.constructor.name === "AsyncFunction")
    return true;
  const Z = $.toString();
  if (Z.includes("=> response.clone("))
    return false;
  return !!Z.match(H$);
};
var b$ = ($) => {
  if (!$.includes("query: {") || $.includes("query,") || $.includes("query }"))
    return false;
  const Z = $.indexOf("query: {");
  return $ = $.slice(Z + 9), $ = $.slice(0, $.indexOf("}")), $.split(",").map((X) => {
    const W = X.indexOf(":");
    if (W === -1)
      return X.trim();
    return X.slice(0, W).trim();
  });
};
var t1 = ({ path: $, method: Z, hooks: X, validator: W, handler: J, handleError: Y, definitions: Q, schema: _, onRequest: B, config: K, getReporter: G, setHeader: M }) => {
  const V = K.forceErrorEncapsulation || X.error.length > 0 || typeof Bun === "undefined" || X.onResponse.length > 0 || !!X.trace.length, P = typeof J === "function", z = P ? "handler(c)" : "handler", A = X.onResponse.length ? `\n;(async () => {${X.onResponse.map((O, I) => `await res${I}(c)`).join(";")}})();\n` : "", U = X.trace.map((O) => O.toString());
  let j = false;
  if (P && V0(J.toString()))
    j = true;
  if (!j)
    for (let [O, I] of Object.entries(X)) {
      if (!Array.isArray(I) || !I.length || !["parse", "transform", "beforeHandle", "afterHandle", "onResponse"].includes(O))
        continue;
      for (let F of I) {
        if (typeof F !== "function")
          continue;
        if (V0(F.toString())) {
          j = true;
          break;
        }
      }
      if (j)
        break;
    }
  const N = { parse: U.some((O) => b("parse", O)), transform: U.some((O) => b("transform", O)), handle: U.some((O) => b("handle", O)), beforeHandle: U.some((O) => b("beforeHandle", O)), afterHandle: U.some((O) => b("afterHandle", O)), error: V || U.some((O) => b("error", O)) }, w = X.trace.length > 0;
  let D = "";
  const k = W || Z !== "GET" && Z !== "HEAD" ? [J, ...X.transform, ...X.beforeHandle, ...X.afterHandle, ...X.mapResponse].map((O) => typeof O === "function" ? O.toString() : `${O}`) : [], w0 = Z !== "GET" && Z !== "HEAD" && (j || X.type !== "none" && (!!W.body || !!X.type || k.some((O) => b("body", O)))), h0 = j || W.headers || k.some((O) => b("headers", O)) || M && Object.keys(M).length, C0 = j || !!W.cookie || k.some((O) => b("cookie", O)), x = W?.cookie?.schema;
  let t = "";
  if (x?.sign) {
    if (!x.secrets)
      throw new Error(`t.Cookie required secret which is not set in (${Z}) ${$}.`);
    const O = !x.secrets ? undefined : typeof x.secrets === "string" ? x.secrets : x.secrets[0];
    if (t += `const _setCookie = c.set.cookie
		if(_setCookie) {`, x.sign === true)
      t += `for(const [key, cookie] of Object.entries(_setCookie)) {
				c.set.cookie[key].value = await signCookie(cookie.value, '${O}')
			}`;
    else
      for (let I of x.sign)
        t += `if(_setCookie['${I}']?.value) { c.set.cookie['${I}'].value = await signCookie(_setCookie['${I}'].value, '${O}') }\n`;
    t += "}\n";
  }
  const { composeValidation: X0, composeResponseValidation: R0 } = T$(V);
  if (h0)
    D += q$ ? "c.headers = c.request.headers.toJSON()\n" : `c.headers = {}
                for (const [key, value] of c.request.headers.entries())
					c.headers[key] = value
				`;
  if (C0) {
    const O = (F, R) => {
      const S = x?.[F] ?? R;
      if (!S)
        return typeof R === "string" ? `${F}: "${R}",` : `${F}: ${R},`;
      if (typeof S === "string")
        return `${F}: '${S}',`;
      if (S instanceof Date)
        return `${F}: new Date(${S.getTime()}),`;
      return `${F}: ${S},`;
    }, I = x ? `{
			secret: ${x.secrets !== undefined ? typeof x.secrets === "string" ? `'${x.secrets}'` : "[" + x.secrets.reduce((F, R) => F + `'${R}',`, "") + "]" : "undefined"},
			sign: ${x.sign === true ? true : x.sign !== undefined ? "[" + x.sign.reduce((F, R) => F + `'${R}',`, "") + "]" : "undefined"},
			${O("domain")}
			${O("expires")}
			${O("httpOnly")}
			${O("maxAge")}
			${O("path", "/")}
			${O("priority")}
			${O("sameSite")}
			${O("secure")}
		}` : "undefined";
    if (h0)
      D += `\nc.cookie = await parseCookie(c.set, c.headers.cookie, ${I})\n`;
    else
      D += `\nc.cookie = await parseCookie(c.set, c.request.headers.get('cookie'), ${I})\n`;
  }
  if (j || W.query || k.some((O) => b("query", O))) {
    let O = [], I = false;
    if (W.query && W.query.schema.type === "object")
      O = Object.keys(W.query.schema.properties);
    else
      for (let F of k) {
        const R = b$(F);
        if (!R) {
          I = true;
          continue;
        }
        for (let S of R)
          if (O.indexOf(S) === -1)
            O.push(S);
      }
    if (!I && O.length)
      D += `
			let requestUrl = c.request.url.slice(c.qi + 1)
			if(requestUrl.includes('+')) requestUrl = requestUrl.replaceAll('+', ' ')

			if(c.qi !== -1) {	
				const url = decodeURIComponent(requestUrl)
				let memory = 0

				${O.map((F, R) => `
						memory = url.indexOf('${F}=')

						const a${R} = memory === -1 ? undefined : url.slice(memory = memory + ${F.length + 1}, (memory = url.indexOf('&', memory)) === -1 ? undefined : memory)`).join("\n")}

				c.query = {
					${O.map((F, R) => `'${F}': a${R}`).join(", ")}
				}
			} else {
				c.query = {}
			}`;
    else
      D += "c.query = c.qi !== -1 ? parseQuery(decodeURIComponent(c.request.url.slice(c.qi + 1))) : {}";
  }
  const S0 = X.trace.map((O) => O.toString()).some((O) => b("set", O) || V0(O));
  j || X.trace.some((O) => b("set", O.toString()));
  const q0 = M && Object.keys(M).length || S0 || C0 || k.some((O) => b("set", O)) || B.some((O) => b("set", O.toString()));
  if (w)
    D += "\nconst id = c.$$requestId\n";
  const E = r1({ hasTrace: w, hasTraceSet: S0, condition: N, addFn: (O) => {
    D += O;
  } });
  if (D += V ? "\n try {\n" : "", S0) {
    D += "\nconst traceDone = Promise.all([";
    for (let O = 0;O < X.trace.length; O++)
      D += `new Promise(r => { reporter.once(\`res\${id}.${O}\`, r) }),`;
    D += "])\n";
  }
  const W0 = typeof J === "function" && L(J), c0 = C0 || w0 || S0 || W0 || !!X.mapResponse.length || X.parse.length > 0 || X.afterHandle.some(L) || X.beforeHandle.some(L) || X.transform.some(L), e1 = E("parse", { unit: X.parse.length });
  if (w0) {
    const O = E$(W?.body);
    if (X.type && !Array.isArray(X.type)) {
      if (X.type)
        switch (X.type) {
          case "json":
          case "application/json":
            D += "c.body = await c.request.json()\n";
            break;
          case "text":
          case "text/plain":
            D += "c.body = await c.request.text()\n";
            break;
          case "urlencoded":
          case "application/x-www-form-urlencoded":
            D += "c.body = parseQuery(await c.request.text())\n";
            break;
          case "arrayBuffer":
          case "application/octet-stream":
            D += "c.body = await c.request.arrayBuffer()\n";
            break;
          case "formdata":
          case "multipart/form-data":
            D += `c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}\n`;
            break;
        }
      if (X.parse.length)
        D += "}}";
    } else {
      const F = (() => {
        if (X.parse.length && O && !Array.isArray(X.type)) {
          const R = W?.body?.schema;
          switch (O) {
            case "object":
              if (m0("File", R) || m0("Files", R))
                return `c.body = {}

								const form = await c.request.formData()
								for (const key of form.keys()) {
									if (c.body[key])
										continue

									const value = form.getAll(key)
									if (value.length === 1)
										c.body[key] = value[0]
									else c.body[key] = value
								}`;
              break;
            default:
              break;
          }
        }
      })();
      if (F)
        D += F;
      else {
        if (D += "\n", D += h0 ? "let contentType = c.headers['content-type']" : "let contentType = c.request.headers.get('content-type')", D += `
				if (contentType) {
					const index = contentType.indexOf(';')
					if (index !== -1) contentType = contentType.substring(0, index)\n`, X.parse.length) {
          D += "let used = false\n";
          const R = E("parse", { unit: X.parse.length });
          for (let S = 0;S < X.parse.length; S++) {
            const d0 = E("parse.unit", { name: X.parse[S].name }), T = `bo${S}`;
            if (S !== 0)
              D += "if(!used) {\n";
            if (D += `let ${T} = parse[${S}](c, contentType)\n`, D += `if(${T} instanceof Promise) ${T} = await ${T}\n`, D += `if(${T} !== undefined) { c.body = ${T}; used = true }\n`, d0(), S !== 0)
              D += "}";
          }
          R();
        }
        if (X.parse.length)
          D += "if (!used)";
        D += `
				switch (contentType) {
					case 'application/json':
						c.body = await c.request.json()
						break

					case 'text/plain':
						c.body = await c.request.text()
						break

					case 'application/x-www-form-urlencoded':
						c.body = parseQuery(await c.request.text())
						break

					case 'application/octet-stream':
						c.body = await c.request.arrayBuffer();
						break

					case 'multipart/form-data':
						c.body = {}

						const form = await c.request.formData()
						for (const key of form.keys()) {
							if (c.body[key])
								continue

							const value = form.getAll(key)
							if (value.length === 1)
								c.body[key] = value[0]
							else c.body[key] = value
						}

						break
					}\n`, D += "}\n";
      }
    }
    D += "\n";
  }
  if (e1(), X?.transform) {
    const O = E("transform", { unit: X.transform.length });
    for (let I = 0;I < X.transform.length; I++) {
      const F = X.transform[I], R = E("transform.unit", { name: F.name });
      if (F.$elysia === "derive")
        D += L(F) ? `Object.assign(c, await transform[${I}](c));` : `Object.assign(c, transform[${I}](c));`;
      else
        D += L(F) ? `await transform[${I}](c);` : `transform[${I}](c);`;
      R();
    }
    O();
  }
  if (W) {
    if (D += "\n", W.headers) {
      if ($0("default", W.headers.params))
        for (let [O, I] of Object.entries(exports_value2.Default(W.headers.schema, {}))) {
          const F = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (F)
            D += `c.headers['${O}'] ??= ${F}\n`;
        }
      if (D += `if(headers.Check(c.headers) === false) {
				${X0("headers")}
			}`, Z0(W.headers.schema))
        D += "\nc.headers = headers.Decode(c.headers)\n";
    }
    if (W.params) {
      if ($0("default", W.params.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.params.schema, {}))) {
          const F = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (F)
            D += `c.params['${O}'] ??= ${F}\n`;
        }
      if (D += `if(params.Check(c.params) === false) {
				${X0("params")}
			}`, Z0(W.params.schema))
        D += "\nc.params = params.Decode(c.params)\n";
    }
    if (W.query) {
      if ($0("default", W.query.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.query.schema, {}))) {
          const F = typeof I === "object" ? JSON.stringify(I) : `'${I}'`;
          if (F)
            D += `c.query['${O}'] ??= ${F}\n`;
        }
      if (D += `if(query.Check(c.query) === false) {
				${X0("query")}
			}`, Z0(W.query.schema))
        D += "\nc.query = query.Decode(Object.assign({}, c.query))\n";
    }
    if (W.body) {
      if ($0("default", W.body.schema))
        D += `if(body.Check(c.body) === false) {
    				c.body = Object.assign(${JSON.stringify(exports_value2.Default(W.body.schema, null) ?? {})}, c.body)

    				if(body.Check(c.query) === false) {
        				${X0("body")}
     			}
            }`;
      else
        D += `if(body.Check(c.body) === false) {
			${X0("body")}
		}`;
      if (Z0(W.body.schema))
        D += "\nc.body = body.Decode(c.body)\n";
    }
    if (u(W.cookie?.schema.properties ?? {})) {
      if (D += `const cookieValue = {}
    			for(const [key, value] of Object.entries(c.cookie))
    				cookieValue[key] = value.value\n`, $0("default", W.cookie.schema))
        for (let [O, I] of Object.entries(exports_value2.Default(W.cookie.schema, {})))
          D += `cookieValue['${O}'] = ${typeof I === "object" ? JSON.stringify(I) : I}\n`;
      if (D += `if(cookie.Check(cookieValue) === false) {
				${X0("cookie", "cookieValue")}
			}`, Z0(W.cookie.schema))
        D += "\nc.cookie = params.Decode(c.cookie)\n";
    }
  }
  if (X?.beforeHandle) {
    const O = E("beforeHandle", { unit: X.beforeHandle.length });
    for (let I = 0;I < X.beforeHandle.length; I++) {
      const F = X.beforeHandle[I], R = E("beforeHandle.unit", { name: F.name }), S = A0(F.toString());
      if (F.$elysia === "resolve")
        D += L(F) ? `Object.assign(c, await beforeHandle[${I}](c));` : `Object.assign(c, beforeHandle[${I}](c));`;
      else if (!S)
        D += L(F) ? `await beforeHandle[${I}](c);\n` : `beforeHandle[${I}](c);\n`, R();
      else {
        D += L(F) ? `be = await beforeHandle[${I}](c);\n` : `be = beforeHandle[${I}](c);\n`, R(), D += "if(be !== undefined) {\n";
        const d0 = E("afterHandle", { unit: X.transform.length });
        if (X.afterHandle) {
          E("handle", { name: P ? J.name : undefined })();
          for (let T = 0;T < X.afterHandle.length; T++) {
            const $$ = A0(X.afterHandle[T].toString()), Z$ = E("afterHandle.unit", { name: X.afterHandle[T].name });
            if (D += "c.response = be\n", !$$)
              D += L(X.afterHandle[T]) ? `await afterHandle[${T}](c, be)\n` : `afterHandle[${T}](c, be)\n`;
            else
              D += L(X.afterHandle[T]) ? `af = await afterHandle[${T}](c)\n` : `af = afterHandle[${T}](c)\n`, D += "if(af !== undefined) { c.response = be = af }\n";
            Z$();
          }
        }
        if (d0(), W.response)
          D += R0("be");
        if (X.mapResponse.length) {
          D += "c.response = be";
          for (let T = 0;T < X.mapResponse.length; T++)
            D += `\nif(mr === undefined) {
							mr = onMapResponse[${T}](c)
							if(mr instanceof Promise) mr = await mr
							if(mr !== undefined) c.response = mr
						}\n`;
        }
        D += t, D += "return mapEarlyResponse(be, c.set)}\n";
      }
    }
    O();
  }
  if (X?.afterHandle.length) {
    const O = E("handle", { name: P ? J.name : undefined });
    if (X.afterHandle.length)
      D += W0 ? `let r = c.response = await ${z};\n` : `let r = c.response = ${z};\n`;
    else
      D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`;
    O();
    const I = E("afterHandle", { unit: X.afterHandle.length });
    for (let F = 0;F < X.afterHandle.length; F++) {
      const R = A0(X.afterHandle[F].toString()), S = E("afterHandle.unit", { name: X.afterHandle[F].name });
      if (!R)
        D += L(X.afterHandle[F]) ? `await afterHandle[${F}](c)\n` : `afterHandle[${F}](c)\n`, S();
      else if (D += L(X.afterHandle[F]) ? `af = await afterHandle[${F}](c)\n` : `af = afterHandle[${F}](c)\n`, S(), W.response)
        D += "if(af !== undefined) {", I(), D += R0("af"), D += "c.response = af }";
      else
        D += "if(af !== undefined) {", I(), D += "c.response = af}\n";
    }
    if (I(), D += "r = c.response\n", W.response)
      D += R0();
    if (D += t, X.mapResponse.length)
      for (let F = 0;F < X.mapResponse.length; F++)
        D += `\nmr = onMapResponse[${F}](c)
				if(mr instanceof Promise) mr = await mr
				if(mr !== undefined) c.response = mr\n`;
    if (q0)
      D += "return mapResponse(r, c.set)\n";
    else
      D += "return mapCompactResponse(r)\n";
  } else {
    const O = E("handle", { name: P ? J.name : undefined });
    if (W.response || X.mapResponse.length) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), W.response)
        D += R0();
      if (E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) { 
						mr = onMapResponse[${I}](c)
						if(mr instanceof Promise) mr = await mr
    					if(mr !== undefined) r = c.response = mr
					}\n`;
      }
      if (D += t, J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else if (N.handle || C0) {
      if (D += W0 ? `let r = await ${z};\n` : `let r = ${z};\n`, O(), E("afterHandle")(), X.mapResponse.length) {
        D += "c.response = r";
        for (let I = 0;I < X.mapResponse.length; I++)
          D += `\nif(mr === undefined) {
							mr = onMapResponse[${I}](c)
							if(mr instanceof Promise) mr = await mr
    						if(mr !== undefined) r = c.response = mr
						}\n`;
      }
      if (D += t, q0)
        D += "return mapResponse(r, c.set)\n";
      else
        D += "return mapCompactResponse(r)\n";
    } else {
      O();
      const I = W0 ? `await ${z}` : z;
      if (E("afterHandle")(), J instanceof Response)
        D += `return ${z}.clone()\n`;
      else if (q0)
        D += `return mapResponse(${I}, c.set)\n`;
      else
        D += `return mapCompactResponse(${I})\n`;
    }
  }
  if (V || A) {
    if (D += `
} catch(error) {`, !c0)
      D += "return (async () => {";
    D += `const set = c.set

		if (!set.status || set.status < 300) set.status = error?.status || 500
	`;
    const O = E("error", { unit: X.error.length });
    if (X.error.length) {
      D += `
				c.error = error
				c.code = error.code ?? error[ERROR_CODE] ?? "UNKNOWN"
			`;
      for (let I = 0;I < X.error.length; I++) {
        const F = `er${I}`, R = E("error.unit", { name: X.error[I].name });
        if (D += `\nlet ${F} = handleErrors[${I}](c)\n`, L(X.error[I]))
          D += `if (${F} instanceof Promise) ${F} = await ${F}\n`;
        R(), D += `${F} = mapEarlyResponse(${F}, set)\n`, D += `if (${F}) {`, D += `return ${F} }\n`;
      }
    }
    if (O(), D += "return handleError(c, error)\n\n", !c0)
      D += "})()";
    if (D += "}", A || w) {
      D += " finally { ";
      const I = E("response", { unit: X.onResponse.length });
      D += A, I(), D += "}";
    }
  }
  return D = `const {
		handler,
		handleError,
		hooks: {
			transform,
			resolve,
			beforeHandle,
			afterHandle,
			mapResponse: onMapResponse,
			parse,
			error: handleErrors,
			onResponse
		},
		validator: {
			body,
			headers,
			params,
			query,
			response,
			cookie
		},
		utils: {
			mapResponse,
			mapCompactResponse,
			mapEarlyResponse,
			parseQuery
		},
		error: {
			NotFoundError,
			ValidationError,
			InternalServerError
		},
		schema,
		definitions,
		ERROR_CODE,
		getReporter,
		requestId,
		parseCookie,
		signCookie,
		decodeURIComponent
	} = hooks

	${X.onResponse.length ? `const ${X.onResponse.map((O, I) => `res${I} = onResponse[${I}]`).join(",")}` : ""}

	return ${c0 ? "async" : ""} function handle(c) {
		${X.beforeHandle.length ? "let be" : ""}
		${X.afterHandle.length ? "let af" : ""}
		${X.mapResponse.length ? "let mr" : ""}

		${_ && Q ? "c.schema = schema; c.defs = definitions;" : ""}
		${D}
	}`, Function("hooks", D)({ handler: J, hooks: X, validator: W, handleError: Y, utils: { mapResponse: v, mapCompactResponse: l, mapEarlyResponse: y, parseQuery: p1.parse }, error: { NotFoundError: e, ValidationError: q, InternalServerError: k0 }, schema: _, definitions: Q, ERROR_CODE: _0, getReporter: G, requestId: n1, parseCookie: g0, signCookie: B0, decodeURIComponent: i1.default });
};
var Y1 = ($) => {
  let Z = "", X = "";
  for (let z of Object.keys($.decorators))
    Z += `,${z}: app.decorators.${z}`;
  const { router: W, staticRouter: J } = $, Y = $.event.trace.length > 0, Q = `
	const route = router.find(request.method, path) ${W.root.ALL ? '?? router.find("ALL", path)' : ""}
	if (route === null)
		return ${$.event.error.length ? "app.handleError(ctx, notFound)" : $.event.request.length ? `new Response(error404Message, {
					status: ctx.set.status === 200 ? 404 : ctx.set.status,
					headers: ctx.set.headers
				})` : "error404.clone()"}

	ctx.params = route.params

	return route.store(ctx)`;
  let _ = "";
  for (let [z, { code: A, all: U }] of Object.entries(J.map))
    _ += `case '${z}':\nswitch(request.method) {\n${A}\n${U ?? "default: break map"}}\n\n`;
  const B = $.event.request.some(L);
  if (X += `const {
		app,
		app: { store, router, staticRouter, wsRouter },
		mapEarlyResponse,
		NotFoundError,
		requestId,
		getReporter,
		handleError
	} = data

	const notFound = new NotFoundError()

	${$.event.request.length ? "const onRequest = app.event.request" : ""}
	${J.variables}
	${$.event.error.length ? "" : `
	const error404Message = notFound.message.toString()
	const error404 = new Response(error404Message, { status: 404 });
	`}

	return ${B ? "async" : ""} function map(request) {\n`, $.event.request.length)
    X += "let re";
  const K = $.event.trace.map((z) => z.toString()), G = r1({ hasTrace: Y, hasTraceSet: $.event.trace.some((z) => {
    const A = z.toString();
    return b("set", A) || V0(A);
  }), condition: { request: K.some((z) => b("request", z) || V0(z)) }, addFn: (z) => {
    X += z;
  } });
  if ($.event.request.length) {
    X += `
			${Y ? "const id = +requestId.value++" : ""}

			const ctx = {
				request,
				store,
				set: {
					headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
					status: 200
				}
				${Y ? ",$$requestId: +id" : ""}
				${Z}
			}
		`;
    const z = G("request", { attribute: "ctx", unit: $.event.request.length });
    X += "\n try {\n";
    for (let A = 0;A < $.event.request.length; A++) {
      const U = $.event.request[A], j = A0(U.toString()), N = L(U), w = G("request.unit", { name: $.event.request[A].name });
      if (j) {
        if (X += `re = mapEarlyResponse(
					${N ? "await" : ""} onRequest[${A}](ctx),
					ctx.set
				)\n`, w(), j)
          X += "if(re !== undefined) return re\n";
      } else
        X += `${N ? "await" : ""} onRequest[${A}](ctx)\n`, w();
    }
    X += `} catch (error) {
			return app.handleError(ctx, error)
		}`, z(), X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = ctx.qi = url.indexOf('?', s + 1)
		const path = ctx.path = url.substring(s, qi === -1 ? undefined : qi)`;
  } else
    X += `
		const url = request.url
		const s = url.indexOf('/', 11)
		const qi = url.indexOf('?', s + 1)
		const path = url.substring(s, qi === -1 ? undefined : qi)
		${Y ? "const id = +requestId.value++" : ""}
		const ctx = {
			request,
			store,
			qi,
			path,
			set: {
				headers: ${Object.keys($.setHeaders ?? {}).length ? "Object.assign({}, app.setHeaders)" : "{}"},
				status: 200
			}
			${Y ? ",$$requestId: id" : ""}
			${Z}
		}`, G("request", { unit: $.event.request.length, attribute: K.some((z) => b("context", z)) || K.some((z) => b("store", z)) || K.some((z) => b("set", z)) ? "ctx" : "" })();
  const { wsPaths: M, wsRouter: V } = $;
  if (Object.keys(M).length || V.history.length) {
    X += `
			if(request.method === 'GET') {
				switch(path) {`;
    for (let [z, A] of Object.entries(M))
      X += `
					case '${z}':
						if(request.headers.get('upgrade') === 'websocket')
							return st${A}(ctx)

						break`;
    X += `
				default:
					if(request.headers.get('upgrade') === 'websocket') {
						const route = wsRouter.find('ws', path)

						if(route) {
							ctx.params = route.params

							return route.store(ctx)
						}
					}

					break
			}
		}\n`;
  }
  X += `
		map: switch(path) {
			${_}

			default:
				break
		}

		${Q}
	}`;
  const P = B1($);
  return $.handleError = P, Function("data", X)({ app: $, mapEarlyResponse: y, NotFoundError: e, getReporter: () => $.reporter, requestId: n1, handleError: P });
};
var B1 = ($) => {
  let Z = `const {
		app: { event: { error: onError, onResponse: res } },
		mapResponse,
		ERROR_CODE,
		ELYSIA_RESPONSE
	} = inject

	return ${$.event.error.find(L) ? "async" : ""} function(context, error) {
		let r

		const { set } = context

		context.code = error.code
		context.error = error

		if(error[ELYSIA_RESPONSE]) {
			error.status = error[ELYSIA_RESPONSE]
			error.message = error.response
		}
`;
  for (let X = 0;X < $.event.error.length; X++) {
    const W = $.event.error[X], J = `${L(W) ? "await " : ""}onError[${X}](context)`;
    if (A0(W.toString()))
      Z += `r = ${J}; if(r !== undefined) {
				if(r instanceof Response) return r

				if(r[ELYSIA_RESPONSE]) {
					error.status = error[ELYSIA_RESPONSE]
					error.message = error.response
				}
		
				if(set.status === 200) set.status = error.status
				return mapResponse(r, set)
			}\n`;
    else
      Z += J + "\n";
  }
  return Z += `if(error.constructor.name === "ValidationError" || error.constructor.name === "TransformDecodeError") {
		set.status = error.status ?? 400
		return new Response(
			error.message,
			{ headers: set.headers, status: set.status }
		)
	} else {
		if(error.code && typeof error.status === "number")
			return new Response(
				error.message,
				{ headers: set.headers, status: error.status }
			)

		return mapResponse(error, set)
	}
}`, Function("inject", Z)({ app: $, mapResponse: v, ERROR_CODE: _0, ELYSIA_RESPONSE: c });
};
var u0 = T0(J1(), 1);
var _1 = ($) => async (Z) => {
  const X = { cookie: {}, status: 200, headers: {} };
  let W;
  if ($.decorators)
    W = $.decorators, W.request = Z, W.set = X, W.store = $.store;
  else
    W = { set: X, store: $.store, request: Z };
  const J = Z.url, Y = J.indexOf("/", 11), Q = J.indexOf("?", Y + 1), _ = Q === -1 ? J.substring(Y) : J.substring(Y, Q);
  try {
    for (let U = 0;U < $.event.request.length; U++) {
      const j = $.event.request[U];
      let N = j(W);
      if (N instanceof Promise)
        N = await N;
      if (N = y(N, X), N)
        return N;
    }
    const B = $.dynamicRouter.find(Z.method, _) ?? $.dynamicRouter.find("ALL", _);
    if (!B)
      throw new e;
    const { handle: K, hooks: G, validator: M, content: V } = B.store;
    let P;
    if (Z.method !== "GET" && Z.method !== "HEAD")
      if (V)
        switch (V) {
          case "application/json":
            P = await Z.json();
            break;
          case "text/plain":
            P = await Z.text();
            break;
          case "application/x-www-form-urlencoded":
            P = u0.parse(await Z.text());
            break;
          case "application/octet-stream":
            P = await Z.arrayBuffer();
            break;
          case "multipart/form-data":
            P = {};
            const U = await Z.formData();
            for (let j of U.keys()) {
              if (P[j])
                continue;
              const N = U.getAll(j);
              if (N.length === 1)
                P[j] = N[0];
              else
                P[j] = N;
            }
            break;
        }
      else {
        let U = Z.headers.get("content-type");
        if (U) {
          const j = U.indexOf(";");
          if (j !== -1)
            U = U.slice(0, j);
          for (let N = 0;N < G.parse.length; N++) {
            let w = G.parse[N](W, U);
            if (w instanceof Promise)
              w = await w;
            if (w) {
              P = w;
              break;
            }
          }
          if (P === undefined)
            switch (U) {
              case "application/json":
                P = await Z.json();
                break;
              case "text/plain":
                P = await Z.text();
                break;
              case "application/x-www-form-urlencoded":
                P = u0.parse(await Z.text());
                break;
              case "application/octet-stream":
                P = await Z.arrayBuffer();
                break;
              case "multipart/form-data":
                P = {};
                const N = await Z.formData();
                for (let w of N.keys()) {
                  if (P[w])
                    continue;
                  const D = N.getAll(w);
                  if (D.length === 1)
                    P[w] = D[0];
                  else
                    P[w] = D;
                }
                break;
            }
        }
      }
    W.body = P, W.params = B?.params || undefined, W.query = Q === -1 ? {} : u0.parse(J.substring(Q + 1)), W.headers = {};
    for (let [U, j] of Z.headers.entries())
      W.headers[U] = j;
    const z = M?.cookie?.schema;
    W.cookie = await g0(W.set, W.headers.cookie, z ? { secret: z.secrets !== undefined ? typeof z.secrets === "string" ? z.secrets : z.secrets.join(",") : undefined, sign: z.sign === true ? true : z.sign !== undefined ? typeof z.sign === "string" ? z.sign : z.sign.join(",") : undefined } : undefined);
    for (let U = 0;U < G.transform.length; U++) {
      const j = G.transform[U](W);
      if (G.transform[U].$elysia === "derive")
        if (j instanceof Promise)
          Object.assign(W, await j);
        else
          Object.assign(W, j);
      else if (j instanceof Promise)
        await j;
    }
    if (M) {
      if (M.headers) {
        const U = {};
        for (let j in Z.headers)
          U[j] = Z.headers.get(j);
        if (M.headers.Check(U) === false)
          throw new q("header", M.headers, U);
      }
      if (M.params?.Check(W.params) === false)
        throw new q("params", M.params, W.params);
      if (M.query?.Check(W.query) === false)
        throw new q("query", M.query, W.query);
      if (M.cookie) {
        const U = {};
        for (let [j, N] of Object.entries(W.cookie))
          U[j] = N.value;
        if (M.cookie?.Check(U) === false)
          throw new q("cookie", M.cookie, U);
      }
      if (M.body?.Check(P) === false)
        throw new q("body", M.body, P);
    }
    for (let U = 0;U < G.beforeHandle.length; U++) {
      let j = G.beforeHandle[U](W);
      if (j instanceof Promise)
        j = await j;
      if (j !== undefined) {
        W.response = j;
        for (let w = 0;w < G.afterHandle.length; w++) {
          let D = G.afterHandle[w](W);
          if (D instanceof Promise)
            D = await D;
          if (D)
            j = D;
        }
        const N = y(j, W.set);
        if (N)
          return N;
      }
    }
    let A = K(W);
    if (A instanceof Promise)
      A = await A;
    if (!G.afterHandle.length) {
      const U = M?.response?.[A.status];
      if (U?.Check(A) === false)
        throw new q("response", U, A);
    } else {
      W.response = A;
      for (let U = 0;U < G.afterHandle.length; U++) {
        let j = G.afterHandle[U](W);
        if (j instanceof Promise)
          j = await j;
        const N = y(j, W.set);
        if (N !== undefined) {
          const w = M?.response?.[A.status];
          if (w?.Check(N) === false)
            throw new q("response", w, N);
          return N;
        }
      }
    }
    if (W.set.cookie && z?.sign) {
      const U = !z.secrets ? undefined : typeof z.secrets === "string" ? z.secrets : z.secrets[0];
      if (z.sign === true)
        for (let [j, N] of Object.entries(W.set.cookie))
          W.set.cookie[j].value = await B0(N.value, "${secret}");
      else
        for (let j of z.sign) {
          if (!(j in z.properties))
            continue;
          if (W.set.cookie[j]?.value)
            W.set.cookie[j].value = await B0(W.set.cookie[j].value, U);
        }
    }
    return v(A, W.set);
  } catch (B) {
    if (B.status)
      X.status = B.status;
    return $.handleError(W, B);
  } finally {
    for (let B of $.event.onResponse)
      await B(W);
  }
};
var s1 = ($) => async (Z, X) => {
  const W = Object.assign(Z, { error: X, code: X.code });
  W.set = Z.set;
  for (let J = 0;J < $.event.error.length; J++) {
    let Y = $.event.error[J](W);
    if (Y instanceof Promise)
      Y = await Y;
    if (Y !== undefined && Y !== null)
      return v(Y, Z.set);
  }
  return new Response(typeof X.cause === "string" ? X.cause : X.message, { headers: Z.set.headers, status: X.status ?? 500 });
};
var C = Object.assign({}, Type);
try {
  TypeSystem.Format("email", ($) => /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i.test($)), TypeSystem.Format("uuid", ($) => /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test($)), TypeSystem.Format("date", ($) => !Number.isNaN(new Date($).getTime())), TypeSystem.Format("date-time", ($) => !Number.isNaN(new Date($).getTime()));
} catch {
}
var o1 = ($) => {
  if (typeof $ === "string")
    switch ($.slice(-1)) {
      case "k":
        return +$.slice(0, $.length - 1) * 1024;
      case "m":
        return +$.slice(0, $.length - 1) * 1048576;
      default:
        return +$;
    }
  return $;
};
var G1 = ($, Z) => {
  if (!(Z instanceof Blob))
    return false;
  if ($.minSize && Z.size < o1($.minSize))
    return false;
  if ($.maxSize && Z.size > o1($.maxSize))
    return false;
  if ($.extension)
    if (typeof $.extension === "string") {
      if (!Z.type.startsWith($.extension))
        return false;
    } else {
      for (let X = 0;X < $.extension.length; X++)
        if (Z.type.startsWith($.extension[X]))
          return true;
      return false;
    }
  return true;
};
var L$ = TypeSystem.Type("Files", ($, Z) => {
  if (!Array.isArray(Z))
    return G1($, Z);
  if ($.minItems && Z.length < $.minItems)
    return false;
  if ($.maxItems && Z.length > $.maxItems)
    return false;
  for (let X = 0;X < Z.length; X++)
    if (!G1($, Z[X]))
      return false;
  return true;
});
exports_format.Set("numeric", ($) => !!$ && !isNaN(+$));
exports_format.Set("boolean", ($) => $ === "true" || $ === "false");
exports_format.Set("ObjectString", ($) => {
  let Z = $.charCodeAt(0);
  if (Z === 9 || Z === 10 || Z === 32)
    Z = $.trimStart().charCodeAt(0);
  if (Z !== 123 && Z !== 91)
    return false;
  try {
    return JSON.parse($), true;
  } catch {
    return false;
  }
});
var a = { Numeric: ($) => {
  const Z = Type.Number($);
  return C.Transform(C.Union([C.String({ format: "numeric", default: 0 }), C.Number($)], $)).Decode((X) => {
    const W = +X;
    if (isNaN(W))
      return X;
    if ($ && !exports_value2.Check(Z, W))
      throw new q("property", Z, W);
    return W;
  }).Encode((X) => X);
}, BooleanString: ($) => {
  const Z = Type.Boolean($);
  return C.Transform(C.Union([C.String({ format: "boolean", default: false }), C.Boolean($)], $)).Decode((X) => {
    if (typeof X === "string")
      return X === "true";
    if ($ && !exports_value2.Check(Z, X))
      throw new q("property", Z, X);
    return X;
  }).Encode((X) => X);
}, ObjectString: ($, Z) => C.Transform(C.Union([C.String({ format: "ObjectString", default: "" }), C.Object($, Z)], Z)).Decode((X) => {
  if (typeof X === "string")
    try {
      return JSON.parse(X);
    } catch {
      return X;
    }
  return X;
}).Encode((X) => JSON.stringify(X)), File: TypeSystem.Type("File", G1), Files: ($ = {}) => C.Transform(C.Union([L$($)])).Decode((Z) => {
  if (Array.isArray(Z))
    return Z;
  return [Z];
}).Encode((Z) => Z), Nullable: ($) => C.Union([C.Null(), $]), MaybeEmpty: ($) => C.Union([C.Null(), C.Undefined(), $]), Cookie: ($, Z) => C.Object($, Z) };
C.BooleanString = a.BooleanString;
C.ObjectString = a.ObjectString;
C.Numeric = a.Numeric;
C.File = ($ = {}) => a.File({ default: "File", ...$, extension: $?.type, type: "string", format: "binary" });
C.Files = ($ = {}) => a.Files({ ...$, elysiaMeta: "Files", default: "Files", extension: $?.type, type: "array", items: { ...$, default: "Files", type: "string", format: "binary" } });
C.Nullable = ($) => a.Nullable($);
C.MaybeEmpty = a.MaybeEmpty;
C.Cookie = a.Cookie;

class r {
  config;
  dependencies = {};
  store = {};
  decorators = {};
  definitions = { type: {}, error: {} };
  schema = {};
  macros = [];
  event = { start: [], request: [], parse: [], transform: [], beforeHandle: [], afterHandle: [], mapResponse: [], onResponse: [], trace: [], error: [], stop: [] };
  reporter = new N1;
  server = null;
  getServer() {
    return this.server;
  }
  validator = null;
  router = new o;
  wsRouter = new o;
  routes = [];
  staticRouter = { handlers: [], variables: "", map: {}, all: "" };
  wsPaths = {};
  dynamicRouter = new o;
  lazyLoadModules = [];
  path = "";
  stack = undefined;
  constructor($) {
    if (this.config = { forceErrorEncapsulation: true, prefix: "", aot: true, strictPath: false, scoped: false, cookie: {}, analytic: false, ...$ || {}, seed: $?.seed === undefined ? "" : $?.seed }, $?.analytic && ($?.name || $?.seed !== undefined))
      this.stack = new Error().stack;
  }
  add($, Z, X, W, { allowMeta: J = false, skipPrefix: Y = false } = { allowMeta: false, skipPrefix: false }) {
    if (typeof Z === "string")
      Z = [Z];
    for (let Q of Z) {
      if (Q = Q === "" ? Q : Q.charCodeAt(0) === 47 ? Q : `/${Q}`, this.config.prefix && !Y && !this.config.scoped)
        Q = this.config.prefix + Q;
      if (W?.type)
        switch (W.type) {
          case "text":
            W.type = "text/plain";
            break;
          case "json":
            W.type = "application/json";
            break;
          case "formdata":
            W.type = "multipart/form-data";
            break;
          case "urlencoded":
            W.type = "application/x-www-form-urlencoded";
            break;
          case "arrayBuffer":
            W.type = "application/octet-stream";
            break;
          default:
            break;
        }
      const _ = this.definitions.type;
      let B = p(W?.cookie ?? this.validator?.cookie, { dynamic: !this.config.aot, models: _, additionalProperties: true });
      if (u(this.config.cookie ?? {}))
        if (B)
          B.schema = C1(B.schema, this.config.cookie ?? {});
        else
          B = p(C.Cookie({}, this.config.cookie), { dynamic: !this.config.aot, models: _, additionalProperties: true });
      const K = { body: p(W?.body ?? this.validator?.body, { dynamic: !this.config.aot, models: _ }), headers: p(W?.headers ?? this.validator?.headers, { dynamic: !this.config.aot, models: _, additionalProperties: true }), params: p(W?.params ?? this.validator?.params, { dynamic: !this.config.aot, models: _ }), query: p(W?.query ?? this.validator?.query, { dynamic: !this.config.aot, models: _ }), cookie: B, response: s0(W?.response ?? this.validator?.response, { dynamic: !this.config.aot, models: _ }) }, G = this.event, M = Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/";
      if (this.macros.length) {
        const U = (N) => (w, D) => {
          if (typeof w === "function" || Array.isArray(w)) {
            if (!W[N])
              W[N] = [];
            if (typeof W[N] === "function")
              W[N] = [W[N]];
            if (Array.isArray(w))
              W[N] = W[N].concat(w);
            else
              W[N].push(w);
            return;
          }
          const { insert: k = "after", stack: w0 = "local" } = w;
          if (w0 === "global") {
            if (!Array.isArray(D))
              if (k === "before")
                G[N].unshift(D);
              else
                G[N].push(D);
            else if (k === "before")
              G[N] = D.concat(G[N]);
            else
              G[N] = G[N].concat(D);
            return;
          } else {
            if (!W[N])
              W[N] = [];
            if (typeof W[N] === "function")
              W[N] = [W[N]];
            if (!Array.isArray(D))
              if (k === "before")
                W[N].unshift(D);
              else
                W[N].push(D);
            else if (k === "before")
              W[N] = D.concat(W[N]);
            else
              W[N] = W[N].concat(D);
            return;
          }
        }, j = { events: { global: G, local: W }, onParse: U("parse"), onTransform: U("transform"), onBeforeHandle: U("beforeHandle"), onAfterHandle: U("afterHandle"), onResponse: U("onResponse"), onError: U("error") };
        for (let N of this.macros)
          o0(N(j), W);
      }
      const V = n(G, W), P = typeof X === "function";
      if (this.config.aot === false) {
        if (this.dynamicRouter.add($, Q, { validator: K, hooks: V, content: W?.type, handle: X }), this.config.strictPath === false)
          this.dynamicRouter.add($, M, { validator: K, hooks: V, content: W?.type, handle: X });
        this.routes.push({ method: $, path: Q, composed: null, handler: X, hooks: V });
        return;
      }
      const z = t1({ path: Q, method: $, hooks: V, validator: K, handler: X, handleError: this.handleError, onRequest: this.event.request, config: this.config, definitions: J ? this.definitions.type : undefined, schema: J ? this.schema : undefined, getReporter: () => this.reporter, setHeader: this.setHeaders });
      if (!P) {
        const U = Object.assign({ headers: {}, query: {}, params: {}, body: undefined, request: new Request(`http://localhost${Q}`), store: this.store, path: Q, set: { headers: this.setHeaders ?? {}, status: 200 } }, this.decorators);
        let j;
        for (let N of Object.values(V.request))
          try {
            const w = y(N(U), U.set);
            if (w !== undefined) {
              j = w;
              break;
            }
          } catch (w) {
            j = this.handleError(U, w);
            break;
          }
        if (j)
          z.response = j;
        else
          try {
            z.response = z(U);
          } catch (N) {
            z.response = this.handleError(U, N);
          }
      }
      const A = this.routes.findIndex((U) => U.path === Q && U.method === $);
      if (A !== -1)
        this.routes.splice(A, 1);
      if (this.routes.push({ method: $, path: Q, composed: z, handler: X, hooks: V }), $ === "$INTERNALWS") {
        const U = this.config.strictPath ? undefined : Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/";
        if (Q.indexOf(":") === -1 && Q.indexOf("*") === -1) {
          const j = this.staticRouter.handlers.length;
          if (this.staticRouter.handlers.push(z), z.response instanceof Response)
            this.staticRouter.variables += `const st${j} = staticRouter.handlers[${j}].response\n`;
          else
            this.staticRouter.variables += `const st${j} = staticRouter.handlers[${j}]\n`;
          if (this.wsPaths[Q] = j, U)
            this.wsPaths[U] = j;
        } else if (this.wsRouter.add("ws", Q, z), U)
          this.wsRouter.add("ws", U, z);
        return;
      }
      if (Q.indexOf(":") === -1 && Q.indexOf("*") === -1) {
        const U = this.staticRouter.handlers.length;
        if (this.staticRouter.handlers.push(z), z.response instanceof Response)
          this.staticRouter.variables += `const st${U} = staticRouter.handlers[${U}].response\n`;
        else
          this.staticRouter.variables += `const st${U} = staticRouter.handlers[${U}]\n`;
        if (!this.staticRouter.map[Q])
          this.staticRouter.map[Q] = { code: "" };
        if ($ === "ALL")
          this.staticRouter.map[Q].all = `default: return st${U}(ctx)\n`;
        else if (z.response instanceof Response)
          this.staticRouter.map[Q].code = `case '${$}': return st${U}.clone()\n${this.staticRouter.map[Q].code}`;
        else
          this.staticRouter.map[Q].code = `case '${$}': return st${U}(ctx)\n${this.staticRouter.map[Q].code}`;
        if (!this.config.strictPath) {
          if (!this.staticRouter.map[M])
            this.staticRouter.map[M] = { code: "" };
          if ($ === "ALL")
            this.staticRouter.map[M].all = `default: return st${U}(ctx)\n`;
          else if (z.response instanceof Response)
            this.staticRouter.map[M].code = `case '${$}': return st${U}.clone()\n${this.staticRouter.map[M].code}`;
          else
            this.staticRouter.map[M].code = `case '${$}': return st${U}(ctx)\n${this.staticRouter.map[M].code}`;
        }
      } else if (this.router.add($, Q, z), !this.config.strictPath)
        this.router.add($, Q.endsWith("/") ? Q.slice(0, Q.length - 1) : Q + "/", z);
    }
  }
  setHeaders;
  headers($) {
    if (!$)
      return this;
    if (!this.setHeaders)
      this.setHeaders = {};
    return this.setHeaders = d(this.setHeaders, $), this;
  }
  onStart($) {
    return this.on("start", $), this;
  }
  onRequest($) {
    return this.on("request", $), this;
  }
  onParse($) {
    return this.on("parse", $), this;
  }
  onTransform($) {
    return this.on("transform", $), this;
  }
  resolve($) {
    return $.$elysia = "resolve", this.onBeforeHandle($);
  }
  onBeforeHandle($) {
    return this.on("beforeHandle", $), this;
  }
  onAfterHandle($) {
    return this.on("afterHandle", $), this;
  }
  mapResponse($) {
    return this.on("mapResponse", $), this;
  }
  onResponse($) {
    return this.on("response", $), this;
  }
  trace($) {
    return this.reporter.on("event", F1(() => this.reporter, this.event.trace.length, $)), this.on("trace", $), this;
  }
  error($, Z) {
    switch (typeof $) {
      case "string":
        return Z.prototype[_0] = $, this.definitions.error[$] = Z, this;
      case "function":
        return this.definitions.error = $(this.definitions.error), this;
    }
    for (let [X, W] of Object.entries($))
      W.prototype[_0] = X, this.definitions.error[X] = W;
    return this;
  }
  onError($) {
    return this.on("error", $), this;
  }
  onStop($) {
    return this.on("stop", $), this;
  }
  on($, Z) {
    for (let X of Array.isArray(Z) ? Z : [Z])
      switch (X = R1(X), $) {
        case "start":
          this.event.start.push(X);
          break;
        case "request":
          this.event.request.push(X);
          break;
        case "parse":
          this.event.parse.splice(this.event.parse.length - 1, 0, X);
          break;
        case "transform":
          this.event.transform.push(X);
          break;
        case "beforeHandle":
          this.event.beforeHandle.push(X);
          break;
        case "afterHandle":
          this.event.afterHandle.push(X);
          break;
        case "mapResponse":
          this.event.mapResponse.push(X);
          break;
        case "response":
          this.event.onResponse.push(X);
          break;
        case "trace":
          this.event.trace.push(X);
          break;
        case "error":
          this.event.error.push(X);
          break;
        case "stop":
          this.event.stop.push(X);
          break;
      }
    return this;
  }
  group($, Z, X) {
    const W = new r({ ...this.config || {}, prefix: "" });
    W.store = this.store, W.definitions = this.definitions, W.getServer = () => this.server;
    const J = typeof Z === "object", Y = (J ? X : Z)(W);
    if (this.decorators = d(this.decorators, W.decorators), Y.event.request.length)
      this.event.request = [...this.event.request || [], ...Y.event.request || []];
    if (Y.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...Y.event.onResponse || []];
    return this.model(Y.definitions.type), Object.values(W.routes).forEach(({ method: Q, path: _, handler: B, hooks: K }) => {
      if (_ = (J ? "" : this.config.prefix) + $ + _, J) {
        const G = Z, M = K;
        this.add(Q, _, B, n(G, { ...M || {}, error: !M.error ? Y.event.error : Array.isArray(M.error) ? [...M.error || {}, ...Y.event.error || {}] : [M.error, ...Y.event.error || {}] }));
      } else
        this.add(Q, _, B, n(K, { error: Y.event.error }), { skipPrefix: true });
    }), this;
  }
  guard($, Z) {
    if (!Z)
      return this.event = v0(this.event, $), this.validator = { body: $.body, headers: $.headers, params: $.params, query: $.query, response: $.response }, this;
    const X = new r({ ...this.config || {}, prefix: "" });
    X.store = this.store, X.definitions = this.definitions;
    const W = Z(X);
    if (this.decorators = d(this.decorators, X.decorators), W.event.request.length)
      this.event.request = [...this.event.request || [], ...W.event.request || []];
    if (W.event.onResponse.length)
      this.event.onResponse = [...this.event.onResponse || [], ...W.event.onResponse || []];
    return this.model(W.definitions.type), Object.values(X.routes).forEach(({ method: J, path: Y, handler: Q, hooks: _ }) => {
      this.add(J, Y, Q, n($, { ..._ || {}, error: !_.error ? W.event.error : Array.isArray(_.error) ? [..._.error || {}, ...W.event.error || []] : [_.error, ...W.event.error || []] }));
    }), this;
  }
  use($) {
    if ($ instanceof Promise)
      return this.lazyLoadModules.push($.then((Z) => {
        if (typeof Z === "function")
          return Z(this);
        if (typeof Z.default === "function")
          return Z.default(this);
        return this._use(Z);
      }).then((Z) => Z.compile())), this;
    else
      return this._use($);
    return this;
  }
  _use($) {
    if (typeof $ === "function") {
      const J = $(this);
      if (J instanceof Promise)
        return this.lazyLoadModules.push(J.then((Y) => {
          if (Y instanceof r) {
            this.compile();
            for (let { method: Q, path: _, handler: B, hooks: K } of Object.values(Y.routes))
              this.add(Q, _, B, n(K, { error: Y.event.error }));
            return Y;
          }
          if (typeof Y === "function")
            return Y(this);
          if (typeof Y.default === "function")
            return Y.default(this);
          return this._use(Y);
        }).then((Y) => Y.compile())), this;
      return J;
    }
    const { name: Z, seed: X } = $.config;
    $.getServer = () => this.getServer(), this.headers($.setHeaders);
    const W = $.config.scoped;
    if (W) {
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const Y = X !== undefined ? j0(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Q }) => Y === Q))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: Y, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: Y, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Q) => Q.$elysia === "derive").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Q) => Q.$elysia === "derive").map((Q) => ({ fn: Q.toString(), stack: new Error().stack ?? "" })) });
      }
      if ($.model(this.definitions.type), $.error(this.definitions.error), $.macros = [...this.macros || [], ...$.macros || []], $.onRequest((Y) => {
        Object.assign(Y, this.decorators), Object.assign(Y.store, this.store);
      }), $.event.trace.length)
        $.event.trace.push(...$.event.trace);
      if (W && !$.config.prefix)
        console.warn("When using scoped plugins it is recommended to use a prefix, else routing may not work correctly for the second scoped instance");
      if ($.event.error.length)
        $.event.error.push(...this.event.error);
      if ($.config.aot)
        $.compile();
      let J;
      if (W && $.config.prefix) {
        J = this.mount($.config.prefix + "/", $.fetch);
        for (let Y of $.routes)
          this.routes.push({ ...Y, path: `${$.config.prefix}${Y.path}`, hooks: n(Y.hooks, { error: this.event.error }) });
      } else if (J = this.mount($.fetch), J.routes.length)
        this.routes.push(...J.routes);
      return this;
    } else {
      $.reporter = this.reporter;
      for (let J of $.event.trace)
        this.trace(J);
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? j0(Z + JSON.stringify(X)) : 0;
        if (!this.dependencies[Z].some(({ checksum: Q }) => J === Q))
          this.macros.push(...$.macros || []);
        const Y = [];
        for (let Q = 0;Q < this.macros.length; Q++) {
          const _ = this.macros[Q];
          if (Y.includes(_.$elysiaChecksum))
            this.macros.splice(Q, 1), Q--;
          Y.push(_.$elysiaChecksum);
        }
      }
    }
    this.decorate($.decorators), this.state($.store), this.model($.definitions.type), this.error($.definitions.error);
    for (let { method: J, path: Y, handler: Q, hooks: _ } of Object.values($.routes))
      this.add(J, Y, Q, n(_, { error: $.event.error }));
    if (!W)
      if (Z) {
        if (!(Z in this.dependencies))
          this.dependencies[Z] = [];
        const J = X !== undefined ? j0(Z + JSON.stringify(X)) : 0;
        if (this.dependencies[Z].some(({ checksum: Y }) => J === Y))
          return this;
        this.dependencies[Z].push(!this.config?.analytic ? { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies } : { name: $.config.name, seed: $.config.seed, checksum: J, dependencies: $.dependencies, stack: $.stack, routes: $.routes, decorators: $.decorators, store: $.store, type: $.definitions.type, error: $.definitions.error, derive: $.event.transform.filter((Y) => Y?.$elysia === "derive").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })), resolve: $.event.transform.filter((Y) => Y?.$elysia === "resolve").map((Y) => ({ fn: Y.toString(), stack: new Error().stack ?? "" })) }), this.event = v0(this.event, a0($.event), J);
      } else
        this.event = v0(this.event, a0($.event));
    return this;
  }
  macro($) {
    return $.$elysiaChecksum = j0(JSON.stringify({ name: this.config.name, seed: this.config.seed, content: $.toString() })), this.macros.push($), this;
  }
  mount($, Z) {
    if ($ instanceof r || typeof $ === "function" || $.length === 0 || $ === "/") {
      const J = typeof $ === "function" ? $ : $ instanceof r ? $.compile().fetch : Z instanceof r ? Z.compile().fetch : Z, Y = async ({ request: Q, path: _ }) => J(new Request(t0(Q.url, _ || "/"), Q));
      return this.all("/", Y, { type: "none" }), this.all("/*", Y, { type: "none" }), this;
    }
    const X = $.length;
    if (Z instanceof r)
      Z = Z.compile().fetch;
    const W = async ({ request: J, path: Y }) => Z(new Request(t0(J.url, Y.slice(X) || "/"), J));
    return this.all($, W, { type: "none" }), this.all($ + ($.endsWith("/") ? "*" : "/*"), W, { type: "none" }), this;
  }
  get($, Z, X) {
    return this.add("GET", $, Z, X), this;
  }
  post($, Z, X) {
    return this.add("POST", $, Z, X), this;
  }
  put($, Z, X) {
    return this.add("PUT", $, Z, X), this;
  }
  patch($, Z, X) {
    return this.add("PATCH", $, Z, X), this;
  }
  delete($, Z, X) {
    return this.add("DELETE", $, Z, X), this;
  }
  options($, Z, X) {
    return this.add("OPTIONS", $, Z, X), this;
  }
  all($, Z, X) {
    return this.add("ALL", $, Z, X), this;
  }
  head($, Z, X) {
    return this.add("HEAD", $, Z, X), this;
  }
  connect($, Z, X) {
    return this.add("CONNECT", $, Z, X), this;
  }
  ws($, Z) {
    const X = Z.transformMessage ? Array.isArray(Z.transformMessage) ? Z.transformMessage : [Z.transformMessage] : undefined;
    let W = null;
    const J = p(Z?.body, { models: this.definitions.type }), Y = p(Z?.response, { models: this.definitions.type }), Q = (_) => {
      if (typeof _ === "string") {
        const B = _?.charCodeAt(0);
        if (B === 47 || B === 123)
          try {
            _ = JSON.parse(_);
          } catch {
          }
        else if (f0(_))
          _ = +_;
      }
      if (X?.length)
        for (let B = 0;B < X.length; B++) {
          const K = X[B](_);
          if (K !== undefined)
            _ = K;
        }
      return _;
    };
    return this.route("$INTERNALWS", $, (_) => {
      const { set: B, path: K, qi: G, headers: M, query: V, params: P } = _;
      if (W === null)
        W = this.getServer();
      if (W?.upgrade(_.request, { headers: typeof Z.upgrade === "function" ? Z.upgrade(_) : Z.upgrade, data: { validator: Y, open(z) {
        Z.open?.(new D0(z, _));
      }, message: (z, A) => {
        const U = Q(A);
        if (J?.Check(U) === false)
          return void z.send(new q("message", J, U).message);
        Z.message?.(new D0(z, _), U);
      }, drain(z) {
        Z.drain?.(new D0(z, _));
      }, close(z, A, U) {
        Z.close?.(new D0(z, _), A, U);
      } } }))
        return;
      return B.status = 400, "Expected a websocket connection";
    }, { beforeHandle: Z.beforeHandle, transform: Z.transform, headers: Z.headers, params: Z.params, query: Z.query }), this;
  }
  route($, Z, X, { config: W, ...J } = { config: { allowMeta: false } }) {
    return this.add($, Z, X, J, W), this;
  }
  state($, Z) {
    switch (typeof $) {
      case "object":
        return this.store = d(this.store, $), this;
      case "function":
        return this.store = $(this.store), this;
    }
    if (!($ in this.store))
      this.store[$] = Z;
    return this;
  }
  decorate($, Z) {
    switch (typeof $) {
      case "object":
        return this.decorators = d(this.decorators, $), this;
      case "function":
        return this.decorators = $(this.decorators), this;
    }
    if (!($ in this.decorators))
      this.decorators[$] = Z;
    return this;
  }
  derive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  model($, Z) {
    switch (typeof $) {
      case "object":
        return Object.entries($).forEach(([X, W]) => {
          if (!(X in this.definitions.type))
            this.definitions.type[X] = W;
        }), this;
      case "function":
        return this.definitions.type = $(this.definitions.type), this;
    }
    return this.definitions.type[$] = Z, this;
  }
  mapDerive($) {
    return $.$elysia = "derive", this.onTransform($);
  }
  affix($, Z, X) {
    if (X === "")
      return this;
    const W = ["_", "-", " "], J = (B) => B[0].toUpperCase() + B.slice(1), Y = $ === "prefix" ? (B, K) => W.includes(B.at(-1) ?? "") ? B + K : B + J(K) : W.includes(X.at(-1) ?? "") ? (B, K) => K + B : (B, K) => K + J(B), Q = (B) => {
      const K = {};
      switch (B) {
        case "decorator":
          for (let G in this.decorators)
            K[Y(X, G)] = this.decorators[G];
          this.decorators = K;
          break;
        case "state":
          for (let G in this.store)
            K[Y(X, G)] = this.store[G];
          this.store = K;
          break;
        case "model":
          for (let G in this.definitions.type)
            K[Y(X, G)] = this.definitions.type[G];
          this.definitions.type = K;
          break;
        case "error":
          for (let G in this.definitions.error)
            K[Y(X, G)] = this.definitions.error[G];
          this.definitions.error = K;
          break;
      }
    }, _ = Array.isArray(Z) ? Z : [Z];
    for (let B of _.some((K) => K === "all") ? ["decorator", "state", "model", "error"] : _)
      Q(B);
    return this;
  }
  prefix($, Z) {
    return this.affix("prefix", $, Z);
  }
  suffix($, Z) {
    return this.affix("suffix", $, Z);
  }
  compile() {
    if (this.fetch = this.config.aot ? Y1(this) : _1(this), typeof this.server?.reload === "function")
      this.server.reload({ ...this.server || {}, fetch: this.fetch });
    return this;
  }
  handle = async ($) => this.fetch($);
  fetch = ($) => {
    return (this.fetch = this.config.aot ? Y1(this) : _1(this))($);
  };
  handleError = async ($, Z) => (this.handleError = this.config.aot ? B1(this) : s1(this))($, Z);
  outerErrorHandler = ($) => new Response($.message || $.name || "Error", { status: $?.status ?? 500 });
  listen = ($, Z) => {
    if (typeof Bun === "undefined")
      throw new Error(".listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch");
    if (this.compile(), typeof $ === "string") {
      if ($ = +$.trim(), Number.isNaN($))
        throw new Error("Port must be a numeric value");
    }
    const X = this.fetch, W = typeof $ === "object" ? { development: !N0, reusePort: true, ...this.config.serve || {}, ...$ || {}, websocket: { ...this.config.websocket || {}, ...$1 || {} }, fetch: X, error: this.outerErrorHandler } : { development: !N0, reusePort: true, ...this.config.serve || {}, websocket: { ...this.config.websocket || {}, ...$1 || {} }, port: $, fetch: X, error: this.outerErrorHandler };
    if (this.server = Bun?.serve(W), this.event.start.length)
      for (let J = 0;J < this.event.start.length; J++)
        this.event.start[J](this);
    if (Z)
      Z(this.server);
    return process.on("beforeExit", () => {
      for (let J = 0;J < this.event.stop.length; J++)
        this.event.stop[J](this);
    }), Promise.all(this.lazyLoadModules).then(() => {
      Bun?.gc(false);
    }), this;
  };
  stop = async () => {
    if (!this.server)
      throw new Error("Elysia isn't running. Call `app.listen` to start the server.");
    if (this.server.stop(), this.event.stop.length)
      for (let $ = 0;$ < this.event.stop.length; $++)
        this.event.stop[$](this);
  };
  get modules() {
    return Promise.all(this.lazyLoadModules);
  }
}

// node_modules/postgres/src/index.js
import os from "os";
import fs from "fs";

// node_modules/postgres/src/query.js
var cachedError = function(xs) {
  if (originCache.has(xs))
    return originCache.get(xs);
  const x = Error.stackTraceLimit;
  Error.stackTraceLimit = 4;
  originCache.set(xs, new Error);
  Error.stackTraceLimit = x;
  return originCache.get(xs);
};
var originCache = new Map;
var originStackCache = new Map;
var originError = Symbol("OriginError");
var CLOSE = {};

class Query extends Promise {
  constructor(strings, args, handler, canceller, options = {}) {
    let resolve, reject;
    super((a2, b2) => {
      resolve = a2;
      reject = b2;
    });
    this.tagged = Array.isArray(strings.raw);
    this.strings = strings;
    this.args = args;
    this.handler = handler;
    this.canceller = canceller;
    this.options = options;
    this.state = null;
    this.statement = null;
    this.resolve = (x) => (this.active = false, resolve(x));
    this.reject = (x) => (this.active = false, reject(x));
    this.active = false;
    this.cancelled = null;
    this.executed = false;
    this.signature = "";
    this[originError] = this.handler.debug ? new Error : this.tagged && cachedError(this.strings);
  }
  get origin() {
    return (this.handler.debug ? this[originError].stack : this.tagged && originStackCache.has(this.strings) ? originStackCache.get(this.strings) : originStackCache.set(this.strings, this[originError].stack).get(this.strings)) || "";
  }
  static get [Symbol.species]() {
    return Promise;
  }
  cancel() {
    return this.canceller && (this.canceller(this), this.canceller = null);
  }
  simple() {
    this.options.simple = true;
    this.options.prepare = false;
    return this;
  }
  async readable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  async writable() {
    this.simple();
    this.streaming = true;
    return this;
  }
  cursor(rows = 1, fn) {
    this.options.simple = false;
    if (typeof rows === "function") {
      fn = rows;
      rows = 1;
    }
    this.cursorRows = rows;
    if (typeof fn === "function")
      return this.cursorFn = fn, this;
    let prev;
    return {
      [Symbol.asyncIterator]: () => ({
        next: () => {
          if (this.executed && !this.active)
            return { done: true };
          prev && prev();
          const promise5 = new Promise((resolve, reject) => {
            this.cursorFn = (value15) => {
              resolve({ value: value15, done: false });
              return new Promise((r2) => prev = r2);
            };
            this.resolve = () => (this.active = false, resolve({ done: true }));
            this.reject = (x) => (this.active = false, reject(x));
          });
          this.execute();
          return promise5;
        },
        return() {
          prev && prev(CLOSE);
          return { done: true };
        }
      })
    };
  }
  describe() {
    this.options.simple = false;
    this.onlyDescribe = this.options.prepare = true;
    return this;
  }
  stream() {
    throw new Error(".stream has been renamed to .forEach");
  }
  forEach(fn) {
    this.forEachFn = fn;
    this.handle();
    return this;
  }
  raw() {
    this.isRaw = true;
    return this;
  }
  values() {
    this.isRaw = "values";
    return this;
  }
  async handle() {
    !this.executed && (this.executed = true) && await 1 && this.handler(this);
  }
  execute() {
    this.handle();
    return this;
  }
  then() {
    this.handle();
    return super.then.apply(this, arguments);
  }
  catch() {
    this.handle();
    return super.catch.apply(this, arguments);
  }
  finally() {
    this.handle();
    return super.finally.apply(this, arguments);
  }
}

// node_modules/postgres/src/errors.js
var connection = function(x, options, socket) {
  const { host, port } = socket || options;
  const error22 = Object.assign(new Error("write " + x + " " + (options.path || host + ":" + port)), {
    code: x,
    errno: x,
    address: options.path || host
  }, options.path ? {} : { port });
  Error.captureStackTrace(error22, connection);
  return error22;
};
var postgres = function(x) {
  const error22 = new PostgresError(x);
  Error.captureStackTrace(error22, postgres);
  return error22;
};
var generic = function(code, message) {
  const error22 = Object.assign(new Error(code + ": " + message), { code });
  Error.captureStackTrace(error22, generic);
  return error22;
};
var notSupported = function(x) {
  const error22 = Object.assign(new Error(x + " (B) is not supported"), {
    code: "MESSAGE_NOT_SUPPORTED",
    name: x
  });
  Error.captureStackTrace(error22, notSupported);
  return error22;
};

class PostgresError extends Error {
  constructor(x) {
    super(x.message);
    this.name = this.constructor.name;
    Object.assign(this, x);
  }
}
var Errors3 = {
  connection,
  postgres,
  generic,
  notSupported
};

// node_modules/postgres/src/types.js
function handleValue(x, parameters4, types, options) {
  let value15 = x instanceof Parameter ? x.value : x;
  if (value15 === undefined) {
    x instanceof Parameter ? x.value = options.transform.undefined : value15 = x = options.transform.undefined;
    if (value15 === undefined)
      throw Errors3.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
  }
  return "$" + types.push(x instanceof Parameter ? (parameters4.push(x.value), x.array ? x.array[x.type || inferType(x.value)] || x.type || firstIsString(x.value) : x.type) : (parameters4.push(x), inferType(x)));
}
function stringify(q2, string7, value15, parameters4, types, options) {
  for (let i = 1;i < q2.strings.length; i++) {
    string7 += stringifyValue(string7, value15, parameters4, types, options) + q2.strings[i];
    value15 = q2.args[i];
  }
  return string7;
}
var stringifyValue = function(string7, value15, parameters4, types, o2) {
  return value15 instanceof Builder ? value15.build(string7, parameters4, types, o2) : value15 instanceof Query ? fragment(value15, parameters4, types, o2) : value15 instanceof Identifier2 ? value15.value : value15 && value15[0] instanceof Query ? value15.reduce((acc, x) => acc + " " + fragment(x, parameters4, types, o2), "") : handleValue(value15, parameters4, types, o2);
};
var fragment = function(q2, parameters4, types, options) {
  q2.fragment = true;
  return stringify(q2, q2.strings[0], q2.args[0], parameters4, types, options);
};
var valuesBuilder = function(first, parameters4, types, columns, options) {
  return first.map((row) => "(" + columns.map((column) => stringifyValue("values", row[column], parameters4, types, options)).join(",") + ")").join(",");
};
var values = function(first, rest4, parameters4, types, options) {
  const multi = Array.isArray(first[0]);
  const columns = rest4.length ? rest4.flat() : Object.keys(multi ? first[0] : first);
  return valuesBuilder(multi ? first : [first], parameters4, types, columns, options);
};
var select = function(first, rest4, parameters4, types, options) {
  typeof first === "string" && (first = [first].concat(rest4));
  if (Array.isArray(first))
    return escapeIdentifiers(first, options);
  let value15;
  const columns = rest4.length ? rest4.flat() : Object.keys(first);
  return columns.map((x) => {
    value15 = first[x];
    return (value15 instanceof Query ? fragment(value15, parameters4, types, options) : value15 instanceof Identifier2 ? value15.value : handleValue(value15, parameters4, types, options)) + " as " + escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x);
  }).join(",");
};
var notTagged = function() {
  throw Errors3.generic("NOT_TAGGED_CALL", "Query not called as a tagged template literal");
};
var firstIsString = function(x) {
  if (Array.isArray(x))
    return firstIsString(x[0]);
  return typeof x === "string" ? 1009 : 0;
};
var typeHandlers = function(types) {
  return Object.keys(types).reduce((acc, k) => {
    types[k].from && [].concat(types[k].from).forEach((x) => acc.parsers[x] = types[k].parse);
    if (types[k].serialize) {
      acc.serializers[types[k].to] = types[k].serialize;
      types[k].from && [].concat(types[k].from).forEach((x) => acc.serializers[x] = types[k].serialize);
    }
    return acc;
  }, { parsers: {}, serializers: {} });
};
var escapeIdentifiers = function(xs, { transform: { column } }) {
  return xs.map((x) => escapeIdentifier(column.to ? column.to(x) : x)).join(",");
};
var arrayEscape = function(x) {
  return x.replace(escapeBackslash, "\\\\").replace(escapeQuote, '\\"');
};
var arrayParserLoop = function(s2, x, parser, typarray) {
  const xs = [];
  const delimiter = typarray === 1020 ? ";" : ",";
  for (;s2.i < x.length; s2.i++) {
    s2.char = x[s2.i];
    if (s2.quoted) {
      if (s2.char === "\\") {
        s2.str += x[++s2.i];
      } else if (s2.char === '"') {
        xs.push(parser ? parser(s2.str) : s2.str);
        s2.str = "";
        s2.quoted = x[s2.i + 1] === '"';
        s2.last = s2.i + 2;
      } else {
        s2.str += s2.char;
      }
    } else if (s2.char === '"') {
      s2.quoted = true;
    } else if (s2.char === "{") {
      s2.last = ++s2.i;
      xs.push(arrayParserLoop(s2, x, parser, typarray));
    } else if (s2.char === "}") {
      s2.quoted = false;
      s2.last < s2.i && xs.push(parser ? parser(x.slice(s2.last, s2.i)) : x.slice(s2.last, s2.i));
      s2.last = s2.i + 1;
      break;
    } else if (s2.char === delimiter && s2.p !== "}" && s2.p !== '"') {
      xs.push(parser ? parser(x.slice(s2.last, s2.i)) : x.slice(s2.last, s2.i));
      s2.last = s2.i + 1;
    }
    s2.p = s2.char;
  }
  s2.last < s2.i && xs.push(parser ? parser(x.slice(s2.last, s2.i + 1)) : x.slice(s2.last, s2.i + 1));
  return xs;
};
var createJsonTransform = function(fn) {
  return function jsonTransform(x, column) {
    return typeof x === "object" && x !== null && (column.type === 114 || column.type === 3802) ? Array.isArray(x) ? x.map((x2) => jsonTransform(x2, column)) : Object.entries(x).reduce((acc, [k, v2]) => Object.assign(acc, { [fn(k)]: jsonTransform(v2, column) }), {}) : x;
  };
};
var types = {
  string: {
    to: 25,
    from: null,
    serialize: (x) => "" + x
  },
  number: {
    to: 0,
    from: [21, 23, 26, 700, 701],
    serialize: (x) => "" + x,
    parse: (x) => +x
  },
  json: {
    to: 114,
    from: [114, 3802],
    serialize: (x) => JSON.stringify(x),
    parse: (x) => JSON.parse(x)
  },
  boolean: {
    to: 16,
    from: 16,
    serialize: (x) => x === true ? "t" : "f",
    parse: (x) => x === "t"
  },
  date: {
    to: 1184,
    from: [1082, 1114, 1184],
    serialize: (x) => (x instanceof Date ? x : new Date(x)).toISOString(),
    parse: (x) => new Date(x)
  },
  bytea: {
    to: 17,
    from: 17,
    serialize: (x) => "\\x" + Buffer.from(x).toString("hex"),
    parse: (x) => Buffer.from(x.slice(2), "hex")
  }
};

class NotTagged {
  then() {
    notTagged();
  }
  catch() {
    notTagged();
  }
  finally() {
    notTagged();
  }
}

class Identifier2 extends NotTagged {
  constructor(value15) {
    super();
    this.value = escapeIdentifier(value15);
  }
}

class Parameter extends NotTagged {
  constructor(value15, type75, array5) {
    super();
    this.value = value15;
    this.type = type75;
    this.array = array5;
  }
}

class Builder extends NotTagged {
  constructor(first, rest4) {
    super();
    this.first = first;
    this.rest = rest4;
  }
  build(before, parameters4, types2, options) {
    const keyword = builders.map(([x, fn]) => ({ fn, i: before.search(x) })).sort((a2, b2) => a2.i - b2.i).pop();
    return keyword.i === -1 ? escapeIdentifiers(this.first, options) : keyword.fn(this.first, this.rest, parameters4, types2, options);
  }
}
var defaultHandlers = typeHandlers(types);
var builders = Object.entries({
  values,
  in: (...xs) => {
    const x = values(...xs);
    return x === "()" ? "(null)" : x;
  },
  select,
  as: select,
  returning: select,
  "\\(": select,
  update(first, rest4, parameters4, types2, options) {
    return (rest4.length ? rest4.flat() : Object.keys(first)).map((x) => escapeIdentifier(options.transform.column.to ? options.transform.column.to(x) : x) + "=" + stringifyValue("values", first[x], parameters4, types2, options));
  },
  insert(first, rest4, parameters4, types2, options) {
    const columns = rest4.length ? rest4.flat() : Object.keys(Array.isArray(first) ? first[0] : first);
    return "(" + escapeIdentifiers(columns, options) + ")values" + valuesBuilder(Array.isArray(first) ? first : [first], parameters4, types2, columns, options);
  }
}).map(([x, fn]) => [new RegExp("((?:^|[\\s(])" + x + "(?:$|[\\s(]))(?![\\s\\S]*\\1)", "i"), fn]);
var serializers = defaultHandlers.serializers;
var parsers = defaultHandlers.parsers;
var mergeUserTypes = function(types2) {
  const user = typeHandlers(types2 || {});
  return {
    serializers: Object.assign({}, serializers, user.serializers),
    parsers: Object.assign({}, parsers, user.parsers)
  };
};
var escapeIdentifier = function escape(str) {
  return '"' + str.replace(/"/g, '""').replace(/\./g, '"."') + '"';
};
var inferType = function inferType2(x) {
  return x instanceof Parameter ? x.type : x instanceof Date ? 1184 : x instanceof Uint8Array ? 17 : x === true || x === false ? 16 : typeof x === "bigint" ? 20 : Array.isArray(x) ? inferType2(x[0]) : 0;
};
var escapeBackslash = /\\/g;
var escapeQuote = /"/g;
var arraySerializer = function arraySerializer2(xs, serializer, options, typarray) {
  if (Array.isArray(xs) === false)
    return xs;
  if (!xs.length)
    return "{}";
  const first = xs[0];
  const delimiter = typarray === 1020 ? ";" : ",";
  if (Array.isArray(first) && !first.type)
    return "{" + xs.map((x) => arraySerializer2(x, serializer, options, typarray)).join(delimiter) + "}";
  return "{" + xs.map((x) => {
    if (x === undefined) {
      x = options.transform.undefined;
      if (x === undefined)
        throw Errors3.generic("UNDEFINED_VALUE", "Undefined values are not allowed");
    }
    return x === null ? "null" : '"' + arrayEscape(serializer ? serializer(x.type ? x.value : x) : "" + x) + '"';
  }).join(delimiter) + "}";
};
var arrayParserState = {
  i: 0,
  char: null,
  str: "",
  quoted: false,
  last: 0
};
var arrayParser = function arrayParser2(x, parser, typarray) {
  arrayParserState.i = arrayParserState.last = 0;
  return arrayParserLoop(arrayParserState, x, parser, typarray);
};
var toCamel = (x) => {
  let str = x[0];
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toPascal = (x) => {
  let str = x[0].toUpperCase();
  for (let i = 1;i < x.length; i++)
    str += x[i] === "_" ? x[++i].toUpperCase() : x[i];
  return str;
};
var toKebab = (x) => x.replace(/_/g, "-");
var fromCamel = (x) => x.replace(/([A-Z])/g, "_$1").toLowerCase();
var fromPascal = (x) => (x.slice(0, 1) + x.slice(1).replace(/([A-Z])/g, "_$1")).toLowerCase();
var fromKebab = (x) => x.replace(/-/g, "_");
toCamel.column = { from: toCamel };
toCamel.value = { from: createJsonTransform(toCamel) };
fromCamel.column = { to: fromCamel };
var camel = { ...toCamel };
camel.column.to = fromCamel;
toPascal.column = { from: toPascal };
toPascal.value = { from: createJsonTransform(toPascal) };
fromPascal.column = { to: fromPascal };
var pascal = { ...toPascal };
pascal.column.to = fromPascal;
toKebab.column = { from: toKebab };
toKebab.value = { from: createJsonTransform(toKebab) };
fromKebab.column = { to: fromKebab };
var kebab = { ...toKebab };
kebab.column.to = fromKebab;

// node_modules/postgres/src/connection.js
import net from "net";
import tls from "tls";
import crypto2 from "crypto";
import Stream from "stream";
import {performance} from "perf_hooks";

// node_modules/postgres/src/result.js
class Result extends Array {
  constructor() {
    super();
    Object.defineProperties(this, {
      count: { value: null, writable: true },
      state: { value: null, writable: true },
      command: { value: null, writable: true },
      columns: { value: null, writable: true },
      statement: { value: null, writable: true }
    });
  }
  static get [Symbol.species]() {
    return Array;
  }
}

// node_modules/postgres/src/queue.js
var Queue = function(initial = []) {
  let xs = initial.slice();
  let index = 0;
  return {
    get length() {
      return xs.length - index;
    },
    remove: (x) => {
      const index2 = xs.indexOf(x);
      return index2 === -1 ? null : (xs.splice(index2, 1), x);
    },
    push: (x) => (xs.push(x), x),
    shift: () => {
      const out = xs[index++];
      if (index === xs.length) {
        index = 0;
        xs = [];
      } else {
        xs[index - 1] = undefined;
      }
      return out;
    }
  };
};
var queue_default = Queue;

// node_modules/postgres/src/bytes.js
var fit = function(x) {
  if (buffer.length - b2.i < x) {
    const prev = buffer, length = prev.length;
    buffer = Buffer.allocUnsafe(length + (length >> 1) + x);
    prev.copy(buffer);
  }
};
var reset = function() {
  b2.i = 0;
  return b2;
};
var size = 256;
var buffer = Buffer.allocUnsafe(size);
var messages = "BCcDdEFfHPpQSX".split("").reduce((acc, x) => {
  const v2 = x.charCodeAt(0);
  acc[x] = () => {
    buffer[0] = v2;
    b2.i = 5;
    return b2;
  };
  return acc;
}, {});
var b2 = Object.assign(reset, messages, {
  N: String.fromCharCode(0),
  i: 0,
  inc(x) {
    b2.i += x;
    return b2;
  },
  str(x) {
    const length = Buffer.byteLength(x);
    fit(length);
    b2.i += buffer.write(x, b2.i, length, "utf8");
    return b2;
  },
  i16(x) {
    fit(2);
    buffer.writeUInt16BE(x, b2.i);
    b2.i += 2;
    return b2;
  },
  i32(x, i) {
    if (i || i === 0) {
      buffer.writeUInt32BE(x, i);
      return b2;
    }
    fit(4);
    buffer.writeUInt32BE(x, b2.i);
    b2.i += 4;
    return b2;
  },
  z(x) {
    fit(x);
    buffer.fill(0, b2.i, b2.i + x);
    b2.i += x;
    return b2;
  },
  raw(x) {
    buffer = Buffer.concat([buffer.subarray(0, b2.i), x]);
    b2.i = buffer.length;
    return b2;
  },
  end(at = 1) {
    buffer.writeUInt32BE(b2.i - at, at);
    const out = buffer.subarray(0, b2.i);
    b2.i = 0;
    buffer = Buffer.allocUnsafe(size);
    return out;
  }
});
var bytes_default = b2;

// node_modules/postgres/src/connection.js
var Connection = function(options, queues = {}, { onopen = noop, onend = noop, onclose = noop } = {}) {
  const {
    ssl,
    max,
    user,
    host,
    port,
    database,
    parsers: parsers2,
    transform: transform7,
    onnotice,
    onnotify,
    onparameter,
    max_pipeline,
    keep_alive,
    backoff,
    target_session_attrs
  } = options;
  const sent = queue_default(), id = uid++, backend = { pid: null, secret: null }, idleTimer = timer(end, options.idle_timeout), lifeTimer = timer(end, options.max_lifetime), connectTimer = timer(connectTimedOut, options.connect_timeout);
  let socket = null, cancelMessage, result2 = new Result, incoming = Buffer.alloc(0), needsTypes = options.fetch_types, backendParameters = {}, statements = {}, statementId = Math.random().toString(36).slice(2), statementCount = 1, closedDate = 0, remaining = 0, hostIndex = 0, retries = 0, length = 0, delay = 0, rows = 0, serverSignature = null, nextWriteTimer = null, terminated = false, incomings = null, results = null, initial = null, ending = null, stream = null, chunk = null, ended = null, nonce = null, query3 = null, final = null;
  const connection2 = {
    queue: queues.closed,
    idleTimer,
    connect(query4) {
      initial = query4 || true;
      reconnect();
    },
    terminate,
    execute,
    cancel,
    end,
    count: 0,
    id
  };
  queues.closed && queues.closed.push(connection2);
  return connection2;
  async function createSocket() {
    let x;
    try {
      x = options.socket ? await Promise.resolve(options.socket(options)) : new net.Socket;
    } catch (e2) {
      error22(e2);
      return;
    }
    x.on("error", error22);
    x.on("close", closed);
    x.on("drain", drain);
    return x;
  }
  async function cancel({ pid, secret }, resolve, reject) {
    try {
      cancelMessage = bytes_default().i32(16).i32(80877102).i32(pid).i32(secret).end(16);
      await connect();
      socket.once("error", reject);
      socket.once("close", resolve);
    } catch (error23) {
      reject(error23);
    }
  }
  function execute(q2) {
    if (terminated)
      return queryError(q2, Errors3.connection("CONNECTION_DESTROYED", options));
    if (q2.cancelled)
      return;
    try {
      q2.state = backend;
      query3 ? sent.push(q2) : (query3 = q2, query3.active = true);
      build(q2);
      return write(toBuffer(q2)) && !q2.describeFirst && !q2.cursorFn && sent.length < max_pipeline && (!q2.options.onexecute || q2.options.onexecute(connection2));
    } catch (error23) {
      sent.length === 0 && write(Sync);
      errored(error23);
      return true;
    }
  }
  function toBuffer(q2) {
    if (q2.parameters.length >= 65534)
      throw Errors3.generic("MAX_PARAMETERS_EXCEEDED", "Max number of parameters (65534) exceeded");
    return q2.options.simple ? bytes_default().Q().str(q2.statement.string + bytes_default.N).end() : q2.describeFirst ? Buffer.concat([describe(q2), Flush]) : q2.prepare ? q2.prepared ? prepared(q2) : Buffer.concat([describe(q2), prepared(q2)]) : unnamed(q2);
  }
  function describe(q2) {
    return Buffer.concat([
      Parse(q2.statement.string, q2.parameters, q2.statement.types, q2.statement.name),
      Describe("S", q2.statement.name)
    ]);
  }
  function prepared(q2) {
    return Buffer.concat([
      Bind(q2.parameters, q2.statement.types, q2.statement.name, q2.cursorName),
      q2.cursorFn ? Execute("", q2.cursorRows) : ExecuteUnnamed
    ]);
  }
  function unnamed(q2) {
    return Buffer.concat([
      Parse(q2.statement.string, q2.parameters, q2.statement.types),
      DescribeUnnamed,
      prepared(q2)
    ]);
  }
  function build(q2) {
    const parameters4 = [], types3 = [];
    const string7 = stringify(q2, q2.strings[0], q2.args[0], parameters4, types3, options);
    !q2.tagged && q2.args.forEach((x) => handleValue(x, parameters4, types3, options));
    q2.prepare = options.prepare && ("prepare" in q2.options ? q2.options.prepare : true);
    q2.string = string7;
    q2.signature = q2.prepare && types3 + string7;
    q2.onlyDescribe && delete statements[q2.signature];
    q2.parameters = q2.parameters || parameters4;
    q2.prepared = q2.prepare && q2.signature in statements;
    q2.describeFirst = q2.onlyDescribe || parameters4.length && !q2.prepared;
    q2.statement = q2.prepared ? statements[q2.signature] : { string: string7, types: types3, name: q2.prepare ? statementId + statementCount++ : "" };
    typeof options.debug === "function" && options.debug(id, string7, parameters4, types3);
  }
  function write(x, fn) {
    chunk = chunk ? Buffer.concat([chunk, x]) : Buffer.from(x);
    if (fn || chunk.length >= 1024)
      return nextWrite(fn);
    nextWriteTimer === null && (nextWriteTimer = setImmediate(nextWrite));
    return true;
  }
  function nextWrite(fn) {
    const x = socket.write(chunk, fn);
    nextWriteTimer !== null && clearImmediate(nextWriteTimer);
    chunk = nextWriteTimer = null;
    return x;
  }
  function connectTimedOut() {
    errored(Errors3.connection("CONNECT_TIMEOUT", options, socket));
    socket.destroy();
  }
  async function secure() {
    write(SSLRequest);
    const canSSL = await new Promise((r2) => socket.once("data", (x) => r2(x[0] === 83)));
    if (!canSSL && ssl === "prefer")
      return connected();
    socket.removeAllListeners();
    socket = tls.connect({
      socket,
      servername: net.isIP(socket.host) ? undefined : socket.host,
      ...ssl === "require" || ssl === "allow" || ssl === "prefer" ? { rejectUnauthorized: false } : ssl === "verify-full" ? {} : typeof ssl === "object" ? ssl : {}
    });
    socket.on("secureConnect", connected);
    socket.on("error", error22);
    socket.on("close", closed);
    socket.on("drain", drain);
  }
  function drain() {
    !query3 && onopen(connection2);
  }
  function data(x) {
    if (incomings) {
      incomings.push(x);
      remaining -= x.length;
      if (remaining >= 0)
        return;
    }
    incoming = incomings ? Buffer.concat(incomings, length - remaining) : incoming.length === 0 ? x : Buffer.concat([incoming, x], incoming.length + x.length);
    while (incoming.length > 4) {
      length = incoming.readUInt32BE(1);
      if (length >= incoming.length) {
        remaining = length - incoming.length;
        incomings = [incoming];
        break;
      }
      try {
        handle(incoming.subarray(0, length + 1));
      } catch (e2) {
        query3 && (query3.cursorFn || query3.describeFirst) && write(Sync);
        errored(e2);
      }
      incoming = incoming.subarray(length + 1);
      remaining = 0;
      incomings = null;
    }
  }
  async function connect() {
    terminated = false;
    backendParameters = {};
    socket || (socket = await createSocket());
    if (!socket)
      return;
    connectTimer.start();
    if (options.socket)
      return ssl ? secure() : connected();
    socket.on("connect", ssl ? secure : connected);
    if (options.path)
      return socket.connect(options.path);
    socket.ssl = ssl;
    socket.connect(port[hostIndex], host[hostIndex]);
    socket.host = host[hostIndex];
    socket.port = port[hostIndex];
    hostIndex = (hostIndex + 1) % port.length;
  }
  function reconnect() {
    setTimeout(connect, closedDate ? closedDate + delay - performance.now() : 0);
  }
  function connected() {
    try {
      statements = {};
      needsTypes = options.fetch_types;
      statementId = Math.random().toString(36).slice(2);
      statementCount = 1;
      lifeTimer.start();
      socket.on("data", data);
      keep_alive && socket.setKeepAlive && socket.setKeepAlive(true, 1000 * keep_alive);
      const s2 = StartupMessage();
      write(s2);
    } catch (err) {
      error22(err);
    }
  }
  function error22(err) {
    if (connection2.queue === queues.connecting && options.host[retries + 1])
      return;
    errored(err);
    while (sent.length)
      queryError(sent.shift(), err);
  }
  function errored(err) {
    stream && (stream.destroy(err), stream = null);
    query3 && queryError(query3, err);
    initial && (queryError(initial, err), initial = null);
  }
  function queryError(query4, err) {
    Object.defineProperties(err, {
      stack: { value: err.stack + query4.origin.replace(/.*\n/, "\n"), enumerable: options.debug },
      query: { value: query4.string, enumerable: options.debug },
      parameters: { value: query4.parameters, enumerable: options.debug },
      args: { value: query4.args, enumerable: options.debug },
      types: { value: query4.statement && query4.statement.types, enumerable: options.debug }
    });
    query4.reject(err);
  }
  function end() {
    return ending || (!connection2.reserved && onend(connection2), !connection2.reserved && !initial && !query3 && sent.length === 0 ? (terminate(), new Promise((r2) => socket && socket.readyState !== "closed" ? socket.once("close", r2) : r2())) : ending = new Promise((r2) => ended = r2));
  }
  function terminate() {
    terminated = true;
    if (stream || query3 || initial || sent.length)
      error22(Errors3.connection("CONNECTION_DESTROYED", options));
    clearImmediate(nextWriteTimer);
    if (socket) {
      socket.removeListener("data", data);
      socket.removeListener("connect", connected);
      socket.readyState === "open" && socket.end(bytes_default().X().end());
    }
    ended && (ended(), ending = ended = null);
  }
  async function closed(hadError) {
    incoming = Buffer.alloc(0);
    remaining = 0;
    incomings = null;
    clearImmediate(nextWriteTimer);
    socket.removeListener("data", data);
    socket.removeListener("connect", connected);
    idleTimer.cancel();
    lifeTimer.cancel();
    connectTimer.cancel();
    if (socket.encrypted) {
      socket.removeAllListeners();
      socket = null;
    }
    if (initial)
      return reconnect();
    !hadError && (query3 || sent.length) && error22(Errors3.connection("CONNECTION_CLOSED", options, socket));
    closedDate = performance.now();
    hadError && options.shared.retries++;
    delay = (typeof backoff === "function" ? backoff(options.shared.retries) : backoff) * 1000;
    onclose(connection2, Errors3.connection("CONNECTION_CLOSED", options, socket));
  }
  function handle(xs, x = xs[0]) {
    (x === 68 ? DataRow : x === 100 ? CopyData : x === 65 ? NotificationResponse : x === 83 ? ParameterStatus : x === 90 ? ReadyForQuery : x === 67 ? CommandComplete : x === 50 ? BindComplete : x === 49 ? ParseComplete : x === 116 ? ParameterDescription : x === 84 ? RowDescription : x === 82 ? Authentication : x === 110 ? NoData : x === 75 ? BackendKeyData : x === 69 ? ErrorResponse : x === 115 ? PortalSuspended : x === 51 ? CloseComplete : x === 71 ? CopyInResponse : x === 78 ? NoticeResponse : x === 72 ? CopyOutResponse : x === 99 ? CopyDone : x === 73 ? EmptyQueryResponse : x === 86 ? FunctionCallResponse : x === 118 ? NegotiateProtocolVersion : x === 87 ? CopyBothResponse : UnknownMessage)(xs);
  }
  function DataRow(x) {
    let index = 7;
    let length2;
    let column;
    let value15;
    const row = query3.isRaw ? new Array(query3.statement.columns.length) : {};
    for (let i = 0;i < query3.statement.columns.length; i++) {
      column = query3.statement.columns[i];
      length2 = x.readInt32BE(index);
      index += 4;
      value15 = length2 === -1 ? null : query3.isRaw === true ? x.subarray(index, index += length2) : column.parser === undefined ? x.toString("utf8", index, index += length2) : column.parser.array === true ? column.parser(x.toString("utf8", index + 1, index += length2)) : column.parser(x.toString("utf8", index, index += length2));
      query3.isRaw ? row[i] = query3.isRaw === true ? value15 : transform7.value.from ? transform7.value.from(value15, column) : value15 : row[column.name] = transform7.value.from ? transform7.value.from(value15, column) : value15;
    }
    query3.forEachFn ? query3.forEachFn(transform7.row.from ? transform7.row.from(row) : row, result2) : result2[rows++] = transform7.row.from ? transform7.row.from(row) : row;
  }
  function ParameterStatus(x) {
    const [k, v2] = x.toString("utf8", 5, x.length - 1).split(bytes_default.N);
    backendParameters[k] = v2;
    if (options.parameters[k] !== v2) {
      options.parameters[k] = v2;
      onparameter && onparameter(k, v2);
    }
  }
  function ReadyForQuery(x) {
    query3 && query3.options.simple && query3.resolve(results || result2);
    query3 = results = null;
    result2 = new Result;
    connectTimer.cancel();
    if (initial) {
      if (target_session_attrs) {
        if (!backendParameters.in_hot_standby || !backendParameters.default_transaction_read_only)
          return fetchState();
        else if (tryNext(target_session_attrs, backendParameters))
          return terminate();
      }
      if (needsTypes) {
        initial === true && (initial = null);
        return fetchArrayTypes();
      }
      initial !== true && execute(initial);
      options.shared.retries = retries = 0;
      initial = null;
      return;
    }
    while (sent.length && (query3 = sent.shift()) && (query3.active = true, query3.cancelled))
      Connection(options).cancel(query3.state, query3.cancelled.resolve, query3.cancelled.reject);
    if (query3)
      return;
    connection2.reserved ? !connection2.reserved.release && x[5] === 73 ? ending ? terminate() : (connection2.reserved = null, onopen(connection2)) : connection2.reserved() : ending ? terminate() : onopen(connection2);
  }
  function CommandComplete(x) {
    rows = 0;
    for (let i = x.length - 1;i > 0; i--) {
      if (x[i] === 32 && x[i + 1] < 58 && result2.count === null)
        result2.count = +x.toString("utf8", i + 1, x.length - 1);
      if (x[i - 1] >= 65) {
        result2.command = x.toString("utf8", 5, i);
        result2.state = backend;
        break;
      }
    }
    final && (final(), final = null);
    if (result2.command === "BEGIN" && max !== 1 && !connection2.reserved)
      return errored(Errors3.generic("UNSAFE_TRANSACTION", "Only use sql.begin, sql.reserved or max: 1"));
    if (query3.options.simple)
      return BindComplete();
    if (query3.cursorFn) {
      result2.count && query3.cursorFn(result2);
      write(Sync);
    }
    query3.resolve(result2);
  }
  function ParseComplete() {
    query3.parsing = false;
  }
  function BindComplete() {
    !result2.statement && (result2.statement = query3.statement);
    result2.columns = query3.statement.columns;
  }
  function ParameterDescription(x) {
    const length2 = x.readUInt16BE(5);
    for (let i = 0;i < length2; ++i)
      !query3.statement.types[i] && (query3.statement.types[i] = x.readUInt32BE(7 + i * 4));
    query3.prepare && (statements[query3.signature] = query3.statement);
    query3.describeFirst && !query3.onlyDescribe && (write(prepared(query3)), query3.describeFirst = false);
  }
  function RowDescription(x) {
    if (result2.command) {
      results = results || [result2];
      results.push(result2 = new Result);
      result2.count = null;
      query3.statement.columns = null;
    }
    const length2 = x.readUInt16BE(5);
    let index = 7;
    let start;
    query3.statement.columns = Array(length2);
    for (let i = 0;i < length2; ++i) {
      start = index;
      while (x[index++] !== 0)
        ;
      const table = x.readUInt32BE(index);
      const number7 = x.readUInt16BE(index + 4);
      const type75 = x.readUInt32BE(index + 6);
      query3.statement.columns[i] = {
        name: transform7.column.from ? transform7.column.from(x.toString("utf8", start, index - 1)) : x.toString("utf8", start, index - 1),
        parser: parsers2[type75],
        table,
        number: number7,
        type: type75
      };
      index += 18;
    }
    result2.statement = query3.statement;
    if (query3.onlyDescribe)
      return query3.resolve(query3.statement), write(Sync);
  }
  async function Authentication(x, type75 = x.readUInt32BE(5)) {
    (type75 === 3 ? AuthenticationCleartextPassword : type75 === 5 ? AuthenticationMD5Password : type75 === 10 ? SASL : type75 === 11 ? SASLContinue : type75 === 12 ? SASLFinal : type75 !== 0 ? UnknownAuth : noop)(x, type75);
  }
  async function AuthenticationCleartextPassword() {
    const payload = await Pass();
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function AuthenticationMD5Password(x) {
    const payload = "md5" + await md5(Buffer.concat([
      Buffer.from(await md5(await Pass() + user)),
      x.subarray(9)
    ]));
    write(bytes_default().p().str(payload).z(1).end());
  }
  async function SASL() {
    nonce = (await crypto2.randomBytes(18)).toString("base64");
    bytes_default().p().str("SCRAM-SHA-256" + bytes_default.N);
    const i = bytes_default.i;
    write(bytes_default.inc(4).str("n,,n=*,r=" + nonce).i32(bytes_default.i - i - 4, i).end());
  }
  async function SASLContinue(x) {
    const res = x.toString("utf8", 9).split(",").reduce((acc, x2) => (acc[x2[0]] = x2.slice(2), acc), {});
    const saltedPassword = await crypto2.pbkdf2Sync(await Pass(), Buffer.from(res.s, "base64"), parseInt(res.i), 32, "sha256");
    const clientKey = await hmac(saltedPassword, "Client Key");
    const auth = "n=*,r=" + nonce + ",r=" + res.r + ",s=" + res.s + ",i=" + res.i + ",c=biws,r=" + res.r;
    serverSignature = (await hmac(await hmac(saltedPassword, "Server Key"), auth)).toString("base64");
    const payload = "c=biws,r=" + res.r + ",p=" + xor(clientKey, Buffer.from(await hmac(await sha256(clientKey), auth))).toString("base64");
    write(bytes_default().p().str(payload).end());
  }
  function SASLFinal(x) {
    if (x.toString("utf8", 9).split(bytes_default.N, 1)[0].slice(2) === serverSignature)
      return;
    errored(Errors3.generic("SASL_SIGNATURE_MISMATCH", "The server did not return the correct signature"));
    socket.destroy();
  }
  function Pass() {
    return Promise.resolve(typeof options.pass === "function" ? options.pass() : options.pass);
  }
  function NoData() {
    result2.statement = query3.statement;
    result2.statement.columns = [];
    if (query3.onlyDescribe)
      return query3.resolve(query3.statement), write(Sync);
  }
  function BackendKeyData(x) {
    backend.pid = x.readUInt32BE(5);
    backend.secret = x.readUInt32BE(9);
  }
  async function fetchArrayTypes() {
    needsTypes = false;
    const types3 = await new Query([`
      select b.oid, b.typarray
      from pg_catalog.pg_type a
      left join pg_catalog.pg_type b on b.oid = a.typelem
      where a.typcategory = 'A'
      group by b.oid, b.typarray
      order by b.oid
    `], [], execute);
    types3.forEach(({ oid, typarray }) => addArrayType(oid, typarray));
  }
  function addArrayType(oid, typarray) {
    if (!!options.parsers[typarray] && !!options.serializers[typarray])
      return;
    const parser = options.parsers[oid];
    options.shared.typeArrayMap[oid] = typarray;
    options.parsers[typarray] = (xs) => arrayParser(xs, parser, typarray);
    options.parsers[typarray].array = true;
    options.serializers[typarray] = (xs) => arraySerializer(xs, options.serializers[oid], options, typarray);
  }
  function tryNext(x, xs) {
    return x === "read-write" && xs.default_transaction_read_only === "on" || x === "read-only" && xs.default_transaction_read_only === "off" || x === "primary" && xs.in_hot_standby === "on" || x === "standby" && xs.in_hot_standby === "off" || x === "prefer-standby" && xs.in_hot_standby === "off" && options.host[retries];
  }
  function fetchState() {
    const query4 = new Query([`
      show transaction_read_only;
      select pg_catalog.pg_is_in_recovery()
    `], [], execute, null, { simple: true });
    query4.resolve = ([[a2], [b3]]) => {
      backendParameters.default_transaction_read_only = a2.transaction_read_only;
      backendParameters.in_hot_standby = b3.pg_is_in_recovery ? "on" : "off";
    };
    query4.execute();
  }
  function ErrorResponse(x) {
    query3 && (query3.cursorFn || query3.describeFirst) && write(Sync);
    const error23 = Errors3.postgres(parseError(x));
    query3 && query3.retried ? errored(query3.retried) : query3 && retryRoutines.has(error23.routine) ? retry(query3, error23) : errored(error23);
  }
  function retry(q2, error23) {
    delete statements[q2.signature];
    q2.retried = error23;
    execute(q2);
  }
  function NotificationResponse(x) {
    if (!onnotify)
      return;
    let index = 9;
    while (x[index++] !== 0)
      ;
    onnotify(x.toString("utf8", 9, index - 1), x.toString("utf8", index, x.length - 1));
  }
  async function PortalSuspended() {
    try {
      const x = await Promise.resolve(query3.cursorFn(result2));
      rows = 0;
      x === CLOSE ? write(Close(query3.portal)) : (result2 = new Result, write(Execute("", query3.cursorRows)));
    } catch (err) {
      write(Sync);
      query3.reject(err);
    }
  }
  function CloseComplete() {
    result2.count && query3.cursorFn(result2);
    query3.resolve(result2);
  }
  function CopyInResponse() {
    stream = new Stream.Writable({
      autoDestroy: true,
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error23, callback) {
        callback(error23);
        socket.write(bytes_default().f().str(error23 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query3.resolve(stream);
  }
  function CopyOutResponse() {
    stream = new Stream.Readable({
      read() {
        socket.resume();
      }
    });
    query3.resolve(stream);
  }
  function CopyBothResponse() {
    stream = new Stream.Duplex({
      autoDestroy: true,
      read() {
        socket.resume();
      },
      write(chunk2, encoding, callback) {
        socket.write(bytes_default().d().raw(chunk2).end(), callback);
      },
      destroy(error23, callback) {
        callback(error23);
        socket.write(bytes_default().f().str(error23 + bytes_default.N).end());
        stream = null;
      },
      final(callback) {
        socket.write(bytes_default().c().end());
        final = callback;
      }
    });
    query3.resolve(stream);
  }
  function CopyData(x) {
    stream && (stream.push(x.subarray(5)) || socket.pause());
  }
  function CopyDone() {
    stream && stream.push(null);
    stream = null;
  }
  function NoticeResponse(x) {
    onnotice ? onnotice(parseError(x)) : console.log(parseError(x));
  }
  function EmptyQueryResponse() {
  }
  function FunctionCallResponse() {
    errored(Errors3.notSupported("FunctionCallResponse"));
  }
  function NegotiateProtocolVersion() {
    errored(Errors3.notSupported("NegotiateProtocolVersion"));
  }
  function UnknownMessage(x) {
    console.error("Postgres.js : Unknown Message:", x[0]);
  }
  function UnknownAuth(x, type75) {
    console.error("Postgres.js : Unknown Auth:", type75);
  }
  function Bind(parameters4, types3, statement = "", portal = "") {
    let prev, type75;
    bytes_default().B().str(portal + bytes_default.N).str(statement + bytes_default.N).i16(0).i16(parameters4.length);
    parameters4.forEach((x, i) => {
      if (x === null)
        return bytes_default.i32(4294967295);
      type75 = types3[i];
      parameters4[i] = x = type75 in options.serializers ? options.serializers[type75](x) : "" + x;
      prev = bytes_default.i;
      bytes_default.inc(4).str(x).i32(bytes_default.i - prev - 4, prev);
    });
    bytes_default.i16(0);
    return bytes_default.end();
  }
  function Parse(str, parameters4, types3, name = "") {
    bytes_default().P().str(name + bytes_default.N).str(str + bytes_default.N).i16(parameters4.length);
    parameters4.forEach((x, i) => bytes_default.i32(types3[i] || 0));
    return bytes_default.end();
  }
  function Describe(x, name = "") {
    return bytes_default().D().str(x).str(name + bytes_default.N).end();
  }
  function Execute(portal = "", rows2 = 0) {
    return Buffer.concat([
      bytes_default().E().str(portal + bytes_default.N).i32(rows2).end(),
      Flush
    ]);
  }
  function Close(portal = "") {
    return Buffer.concat([
      bytes_default().C().str("P").str(portal + bytes_default.N).end(),
      bytes_default().S().end()
    ]);
  }
  function StartupMessage() {
    return cancelMessage || bytes_default().inc(4).i16(3).z(2).str(Object.entries(Object.assign({
      user,
      database,
      client_encoding: "UTF8"
    }, options.connection)).filter(([, v2]) => v2).map(([k, v2]) => k + bytes_default.N + v2).join(bytes_default.N)).z(2).end(0);
  }
};
var parseError = function(x) {
  const error22 = {};
  let start = 5;
  for (let i = 5;i < x.length - 1; i++) {
    if (x[i] === 0) {
      error22[errorFields[x[start]]] = x.toString("utf8", start + 1, i);
      start = i + 1;
    }
  }
  return error22;
};
var md5 = function(x) {
  return crypto2.createHash("md5").update(x).digest("hex");
};
var hmac = function(key, x) {
  return crypto2.createHmac("sha256", key).update(x).digest();
};
var sha256 = function(x) {
  return crypto2.createHash("sha256").update(x).digest();
};
var xor = function(a2, b3) {
  const length = Math.max(a2.length, b3.length);
  const buffer2 = Buffer.allocUnsafe(length);
  for (let i = 0;i < length; i++)
    buffer2[i] = a2[i] ^ b3[i];
  return buffer2;
};
var timer = function(fn, seconds) {
  seconds = typeof seconds === "function" ? seconds() : seconds;
  if (!seconds)
    return { cancel: noop, start: noop };
  let timer2;
  return {
    cancel() {
      timer2 && (clearTimeout(timer2), timer2 = null);
    },
    start() {
      timer2 && clearTimeout(timer2);
      timer2 = setTimeout(done, seconds * 1000, arguments);
    }
  };
  function done(args) {
    fn.apply(null, args);
    timer2 = null;
  }
};
var connection_default = Connection;
var uid = 1;
var Sync = bytes_default().S().end();
var Flush = bytes_default().H().end();
var SSLRequest = bytes_default().i32(8).i32(80877103).end(8);
var ExecuteUnnamed = Buffer.concat([bytes_default().E().str(bytes_default.N).i32(0).end(), Sync]);
var DescribeUnnamed = bytes_default().D().str("S").str(bytes_default.N).end();
var noop = () => {
};
var retryRoutines = new Set([
  "FetchPreparedStatement",
  "RevalidateCachedQuery",
  "transformAssignedExpr"
]);
var errorFields = {
  83: "severity_local",
  86: "severity",
  67: "code",
  77: "message",
  68: "detail",
  72: "hint",
  80: "position",
  112: "internal_position",
  113: "internal_query",
  87: "where",
  115: "schema_name",
  116: "table_name",
  99: "column_name",
  100: "data type_name",
  110: "constraint_name",
  70: "file",
  76: "line",
  82: "routine"
};

// node_modules/postgres/src/subscribe.js
var Time = function(x) {
  return new Date(Date.UTC(2000, 0, 1) + Number(x / BigInt(1000)));
};
var parse4 = function(x, state, parsers2, handle, transform7) {
  const char = (acc, [k, v2]) => (acc[k.charCodeAt(0)] = v2, acc);
  Object.entries({
    R: (x2) => {
      let i = 1;
      const r2 = state[x2.readUInt32BE(i)] = {
        schema: x2.toString("utf8", i += 4, i = x2.indexOf(0, i)) || "pg_catalog",
        table: x2.toString("utf8", i + 1, i = x2.indexOf(0, i + 1)),
        columns: Array(x2.readUInt16BE(i += 2)),
        keys: []
      };
      i += 2;
      let columnIndex = 0, column;
      while (i < x2.length) {
        column = r2.columns[columnIndex++] = {
          key: x2[i++],
          name: transform7.column.from ? transform7.column.from(x2.toString("utf8", i, i = x2.indexOf(0, i))) : x2.toString("utf8", i, i = x2.indexOf(0, i)),
          type: x2.readUInt32BE(i += 1),
          parser: parsers2[x2.readUInt32BE(i)],
          atttypmod: x2.readUInt32BE(i += 4)
        };
        column.key && r2.keys.push(column);
        i += 4;
      }
    },
    Y: () => {
    },
    O: () => {
    },
    B: (x2) => {
      state.date = Time(x2.readBigInt64BE(9));
      state.lsn = x2.subarray(1, 9);
    },
    I: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      const { row } = tuples(x2, relation.columns, i += 7, transform7);
      handle(row, {
        command: "insert",
        relation
      });
    },
    D: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      handle(key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform7).row : null, {
        command: "delete",
        relation,
        key
      });
    },
    U: (x2) => {
      let i = 1;
      const relation = state[x2.readUInt32BE(i)];
      i += 4;
      const key = x2[i] === 75;
      const xs = key || x2[i] === 79 ? tuples(x2, relation.columns, i += 3, transform7) : null;
      xs && (i = xs.i);
      const { row } = tuples(x2, relation.columns, i + 3, transform7);
      handle(row, {
        command: "update",
        relation,
        key,
        old: xs && xs.row
      });
    },
    T: () => {
    },
    C: () => {
    }
  }).reduce(char, {})[x[0]](x);
};
var tuples = function(x, columns, xi, transform7) {
  let type75, column, value15;
  const row = transform7.raw ? new Array(columns.length) : {};
  for (let i = 0;i < columns.length; i++) {
    type75 = x[xi++];
    column = columns[i];
    value15 = type75 === 110 ? null : type75 === 117 ? undefined : column.parser === undefined ? x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)) : column.parser.array === true ? column.parser(x.toString("utf8", xi + 5, xi += 4 + x.readUInt32BE(xi))) : column.parser(x.toString("utf8", xi + 4, xi += 4 + x.readUInt32BE(xi)));
    transform7.raw ? row[i] = transform7.raw === true ? value15 : transform7.value.from ? transform7.value.from(value15, column) : value15 : row[column.name] = transform7.value.from ? transform7.value.from(value15, column) : value15;
  }
  return { i: xi, row: transform7.row.from ? transform7.row.from(row) : row };
};
var parseEvent = function(x) {
  const xs = x.match(/^(\*|insert|update|delete)?:?([^.]+?\.?[^=]+)?=?(.+)?/i) || [];
  if (!xs)
    throw new Error("Malformed subscribe pattern: " + x);
  const [, command, path, key] = xs;
  return (command || "*") + (path ? ":" + (path.indexOf(".") === -1 ? "public." + path : path) : "") + (key ? "=" + key : "");
};
var noop2 = () => {
};
function Subscribe(postgres2, options) {
  const subscribers = new Map, slot = "postgresjs_" + Math.random().toString(36).slice(2), state = {};
  let connection2, stream, ended = false;
  const sql = subscribe.sql = postgres2({
    ...options,
    transform: { column: {}, value: {}, row: {} },
    max: 1,
    fetch_types: false,
    idle_timeout: null,
    max_lifetime: null,
    connection: {
      ...options.connection,
      replication: "database"
    },
    onclose: async function() {
      if (ended)
        return;
      stream = null;
      state.pid = state.secret = undefined;
      connected(await init(sql, slot, options.publications));
      subscribers.forEach((event) => event.forEach(({ onsubscribe }) => onsubscribe()));
    },
    no_subscribe: true
  });
  const { end, close } = sql;
  sql.end = async () => {
    ended = true;
    stream && await new Promise((r2) => (stream.once("close", r2), stream.end()));
    return end();
  };
  sql.close = async () => {
    stream && await new Promise((r2) => (stream.once("close", r2), stream.end()));
    return close();
  };
  return subscribe;
  async function subscribe(event, fn, onsubscribe = noop2) {
    event = parseEvent(event);
    if (!connection2)
      connection2 = init(sql, slot, options.publications);
    const subscriber = { fn, onsubscribe };
    const fns = subscribers.has(event) ? subscribers.get(event).add(subscriber) : subscribers.set(event, new Set([subscriber])).get(event);
    const unsubscribe = () => {
      fns.delete(subscriber);
      fns.size === 0 && subscribers.delete(event);
    };
    return connection2.then((x) => {
      connected(x);
      onsubscribe();
      return { unsubscribe, state, sql };
    });
  }
  function connected(x) {
    stream = x.stream;
    state.pid = x.state.pid;
    state.secret = x.state.secret;
  }
  async function init(sql2, slot2, publications) {
    if (!publications)
      throw new Error("Missing publication names");
    const xs = await sql2.unsafe(`CREATE_REPLICATION_SLOT ${slot2} TEMPORARY LOGICAL pgoutput NOEXPORT_SNAPSHOT`);
    const [x] = xs;
    const stream2 = await sql2.unsafe(`START_REPLICATION SLOT ${slot2} LOGICAL ${x.consistent_point} (proto_version '1', publication_names '${publications}')`).writable();
    const state2 = {
      lsn: Buffer.concat(x.consistent_point.split("/").map((x2) => Buffer.from(("00000000" + x2).slice(-8), "hex")))
    };
    stream2.on("data", data);
    stream2.on("error", error22);
    stream2.on("close", sql2.close);
    return { stream: stream2, state: xs.state };
    function error22(e2) {
      console.error("Unexpected error during logical streaming - reconnecting", e2);
    }
    function data(x2) {
      if (x2[0] === 119)
        parse4(x2.subarray(25), state2, sql2.options.parsers, handle, options.transform);
      else if (x2[0] === 107 && x2[17])
        pong();
    }
    function handle(a2, b3) {
      const path = b3.relation.schema + "." + b3.relation.table;
      call("*", a2, b3);
      call("*:" + path, a2, b3);
      b3.relation.keys.length && call("*:" + path + "=" + b3.relation.keys.map((x2) => a2[x2.name]), a2, b3);
      call(b3.command, a2, b3);
      call(b3.command + ":" + path, a2, b3);
      b3.relation.keys.length && call(b3.command + ":" + path + "=" + b3.relation.keys.map((x2) => a2[x2.name]), a2, b3);
    }
    function pong() {
      const x2 = Buffer.alloc(34);
      x2[0] = "r".charCodeAt(0);
      x2.fill(state2.lsn, 1);
      x2.writeBigInt64BE(BigInt(Date.now() - Date.UTC(2000, 0, 1)) * BigInt(1000), 25);
      stream2.write(x2);
    }
  }
  function call(x, a2, b3) {
    subscribers.has(x) && subscribers.get(x).forEach(({ fn }) => fn(a2, b3, x));
  }
}

// node_modules/postgres/src/large.js
import Stream2 from "stream";
function largeObject(sql, oid, mode = 131072 | 262144) {
  return new Promise(async (resolve, reject) => {
    await sql.begin(async (sql2) => {
      let finish;
      !oid && ([{ oid }] = await sql2`select lo_creat(-1) as oid`);
      const [{ fd }] = await sql2`select lo_open(${oid}, ${mode}) as fd`;
      const lo = {
        writable,
        readable,
        close: () => sql2`select lo_close(${fd})`.then(finish),
        tell: () => sql2`select lo_tell64(${fd})`,
        read: (x) => sql2`select loread(${fd}, ${x}) as data`,
        write: (x) => sql2`select lowrite(${fd}, ${x})`,
        truncate: (x) => sql2`select lo_truncate64(${fd}, ${x})`,
        seek: (x, whence = 0) => sql2`select lo_lseek64(${fd}, ${x}, ${whence})`,
        size: () => sql2`
          select
            lo_lseek64(${fd}, location, 0) as position,
            seek.size
          from (
            select
              lo_lseek64($1, 0, 2) as size,
              tell.location
            from (select lo_tell64($1) as location) tell
          ) seek
        `
      };
      resolve(lo);
      return new Promise(async (r2) => finish = r2);
      async function readable({
        highWaterMark = 2048 * 8,
        start = 0,
        end = Infinity
      } = {}) {
        let max = end - start;
        start && await lo.seek(start);
        return new Stream2.Readable({
          highWaterMark,
          async read(size2) {
            const l2 = size2 > max ? size2 - max : size2;
            max -= size2;
            const [{ data }] = await lo.read(l2);
            this.push(data);
            if (data.length < size2)
              this.push(null);
          }
        });
      }
      async function writable({
        highWaterMark = 2048 * 8,
        start = 0
      } = {}) {
        start && await lo.seek(start);
        return new Stream2.Writable({
          highWaterMark,
          write(chunk, encoding, callback) {
            lo.write(chunk).then(() => callback(), callback);
          }
        });
      }
    }).catch(reject);
  });
}

// node_modules/postgres/src/index.js
var Postgres = function(a2, b3) {
  const options = parseOptions(a2, b3), subscribe2 = options.no_subscribe || Subscribe(Postgres, { ...options });
  let ending = false;
  const queries = queue_default(), connecting = queue_default(), reserved = queue_default(), closed = queue_default(), ended = queue_default(), open = queue_default(), busy = queue_default(), full = queue_default(), queues = { connecting, reserved, closed, ended, open, busy, full };
  const connections = [...Array(options.max)].map(() => connection_default(options, queues, { onopen, onend, onclose }));
  const sql = Sql(handler);
  Object.assign(sql, {
    get parameters() {
      return options.parameters;
    },
    largeObject: largeObject.bind(null, sql),
    subscribe: subscribe2,
    CLOSE,
    END: CLOSE,
    PostgresError,
    options,
    reserve,
    listen,
    begin,
    close,
    end
  });
  return sql;
  function Sql(handler2) {
    handler2.debug = options.debug;
    Object.entries(options.types).reduce((acc, [name, type75]) => {
      acc[name] = (x) => new Parameter(x, type75.to);
      return acc;
    }, typed);
    Object.assign(sql2, {
      types: typed,
      typed,
      unsafe: unsafe5,
      notify,
      array: array5,
      json: json2,
      file
    });
    return sql2;
    function typed(value15, type75) {
      return new Parameter(value15, type75);
    }
    function sql2(strings, ...args) {
      const query4 = strings && Array.isArray(strings.raw) ? new Query(strings, args, handler2, cancel) : typeof strings === "string" && !args.length ? new Identifier2(options.transform.column.to ? options.transform.column.to(strings) : strings) : new Builder(strings, args);
      return query4;
    }
    function unsafe5(string7, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query4 = new Query([string7], args, handler2, cancel, {
        prepare: false,
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query4;
    }
    function file(path, args = [], options2 = {}) {
      arguments.length === 2 && !Array.isArray(args) && (options2 = args, args = []);
      const query4 = new Query([], args, (query5) => {
        fs.readFile(path, "utf8", (err, string7) => {
          if (err)
            return query5.reject(err);
          query5.strings = [string7];
          handler2(query5);
        });
      }, cancel, {
        ...options2,
        simple: "simple" in options2 ? options2.simple : args.length === 0
      });
      return query4;
    }
  }
  async function listen(name, fn, onlisten) {
    const listener = { fn, onlisten };
    const sql2 = listen.sql || (listen.sql = Postgres({
      ...options,
      max: 1,
      idle_timeout: null,
      max_lifetime: null,
      fetch_types: false,
      onclose() {
        Object.entries(listen.channels).forEach(([name2, { listeners }]) => {
          delete listen.channels[name2];
          Promise.all(listeners.map((l2) => listen(name2, l2.fn, l2.onlisten).catch(() => {
          })));
        });
      },
      onnotify(c2, x) {
        c2 in listen.channels && listen.channels[c2].listeners.forEach((l2) => l2.fn(x));
      }
    }));
    const channels = listen.channels || (listen.channels = {}), exists = name in channels;
    if (exists) {
      channels[name].listeners.push(listener);
      const result3 = await channels[name].result;
      listener.onlisten && listener.onlisten();
      return { state: result3.state, unlisten };
    }
    channels[name] = { result: sql2`listen ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`, listeners: [listener] };
    const result2 = await channels[name].result;
    listener.onlisten && listener.onlisten();
    return { state: result2.state, unlisten };
    async function unlisten() {
      if (name in channels === false)
        return;
      channels[name].listeners = channels[name].listeners.filter((x) => x !== listener);
      if (channels[name].listeners.length)
        return;
      delete channels[name];
      return sql2`unlisten ${sql2.unsafe('"' + name.replace(/"/g, '""') + '"')}`;
    }
  }
  async function notify(channel, payload) {
    return await sql`select pg_notify(${channel}, ${"" + payload})`;
  }
  async function reserve() {
    const queue3 = queue_default();
    const c2 = open.length ? open.shift() : await new Promise((r2) => {
      queries.push({ reserve: r2 });
      closed.length && connect(closed.shift());
    });
    move(c2, reserved);
    c2.reserved = () => queue3.length ? c2.execute(queue3.shift()) : move(c2, reserved);
    c2.reserved.release = true;
    const sql2 = Sql(handler2);
    sql2.release = () => {
      c2.reserved = null;
      onopen(c2);
    };
    return sql2;
    function handler2(q2) {
      c2.queue === full ? queue3.push(q2) : c2.execute(q2) || move(c2, full);
    }
  }
  async function begin(options2, fn) {
    !fn && (fn = options2, options2 = "");
    const queries2 = queue_default();
    let savepoints = 0, connection3, prepare = null;
    try {
      await sql.unsafe("begin " + options2.replace(/[^a-z ]/ig, ""), [], { onexecute }).execute();
      return await Promise.race([
        scope(connection3, fn),
        new Promise((_, reject) => connection3.onclose = reject)
      ]);
    } catch (error22) {
      throw error22;
    }
    async function scope(c2, fn2, name) {
      const sql2 = Sql(handler2);
      sql2.savepoint = savepoint;
      sql2.prepare = (x) => prepare = x.replace(/[^a-z0-9$-_. ]/gi);
      let uncaughtError, result2;
      name && await sql2`savepoint ${sql2(name)}`;
      try {
        result2 = await new Promise((resolve, reject) => {
          const x = fn2(sql2);
          Promise.resolve(Array.isArray(x) ? Promise.all(x) : x).then(resolve, reject);
        });
        if (uncaughtError)
          throw uncaughtError;
      } catch (e2) {
        await (name ? sql2`rollback to ${sql2(name)}` : sql2`rollback`);
        throw e2 instanceof PostgresError && e2.code === "25P02" && uncaughtError || e2;
      }
      if (!name) {
        prepare ? await sql2`prepare transaction '${sql2.unsafe(prepare)}'` : await sql2`commit`;
      }
      return result2;
      function savepoint(name2, fn3) {
        if (name2 && Array.isArray(name2.raw))
          return savepoint((sql3) => sql3.apply(sql3, arguments));
        arguments.length === 1 && (fn3 = name2, name2 = null);
        return scope(c2, fn3, "s" + savepoints++ + (name2 ? "_" + name2 : ""));
      }
      function handler2(q2) {
        q2.catch((e2) => uncaughtError || (uncaughtError = e2));
        c2.queue === full ? queries2.push(q2) : c2.execute(q2) || move(c2, full);
      }
    }
    function onexecute(c2) {
      connection3 = c2;
      move(c2, reserved);
      c2.reserved = () => queries2.length ? c2.execute(queries2.shift()) : move(c2, reserved);
    }
  }
  function move(c2, queue3) {
    c2.queue.remove(c2);
    queue3.push(c2);
    c2.queue = queue3;
    queue3 === open ? c2.idleTimer.start() : c2.idleTimer.cancel();
    return c2;
  }
  function json2(x) {
    return new Parameter(x, 3802);
  }
  function array5(x, type75) {
    if (!Array.isArray(x))
      return array5(Array.from(arguments));
    return new Parameter(x, type75 || (x.length ? inferType(x) || 25 : 0), options.shared.typeArrayMap);
  }
  function handler(query4) {
    if (ending)
      return query4.reject(Errors3.connection("CONNECTION_ENDED", options, options));
    if (open.length)
      return go(open.shift(), query4);
    if (closed.length)
      return connect(closed.shift(), query4);
    busy.length ? go(busy.shift(), query4) : queries.push(query4);
  }
  function go(c2, query4) {
    return c2.execute(query4) ? move(c2, busy) : move(c2, full);
  }
  function cancel(query4) {
    return new Promise((resolve, reject) => {
      query4.state ? query4.active ? connection_default(options).cancel(query4.state, resolve, reject) : query4.cancelled = { resolve, reject } : (queries.remove(query4), query4.cancelled = true, query4.reject(Errors3.generic("57014", "canceling statement due to user request")), resolve());
    });
  }
  async function end({ timeout = null } = {}) {
    if (ending)
      return ending;
    await 1;
    let timer2;
    return ending = Promise.race([
      new Promise((r2) => timeout !== null && (timer2 = setTimeout(destroy, timeout * 1000, r2))),
      Promise.all(connections.map((c2) => c2.end()).concat(listen.sql ? listen.sql.end({ timeout: 0 }) : [], subscribe2.sql ? subscribe2.sql.end({ timeout: 0 }) : []))
    ]).then(() => clearTimeout(timer2));
  }
  async function close() {
    await Promise.all(connections.map((c2) => c2.end()));
  }
  async function destroy(resolve) {
    await Promise.all(connections.map((c2) => c2.terminate()));
    while (queries.length)
      queries.shift().reject(Errors3.connection("CONNECTION_DESTROYED", options));
    resolve();
  }
  function connect(c2, query4) {
    move(c2, connecting);
    c2.connect(query4);
    return c2;
  }
  function onend(c2) {
    move(c2, ended);
  }
  function onopen(c2) {
    if (queries.length === 0)
      return move(c2, open);
    let max = Math.ceil(queries.length / (connecting.length + 1)), ready = true;
    while (ready && queries.length && max-- > 0) {
      const query4 = queries.shift();
      if (query4.reserve)
        return query4.reserve(c2);
      ready = c2.execute(query4);
    }
    ready ? move(c2, busy) : move(c2, full);
  }
  function onclose(c2, e2) {
    move(c2, closed);
    c2.reserved = null;
    c2.onclose && (c2.onclose(e2), c2.onclose = null);
    options.onclose && options.onclose(c2.id);
    queries.length && connect(c2, queries.shift());
  }
};
var parseOptions = function(a2, b3) {
  if (a2 && a2.shared)
    return a2;
  const env = process.env, o2 = (!a2 || typeof a2 === "string" ? b3 : a2) || {}, { url, multihost } = parseUrl(a2), query4 = [...url.searchParams].reduce((a3, [b4, c2]) => (a3[b4] = c2, a3), {}), host = o2.hostname || o2.host || multihost || url.hostname || env.PGHOST || "localhost", port = o2.port || url.port || env.PGPORT || 5432, user = o2.user || o2.username || url.username || env.PGUSERNAME || env.PGUSER || osUsername();
  o2.no_prepare && (o2.prepare = false);
  query4.sslmode && (query4.ssl = query4.sslmode, delete query4.sslmode);
  "timeout" in o2 && (console.log("The timeout option is deprecated, use idle_timeout instead"), o2.idle_timeout = o2.timeout);
  query4.sslrootcert === "system" && (query4.ssl = "verify-full");
  const ints = ["idle_timeout", "connect_timeout", "max_lifetime", "max_pipeline", "backoff", "keep_alive"];
  const defaults = {
    max: 10,
    ssl: false,
    idle_timeout: null,
    connect_timeout: 30,
    max_lifetime,
    max_pipeline: 100,
    backoff,
    keep_alive: 60,
    prepare: true,
    debug: false,
    fetch_types: true,
    publications: "alltables",
    target_session_attrs: null
  };
  return {
    host: Array.isArray(host) ? host : host.split(",").map((x) => x.split(":")[0]),
    port: Array.isArray(port) ? port : host.split(",").map((x) => parseInt(x.split(":")[1] || port)),
    path: o2.path || host.indexOf("/") > -1 && host + "/.s.PGSQL." + port,
    database: o2.database || o2.db || (url.pathname || "").slice(1) || env.PGDATABASE || user,
    user,
    pass: o2.pass || o2.password || url.password || env.PGPASSWORD || "",
    ...Object.entries(defaults).reduce((acc, [k, d2]) => {
      const value15 = k in o2 ? o2[k] : (k in query4) ? query4[k] === "disable" || query4[k] === "false" ? false : query4[k] : env["PG" + k.toUpperCase()] || d2;
      acc[k] = typeof value15 === "string" && ints.includes(k) ? +value15 : value15;
      return acc;
    }, {}),
    connection: {
      application_name: "postgres.js",
      ...o2.connection,
      ...Object.entries(query4).reduce((acc, [k, v2]) => ((k in defaults) || (acc[k] = v2), acc), {})
    },
    types: o2.types || {},
    target_session_attrs: tsa(o2, url, env),
    onnotice: o2.onnotice,
    onnotify: o2.onnotify,
    onclose: o2.onclose,
    onparameter: o2.onparameter,
    socket: o2.socket,
    transform: parseTransform(o2.transform || { undefined: undefined }),
    parameters: {},
    shared: { retries: 0, typeArrayMap: {} },
    ...mergeUserTypes(o2.types)
  };
};
var tsa = function(o2, url, env) {
  const x = o2.target_session_attrs || url.searchParams.get("target_session_attrs") || env.PGTARGETSESSIONATTRS;
  if (!x || ["read-write", "read-only", "primary", "standby", "prefer-standby"].includes(x))
    return x;
  throw new Error("target_session_attrs " + x + " is not supported");
};
var backoff = function(retries) {
  return (0.5 + Math.random() / 2) * Math.min(3 ** retries / 100, 20);
};
var max_lifetime = function() {
  return 60 * (30 + Math.random() * 30);
};
var parseTransform = function(x) {
  return {
    undefined: x.undefined,
    column: {
      from: typeof x.column === "function" ? x.column : x.column && x.column.from,
      to: x.column && x.column.to
    },
    value: {
      from: typeof x.value === "function" ? x.value : x.value && x.value.from,
      to: x.value && x.value.to
    },
    row: {
      from: typeof x.row === "function" ? x.row : x.row && x.row.from,
      to: x.row && x.row.to
    }
  };
};
var parseUrl = function(url) {
  if (!url || typeof url !== "string")
    return { url: { searchParams: new Map } };
  let host = url;
  host = host.slice(host.indexOf("://") + 3).split(/[?/]/)[0];
  host = decodeURIComponent(host.slice(host.indexOf("@") + 1));
  const urlObj = new URL(url.replace(host, host.split(",")[0]));
  return {
    url: {
      username: decodeURIComponent(urlObj.username),
      password: decodeURIComponent(urlObj.password),
      host: urlObj.host,
      hostname: urlObj.hostname,
      port: urlObj.port,
      pathname: urlObj.pathname,
      searchParams: urlObj.searchParams
    },
    multihost: host.indexOf(",") > -1 && host
  };
};
var osUsername = function() {
  try {
    return os.userInfo().username;
  } catch (_) {
    return "jeffsilva01";
  }
};
Object.assign(Postgres, {
  PostgresError,
  toPascal,
  pascal,
  toCamel,
  camel,
  toKebab,
  kebab,
  fromPascal,
  fromCamel,
  fromKebab,
  BigInt: {
    to: 20,
    from: [20],
    parse: (x) => BigInt(x),
    serialize: (x) => x.toString()
  }
});
var src_default = Postgres;

// src/db/schema/index.ts
var exports_schema = {};
__export(exports_schema, {
  usersRelations: () => {
    {
      return usersRelations;
    }
  },
  users: () => {
    {
      return users2;
    }
  },
  userRoleEnum: () => {
    {
      return userRoleEnum;
    }
  },
  restaurantsRelations: () => {
    {
      return restaurantsRelations;
    }
  },
  restaurants: () => {
    {
      return restaurants2;
    }
  },
  productsRelations: () => {
    {
      return productsRelations;
    }
  },
  products: () => {
    {
      return products2;
    }
  },
  ordersRelations: () => {
    {
      return ordersRelations;
    }
  },
  orders: () => {
    {
      return orders2;
    }
  },
  orderItemsRelations: () => {
    {
      return orderItemsRelations;
    }
  },
  orderItems: () => {
    {
      return orderItems;
    }
  },
  orderIstatusEnun: () => {
    {
      return orderIstatusEnun;
    }
  },
  authCodes: () => {
    {
      return authCodes;
    }
  }
});

// node_modules/@paralleldrive/cuid2/index.js
var { createId, init, getConstants, isCuid } = require_src();
var $createId = createId;

// node_modules/drizzle-orm/entity.js
var is = function(value15, type75) {
  if (!value15 || typeof value15 !== "object") {
    return false;
  }
  if (value15 instanceof type75) {
    return true;
  }
  if (!Object.prototype.hasOwnProperty.call(type75, entityKind)) {
    throw new Error(`Class "${type75.name ?? "<unknown>"}" doesn't look like a Drizzle entity. If this is incorrect and the class is provided by Drizzle, please report this as a bug.`);
  }
  let cls = value15.constructor;
  if (cls) {
    while (cls) {
      if (entityKind in cls && cls[entityKind] === type75[entityKind]) {
        return true;
      }
      cls = Object.getPrototypeOf(cls);
    }
  }
  return false;
};
var entityKind = Symbol.for("drizzle:entityKind");
var hasOwnEntityKind = Symbol.for("drizzle:hasOwnEntityKind");

// node_modules/drizzle-orm/column.js
class Column {
  constructor(table, config) {
    this.table = table;
    this.config = config;
    this.name = config.name;
    this.notNull = config.notNull;
    this.default = config.default;
    this.defaultFn = config.defaultFn;
    this.hasDefault = config.hasDefault;
    this.primary = config.primaryKey;
    this.isUnique = config.isUnique;
    this.uniqueName = config.uniqueName;
    this.uniqueType = config.uniqueType;
    this.dataType = config.dataType;
    this.columnType = config.columnType;
  }
  static [entityKind] = "Column";
  name;
  primary;
  notNull;
  default;
  defaultFn;
  hasDefault;
  isUnique;
  uniqueName;
  uniqueType;
  dataType;
  columnType;
  enumValues = undefined;
  config;
  mapFromDriverValue(value15) {
    return value15;
  }
  mapToDriverValue(value15) {
    return value15;
  }
}

// node_modules/drizzle-orm/subquery.js
var SubqueryConfig = Symbol.for("drizzle:SubqueryConfig");

class Subquery {
  static [entityKind] = "Subquery";
  [SubqueryConfig];
  constructor(sql, selection, alias, isWith = false) {
    this[SubqueryConfig] = {
      sql,
      selection,
      alias,
      isWith
    };
  }
}

class WithSubquery extends Subquery {
  static [entityKind] = "WithSubquery";
}

// node_modules/drizzle-orm/tracing-utils.js
var iife = function(fn, ...args) {
  return fn(...args);
};

// node_modules/drizzle-orm/version.js
var version = "0.30.1";

// node_modules/drizzle-orm/tracing.js
var otel;
var rawTracer;
var tracer = {
  startActiveSpan(name, fn) {
    if (!otel) {
      return fn();
    }
    if (!rawTracer) {
      rawTracer = otel.trace.getTracer("drizzle-orm", version);
    }
    return iife((otel2, rawTracer2) => rawTracer2.startActiveSpan(name, (span) => {
      try {
        return fn(span);
      } catch (e2) {
        span.setStatus({
          code: otel2.SpanStatusCode.ERROR,
          message: e2 instanceof Error ? e2.message : "Unknown error"
        });
        throw e2;
      } finally {
        span.end();
      }
    }), otel, rawTracer);
  }
};

// node_modules/drizzle-orm/view-common.js
var ViewBaseConfig = Symbol.for("drizzle:ViewBaseConfig");

// node_modules/drizzle-orm/table.js
var isTable = function(table) {
  return typeof table === "object" && table !== null && IsDrizzleTable in table;
};
var getTableName = function(table) {
  return table[TableName];
};
var TableName = Symbol.for("drizzle:Name");
var Schema = Symbol.for("drizzle:Schema");
var Columns = Symbol.for("drizzle:Columns");
var OriginalName = Symbol.for("drizzle:OriginalName");
var BaseName = Symbol.for("drizzle:BaseName");
var IsAlias = Symbol.for("drizzle:IsAlias");
var ExtraConfigBuilder = Symbol.for("drizzle:ExtraConfigBuilder");
var IsDrizzleTable = Symbol.for("drizzle:IsDrizzleTable");

class Table {
  static [entityKind] = "Table";
  static Symbol = {
    Name: TableName,
    Schema,
    OriginalName,
    Columns,
    BaseName,
    IsAlias,
    ExtraConfigBuilder
  };
  [TableName];
  [OriginalName];
  [Schema];
  [Columns];
  [BaseName];
  [IsAlias] = false;
  [ExtraConfigBuilder] = undefined;
  [IsDrizzleTable] = true;
  constructor(name, schema3, baseName) {
    this[TableName] = this[OriginalName] = name;
    this[Schema] = schema3;
    this[BaseName] = baseName;
  }
}

// node_modules/drizzle-orm/sql/sql.js
var isSQLWrapper = function(value15) {
  return typeof value15 === "object" && value15 !== null && "getSQL" in value15 && typeof value15.getSQL === "function";
};
var mergeQueries = function(queries) {
  const result2 = { sql: "", params: [] };
  for (const query4 of queries) {
    result2.sql += query4.sql;
    result2.params.push(...query4.params);
    if (query4.typings?.length) {
      if (!result2.typings) {
        result2.typings = [];
      }
      result2.typings.push(...query4.typings);
    }
  }
  return result2;
};
var isDriverValueEncoder = function(value15) {
  return typeof value15 === "object" && value15 !== null && "mapToDriverValue" in value15 && typeof value15.mapToDriverValue === "function";
};
var sql = function(strings, ...params) {
  const queryChunks = [];
  if (params.length > 0 || strings.length > 0 && strings[0] !== "") {
    queryChunks.push(new StringChunk(strings[0]));
  }
  for (const [paramIndex, param2] of params.entries()) {
    queryChunks.push(param2, new StringChunk(strings[paramIndex + 1]));
  }
  return new SQL(queryChunks);
};
var fillPlaceholders = function(params, values2) {
  return params.map((p2) => {
    if (is(p2, Placeholder)) {
      if (!(p2.name in values2)) {
        throw new Error(`No value for placeholder "${p2.name}" was provided`);
      }
      return values2[p2.name];
    }
    return p2;
  });
};
class StringChunk {
  static [entityKind] = "StringChunk";
  value;
  constructor(value15) {
    this.value = Array.isArray(value15) ? value15 : [value15];
  }
  getSQL() {
    return new SQL([this]);
  }
}

class SQL {
  constructor(queryChunks) {
    this.queryChunks = queryChunks;
  }
  static [entityKind] = "SQL";
  decoder = noopDecoder;
  shouldInlineParams = false;
  append(query4) {
    this.queryChunks.push(...query4.queryChunks);
    return this;
  }
  toQuery(config) {
    return tracer.startActiveSpan("drizzle.buildSQL", (span) => {
      const query4 = this.buildQueryFromSourceParams(this.queryChunks, config);
      span?.setAttributes({
        "drizzle.query.text": query4.sql,
        "drizzle.query.params": JSON.stringify(query4.params)
      });
      return query4;
    });
  }
  buildQueryFromSourceParams(chunks, _config) {
    const config = Object.assign({}, _config, {
      inlineParams: _config.inlineParams || this.shouldInlineParams,
      paramStartIndex: _config.paramStartIndex || { value: 0 }
    });
    const {
      escapeName,
      escapeParam,
      prepareTyping,
      inlineParams,
      paramStartIndex
    } = config;
    return mergeQueries(chunks.map((chunk) => {
      if (is(chunk, StringChunk)) {
        return { sql: chunk.value.join(""), params: [] };
      }
      if (is(chunk, Name)) {
        return { sql: escapeName(chunk.value), params: [] };
      }
      if (chunk === undefined) {
        return { sql: "", params: [] };
      }
      if (Array.isArray(chunk)) {
        const result2 = [new StringChunk("(")];
        for (const [i, p2] of chunk.entries()) {
          result2.push(p2);
          if (i < chunk.length - 1) {
            result2.push(new StringChunk(", "));
          }
        }
        result2.push(new StringChunk(")"));
        return this.buildQueryFromSourceParams(result2, config);
      }
      if (is(chunk, SQL)) {
        return this.buildQueryFromSourceParams(chunk.queryChunks, {
          ...config,
          inlineParams: inlineParams || chunk.shouldInlineParams
        });
      }
      if (is(chunk, Table)) {
        const schemaName = chunk[Table.Symbol.Schema];
        const tableName = chunk[Table.Symbol.Name];
        return {
          sql: schemaName === undefined ? escapeName(tableName) : escapeName(schemaName) + "." + escapeName(tableName),
          params: []
        };
      }
      if (is(chunk, Column)) {
        return { sql: escapeName(chunk.table[Table.Symbol.Name]) + "." + escapeName(chunk.name), params: [] };
      }
      if (is(chunk, View)) {
        const schemaName = chunk[ViewBaseConfig].schema;
        const viewName = chunk[ViewBaseConfig].name;
        return {
          sql: schemaName === undefined ? escapeName(viewName) : escapeName(schemaName) + "." + escapeName(viewName),
          params: []
        };
      }
      if (is(chunk, Param)) {
        const mappedValue = chunk.value === null ? null : chunk.encoder.mapToDriverValue(chunk.value);
        if (is(mappedValue, SQL)) {
          return this.buildQueryFromSourceParams([mappedValue], config);
        }
        if (inlineParams) {
          return { sql: this.mapInlineParam(mappedValue, config), params: [] };
        }
        let typings;
        if (prepareTyping !== undefined) {
          typings = [prepareTyping(chunk.encoder)];
        }
        return { sql: escapeParam(paramStartIndex.value++, mappedValue), params: [mappedValue], typings };
      }
      if (is(chunk, Placeholder)) {
        return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
      }
      if (is(chunk, SQL.Aliased) && chunk.fieldAlias !== undefined) {
        return { sql: escapeName(chunk.fieldAlias), params: [] };
      }
      if (is(chunk, Subquery)) {
        if (chunk[SubqueryConfig].isWith) {
          return { sql: escapeName(chunk[SubqueryConfig].alias), params: [] };
        }
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk[SubqueryConfig].sql,
          new StringChunk(") "),
          new Name(chunk[SubqueryConfig].alias)
        ], config);
      }
      if (isSQLWrapper(chunk)) {
        return this.buildQueryFromSourceParams([
          new StringChunk("("),
          chunk.getSQL(),
          new StringChunk(")")
        ], config);
      }
      if (inlineParams) {
        return { sql: this.mapInlineParam(chunk, config), params: [] };
      }
      return { sql: escapeParam(paramStartIndex.value++, chunk), params: [chunk] };
    }));
  }
  mapInlineParam(chunk, { escapeString }) {
    if (chunk === null) {
      return "null";
    }
    if (typeof chunk === "number" || typeof chunk === "boolean") {
      return chunk.toString();
    }
    if (typeof chunk === "string") {
      return escapeString(chunk);
    }
    if (typeof chunk === "object") {
      const mappedValueAsString = chunk.toString();
      if (mappedValueAsString === "[object Object]") {
        return escapeString(JSON.stringify(chunk));
      }
      return escapeString(mappedValueAsString);
    }
    throw new Error("Unexpected param value: " + chunk);
  }
  getSQL() {
    return this;
  }
  as(alias) {
    if (alias === undefined) {
      return this;
    }
    return new SQL.Aliased(this, alias);
  }
  mapWith(decoder) {
    this.decoder = typeof decoder === "function" ? { mapFromDriverValue: decoder } : decoder;
    return this;
  }
  inlineParams() {
    this.shouldInlineParams = true;
    return this;
  }
}

class Name {
  constructor(value15) {
    this.value = value15;
  }
  static [entityKind] = "Name";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
var noopDecoder = {
  mapFromDriverValue: (value15) => value15
};
var noopEncoder = {
  mapToDriverValue: (value15) => value15
};
var noopMapper = {
  ...noopDecoder,
  ...noopEncoder
};

class Param {
  constructor(value15, encoder = noopEncoder) {
    this.value = value15;
    this.encoder = encoder;
  }
  static [entityKind] = "Param";
  brand;
  getSQL() {
    return new SQL([this]);
  }
}
((sql2) => {
  function empty() {
    return new SQL([]);
  }
  sql2.empty = empty;
  function fromList(list) {
    return new SQL(list);
  }
  sql2.fromList = fromList;
  function raw(str) {
    return new SQL([new StringChunk(str)]);
  }
  sql2.raw = raw;
  function join(chunks, separator) {
    const result2 = [];
    for (const [i, chunk] of chunks.entries()) {
      if (i > 0 && separator !== undefined) {
        result2.push(separator);
      }
      result2.push(chunk);
    }
    return new SQL(result2);
  }
  sql2.join = join;
  function identifier(value15) {
    return new Name(value15);
  }
  sql2.identifier = identifier;
  function placeholder2(name2) {
    return new Placeholder(name2);
  }
  sql2.placeholder = placeholder2;
  function param2(value15, encoder) {
    return new Param(value15, encoder);
  }
  sql2.param = param2;
})(sql || (sql = {}));
((SQL2) => {

  class Aliased {
    constructor(sql2, fieldAlias) {
      this.sql = sql2;
      this.fieldAlias = fieldAlias;
    }
    static [entityKind] = "SQL.Aliased";
    isSelectionField = false;
    getSQL() {
      return this.sql;
    }
    clone() {
      return new Aliased(this.sql, this.fieldAlias);
    }
  }
  SQL2.Aliased = Aliased;
})(SQL || (SQL = {}));

class Placeholder {
  constructor(name2) {
    this.name = name2;
  }
  static [entityKind] = "Placeholder";
  getSQL() {
    return new SQL([this]);
  }
}

class View {
  static [entityKind] = "View";
  [ViewBaseConfig];
  constructor({ name: name2, schema: schema3, selectedFields, query: query4 }) {
    this[ViewBaseConfig] = {
      name: name2,
      originalName: name2,
      schema: schema3,
      selectedFields,
      query: query4,
      isExisting: !query4,
      isAlias: false
    };
  }
  getSQL() {
    return new SQL([this]);
  }
}
Column.prototype.getSQL = function() {
  return new SQL([this]);
};
Table.prototype.getSQL = function() {
  return new SQL([this]);
};
Subquery.prototype.getSQL = function() {
  return new SQL([this]);
};

// node_modules/drizzle-orm/alias.js
var aliasedTable = function(table3, tableAlias) {
  return new Proxy(table3, new TableAliasProxyHandler(tableAlias, false));
};
var aliasedTableColumn = function(column3, tableAlias) {
  return new Proxy(column3, new ColumnAliasProxyHandler(new Proxy(column3.table, new TableAliasProxyHandler(tableAlias, false))));
};
var mapColumnsInAliasedSQLToAlias = function(query4, alias) {
  return new SQL.Aliased(mapColumnsInSQLToAlias(query4.sql, alias), query4.fieldAlias);
};
var mapColumnsInSQLToAlias = function(query4, alias) {
  return sql.join(query4.queryChunks.map((c2) => {
    if (is(c2, Column)) {
      return aliasedTableColumn(c2, alias);
    }
    if (is(c2, SQL)) {
      return mapColumnsInSQLToAlias(c2, alias);
    }
    if (is(c2, SQL.Aliased)) {
      return mapColumnsInAliasedSQLToAlias(c2, alias);
    }
    return c2;
  }));
};

class ColumnAliasProxyHandler {
  constructor(table3) {
    this.table = table3;
  }
  static [entityKind] = "ColumnAliasProxyHandler";
  get(columnObj, prop) {
    if (prop === "table") {
      return this.table;
    }
    return columnObj[prop];
  }
}

class TableAliasProxyHandler {
  constructor(alias, replaceOriginalName) {
    this.alias = alias;
    this.replaceOriginalName = replaceOriginalName;
  }
  static [entityKind] = "TableAliasProxyHandler";
  get(target, prop) {
    if (prop === Table.Symbol.IsAlias) {
      return true;
    }
    if (prop === Table.Symbol.Name) {
      return this.alias;
    }
    if (this.replaceOriginalName && prop === Table.Symbol.OriginalName) {
      return this.alias;
    }
    if (prop === ViewBaseConfig) {
      return {
        ...target[ViewBaseConfig],
        name: this.alias,
        isAlias: true
      };
    }
    if (prop === Table.Symbol.Columns) {
      const columns = target[Table.Symbol.Columns];
      if (!columns) {
        return columns;
      }
      const proxiedColumns = {};
      Object.keys(columns).map((key) => {
        proxiedColumns[key] = new Proxy(columns[key], new ColumnAliasProxyHandler(new Proxy(target, this)));
      });
      return proxiedColumns;
    }
    const value15 = target[prop];
    if (is(value15, Column)) {
      return new Proxy(value15, new ColumnAliasProxyHandler(new Proxy(target, this)));
    }
    return value15;
  }
}

// node_modules/drizzle-orm/column-builder.js
class ColumnBuilder {
  static [entityKind] = "ColumnBuilder";
  config;
  constructor(name, dataType, columnType) {
    this.config = {
      name,
      notNull: false,
      default: undefined,
      hasDefault: false,
      primaryKey: false,
      isUnique: false,
      uniqueName: undefined,
      uniqueType: undefined,
      dataType,
      columnType
    };
  }
  $type() {
    return this;
  }
  notNull() {
    this.config.notNull = true;
    return this;
  }
  default(value15) {
    this.config.default = value15;
    this.config.hasDefault = true;
    return this;
  }
  $defaultFn(fn) {
    this.config.defaultFn = fn;
    this.config.hasDefault = true;
    return this;
  }
  $default = this.$defaultFn;
  primaryKey() {
    this.config.primaryKey = true;
    this.config.notNull = true;
    return this;
  }
}

// node_modules/drizzle-orm/errors.js
class DrizzleError extends Error {
  static [entityKind] = "DrizzleError";
  constructor({ message, cause }) {
    super(message);
    this.name = "DrizzleError";
    this.cause = cause;
  }
}

class TransactionRollbackError extends DrizzleError {
  static [entityKind] = "TransactionRollbackError";
  constructor() {
    super({ message: "Rollback" });
  }
}

// node_modules/drizzle-orm/sql/expressions/conditions.js
var bindIfParam = function(value15, column4) {
  if (isDriverValueEncoder(column4) && !isSQLWrapper(value15) && !is(value15, Param) && !is(value15, Placeholder) && !is(value15, Column) && !is(value15, Table) && !is(value15, View)) {
    return new Param(value15, column4);
  }
  return value15;
};
var and = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c2) => c2 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" and ")),
    new StringChunk(")")
  ]);
};
var or = function(...unfilteredConditions) {
  const conditions = unfilteredConditions.filter((c2) => c2 !== undefined);
  if (conditions.length === 0) {
    return;
  }
  if (conditions.length === 1) {
    return new SQL(conditions);
  }
  return new SQL([
    new StringChunk("("),
    sql.join(conditions, new StringChunk(" or ")),
    new StringChunk(")")
  ]);
};
var not4 = function(condition) {
  return sql`not ${condition}`;
};
var inArray = function(column4, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      throw new Error("inArray requires at least one value");
    }
    return sql`${column4} in ${values2.map((v2) => bindIfParam(v2, column4))}`;
  }
  return sql`${column4} in ${bindIfParam(values2, column4)}`;
};
var notInArray = function(column4, values2) {
  if (Array.isArray(values2)) {
    if (values2.length === 0) {
      throw new Error("notInArray requires at least one value");
    }
    return sql`${column4} not in ${values2.map((v2) => bindIfParam(v2, column4))}`;
  }
  return sql`${column4} not in ${bindIfParam(values2, column4)}`;
};
var isNull = function(value15) {
  return sql`${value15} is null`;
};
var isNotNull = function(value15) {
  return sql`${value15} is not null`;
};
var exists = function(subquery2) {
  return sql`exists ${subquery2}`;
};
var notExists = function(subquery2) {
  return sql`not exists ${subquery2}`;
};
var between = function(column4, min, max) {
  return sql`${column4} between ${bindIfParam(min, column4)} and ${bindIfParam(max, column4)}`;
};
var notBetween = function(column4, min, max) {
  return sql`${column4} not between ${bindIfParam(min, column4)} and ${bindIfParam(max, column4)}`;
};
var like = function(column4, value15) {
  return sql`${column4} like ${value15}`;
};
var notLike = function(column4, value15) {
  return sql`${column4} not like ${value15}`;
};
var ilike = function(column4, value15) {
  return sql`${column4} ilike ${value15}`;
};
var notIlike = function(column4, value15) {
  return sql`${column4} not ilike ${value15}`;
};
var eq = (left, right) => {
  return sql`${left} = ${bindIfParam(right, left)}`;
};
var ne = (left, right) => {
  return sql`${left} <> ${bindIfParam(right, left)}`;
};
var gt = (left, right) => {
  return sql`${left} > ${bindIfParam(right, left)}`;
};
var gte = (left, right) => {
  return sql`${left} >= ${bindIfParam(right, left)}`;
};
var lt = (left, right) => {
  return sql`${left} < ${bindIfParam(right, left)}`;
};
var lte = (left, right) => {
  return sql`${left} <= ${bindIfParam(right, left)}`;
};

// node_modules/drizzle-orm/sql/expressions/select.js
var asc = function(column4) {
  return sql`${column4} asc`;
};
var desc = function(column4) {
  return sql`${column4} desc`;
};

// node_modules/drizzle-orm/logger.js
class ConsoleLogWriter {
  static [entityKind] = "ConsoleLogWriter";
  write(message) {
    console.log(message);
  }
}

class DefaultLogger {
  static [entityKind] = "DefaultLogger";
  writer;
  constructor(config) {
    this.writer = config?.writer ?? new ConsoleLogWriter;
  }
  logQuery(query4, params) {
    const stringifiedParams = params.map((p2) => {
      try {
        return JSON.stringify(p2);
      } catch {
        return String(p2);
      }
    });
    const paramsStr = stringifiedParams.length ? ` -- params: [${stringifiedParams.join(", ")}]` : "";
    this.writer.write(`Query: ${query4}${paramsStr}`);
  }
}

class NoopLogger {
  static [entityKind] = "NoopLogger";
  logQuery() {
  }
}

// node_modules/drizzle-orm/query-promise.js
class QueryPromise {
  static [entityKind] = "QueryPromise";
  [Symbol.toStringTag] = "QueryPromise";
  catch(onRejected) {
    return this.then(undefined, onRejected);
  }
  finally(onFinally) {
    return this.then((value15) => {
      onFinally?.();
      return value15;
    }, (reason) => {
      onFinally?.();
      throw reason;
    });
  }
  then(onFulfilled, onRejected) {
    return this.execute().then(onFulfilled, onRejected);
  }
}

// node_modules/drizzle-orm/pg-core/table.js
var pgTableWithSchema = function(name, columns, extraConfig, schema3, baseName = name) {
  const rawTable = new PgTable(name, schema3, baseName);
  const builtColumns = Object.fromEntries(Object.entries(columns).map(([name2, colBuilderBase]) => {
    const colBuilder = colBuilderBase;
    const column4 = colBuilder.build(rawTable);
    rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column4, rawTable));
    return [name2, column4];
  }));
  const table5 = Object.assign(rawTable, builtColumns);
  table5[Table.Symbol.Columns] = builtColumns;
  if (extraConfig) {
    table5[PgTable.Symbol.ExtraConfigBuilder] = extraConfig;
  }
  return table5;
};
var InlineForeignKeys = Symbol.for("drizzle:PgInlineForeignKeys");

class PgTable extends Table {
  static [entityKind] = "PgTable";
  static Symbol = Object.assign({}, Table.Symbol, {
    InlineForeignKeys
  });
  [InlineForeignKeys] = [];
  [Table.Symbol.ExtraConfigBuilder] = undefined;
}
var pgTable = (name, columns, extraConfig) => {
  return pgTableWithSchema(name, columns, extraConfig, undefined);
};

// node_modules/drizzle-orm/pg-core/primary-keys.js
class PrimaryKeyBuilder {
  static [entityKind] = "PgPrimaryKeyBuilder";
  columns;
  name;
  constructor(columns, name) {
    this.columns = columns;
    this.name = name;
  }
  build(table6) {
    return new PrimaryKey(table6, this.columns, this.name);
  }
}

class PrimaryKey {
  constructor(table6, columns, name) {
    this.table = table6;
    this.columns = columns;
    this.name = name;
  }
  static [entityKind] = "PgPrimaryKey";
  columns;
  name;
  getName() {
    return this.name ?? `${this.table[PgTable.Symbol.Name]}_${this.columns.map((column4) => column4.name).join("_")}_pk`;
  }
}

// node_modules/drizzle-orm/relations.js
var getOperators = function() {
  return {
    and,
    between,
    eq,
    exists,
    gt,
    gte,
    ilike,
    inArray,
    isNull,
    isNotNull,
    like,
    lt,
    lte,
    ne,
    not: not4,
    notBetween,
    notExists,
    notLike,
    notIlike,
    notInArray,
    or,
    sql
  };
};
var getOrderByOperators = function() {
  return {
    sql,
    asc,
    desc
  };
};
var extractTablesRelationalConfig = function(schema3, configHelpers) {
  if (Object.keys(schema3).length === 1 && "default" in schema3 && !is(schema3["default"], Table)) {
    schema3 = schema3["default"];
  }
  const tableNamesMap = {};
  const relationsBuffer = {};
  const tablesConfig = {};
  for (const [key, value15] of Object.entries(schema3)) {
    if (isTable(value15)) {
      const dbName = value15[Table.Symbol.Name];
      const bufferedRelations = relationsBuffer[dbName];
      tableNamesMap[dbName] = key;
      tablesConfig[key] = {
        tsName: key,
        dbName: value15[Table.Symbol.Name],
        schema: value15[Table.Symbol.Schema],
        columns: value15[Table.Symbol.Columns],
        relations: bufferedRelations?.relations ?? {},
        primaryKey: bufferedRelations?.primaryKey ?? []
      };
      for (const column5 of Object.values(value15[Table.Symbol.Columns])) {
        if (column5.primary) {
          tablesConfig[key].primaryKey.push(column5);
        }
      }
      const extraConfig = value15[Table.Symbol.ExtraConfigBuilder]?.(value15);
      if (extraConfig) {
        for (const configEntry of Object.values(extraConfig)) {
          if (is(configEntry, PrimaryKeyBuilder)) {
            tablesConfig[key].primaryKey.push(...configEntry.columns);
          }
        }
      }
    } else if (is(value15, Relations)) {
      const dbName = value15.table[Table.Symbol.Name];
      const tableName = tableNamesMap[dbName];
      const relations2 = value15.config(configHelpers(value15.table));
      let primaryKey;
      for (const [relationName, relation] of Object.entries(relations2)) {
        if (tableName) {
          const tableConfig = tablesConfig[tableName];
          tableConfig.relations[relationName] = relation;
          if (primaryKey) {
            tableConfig.primaryKey.push(...primaryKey);
          }
        } else {
          if (!(dbName in relationsBuffer)) {
            relationsBuffer[dbName] = {
              relations: {},
              primaryKey
            };
          }
          relationsBuffer[dbName].relations[relationName] = relation;
        }
      }
    }
  }
  return { tables: tablesConfig, tableNamesMap };
};
var relations = function(table7, relations2) {
  return new Relations(table7, (helpers3) => Object.fromEntries(Object.entries(relations2(helpers3)).map(([key, value15]) => [
    key,
    value15.withFieldName(key)
  ])));
};
var createOne = function(sourceTable) {
  return function one(table7, config) {
    return new One(sourceTable, table7, config, config?.fields.reduce((res, f) => res && f.notNull, true) ?? false);
  };
};
var createMany = function(sourceTable) {
  return function many(referencedTable, config) {
    return new Many(sourceTable, referencedTable, config);
  };
};
var normalizeRelation = function(schema3, tableNamesMap, relation) {
  if (is(relation, One) && relation.config) {
    return {
      fields: relation.config.fields,
      references: relation.config.references
    };
  }
  const referencedTableTsName = tableNamesMap[relation.referencedTable[Table.Symbol.Name]];
  if (!referencedTableTsName) {
    throw new Error(`Table "${relation.referencedTable[Table.Symbol.Name]}" not found in schema`);
  }
  const referencedTableConfig = schema3[referencedTableTsName];
  if (!referencedTableConfig) {
    throw new Error(`Table "${referencedTableTsName}" not found in schema`);
  }
  const sourceTable = relation.sourceTable;
  const sourceTableTsName = tableNamesMap[sourceTable[Table.Symbol.Name]];
  if (!sourceTableTsName) {
    throw new Error(`Table "${sourceTable[Table.Symbol.Name]}" not found in schema`);
  }
  const reverseRelations = [];
  for (const referencedTableRelation of Object.values(referencedTableConfig.relations)) {
    if (relation.relationName && relation !== referencedTableRelation && referencedTableRelation.relationName === relation.relationName || !relation.relationName && referencedTableRelation.referencedTable === relation.sourceTable) {
      reverseRelations.push(referencedTableRelation);
    }
  }
  if (reverseRelations.length > 1) {
    throw relation.relationName ? new Error(`There are multiple relations with name "${relation.relationName}" in table "${referencedTableTsName}"`) : new Error(`There are multiple relations between "${referencedTableTsName}" and "${relation.sourceTable[Table.Symbol.Name]}". Please specify relation name`);
  }
  if (reverseRelations[0] && is(reverseRelations[0], One) && reverseRelations[0].config) {
    return {
      fields: reverseRelations[0].config.references,
      references: reverseRelations[0].config.fields
    };
  }
  throw new Error(`There is not enough information to infer relation "${sourceTableTsName}.${relation.fieldName}"`);
};
var createTableRelationsHelpers = function(sourceTable) {
  return {
    one: createOne(sourceTable),
    many: createMany(sourceTable)
  };
};
var mapRelationalRow = function(tablesConfig, tableConfig, row, buildQueryResultSelection, mapColumnValue = (value15) => value15) {
  const result2 = {};
  for (const [
    selectionItemIndex,
    selectionItem
  ] of buildQueryResultSelection.entries()) {
    if (selectionItem.isJson) {
      const relation = tableConfig.relations[selectionItem.tsKey];
      const rawSubRows = row[selectionItemIndex];
      const subRows = typeof rawSubRows === "string" ? JSON.parse(rawSubRows) : rawSubRows;
      result2[selectionItem.tsKey] = is(relation, One) ? subRows && mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRows, selectionItem.selection, mapColumnValue) : subRows.map((subRow) => mapRelationalRow(tablesConfig, tablesConfig[selectionItem.relationTableTsKey], subRow, selectionItem.selection, mapColumnValue));
    } else {
      const value15 = mapColumnValue(row[selectionItemIndex]);
      const field = selectionItem.field;
      let decoder;
      if (is(field, Column)) {
        decoder = field;
      } else if (is(field, SQL)) {
        decoder = field.decoder;
      } else {
        decoder = field.sql.decoder;
      }
      result2[selectionItem.tsKey] = value15 === null ? null : decoder.mapFromDriverValue(value15);
    }
  }
  return result2;
};

class Relation {
  constructor(sourceTable, referencedTable, relationName) {
    this.sourceTable = sourceTable;
    this.referencedTable = referencedTable;
    this.relationName = relationName;
    this.referencedTableName = referencedTable[Table.Symbol.Name];
  }
  static [entityKind] = "Relation";
  referencedTableName;
  fieldName;
}

class Relations {
  constructor(table7, config) {
    this.table = table7;
    this.config = config;
  }
  static [entityKind] = "Relations";
}

class One extends Relation {
  constructor(sourceTable, referencedTable, config, isNullable) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
    this.isNullable = isNullable;
  }
  static [entityKind] = "One";
  withFieldName(fieldName) {
    const relation = new One(this.sourceTable, this.referencedTable, this.config, this.isNullable);
    relation.fieldName = fieldName;
    return relation;
  }
}

class Many extends Relation {
  constructor(sourceTable, referencedTable, config) {
    super(sourceTable, referencedTable, config?.relationName);
    this.config = config;
  }
  static [entityKind] = "Many";
  withFieldName(fieldName) {
    const relation = new Many(this.sourceTable, this.referencedTable, this.config);
    relation.fieldName = fieldName;
    return relation;
  }
}

// node_modules/drizzle-orm/utils.js
var mapResultRow = function(columns, row, joinsNotNullableMap) {
  const nullifyMap = {};
  const result2 = columns.reduce((result22, { path, field }, columnIndex) => {
    let decoder;
    if (is(field, Column)) {
      decoder = field;
    } else if (is(field, SQL)) {
      decoder = field.decoder;
    } else {
      decoder = field.sql.decoder;
    }
    let node = result22;
    for (const [pathChunkIndex, pathChunk] of path.entries()) {
      if (pathChunkIndex < path.length - 1) {
        if (!(pathChunk in node)) {
          node[pathChunk] = {};
        }
        node = node[pathChunk];
      } else {
        const rawValue = row[columnIndex];
        const value15 = node[pathChunk] = rawValue === null ? null : decoder.mapFromDriverValue(rawValue);
        if (joinsNotNullableMap && is(field, Column) && path.length === 2) {
          const objectName = path[0];
          if (!(objectName in nullifyMap)) {
            nullifyMap[objectName] = value15 === null ? getTableName(field.table) : false;
          } else if (typeof nullifyMap[objectName] === "string" && nullifyMap[objectName] !== getTableName(field.table)) {
            nullifyMap[objectName] = false;
          }
        }
      }
    }
    return result22;
  }, {});
  if (joinsNotNullableMap && Object.keys(nullifyMap).length > 0) {
    for (const [objectName, tableName] of Object.entries(nullifyMap)) {
      if (typeof tableName === "string" && !joinsNotNullableMap[tableName]) {
        result2[objectName] = null;
      }
    }
  }
  return result2;
};
var orderSelectedFields = function(fields, pathPrefix) {
  return Object.entries(fields).reduce((result2, [name, field]) => {
    if (typeof name !== "string") {
      return result2;
    }
    const newPath = pathPrefix ? [...pathPrefix, name] : [name];
    if (is(field, Column) || is(field, SQL) || is(field, SQL.Aliased)) {
      result2.push({ path: newPath, field });
    } else if (is(field, Table)) {
      result2.push(...orderSelectedFields(field[Table.Symbol.Columns], newPath));
    } else {
      result2.push(...orderSelectedFields(field, newPath));
    }
    return result2;
  }, []);
};
var haveSameKeys = function(left, right) {
  const leftKeys = Object.keys(left);
  const rightKeys = Object.keys(right);
  if (leftKeys.length !== rightKeys.length) {
    return false;
  }
  for (const [index, key] of leftKeys.entries()) {
    if (key !== rightKeys[index]) {
      return false;
    }
  }
  return true;
};
var mapUpdateSet = function(table8, values2) {
  const entries = Object.entries(values2).filter(([, value15]) => value15 !== undefined).map(([key, value15]) => {
    if (is(value15, SQL)) {
      return [key, value15];
    } else {
      return [key, new Param(value15, table8[Table.Symbol.Columns][key])];
    }
  });
  if (entries.length === 0) {
    throw new Error("No values to set");
  }
  return Object.fromEntries(entries);
};
var applyMixins = function(baseClass, extendedClasses) {
  for (const extendedClass of extendedClasses) {
    for (const name of Object.getOwnPropertyNames(extendedClass.prototype)) {
      if (name === "constructor")
        continue;
      Object.defineProperty(baseClass.prototype, name, Object.getOwnPropertyDescriptor(extendedClass.prototype, name) || Object.create(null));
    }
  }
};
var getTableColumns = function(table8) {
  return table8[Table.Symbol.Columns];
};
var getTableLikeName = function(table8) {
  return is(table8, Subquery) ? table8[SubqueryConfig].alias : is(table8, View) ? table8[ViewBaseConfig].name : is(table8, SQL) ? undefined : table8[Table.Symbol.IsAlias] ? table8[Table.Symbol.Name] : table8[Table.Symbol.BaseName];
};

// node_modules/drizzle-orm/pg-core/foreign-keys.js
class ForeignKeyBuilder {
  static [entityKind] = "PgForeignKeyBuilder";
  reference;
  _onUpdate = "no action";
  _onDelete = "no action";
  constructor(config, actions) {
    this.reference = () => {
      const { name, columns, foreignColumns } = config();
      return { name, columns, foreignTable: foreignColumns[0].table, foreignColumns };
    };
    if (actions) {
      this._onUpdate = actions.onUpdate;
      this._onDelete = actions.onDelete;
    }
  }
  onUpdate(action) {
    this._onUpdate = action === undefined ? "no action" : action;
    return this;
  }
  onDelete(action) {
    this._onDelete = action === undefined ? "no action" : action;
    return this;
  }
  build(table9) {
    return new ForeignKey(table9, this);
  }
}

class ForeignKey {
  constructor(table9, builder) {
    this.table = table9;
    this.reference = builder.reference;
    this.onUpdate = builder._onUpdate;
    this.onDelete = builder._onDelete;
  }
  static [entityKind] = "PgForeignKey";
  reference;
  onUpdate;
  onDelete;
  getName() {
    const { name, columns, foreignColumns } = this.reference();
    const columnNames = columns.map((column6) => column6.name);
    const foreignColumnNames = foreignColumns.map((column6) => column6.name);
    const chunks = [
      this.table[PgTable.Symbol.Name],
      ...columnNames,
      foreignColumns[0].table[PgTable.Symbol.Name],
      ...foreignColumnNames
    ];
    return name ?? `${chunks.join("_")}_fk`;
  }
}

// node_modules/drizzle-orm/pg-core/unique-constraint.js
var uniqueKeyName = function(table10, columns) {
  return `${table10[PgTable.Symbol.Name]}_${columns.join("_")}_unique`;
};

// node_modules/drizzle-orm/pg-core/utils/array.js
var parsePgArrayValue = function(arrayString, startFrom, inQuotes) {
  for (let i = startFrom;i < arrayString.length; i++) {
    const char = arrayString[i];
    if (char === "\\") {
      i++;
      continue;
    }
    if (char === '"') {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i + 1];
    }
    if (inQuotes) {
      continue;
    }
    if (char === "," || char === "}") {
      return [arrayString.slice(startFrom, i).replace(/\\/g, ""), i];
    }
  }
  return [arrayString.slice(startFrom).replace(/\\/g, ""), arrayString.length];
};
var parsePgNestedArray = function(arrayString, startFrom = 0) {
  const result2 = [];
  let i = startFrom;
  let lastCharIsComma = false;
  while (i < arrayString.length) {
    const char = arrayString[i];
    if (char === ",") {
      if (lastCharIsComma || i === startFrom) {
        result2.push("");
      }
      lastCharIsComma = true;
      i++;
      continue;
    }
    lastCharIsComma = false;
    if (char === "\\") {
      i += 2;
      continue;
    }
    if (char === '"') {
      const [value22, startFrom2] = parsePgArrayValue(arrayString, i + 1, true);
      result2.push(value22);
      i = startFrom2;
      continue;
    }
    if (char === "}") {
      return [result2, i + 1];
    }
    if (char === "{") {
      const [value22, startFrom2] = parsePgNestedArray(arrayString, i + 1);
      result2.push(value22);
      i = startFrom2;
      continue;
    }
    const [value15, newStartFrom] = parsePgArrayValue(arrayString, i, false);
    result2.push(value15);
    i = newStartFrom;
  }
  return [result2, i];
};
var parsePgArray = function(arrayString) {
  const [result2] = parsePgNestedArray(arrayString, 1);
  return result2;
};
var makePgArray = function(array5) {
  return `{${array5.map((item) => {
    if (Array.isArray(item)) {
      return makePgArray(item);
    }
    if (typeof item === "string") {
      return `"${item.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
    }
    return `${item}`;
  }).join(",")}}`;
};

// node_modules/drizzle-orm/pg-core/columns/common.js
class PgColumnBuilder extends ColumnBuilder {
  foreignKeyConfigs = [];
  static [entityKind] = "PgColumnBuilder";
  array(size2) {
    return new PgArrayBuilder(this.config.name, this, size2);
  }
  references(ref4, actions = {}) {
    this.foreignKeyConfigs.push({ ref: ref4, actions });
    return this;
  }
  unique(name, config) {
    this.config.isUnique = true;
    this.config.uniqueName = name;
    this.config.uniqueType = config?.nulls;
    return this;
  }
  buildForeignKeys(column7, table10) {
    return this.foreignKeyConfigs.map(({ ref: ref4, actions }) => {
      return iife((ref22, actions2) => {
        const builder = new ForeignKeyBuilder(() => {
          const foreignColumn = ref22();
          return { columns: [column7], foreignColumns: [foreignColumn] };
        });
        if (actions2.onUpdate) {
          builder.onUpdate(actions2.onUpdate);
        }
        if (actions2.onDelete) {
          builder.onDelete(actions2.onDelete);
        }
        return builder.build(table10);
      }, ref4, actions);
    });
  }
}

class PgColumn extends Column {
  constructor(table10, config) {
    if (!config.uniqueName) {
      config.uniqueName = uniqueKeyName(table10, [config.name]);
    }
    super(table10, config);
    this.table = table10;
  }
  static [entityKind] = "PgColumn";
}

class PgArrayBuilder extends PgColumnBuilder {
  static [entityKind] = "PgArrayBuilder";
  constructor(name, baseBuilder, size2) {
    super(name, "array", "PgArray");
    this.config.baseBuilder = baseBuilder;
    this.config.size = size2;
  }
  build(table10) {
    const baseColumn = this.config.baseBuilder.build(table10);
    return new PgArray(table10, this.config, baseColumn);
  }
}

class PgArray extends PgColumn {
  constructor(table10, config, baseColumn, range) {
    super(table10, config);
    this.baseColumn = baseColumn;
    this.range = range;
    this.size = config.size;
  }
  size;
  static [entityKind] = "PgArray";
  getSQLType() {
    return `${this.baseColumn.getSQLType()}[${typeof this.size === "number" ? this.size : ""}]`;
  }
  mapFromDriverValue(value15) {
    if (typeof value15 === "string") {
      value15 = parsePgArray(value15);
    }
    return value15.map((v2) => this.baseColumn.mapFromDriverValue(v2));
  }
  mapToDriverValue(value15, isNestedArray = false) {
    const a2 = value15.map((v2) => v2 === null ? null : is(this.baseColumn, PgArray) ? this.baseColumn.mapToDriverValue(v2, true) : this.baseColumn.mapToDriverValue(v2));
    if (isNestedArray)
      return a2;
    return makePgArray(a2);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.common.js
class PgDateColumnBaseBuilder extends PgColumnBuilder {
  static [entityKind] = "PgDateColumnBaseBuilder";
  defaultNow() {
    return this.default(sql`now()`);
  }
}

// node_modules/drizzle-orm/pg-core/columns/date.js
class PgDate extends PgColumn {
  static [entityKind] = "PgDate";
  getSQLType() {
    return "date";
  }
  mapFromDriverValue(value15) {
    return new Date(value15);
  }
  mapToDriverValue(value15) {
    return value15.toISOString();
  }
}

// node_modules/drizzle-orm/pg-core/columns/enum.js
var pgEnum = function(enumName, values2) {
  const enumInstance = Object.assign((name) => new PgEnumColumnBuilder(name, enumInstance), {
    enumName,
    enumValues: values2,
    [isPgEnumSym]: true
  });
  return enumInstance;
};
var isPgEnumSym = Symbol.for("drizzle:isPgEnum");

class PgEnumColumnBuilder extends PgColumnBuilder {
  static [entityKind] = "PgEnumColumnBuilder";
  constructor(name, enumInstance) {
    super(name, "string", "PgEnumColumn");
    this.config.enum = enumInstance;
  }
  build(table10) {
    return new PgEnumColumn(table10, this.config);
  }
}

class PgEnumColumn extends PgColumn {
  static [entityKind] = "PgEnumColumn";
  enum = this.config.enum;
  enumValues = this.config.enum.enumValues;
  constructor(table10, config) {
    super(table10, config);
    this.enum = config.enum;
  }
  getSQLType() {
    return this.enum.enumName;
  }
}

// node_modules/drizzle-orm/pg-core/columns/integer.js
var integer4 = function(name) {
  return new PgIntegerBuilder(name);
};

class PgIntegerBuilder extends PgColumnBuilder {
  static [entityKind] = "PgIntegerBuilder";
  constructor(name) {
    super(name, "number", "PgInteger");
  }
  build(table10) {
    return new PgInteger(table10, this.config);
  }
}

class PgInteger extends PgColumn {
  static [entityKind] = "PgInteger";
  getSQLType() {
    return "integer";
  }
  mapFromDriverValue(value15) {
    if (typeof value15 === "string") {
      return Number.parseInt(value15);
    }
    return value15;
  }
}

// node_modules/drizzle-orm/pg-core/columns/json.js
class PgJson extends PgColumn {
  static [entityKind] = "PgJson";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "json";
  }
  mapToDriverValue(value15) {
    return JSON.stringify(value15);
  }
  mapFromDriverValue(value15) {
    if (typeof value15 === "string") {
      try {
        return JSON.parse(value15);
      } catch {
        return value15;
      }
    }
    return value15;
  }
}

// node_modules/drizzle-orm/pg-core/columns/jsonb.js
class PgJsonb extends PgColumn {
  static [entityKind] = "PgJsonb";
  constructor(table10, config) {
    super(table10, config);
  }
  getSQLType() {
    return "jsonb";
  }
  mapToDriverValue(value15) {
    return JSON.stringify(value15);
  }
  mapFromDriverValue(value15) {
    if (typeof value15 === "string") {
      try {
        return JSON.parse(value15);
      } catch {
        return value15;
      }
    }
    return value15;
  }
}

// node_modules/drizzle-orm/pg-core/columns/numeric.js
class PgNumeric extends PgColumn {
  static [entityKind] = "PgNumeric";
  precision;
  scale;
  constructor(table10, config) {
    super(table10, config);
    this.precision = config.precision;
    this.scale = config.scale;
  }
  getSQLType() {
    if (this.precision !== undefined && this.scale !== undefined) {
      return `numeric(${this.precision}, ${this.scale})`;
    } else if (this.precision === undefined) {
      return "numeric";
    } else {
      return `numeric(${this.precision})`;
    }
  }
}

// node_modules/drizzle-orm/pg-core/columns/text.js
var text = function(name, config = {}) {
  return new PgTextBuilder(name, config);
};

class PgTextBuilder extends PgColumnBuilder {
  static [entityKind] = "PgTextBuilder";
  constructor(name, config) {
    super(name, "string", "PgText");
    this.config.enumValues = config.enum;
  }
  build(table10) {
    return new PgText(table10, this.config);
  }
}

class PgText extends PgColumn {
  static [entityKind] = "PgText";
  enumValues = this.config.enumValues;
  getSQLType() {
    return "text";
  }
}

// node_modules/drizzle-orm/pg-core/columns/time.js
class PgTime extends PgColumn {
  static [entityKind] = "PgTime";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `time${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/timestamp.js
var timestamp = function(name, config = {}) {
  if (config.mode === "string") {
    return new PgTimestampStringBuilder(name, config.withTimezone ?? false, config.precision);
  }
  return new PgTimestampBuilder(name, config.withTimezone ?? false, config.precision);
};

class PgTimestampBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "date", "PgTimestamp");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestamp(table10, this.config);
  }
}

class PgTimestamp extends PgColumn {
  static [entityKind] = "PgTimestamp";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : ` (${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
  mapFromDriverValue = (value15) => {
    return new Date(this.withTimezone ? value15 : value15 + "+0000");
  };
  mapToDriverValue = (value15) => {
    return value15.toISOString();
  };
}

class PgTimestampStringBuilder extends PgDateColumnBaseBuilder {
  static [entityKind] = "PgTimestampStringBuilder";
  constructor(name, withTimezone, precision) {
    super(name, "string", "PgTimestampString");
    this.config.withTimezone = withTimezone;
    this.config.precision = precision;
  }
  build(table10) {
    return new PgTimestampString(table10, this.config);
  }
}

class PgTimestampString extends PgColumn {
  static [entityKind] = "PgTimestampString";
  withTimezone;
  precision;
  constructor(table10, config) {
    super(table10, config);
    this.withTimezone = config.withTimezone;
    this.precision = config.precision;
  }
  getSQLType() {
    const precision = this.precision === undefined ? "" : `(${this.precision})`;
    return `timestamp${precision}${this.withTimezone ? " with time zone" : ""}`;
  }
}

// node_modules/drizzle-orm/pg-core/columns/uuid.js
class PgUUID extends PgColumn {
  static [entityKind] = "PgUUID";
  getSQLType() {
    return "uuid";
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/delete.js
class PgDeleteBase extends QueryPromise {
  constructor(table11, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table11, withList };
  }
  static [entityKind] = "PgDelete";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildDeleteQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest4 } = this.dialect.sqlToQuery(this.getSQL());
    return rest4;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/insert.js
class PgInsertBuilder {
  constructor(table12, session, dialect, withList) {
    this.table = table12;
    this.session = session;
    this.dialect = dialect;
    this.withList = withList;
  }
  static [entityKind] = "PgInsertBuilder";
  values(values2) {
    values2 = Array.isArray(values2) ? values2 : [values2];
    if (values2.length === 0) {
      throw new Error("values() must be called with at least one value");
    }
    const mappedValues = values2.map((entry) => {
      const result2 = {};
      const cols = this.table[Table.Symbol.Columns];
      for (const colKey of Object.keys(entry)) {
        const colValue = entry[colKey];
        result2[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
      }
      return result2;
    });
    return new PgInsertBase(this.table, mappedValues, this.session, this.dialect, this.withList);
  }
}

class PgInsertBase extends QueryPromise {
  constructor(table12, values2, session, dialect, withList) {
    super();
    this.session = session;
    this.dialect = dialect;
    this.config = { table: table12, values: values2, withList };
  }
  static [entityKind] = "PgInsert";
  config;
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  onConflictDoNothing(config = {}) {
    if (config.target === undefined) {
      this.config.onConflict = sql`do nothing`;
    } else {
      let targetColumn = "";
      targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
      const whereSql = config.where ? sql` where ${config.where}` : undefined;
      this.config.onConflict = sql`(${sql.raw(targetColumn)}) do nothing${whereSql}`;
    }
    return this;
  }
  onConflictDoUpdate(config) {
    const whereSql = config.where ? sql` where ${config.where}` : undefined;
    const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
    let targetColumn = "";
    targetColumn = Array.isArray(config.target) ? config.target.map((it) => this.dialect.escapeName(it.name)).join(",") : this.dialect.escapeName(config.target.name);
    this.config.onConflict = sql`(${sql.raw(targetColumn)}) do update set ${setSql}${whereSql}`;
    return this;
  }
  getSQL() {
    return this.dialect.buildInsertQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest4 } = this.dialect.sqlToQuery(this.getSQL());
    return rest4;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/view-base.js
class PgViewBase extends View {
  static [entityKind] = "PgViewBase";
}

// node_modules/drizzle-orm/pg-core/dialect.js
class PgDialect {
  static [entityKind] = "PgDialect";
  async migrate(migrations, session, config) {
    const migrationsTable = typeof config === "string" ? "__drizzle_migrations" : config.migrationsTable ?? "__drizzle_migrations";
    const migrationsSchema = typeof config === "string" ? "drizzle" : config.migrationsSchema ?? "drizzle";
    const migrationTableCreate = sql`
			CREATE TABLE IF NOT EXISTS ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} (
				id SERIAL PRIMARY KEY,
				hash text NOT NULL,
				created_at bigint
			)
		`;
    await session.execute(sql`CREATE SCHEMA IF NOT EXISTS ${sql.identifier(migrationsSchema)}`);
    await session.execute(migrationTableCreate);
    const dbMigrations = await session.all(sql`select id, hash, created_at from ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
    const lastDbMigration = dbMigrations[0];
    await session.transaction(async (tx) => {
      for await (const migration of migrations) {
        if (!lastDbMigration || Number(lastDbMigration.created_at) < migration.folderMillis) {
          for (const stmt of migration.sql) {
            await tx.execute(sql.raw(stmt));
          }
          await tx.execute(sql`insert into ${sql.identifier(migrationsSchema)}.${sql.identifier(migrationsTable)} ("hash", "created_at") values(${migration.hash}, ${migration.folderMillis})`);
        }
      }
    });
  }
  escapeName(name) {
    return `"${name}"`;
  }
  escapeParam(num) {
    return `\$${num + 1}`;
  }
  escapeString(str) {
    return `'${str.replace(/'/g, "''")}'`;
  }
  buildWithCTE(queries) {
    if (!queries?.length)
      return;
    const withSqlChunks = [sql`with `];
    for (const [i, w] of queries.entries()) {
      withSqlChunks.push(sql`${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
      if (i < queries.length - 1) {
        withSqlChunks.push(sql`, `);
      }
    }
    withSqlChunks.push(sql` `);
    return sql.join(withSqlChunks);
  }
  buildDeleteQuery({ table: table14, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}delete from ${table14}${whereSql}${returningSql}`;
  }
  buildUpdateSet(table14, set2) {
    const setEntries = Object.entries(set2);
    const setSize = setEntries.length;
    return sql.join(setEntries.flatMap(([colName, value15], i) => {
      const col = table14[Table.Symbol.Columns][colName];
      const res = sql`${sql.identifier(col.name)} = ${value15}`;
      if (i < setSize - 1) {
        return [res, sql.raw(", ")];
      }
      return [res];
    }));
  }
  buildUpdateQuery({ table: table14, set: set2, where, returning, withList }) {
    const withSql = this.buildWithCTE(withList);
    const setSql = this.buildUpdateSet(table14, set2);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const whereSql = where ? sql` where ${where}` : undefined;
    return sql`${withSql}update ${table14} set ${setSql}${whereSql}${returningSql}`;
  }
  buildSelection(fields, { isSingleTable = false } = {}) {
    const columnsLen = fields.length;
    const chunks = fields.flatMap(({ field }, i) => {
      const chunk = [];
      if (is(field, SQL.Aliased) && field.isSelectionField) {
        chunk.push(sql.identifier(field.fieldAlias));
      } else if (is(field, SQL.Aliased) || is(field, SQL)) {
        const query4 = is(field, SQL.Aliased) ? field.sql : field;
        if (isSingleTable) {
          chunk.push(new SQL(query4.queryChunks.map((c2) => {
            if (is(c2, PgColumn)) {
              return sql.identifier(c2.name);
            }
            return c2;
          })));
        } else {
          chunk.push(query4);
        }
        if (is(field, SQL.Aliased)) {
          chunk.push(sql` as ${sql.identifier(field.fieldAlias)}`);
        }
      } else if (is(field, Column)) {
        if (isSingleTable) {
          chunk.push(sql.identifier(field.name));
        } else {
          chunk.push(field);
        }
      }
      if (i < columnsLen - 1) {
        chunk.push(sql`, `);
      }
      return chunk;
    });
    return sql.join(chunks);
  }
  buildSelectQuery({
    withList,
    fields,
    fieldsFlat,
    where,
    having,
    table: table14,
    joins,
    orderBy,
    groupBy,
    limit,
    offset,
    lockingClause,
    distinct,
    setOperators
  }) {
    const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
    for (const f of fieldsList) {
      if (is(f.field, Column) && getTableName(f.field.table) !== (is(table14, Subquery) ? table14[SubqueryConfig].alias : is(table14, PgViewBase) ? table14[ViewBaseConfig].name : is(table14, SQL) ? undefined : getTableName(table14)) && !((table22) => joins?.some(({ alias: alias2 }) => alias2 === (table22[Table.Symbol.IsAlias] ? getTableName(table22) : table22[Table.Symbol.BaseName])))(f.field.table)) {
        const tableName = getTableName(f.field.table);
        throw new Error(`Your "${f.path.join("->")}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
      }
    }
    const isSingleTable = !joins || joins.length === 0;
    const withSql = this.buildWithCTE(withList);
    let distinctSql;
    if (distinct) {
      distinctSql = distinct === true ? sql` distinct` : sql` distinct on (${sql.join(distinct.on, sql`, `)})`;
    }
    const selection = this.buildSelection(fieldsList, { isSingleTable });
    const tableSql = (() => {
      if (is(table14, Table) && table14[Table.Symbol.OriginalName] !== table14[Table.Symbol.Name]) {
        let fullName = sql`${sql.identifier(table14[Table.Symbol.OriginalName])}`;
        if (table14[Table.Symbol.Schema]) {
          fullName = sql`${sql.identifier(table14[Table.Symbol.Schema])}.${fullName}`;
        }
        return sql`${fullName} ${sql.identifier(table14[Table.Symbol.Name])}`;
      }
      return table14;
    })();
    const joinsArray = [];
    if (joins) {
      for (const [index, joinMeta] of joins.entries()) {
        if (index === 0) {
          joinsArray.push(sql` `);
        }
        const table22 = joinMeta.table;
        const lateralSql = joinMeta.lateral ? sql` lateral` : undefined;
        if (is(table22, PgTable)) {
          const tableName = table22[PgTable.Symbol.Name];
          const tableSchema = table22[PgTable.Symbol.Schema];
          const origTableName = table22[PgTable.Symbol.OriginalName];
          const alias2 = tableName === origTableName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql`${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias2 && sql` ${sql.identifier(alias2)}`} on ${joinMeta.on}`);
        } else if (is(table22, View)) {
          const viewName = table22[ViewBaseConfig].name;
          const viewSchema = table22[ViewBaseConfig].schema;
          const origViewName = table22[ViewBaseConfig].originalName;
          const alias2 = viewName === origViewName ? undefined : joinMeta.alias;
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql`${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias2 && sql` ${sql.identifier(alias2)}`} on ${joinMeta.on}`);
        } else {
          joinsArray.push(sql`${sql.raw(joinMeta.joinType)} join${lateralSql} ${table22} on ${joinMeta.on}`);
        }
        if (index < joins.length - 1) {
          joinsArray.push(sql` `);
        }
      }
    }
    const joinsSql = sql.join(joinsArray);
    const whereSql = where ? sql` where ${where}` : undefined;
    const havingSql = having ? sql` having ${having}` : undefined;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      orderBySql = sql` order by ${sql.join(orderBy, sql`, `)}`;
    }
    let groupBySql;
    if (groupBy && groupBy.length > 0) {
      groupBySql = sql` group by ${sql.join(groupBy, sql`, `)}`;
    }
    const limitSql = limit ? sql` limit ${limit}` : undefined;
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    const lockingClauseSql = sql.empty();
    if (lockingClause) {
      const clauseSql = sql` for ${sql.raw(lockingClause.strength)}`;
      if (lockingClause.config.of) {
        clauseSql.append(sql` of ${sql.join(Array.isArray(lockingClause.config.of) ? lockingClause.config.of : [lockingClause.config.of], sql`, `)}`);
      }
      if (lockingClause.config.noWait) {
        clauseSql.append(sql` no wait`);
      } else if (lockingClause.config.skipLocked) {
        clauseSql.append(sql` skip locked`);
      }
      lockingClauseSql.append(clauseSql);
    }
    const finalQuery = sql`${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClauseSql}`;
    if (setOperators.length > 0) {
      return this.buildSetOperations(finalQuery, setOperators);
    }
    return finalQuery;
  }
  buildSetOperations(leftSelect, setOperators) {
    const [setOperator, ...rest4] = setOperators;
    if (!setOperator) {
      throw new Error("Cannot pass undefined values to any set operator");
    }
    if (rest4.length === 0) {
      return this.buildSetOperationQuery({ leftSelect, setOperator });
    }
    return this.buildSetOperations(this.buildSetOperationQuery({ leftSelect, setOperator }), rest4);
  }
  buildSetOperationQuery({
    leftSelect,
    setOperator: { type: type75, isAll, rightSelect, limit, orderBy, offset }
  }) {
    const leftChunk = sql`(${leftSelect.getSQL()}) `;
    const rightChunk = sql`(${rightSelect.getSQL()})`;
    let orderBySql;
    if (orderBy && orderBy.length > 0) {
      const orderByValues = [];
      for (const singleOrderBy of orderBy) {
        if (is(singleOrderBy, PgColumn)) {
          orderByValues.push(sql.identifier(singleOrderBy.name));
        } else if (is(singleOrderBy, SQL)) {
          for (let i = 0;i < singleOrderBy.queryChunks.length; i++) {
            const chunk = singleOrderBy.queryChunks[i];
            if (is(chunk, PgColumn)) {
              singleOrderBy.queryChunks[i] = sql.identifier(chunk.name);
            }
          }
          orderByValues.push(sql`${singleOrderBy}`);
        } else {
          orderByValues.push(sql`${singleOrderBy}`);
        }
      }
      orderBySql = sql` order by ${sql.join(orderByValues, sql`, `)} `;
    }
    const limitSql = limit ? sql` limit ${limit}` : undefined;
    const operatorChunk = sql.raw(`${type75} ${isAll ? "all " : ""}`);
    const offsetSql = offset ? sql` offset ${offset}` : undefined;
    return sql`${leftChunk}${operatorChunk}${rightChunk}${orderBySql}${limitSql}${offsetSql}`;
  }
  buildInsertQuery({ table: table14, values: values2, onConflict, returning, withList }) {
    const valuesSqlList = [];
    const columns2 = table14[Table.Symbol.Columns];
    const colEntries = Object.entries(columns2);
    const insertOrder = colEntries.map(([, column8]) => sql.identifier(column8.name));
    for (const [valueIndex, value15] of values2.entries()) {
      const valueList = [];
      for (const [fieldName, col] of colEntries) {
        const colValue = value15[fieldName];
        if (colValue === undefined || is(colValue, Param) && colValue.value === undefined) {
          if (col.defaultFn !== undefined) {
            const defaultFnResult = col.defaultFn();
            const defaultValue = is(defaultFnResult, SQL) ? defaultFnResult : sql.param(defaultFnResult, col);
            valueList.push(defaultValue);
          } else {
            valueList.push(sql`default`);
          }
        } else {
          valueList.push(colValue);
        }
      }
      valuesSqlList.push(valueList);
      if (valueIndex < values2.length - 1) {
        valuesSqlList.push(sql`, `);
      }
    }
    const withSql = this.buildWithCTE(withList);
    const valuesSql = sql.join(valuesSqlList);
    const returningSql = returning ? sql` returning ${this.buildSelection(returning, { isSingleTable: true })}` : undefined;
    const onConflictSql = onConflict ? sql` on conflict ${onConflict}` : undefined;
    return sql`${withSql}insert into ${table14} ${insertOrder} values ${valuesSql}${onConflictSql}${returningSql}`;
  }
  buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }) {
    const concurrentlySql = concurrently ? sql` concurrently` : undefined;
    const withNoDataSql = withNoData ? sql` with no data` : undefined;
    return sql`refresh materialized view${concurrentlySql} ${view}${withNoDataSql}`;
  }
  prepareTyping(encoder) {
    if (is(encoder, PgJsonb) || is(encoder, PgJson)) {
      return "json";
    } else if (is(encoder, PgNumeric)) {
      return "decimal";
    } else if (is(encoder, PgTime)) {
      return "time";
    } else if (is(encoder, PgTimestamp)) {
      return "timestamp";
    } else if (is(encoder, PgDate)) {
      return "date";
    } else if (is(encoder, PgUUID)) {
      return "uuid";
    } else {
      return "none";
    }
  }
  sqlToQuery(sql22) {
    return sql22.toQuery({
      escapeName: this.escapeName,
      escapeParam: this.escapeParam,
      escapeString: this.escapeString,
      prepareTyping: this.prepareTyping
    });
  }
  buildRelationalQueryWithoutPK({
    fullSchema,
    schema: schema3,
    tableNamesMap,
    table: table14,
    tableConfig,
    queryConfig: config,
    tableAlias,
    nestedQueryRelation,
    joinOn
  }) {
    let selection = [];
    let limit, offset, orderBy = [], where;
    const joins = [];
    if (config === true) {
      const selectionEntries = Object.entries(tableConfig.columns);
      selection = selectionEntries.map(([key, value15]) => ({
        dbKey: value15.name,
        tsKey: key,
        field: aliasedTableColumn(value15, tableAlias),
        relationTableTsKey: undefined,
        isJson: false,
        selection: []
      }));
    } else {
      const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value15]) => [key, aliasedTableColumn(value15, tableAlias)]));
      if (config.where) {
        const whereSql = typeof config.where === "function" ? config.where(aliasedColumns, getOperators()) : config.where;
        where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
      }
      const fieldsSelection = [];
      let selectedColumns = [];
      if (config.columns) {
        let isIncludeMode = false;
        for (const [field, value15] of Object.entries(config.columns)) {
          if (value15 === undefined) {
            continue;
          }
          if (field in tableConfig.columns) {
            if (!isIncludeMode && value15 === true) {
              isIncludeMode = true;
            }
            selectedColumns.push(field);
          }
        }
        if (selectedColumns.length > 0) {
          selectedColumns = isIncludeMode ? selectedColumns.filter((c2) => config.columns?.[c2] === true) : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
        }
      } else {
        selectedColumns = Object.keys(tableConfig.columns);
      }
      for (const field of selectedColumns) {
        const column8 = tableConfig.columns[field];
        fieldsSelection.push({ tsKey: field, value: column8 });
      }
      let selectedRelations = [];
      if (config.with) {
        selectedRelations = Object.entries(config.with).filter((entry) => !!entry[1]).map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
      }
      let extras;
      if (config.extras) {
        extras = typeof config.extras === "function" ? config.extras(aliasedColumns, { sql }) : config.extras;
        for (const [tsKey, value15] of Object.entries(extras)) {
          fieldsSelection.push({
            tsKey,
            value: mapColumnsInAliasedSQLToAlias(value15, tableAlias)
          });
        }
      }
      for (const { tsKey, value: value15 } of fieldsSelection) {
        selection.push({
          dbKey: is(value15, SQL.Aliased) ? value15.fieldAlias : tableConfig.columns[tsKey].name,
          tsKey,
          field: is(value15, Column) ? aliasedTableColumn(value15, tableAlias) : value15,
          relationTableTsKey: undefined,
          isJson: false,
          selection: []
        });
      }
      let orderByOrig = typeof config.orderBy === "function" ? config.orderBy(aliasedColumns, getOrderByOperators()) : config.orderBy ?? [];
      if (!Array.isArray(orderByOrig)) {
        orderByOrig = [orderByOrig];
      }
      orderBy = orderByOrig.map((orderByValue) => {
        if (is(orderByValue, Column)) {
          return aliasedTableColumn(orderByValue, tableAlias);
        }
        return mapColumnsInSQLToAlias(orderByValue, tableAlias);
      });
      limit = config.limit;
      offset = config.offset;
      for (const {
        tsKey: selectedRelationTsKey,
        queryConfig: selectedRelationConfigValue,
        relation
      } of selectedRelations) {
        const normalizedRelation = normalizeRelation(schema3, tableNamesMap, relation);
        const relationTableName = relation.referencedTable[Table.Symbol.Name];
        const relationTableTsName = tableNamesMap[relationTableName];
        const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
        const joinOn2 = and(...normalizedRelation.fields.map((field2, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field2, tableAlias))));
        const builtRelation = this.buildRelationalQueryWithoutPK({
          fullSchema,
          schema: schema3,
          tableNamesMap,
          table: fullSchema[relationTableTsName],
          tableConfig: schema3[relationTableTsName],
          queryConfig: is(relation, One) ? selectedRelationConfigValue === true ? { limit: 1 } : { ...selectedRelationConfigValue, limit: 1 } : selectedRelationConfigValue,
          tableAlias: relationTableAlias,
          joinOn: joinOn2,
          nestedQueryRelation: relation
        });
        const field = sql`${sql.identifier(relationTableAlias)}.${sql.identifier("data")}`.as(selectedRelationTsKey);
        joins.push({
          on: sql`true`,
          table: new Subquery(builtRelation.sql, {}, relationTableAlias),
          alias: relationTableAlias,
          joinType: "left",
          lateral: true
        });
        selection.push({
          dbKey: selectedRelationTsKey,
          tsKey: selectedRelationTsKey,
          field,
          relationTableTsKey: relationTableTsName,
          isJson: true,
          selection: builtRelation.selection
        });
      }
    }
    if (selection.length === 0) {
      throw new DrizzleError({ message: `No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")` });
    }
    let result2;
    where = and(joinOn, where);
    if (nestedQueryRelation) {
      let field = sql`json_build_array(${sql.join(selection.map(({ field: field2, tsKey, isJson }) => isJson ? sql`${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier("data")}` : is(field2, SQL.Aliased) ? field2.sql : field2), sql`, `)})`;
      if (is(nestedQueryRelation, Many)) {
        field = sql`coalesce(json_agg(${field}${orderBy.length > 0 ? sql` order by ${sql.join(orderBy, sql`, `)}` : undefined}), '[]'::json)`;
      }
      const nestedSelection = [{
        dbKey: "data",
        tsKey: "data",
        field: field.as("data"),
        isJson: true,
        relationTableTsKey: tableConfig.tsName,
        selection
      }];
      const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
      if (needsSubquery) {
        result2 = this.buildSelectQuery({
          table: aliasedTable(table14, tableAlias),
          fields: {},
          fieldsFlat: [{
            path: [],
            field: sql.raw("*")
          }],
          where,
          limit,
          offset,
          orderBy,
          setOperators: []
        });
        where = undefined;
        limit = undefined;
        offset = undefined;
        orderBy = [];
      } else {
        result2 = aliasedTable(table14, tableAlias);
      }
      result2 = this.buildSelectQuery({
        table: is(result2, PgTable) ? result2 : new Subquery(result2, {}, tableAlias),
        fields: {},
        fieldsFlat: nestedSelection.map(({ field: field2 }) => ({
          path: [],
          field: is(field2, Column) ? aliasedTableColumn(field2, tableAlias) : field2
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    } else {
      result2 = this.buildSelectQuery({
        table: aliasedTable(table14, tableAlias),
        fields: {},
        fieldsFlat: selection.map(({ field }) => ({
          path: [],
          field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field
        })),
        joins,
        where,
        limit,
        offset,
        orderBy,
        setOperators: []
      });
    }
    return {
      tableTsKey: tableConfig.tsName,
      sql: result2,
      selection
    };
  }
}

// node_modules/drizzle-orm/query-builders/query-builder.js
class TypedQueryBuilder {
  static [entityKind] = "TypedQueryBuilder";
  getSelectedFields() {
    return this._.selectedFields;
  }
}

// node_modules/drizzle-orm/selection-proxy.js
class SelectionProxyHandler {
  static [entityKind] = "SelectionProxyHandler";
  config;
  constructor(config) {
    this.config = { ...config };
  }
  get(subquery5, prop) {
    if (prop === SubqueryConfig) {
      return {
        ...subquery5[SubqueryConfig],
        selection: new Proxy(subquery5[SubqueryConfig].selection, this)
      };
    }
    if (prop === ViewBaseConfig) {
      return {
        ...subquery5[ViewBaseConfig],
        selectedFields: new Proxy(subquery5[ViewBaseConfig].selectedFields, this)
      };
    }
    if (typeof prop === "symbol") {
      return subquery5[prop];
    }
    const columns2 = is(subquery5, Subquery) ? subquery5[SubqueryConfig].selection : is(subquery5, View) ? subquery5[ViewBaseConfig].selectedFields : subquery5;
    const value15 = columns2[prop];
    if (is(value15, SQL.Aliased)) {
      if (this.config.sqlAliasedBehavior === "sql" && !value15.isSelectionField) {
        return value15.sql;
      }
      const newValue = value15.clone();
      newValue.isSelectionField = true;
      return newValue;
    }
    if (is(value15, SQL)) {
      if (this.config.sqlBehavior === "sql") {
        return value15;
      }
      throw new Error(`You tried to reference "${prop}" field from a subquery, which is a raw SQL field, but it doesn't have an alias declared. Please add an alias to the field using ".as('alias')" method.`);
    }
    if (is(value15, Column)) {
      if (this.config.alias) {
        return new Proxy(value15, new ColumnAliasProxyHandler(new Proxy(value15.table, new TableAliasProxyHandler(this.config.alias, this.config.replaceOriginalName ?? false))));
      }
      return value15;
    }
    if (typeof value15 !== "object" || value15 === null) {
      return value15;
    }
    return new Proxy(value15, new SelectionProxyHandler(this.config));
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/select.js
var createSetOperator = function(type75, isAll) {
  return (leftSelect, rightSelect, ...restSelects) => {
    const setOperators = [rightSelect, ...restSelects].map((select2) => ({
      type: type75,
      isAll,
      rightSelect: select2
    }));
    for (const setOperator of setOperators) {
      if (!haveSameKeys(leftSelect.getSelectedFields(), setOperator.rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
    }
    return leftSelect.addSetOperators(setOperators);
  };
};

class PgSelectBuilder {
  static [entityKind] = "PgSelectBuilder";
  fields;
  session;
  dialect;
  withList = [];
  distinct;
  constructor(config) {
    this.fields = config.fields;
    this.session = config.session;
    this.dialect = config.dialect;
    if (config.withList) {
      this.withList = config.withList;
    }
    this.distinct = config.distinct;
  }
  from(source) {
    const isPartialSelect = !!this.fields;
    let fields;
    if (this.fields) {
      fields = this.fields;
    } else if (is(source, Subquery)) {
      fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
    } else if (is(source, PgViewBase)) {
      fields = source[ViewBaseConfig].selectedFields;
    } else if (is(source, SQL)) {
      fields = {};
    } else {
      fields = getTableColumns(source);
    }
    return new PgSelectBase({
      table: source,
      fields,
      isPartialSelect,
      session: this.session,
      dialect: this.dialect,
      withList: this.withList,
      distinct: this.distinct
    });
  }
}

class PgSelectQueryBuilderBase extends TypedQueryBuilder {
  static [entityKind] = "PgSelectQueryBuilder";
  _;
  config;
  joinsNotNullableMap;
  tableName;
  isPartialSelect;
  session;
  dialect;
  constructor({ table: table15, fields, isPartialSelect, session, dialect, withList, distinct }) {
    super();
    this.config = {
      withList,
      table: table15,
      fields: { ...fields },
      distinct,
      setOperators: []
    };
    this.isPartialSelect = isPartialSelect;
    this.session = session;
    this.dialect = dialect;
    this._ = {
      selectedFields: fields
    };
    this.tableName = getTableLikeName(table15);
    this.joinsNotNullableMap = typeof this.tableName === "string" ? { [this.tableName]: true } : {};
  }
  createJoin(joinType) {
    return (table15, on) => {
      const baseTableName = this.tableName;
      const tableName = getTableLikeName(table15);
      if (typeof tableName === "string" && this.config.joins?.some((join) => join.alias === tableName)) {
        throw new Error(`Alias "${tableName}" is already used in this query`);
      }
      if (!this.isPartialSelect) {
        if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === "string") {
          this.config.fields = {
            [baseTableName]: this.config.fields
          };
        }
        if (typeof tableName === "string" && !is(table15, SQL)) {
          const selection = is(table15, Subquery) ? table15[SubqueryConfig].selection : is(table15, View) ? table15[ViewBaseConfig].selectedFields : table15[Table.Symbol.Columns];
          this.config.fields[tableName] = selection;
        }
      }
      if (typeof on === "function") {
        on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
      }
      if (!this.config.joins) {
        this.config.joins = [];
      }
      this.config.joins.push({ on, table: table15, joinType, alias: tableName });
      if (typeof tableName === "string") {
        switch (joinType) {
          case "left": {
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
          case "right": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "inner": {
            this.joinsNotNullableMap[tableName] = true;
            break;
          }
          case "full": {
            this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
            this.joinsNotNullableMap[tableName] = false;
            break;
          }
        }
      }
      return this;
    };
  }
  leftJoin = this.createJoin("left");
  rightJoin = this.createJoin("right");
  innerJoin = this.createJoin("inner");
  fullJoin = this.createJoin("full");
  createSetOperator(type75, isAll) {
    return (rightSelection) => {
      const rightSelect = typeof rightSelection === "function" ? rightSelection(getPgSetOperators()) : rightSelection;
      if (!haveSameKeys(this.getSelectedFields(), rightSelect.getSelectedFields())) {
        throw new Error("Set operator error (union / intersect / except): selected fields are not the same or are in a different order");
      }
      this.config.setOperators.push({ type: type75, isAll, rightSelect });
      return this;
    };
  }
  union = this.createSetOperator("union", false);
  unionAll = this.createSetOperator("union", true);
  intersect = this.createSetOperator("intersect", false);
  intersectAll = this.createSetOperator("intersect", true);
  except = this.createSetOperator("except", false);
  exceptAll = this.createSetOperator("except", true);
  addSetOperators(setOperators) {
    this.config.setOperators.push(...setOperators);
    return this;
  }
  where(where) {
    if (typeof where === "function") {
      where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.where = where;
    return this;
  }
  having(having) {
    if (typeof having === "function") {
      having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "sql", sqlBehavior: "sql" })));
    }
    this.config.having = having;
    return this;
  }
  groupBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const groupBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
    } else {
      this.config.groupBy = columns2;
    }
    return this;
  }
  orderBy(...columns2) {
    if (typeof columns2[0] === "function") {
      const orderBy = columns2[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: "alias", sqlBehavior: "sql" })));
      const orderByArray = Array.isArray(orderBy) ? orderBy : [orderBy];
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    } else {
      const orderByArray = columns2;
      if (this.config.setOperators.length > 0) {
        this.config.setOperators.at(-1).orderBy = orderByArray;
      } else {
        this.config.orderBy = orderByArray;
      }
    }
    return this;
  }
  limit(limit) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).limit = limit;
    } else {
      this.config.limit = limit;
    }
    return this;
  }
  offset(offset) {
    if (this.config.setOperators.length > 0) {
      this.config.setOperators.at(-1).offset = offset;
    } else {
      this.config.offset = offset;
    }
    return this;
  }
  for(strength, config = {}) {
    this.config.lockingClause = { strength, config };
    return this;
  }
  getSQL() {
    return this.dialect.buildSelectQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest4 } = this.dialect.sqlToQuery(this.getSQL());
    return rest4;
  }
  as(alias3) {
    return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias3), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  getSelectedFields() {
    return new Proxy(this.config.fields, new SelectionProxyHandler({ alias: this.tableName, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
  }
  $dynamic() {
    return this;
  }
}

class PgSelectBase extends PgSelectQueryBuilderBase {
  static [entityKind] = "PgSelect";
  _prepare(name) {
    const { session, config, dialect, joinsNotNullableMap } = this;
    if (!session) {
      throw new Error("Cannot execute a query on a query builder. Please use a database instance instead.");
    }
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const fieldsList = orderSelectedFields(config.fields);
      const query4 = session.prepareQuery(dialect.sqlToQuery(this.getSQL()), fieldsList, name);
      query4.joinsNotNullableMap = joinsNotNullableMap;
      return query4;
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}
applyMixins(PgSelectBase, [QueryPromise]);
var getPgSetOperators = () => ({
  union: union22,
  unionAll,
  intersect: intersect12,
  intersectAll,
  except,
  exceptAll
});
var union22 = createSetOperator("union", false);
var unionAll = createSetOperator("union", true);
var intersect12 = createSetOperator("intersect", false);
var intersectAll = createSetOperator("intersect", true);
var except = createSetOperator("except", false);
var exceptAll = createSetOperator("except", true);

// node_modules/drizzle-orm/pg-core/query-builders/query-builder.js
class QueryBuilder {
  static [entityKind] = "PgQueryBuilder";
  dialect;
  $with(alias3) {
    const queryBuilder = this;
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(queryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select3(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: undefined,
        dialect: self2.getDialect(),
        distinct: { on }
      });
    }
    return { select: select3, selectDistinct, selectDistinctOn };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect()
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: undefined,
      dialect: this.getDialect(),
      distinct: { on }
    });
  }
  getDialect() {
    if (!this.dialect) {
      this.dialect = new PgDialect;
    }
    return this.dialect;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/refresh-materialized-view.js
class PgRefreshMaterializedView extends QueryPromise {
  constructor(view, session, dialect2) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { view };
  }
  static [entityKind] = "PgRefreshMaterializedView";
  config;
  concurrently() {
    if (this.config.withNoData !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.concurrently = true;
    return this;
  }
  withNoData() {
    if (this.config.concurrently !== undefined) {
      throw new Error("Cannot use concurrently and withNoData together");
    }
    this.config.withNoData = true;
    return this;
  }
  getSQL() {
    return this.dialect.buildRefreshMaterializedViewQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest4 } = this.dialect.sqlToQuery(this.getSQL());
    return rest4;
  }
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined, name);
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute(placeholderValues);
    });
  };
}

// node_modules/drizzle-orm/pg-core/query-builders/update.js
class PgUpdateBuilder {
  constructor(table16, session, dialect2, withList) {
    this.table = table16;
    this.session = session;
    this.dialect = dialect2;
    this.withList = withList;
  }
  static [entityKind] = "PgUpdateBuilder";
  set(values2) {
    return new PgUpdateBase(this.table, mapUpdateSet(this.table, values2), this.session, this.dialect, this.withList);
  }
}

class PgUpdateBase extends QueryPromise {
  constructor(table16, set2, session, dialect2, withList) {
    super();
    this.session = session;
    this.dialect = dialect2;
    this.config = { set: set2, table: table16, withList };
  }
  static [entityKind] = "PgUpdate";
  config;
  where(where) {
    this.config.where = where;
    return this;
  }
  returning(fields = this.config.table[Table.Symbol.Columns]) {
    this.config.returning = orderSelectedFields(fields);
    return this;
  }
  getSQL() {
    return this.dialect.buildUpdateQuery(this.config);
  }
  toSQL() {
    const { typings: _typings, ...rest4 } = this.dialect.sqlToQuery(this.getSQL());
    return rest4;
  }
  _prepare(name) {
    return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning, name);
  }
  prepare(name) {
    return this._prepare(name);
  }
  execute = (placeholderValues) => {
    return this._prepare().execute(placeholderValues);
  };
  $dynamic() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/query.js
class RelationalQueryBuilder {
  constructor(fullSchema, schema3, tableNamesMap, table16, tableConfig, dialect2, session) {
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
  }
  static [entityKind] = "PgRelationalQueryBuilder";
  findMany(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, "many");
  }
  findFirst(config) {
    return new PgRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, "first");
  }
}

class PgRelationalQuery extends QueryPromise {
  constructor(fullSchema, schema3, tableNamesMap, table16, tableConfig, dialect2, session, config, mode) {
    super();
    this.fullSchema = fullSchema;
    this.schema = schema3;
    this.tableNamesMap = tableNamesMap;
    this.table = table16;
    this.tableConfig = tableConfig;
    this.dialect = dialect2;
    this.session = session;
    this.config = config;
    this.mode = mode;
  }
  static [entityKind] = "PgRelationalQuery";
  _prepare(name) {
    return tracer.startActiveSpan("drizzle.prepareQuery", () => {
      const { query: query4, builtQuery } = this._toSQL();
      return this.session.prepareQuery(builtQuery, undefined, name, (rawRows, mapColumnValue) => {
        const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query4.selection, mapColumnValue));
        if (this.mode === "first") {
          return rows[0];
        }
        return rows;
      });
    });
  }
  prepare(name) {
    return this._prepare(name);
  }
  _getQuery() {
    return this.dialect.buildRelationalQueryWithoutPK({
      fullSchema: this.fullSchema,
      schema: this.schema,
      tableNamesMap: this.tableNamesMap,
      table: this.table,
      tableConfig: this.tableConfig,
      queryConfig: this.config,
      tableAlias: this.tableConfig.tsName
    });
  }
  getSQL() {
    return this._getQuery().sql;
  }
  _toSQL() {
    const query4 = this._getQuery();
    const builtQuery = this.dialect.sqlToQuery(query4.sql);
    return { query: query4, builtQuery };
  }
  toSQL() {
    return this._toSQL().builtQuery;
  }
  execute() {
    return tracer.startActiveSpan("drizzle.operation", () => {
      return this._prepare().execute();
    });
  }
}

// node_modules/drizzle-orm/pg-core/query-builders/raw.js
class PgRaw extends QueryPromise {
  constructor(execute, sql14, query4, mapBatchResult) {
    super();
    this.execute = execute;
    this.sql = sql14;
    this.query = query4;
    this.mapBatchResult = mapBatchResult;
  }
  static [entityKind] = "PgRaw";
  getSQL() {
    return this.sql;
  }
  getQuery() {
    return this.query;
  }
  mapResult(result2, isFromBatch) {
    return isFromBatch ? this.mapBatchResult(result2) : result2;
  }
  _prepare() {
    return this;
  }
}

// node_modules/drizzle-orm/pg-core/db.js
class PgDatabase {
  constructor(dialect2, session, schema3) {
    this.dialect = dialect2;
    this.session = session;
    this._ = schema3 ? { schema: schema3.schema, tableNamesMap: schema3.tableNamesMap } : { schema: undefined, tableNamesMap: {} };
    this.query = {};
    if (this._.schema) {
      for (const [tableName, columns2] of Object.entries(this._.schema)) {
        this.query[tableName] = new RelationalQueryBuilder(schema3.fullSchema, this._.schema, this._.tableNamesMap, schema3.fullSchema[tableName], columns2, dialect2, session);
      }
    }
  }
  static [entityKind] = "PgDatabase";
  query;
  $with(alias3) {
    return {
      as(qb) {
        if (typeof qb === "function") {
          qb = qb(new QueryBuilder);
        }
        return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias3, true), new SelectionProxyHandler({ alias: alias3, sqlAliasedBehavior: "alias", sqlBehavior: "error" }));
      }
    };
  }
  with(...queries) {
    const self2 = this;
    function select3(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries
      });
    }
    function selectDistinct(fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: true
      });
    }
    function selectDistinctOn(on, fields) {
      return new PgSelectBuilder({
        fields: fields ?? undefined,
        session: self2.session,
        dialect: self2.dialect,
        withList: queries,
        distinct: { on }
      });
    }
    function update(table16) {
      return new PgUpdateBuilder(table16, self2.session, self2.dialect, queries);
    }
    function insert(table16) {
      return new PgInsertBuilder(table16, self2.session, self2.dialect, queries);
    }
    function delete_(table16) {
      return new PgDeleteBase(table16, self2.session, self2.dialect, queries);
    }
    return { select: select3, selectDistinct, selectDistinctOn, update, insert, delete: delete_ };
  }
  select(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect
    });
  }
  selectDistinct(fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: true
    });
  }
  selectDistinctOn(on, fields) {
    return new PgSelectBuilder({
      fields: fields ?? undefined,
      session: this.session,
      dialect: this.dialect,
      distinct: { on }
    });
  }
  update(table16) {
    return new PgUpdateBuilder(table16, this.session, this.dialect);
  }
  insert(table16) {
    return new PgInsertBuilder(table16, this.session, this.dialect);
  }
  delete(table16) {
    return new PgDeleteBase(table16, this.session, this.dialect);
  }
  refreshMaterializedView(view) {
    return new PgRefreshMaterializedView(view, this.session, this.dialect);
  }
  execute(query5) {
    const sql14 = query5.getSQL();
    const builtQuery = this.dialect.sqlToQuery(sql14);
    const prepared = this.session.prepareQuery(builtQuery, undefined, undefined);
    return new PgRaw(() => prepared.execute(), sql14, builtQuery, (result2) => prepared.mapResult(result2, false));
  }
  transaction(transaction, config) {
    return this.session.transaction(transaction, config);
  }
}

// node_modules/drizzle-orm/pg-core/session.js
class PgPreparedQuery {
  constructor(query5) {
    this.query = query5;
  }
  getQuery() {
    return this.query;
  }
  mapResult(response, _isFromBatch) {
    return response;
  }
  static [entityKind] = "PgPreparedQuery";
  joinsNotNullableMap;
}

class PgSession {
  constructor(dialect2) {
    this.dialect = dialect2;
  }
  static [entityKind] = "PgSession";
  execute(query5) {
    return tracer.startActiveSpan("drizzle.operation", () => {
      const prepared = tracer.startActiveSpan("drizzle.prepareQuery", () => {
        return this.prepareQuery(this.dialect.sqlToQuery(query5), undefined, undefined);
      });
      return prepared.execute();
    });
  }
  all(query5) {
    return this.prepareQuery(this.dialect.sqlToQuery(query5), undefined, undefined).all();
  }
}

class PgTransaction extends PgDatabase {
  constructor(dialect2, session, schema3, nestedIndex = 0) {
    super(dialect2, session, schema3);
    this.schema = schema3;
    this.nestedIndex = nestedIndex;
  }
  static [entityKind] = "PgTransaction";
  rollback() {
    throw new TransactionRollbackError;
  }
  getTransactionConfigSQL(config) {
    const chunks = [];
    if (config.isolationLevel) {
      chunks.push(`isolation level ${config.isolationLevel}`);
    }
    if (config.accessMode) {
      chunks.push(config.accessMode);
    }
    if (typeof config.deferrable === "boolean") {
      chunks.push(config.deferrable ? "deferrable" : "not deferrable");
    }
    return sql.raw(chunks.join(" "));
  }
  setTransaction(config) {
    return this.session.execute(sql`set transaction ${this.getTransactionConfigSQL(config)}`);
  }
}

// src/db/schema/order-items.ts
var orderItems = pgTable("orderItems", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  orderId: text("order_id").notNull().references(() => orders2.id, {
    onDelete: "cascade"
  }),
  productId: text("product_id").references(() => products2.id, {
    onDelete: "set null"
  }),
  priceInCents: integer4("price_in_centes").notNull(),
  quantity: integer4("quantity").default(1).notNull()
});
var orderItemsRelations = relations(orderItems, ({ one }) => {
  return {
    order: one(orders2, {
      fields: [orderItems.orderId],
      references: [orders2.id],
      relationName: "order_item_order"
    }),
    product: one(products2, {
      fields: [orderItems.productId],
      references: [products2.id],
      relationName: "order_item_product"
    })
  };
});

// src/db/schema/products.ts
var products2 = pgTable("products", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description").notNull(),
  priceInCents: integer4("price_in_cents").notNull(),
  restaurantId: text("restaurant_id").notNull().references(() => restaurants2.id, {
    onDelete: "cascade"
  }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var productsRelations = relations(products2, ({ one, many }) => {
  return {
    restaurant: one(restaurants2, {
      fields: [products2.restaurantId],
      references: [restaurants2.id],
      relationName: "products_restaurant"
    }),
    orderItems: many(orderItems)
  };
});

// src/db/schema/restaurants.ts
var restaurants2 = pgTable("restaurants", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  managerId: text("manager_id").references(() => users2.id, {
    onDelete: "set null"
  }),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var restaurantsRelations = relations(restaurants2, ({ one, many }) => {
  return {
    manager: one(users2, {
      fields: [restaurants2.managerId],
      references: [users2.id],
      relationName: "restaurant_manager"
    }),
    orders: many(orders2),
    products: many(products2)
  };
});

// src/db/schema/orders.ts
var orderIstatusEnun = pgEnum("order_status", [
  "pending",
  "processing",
  "delivering",
  "delivered",
  "canceled"
]);
var orders2 = pgTable("orders", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  customerId: text("customer_id").references(() => users2.id, {
    onDelete: "set null"
  }),
  restaurantId: text("restaurant_id").notNull().references(() => restaurants2.id, {
    onDelete: "cascade"
  }),
  status: orderIstatusEnun("status").default("pending").notNull(),
  totalInCents: integer4("total_in_cents").notNull(),
  comments: text("comments"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var ordersRelations = relations(orders2, ({ one, many }) => {
  return {
    restaurant: one(restaurants2, {
      fields: [orders2.restaurantId],
      references: [restaurants2.id],
      relationName: "restaurantId"
    }),
    customer: one(users2, {
      fields: [orders2.customerId],
      references: [users2.id],
      relationName: "order_customer"
    }),
    orderItems: many(orderItems)
  };
});

// src/db/schema/users.ts
var userRoleEnum = pgEnum("user_role", ["manager", "customer"]);
var users2 = pgTable("users", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  name: text("name").notNull(),
  email: text("email").notNull().unique(),
  phone: text("phone"),
  role: userRoleEnum("role").default("customer").notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow()
});
var usersRelations = relations(users2, ({ one, many }) => {
  return {
    managedRestaurant: one(restaurants2, {
      fields: [users2.id],
      references: [restaurants2.managerId],
      relationName: "managed_restaurant"
    }),
    orders: many(orders2)
  };
});
// src/db/schema/auth-code.ts
var authCodes = pgTable("auth_codes", {
  id: text("id").$defaultFn(() => $createId()).primaryKey(),
  code: text("code").notNull().unique(),
  userId: text("user_id").references(() => users2.id, {
    onDelete: "cascade"
  }).notNull(),
  createdAt: timestamp("created_at").notNull().defaultNow()
});
// node_modules/drizzle-orm/postgres-js/session.js
class PostgresJsPreparedQuery extends PgPreparedQuery {
  constructor(client, queryString, params, logger2, fields, customResultMapper) {
    super({ sql: queryString, params });
    this.client = client;
    this.queryString = queryString;
    this.params = params;
    this.logger = logger2;
    this.fields = fields;
    this.customResultMapper = customResultMapper;
  }
  static [entityKind] = "PostgresJsPreparedQuery";
  async execute(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      const { fields, queryString: query5, client, joinsNotNullableMap, customResultMapper } = this;
      if (!fields && !customResultMapper) {
        return tracer.startActiveSpan("drizzle.driver.execute", () => {
          return client.unsafe(query5, params);
        });
      }
      const rows = await tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": query5,
          "drizzle.query.params": JSON.stringify(params)
        });
        return client.unsafe(query5, params).values();
      });
      return tracer.startActiveSpan("drizzle.mapResponse", () => {
        return customResultMapper ? customResultMapper(rows) : rows.map((row) => mapResultRow(fields, row, joinsNotNullableMap));
      });
    });
  }
  all(placeholderValues = {}) {
    return tracer.startActiveSpan("drizzle.execute", async (span) => {
      const params = fillPlaceholders(this.params, placeholderValues);
      span?.setAttributes({
        "drizzle.query.text": this.queryString,
        "drizzle.query.params": JSON.stringify(params)
      });
      this.logger.logQuery(this.queryString, params);
      return tracer.startActiveSpan("drizzle.driver.execute", () => {
        span?.setAttributes({
          "drizzle.query.text": this.queryString,
          "drizzle.query.params": JSON.stringify(params)
        });
        return this.client.unsafe(this.queryString, params);
      });
    });
  }
}

class PostgresJsSession extends PgSession {
  constructor(client, dialect2, schema3, options = {}) {
    super(dialect2);
    this.client = client;
    this.schema = schema3;
    this.options = options;
    this.logger = options.logger ?? new NoopLogger;
  }
  static [entityKind] = "PostgresJsSession";
  logger;
  prepareQuery(query5, fields, name, customResultMapper) {
    return new PostgresJsPreparedQuery(this.client, query5.sql, query5.params, this.logger, fields, customResultMapper);
  }
  query(query5, params) {
    this.logger.logQuery(query5, params);
    return this.client.unsafe(query5, params).values();
  }
  queryObjects(query5, params) {
    return this.client.unsafe(query5, params);
  }
  transaction(transaction, config) {
    return this.client.begin(async (client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      if (config) {
        await tx.setTransaction(config);
      }
      return transaction(tx);
    });
  }
}

class PostgresJsTransaction extends PgTransaction {
  constructor(dialect2, session2, schema3, nestedIndex = 0) {
    super(dialect2, session2, schema3, nestedIndex);
    this.session = session2;
  }
  static [entityKind] = "PostgresJsTransaction";
  transaction(transaction) {
    return this.session.client.savepoint((client) => {
      const session2 = new PostgresJsSession(client, this.dialect, this.schema, this.session.options);
      const tx = new PostgresJsTransaction(this.dialect, session2, this.schema);
      return transaction(tx);
    });
  }
}

// node_modules/drizzle-orm/postgres-js/driver.js
var drizzle = function(client, config = {}) {
  const transparentParser = (val) => val;
  for (const type75 of ["1184", "1082", "1083", "1114"]) {
    client.options.parsers[type75] = transparentParser;
    client.options.serializers[type75] = transparentParser;
  }
  const dialect3 = new PgDialect;
  let logger3;
  if (config.logger === true) {
    logger3 = new DefaultLogger;
  } else if (config.logger !== false) {
    logger3 = config.logger;
  }
  let schema3;
  if (config.schema) {
    const tablesConfig = extractTablesRelationalConfig(config.schema, createTableRelationsHelpers);
    schema3 = {
      fullSchema: config.schema,
      schema: tablesConfig.tables,
      tableNamesMap: tablesConfig.tableNamesMap
    };
  }
  const session3 = new PostgresJsSession(client, dialect3, schema3, { logger: logger3 });
  return new PgDatabase(dialect3, session3, schema3);
};

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map3) {
  overrideErrorMap = map3;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema3) {
  if (schema3 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema3.shape) {
      const fieldSchema = schema3.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema3._def,
      shape: () => newShape
    });
  } else if (schema3 instanceof ZodArray) {
    return new ZodArray({
      ...schema3._def,
      type: deepPartialify(schema3.element)
    });
  } else if (schema3 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema3.unwrap()));
  } else if (schema3 instanceof ZodTuple) {
    return ZodTuple.create(schema3.items.map((item) => deepPartialify(item)));
  } else {
    return schema3;
  }
};
var mergeValues = function(a2, b3) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b3);
  if (a2 === b3) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b3);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b3[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b3.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b3) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values2, params) {
  return new ZodEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object13) => {
    const keys = [];
    for (const key in object13) {
      if (Object.prototype.hasOwnProperty.call(object13, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array6, separator = " | ") {
    return array6.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value15) => {
    if (typeof value15 === "bigint") {
      return value15.toString();
    }
    return value15;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error22) => {
      for (const issue of error22.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error22 = new ZodError(issues);
  return error22;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map3 of maps) {
    errorMessage = map3(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value: value15 } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value15.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value15.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value15.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value15.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value15) => ({ status: "dirty", value: value15 });
var OK = (value15) => ({ status: "valid", value: value15 });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value15, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value15;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result2) => {
  if (isValid(result2)) {
    return { success: true, data: result2.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error22 = new ZodError(ctx.common.issues);
        this._error = error22;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result2 = this._parse(input);
    if (isAsync(result2)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result2;
  }
  _parseAsync(input) {
    const result2 = this._parse(input);
    return Promise.resolve(result2);
  }
  parse(data, params) {
    const result2 = this.safeParse(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result2);
  }
  async parseAsync(data, params) {
    const result2 = await this.safeParseAsync(data, params);
    if (result2.success)
      return result2.data;
    throw result2.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result2 = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result2);
  }
  refine(check11, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result2 = check11(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result2 instanceof Promise) {
        return result2.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result2) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check11, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check11(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform7) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform7 }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.length < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.length > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "length") {
        const tooBig = input.data.length > check11.value;
        const tooSmall = input.data.length < check11.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check11.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check11.message
            });
          }
          status.dirty();
        }
      } else if (check11.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "regex") {
        check11.regex.lastIndex = 0;
        const testResult = check11.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "trim") {
        input.data = input.data.trim();
      } else if (check11.kind === "includes") {
        if (!input.data.includes(check11.value, check11.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check11.value, position: check11.position },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check11.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check11.kind === "startsWith") {
        if (!input.data.startsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "endsWith") {
        if (!input.data.endsWith(check11.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check11.value },
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "datetime") {
        const regex = datetimeRegex(check11);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "ip") {
        if (!isValidIP(input.data, check11.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check11) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value15, options) {
    return this._addCheck({
      kind: "includes",
      value: value15,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value15, message) {
    return this._addCheck({
      kind: "startsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value15, message) {
    return this._addCheck({
      kind: "endsWith",
      value: value15,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check11.value,
            type: "number",
            inclusive: check11.inclusive,
            exact: false,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check11.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind, value15, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        const tooSmall = check11.inclusive ? input.data < check11.value : input.data <= check11.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        const tooBig = check11.inclusive ? input.data > check11.value : input.data >= check11.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check11.value,
            inclusive: check11.inclusive,
            message: check11.message
          });
          status.dirty();
        }
      } else if (check11.kind === "multipleOf") {
        if (input.data % check11.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check11.value,
            message: check11.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value15, message) {
    return this.setLimit("min", value15, true, errorUtil.toString(message));
  }
  gt(value15, message) {
    return this.setLimit("min", value15, false, errorUtil.toString(message));
  }
  lte(value15, message) {
    return this.setLimit("max", value15, true, errorUtil.toString(message));
  }
  lt(value15, message) {
    return this.setLimit("max", value15, false, errorUtil.toString(message));
  }
  setLimit(kind, value15, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value: value15,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check11) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value15, message) {
    return this._addCheck({
      kind: "multipleOf",
      value: value15,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check11 of this._def.checks) {
      if (check11.kind === "min") {
        if (input.data.getTime() < check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check11.message,
            inclusive: true,
            exact: false,
            minimum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check11.kind === "max") {
        if (input.data.getTime() > check11.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check11.message,
            inclusive: true,
            exact: false,
            maximum: check11.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check11);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check11) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check11]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result3) => {
        return ParseStatus.mergeArray(status, result3);
      });
    }
    const result2 = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result2);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema3, params) => {
  return new ZodArray({
    type: schema3,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value15 = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value15 = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value15, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema3) {
    return this.augment({ [key]: schema3 });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result2 of results) {
        if (result2.result.status === "valid") {
          return result2.result;
        }
      }
      for (const result2 of results) {
        if (result2.result.status === "dirty") {
          ctx.common.issues.push(...result2.ctx.common.issues);
          return result2.result;
        }
      }
      const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result2 = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result2.status === "valid") {
          return result2;
        } else if (result2.status === "dirty" && !dirty) {
          dirty = { result: result2, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types4, params) => {
  return new ZodUnion({
    options: types4,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type75) => {
  if (type75 instanceof ZodLazy) {
    return getDiscriminator(type75.schema);
  } else if (type75 instanceof ZodEffects) {
    return getDiscriminator(type75.innerType());
  } else if (type75 instanceof ZodLiteral) {
    return [type75.value];
  } else if (type75 instanceof ZodEnum) {
    return type75.options;
  } else if (type75 instanceof ZodNativeEnum) {
    return Object.keys(type75.enum);
  } else if (type75 instanceof ZodDefault) {
    return getDiscriminator(type75._def.innerType);
  } else if (type75 instanceof ZodUndefined) {
    return [undefined];
  } else if (type75 instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type75 of options) {
      const discriminatorValues = getDiscriminator(type75.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value15 of discriminatorValues) {
        if (optionsMap.has(value15)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value15)}`);
        }
        optionsMap.set(value15, type75);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest4 = this._def.rest;
    if (!rest4 && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema3 = this._def.items[itemIndex] || this._def.rest;
      if (!schema3)
        return null;
      return schema3._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest4) {
    return new ZodTuple({
      ...this._def,
      rest: rest4
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value15], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value15, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value15 = await pair.value;
          if (key.status === "aborted" || value15.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value15.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value15.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value15 = pair.value;
        if (key.status === "aborted" || value15.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value15.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value15.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error22) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error22
        }
      });
    }
    function makeReturnsIssue(returns, error22) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error22
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error22 = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e2) => {
          error22.addIssue(makeArgsIssue(args, e2));
          throw error22;
        });
        const result2 = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params).catch((e2) => {
          error22.addIssue(makeReturnsIssue(result2, e2));
          throw error22;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result2 = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result2, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value15, params) => {
  return new ZodLiteral({
    value: value15,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values2) {
    return ZodEnum.create(values2);
  }
  exclude(values2) {
    return ZodEnum.create(this.options.filter((opt) => !values2.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values2, params) => {
  return new ZodNativeEnum({
    values: values2,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema3, params) => {
  return new ZodPromise({
    type: schema3,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result2 = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result2);
        }
        if (result2 instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result2 = effect.transform(base.value, checkCtx);
        if (result2 instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result2 };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema3, effect, params) => {
  return new ZodEffects({
    schema: schema3,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema3, params) => {
  return new ZodEffects({
    schema: schema3,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type75, params) => {
  return new ZodOptional({
    innerType: type75,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type75, params) => {
  return new ZodNullable({
    innerType: type75,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type75, params) => {
  return new ZodDefault({
    innerType: type75,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result2 = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result2)) {
      return result2.then((result3) => {
        return {
          status: "valid",
          value: result3.status === "valid" ? result3.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result2.status === "valid" ? result2.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type75, params) => {
  return new ZodCatch({
    innerType: type75,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b3) {
    return new ZodPipeline({
      in: a2,
      out: b3,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result2 = this._def.innerType._parse(input);
    if (isValid(result2)) {
      result2.value = Object.freeze(result2.value);
    }
    return result2;
  }
}
ZodReadonly.create = (type75, params) => {
  return new ZodReadonly({
    innerType: type75,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check11, params = {}, fatal) => {
  if (check11)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check11(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/env.ts
var envSchema = z.object({
  DATABASE_URL: z.string().url(),
  API_BASE_URL: z.string().url().default("http://localhost:3333"),
  AUTH_REDIRECT_URL: z.string().url(),
  EMAIL_HOST: z.string(),
  EMAIL_PORT: z.coerce.number(),
  EMAIL_USER: z.string(),
  EMAIL_PASS: z.string(),
  JWT_SECRET_KEY: z.string(),
  REDIS_HOST: z.string(),
  REDIS_PORT: z.coerce.number()
});
var env = envSchema.parse(process.env);

// src/db/connection.ts
var connection3 = src_default(env.DATABASE_URL);
var db3 = drizzle(connection3, { schema: exports_schema });

// src/repositories/drizzle/drizzle-restaurants-repository.ts
class DrizzleRestaurantRepository {
  async create({ name, description, managerId }) {
    const [restaurant] = await db3.insert(restaurants2).values({
      name,
      description,
      managerId
    }).returning();
    return restaurant;
  }
  async findById(id) {
    const restaurant = await db3.query.restaurants.findFirst({
      where(filds, { eq: eq2 }) {
        return eq2(filds.id, id);
      }
    });
    return restaurant || null;
  }
  async findByManagerId(id) {
    const restaurant = await db3.query.restaurants.findFirst({
      where(filds, { eq: eq2 }) {
        return eq2(filds.managerId, id);
      }
    });
    return restaurant || null;
  }
}

// src/repositories/drizzle/drizzle-users-repository.ts
class DrizzleUsersRepository {
  async create({ email, phone, name, role }) {
    const [user] = await db3.insert(users2).values({
      email,
      phone,
      name,
      role
    }).returning();
    return user;
  }
  async findByEmail(email) {
    const user = await db3.query.users.findFirst({
      where(filds, { eq: eq2 }) {
        return eq2(filds.email, email);
      }
    });
    return user || null;
  }
  async findById(id) {
    const user = await db3.query.users.findFirst({
      where(filds, { eq: eq2 }) {
        return eq2(filds.id, id);
      }
    });
    return user || null;
  }
}

// src/use-cases/errors/user-already-exists-error.ts
class UserAlreadyExistsError extends Error {
  constructor() {
    super("E-mail already exists.");
  }
}

// src/use-cases/create-restaurant.ts
class CreateRestaurantUseCase {
  restaurantRepository;
  userRepository;
  constructor(restaurantRepository, userRepository) {
    this.restaurantRepository = restaurantRepository;
    this.userRepository = userRepository;
  }
  async execute({
    managerName,
    managerEmail,
    managerPhone,
    restaurantName,
    restaurantDescription
  }) {
    const userWithSameEmail = await this.userRepository.findByEmail(managerEmail);
    if (userWithSameEmail) {
      throw new UserAlreadyExistsError;
    }
    const manager = await this.userRepository.create({
      name: managerName,
      email: managerEmail,
      role: "manager",
      phone: managerPhone
    });
    const restaurant = await this.restaurantRepository.create({
      name: restaurantName,
      description: restaurantDescription,
      managerId: manager.id
    });
    return {
      restaurant
    };
  }
}

// src/use-cases/factories/make-create-restaurant.ts
function makeCreateRestaurant() {
  const userRepository = new DrizzleUsersRepository;
  const restaurantRepository = new DrizzleRestaurantRepository;
  const useCase = new CreateRestaurantUseCase(restaurantRepository, userRepository);
  return useCase;
}

// src/http/routes/register-restaurants.ts
var registerRestaurants = new r().post("/restaurants", async ({ body, set: set2 }) => {
  const { restaurantName, managerName, email, description, phone } = body;
  try {
    const createRestaurantUseCase = makeCreateRestaurant();
    await createRestaurantUseCase.execute({
      restaurantName,
      managerName,
      managerEmail: email,
      restaurantDescription: description,
      managerPhone: phone
    });
    set2.status = 204;
  } catch (error22) {
    if (error22 instanceof UserAlreadyExistsError) {
      set2.status = 409;
      return {
        message: error22.message
      };
    }
    throw error22;
  }
}, {
  body: C.Object({
    restaurantName: C.String(),
    managerName: C.String(),
    email: C.String({ format: "email" }),
    description: C.Optional(C.String()),
    phone: C.String()
  })
});

// src/lib/queue.ts
var import_bull = __toESM(require_bull(), 1);

// src/jobs/index.ts
var exports_jobs = {};
__export(exports_jobs, {
  registrationMail: () => {
    {
      return registrationMail_default;
    }
  }
});

// src/lib/mail.ts
var import_nodemailer = __toESM(require_nodemailer(), 1);
var mail = import_nodemailer.default.createTransport({
  host: env.EMAIL_HOST,
  port: env.EMAIL_PORT,
  auth: {
    user: env.EMAIL_USER,
    pass: env.EMAIL_PASS
  }
});

// src/jobs/registrationMail.ts
var registrationMail_default = {
  key: "registrationMail",
  options: {},
  async handle({ data }) {
    mail.sendMail({
      from: {
        name: "Pizza Shop",
        address: "hi@pizzashop.com"
      },
      to: data.email,
      subject: "Authenticate to Pizza Shop",
      text: `Use the following to authenticate on Pizza Shop: ${data.authLink.toString()}`,
      html: `<p>Use the following to authenticate on Pizza Shop: <a href="${data.authLink.toString()}" target="_blank">LINK</a></p>`
    });
  }
};
// src/lib/queue.ts
var queues = Object.values(exports_jobs).map((job) => ({
  bull: new import_bull.default(job.key, {
    redis: { host: env.REDIS_HOST, port: env.REDIS_PORT }
  }),
  name: job.key,
  handle: job.handle
}));
var queue_default2 = {
  queues,
  add(name, data) {
    const queue3 = this.queues.find((queue4) => queue4.name === name);
    return queue3?.bull.add(data);
  },
  process() {
    return this.queues.forEach((queue3) => {
      queue3.bull.process(queue3.handle);
      queue3.bull.on("failed", (job, err) => {
        console.log("Job failed", queue3.name, job.data);
        console.log(err);
      });
    });
  }
};

// src/repositories/drizzle/drizzle-auth-codes-repository.ts
class DrizzleAuthCodesRepository {
  async create({ code, userId }) {
    const [authLink] = await db3.insert(authCodes).values({
      code,
      userId
    }).returning();
    return authLink;
  }
  async findByCode(code) {
    const authLink = await db3.query.authCodes.findFirst({
      where: (authLink2, { eq: eq2 }) => eq2(authLink2.code, code)
    });
    return authLink || null;
  }
  async deleteById(id) {
    await db3.delete(authCodes).where(eq(authCodes.id, id));
  }
}

// src/use-cases/errors/resource-not-found-error.ts
class ResourceNotFoundError extends Error {
  constructor() {
    super("Resource not found.");
  }
}

// src/use-cases/create-authenticate-code.ts
class CreateAuthenticateCodeUseCase {
  usersRepository;
  authCodesRepository;
  constructor(usersRepository, authCodesRepository) {
    this.usersRepository = usersRepository;
    this.authCodesRepository = authCodesRepository;
  }
  async execute({
    userEmail
  }) {
    const user = await this.usersRepository.findByEmail(userEmail);
    if (!user) {
      throw new ResourceNotFoundError;
    }
    const code = $createId();
    await this.authCodesRepository.create({
      userId: user.id,
      code
    });
    return {
      code
    };
  }
}

// src/use-cases/factories/make-create-authenticate-code.ts
function makeCreateAuthenticateCode() {
  const usersRepository = new DrizzleUsersRepository;
  const authLinksRepository = new DrizzleAuthCodesRepository;
  const useCase = new CreateAuthenticateCodeUseCase(usersRepository, authLinksRepository);
  return useCase;
}

// src/http/routes/send-auth-link.ts
var sendAuthLink = new r().post("/authenticate", async ({ body, set: set2 }) => {
  const { email } = body;
  const createAuthLinksUseCase = makeCreateAuthenticateCode();
  const { code } = await createAuthLinksUseCase.execute({ userEmail: email });
  const authLink = new URL("/auth-links/authenticate", env.API_BASE_URL);
  authLink.searchParams.set("code", code);
  authLink.searchParams.set("redirect", env.AUTH_REDIRECT_URL);
  queue_default2.add("registrationMail", { authLink, email });
  set2.status = 204;
}, {
  body: C.Object({
    email: C.String({ format: "email" })
  })
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default = crypto;
var isCryptoKey = (key) => key instanceof CryptoKey;

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i = 0;
  buffers.forEach((buffer2) => {
    buf.set(buffer2, i);
    i += buffer2.length;
  });
  return buf;
}
var encoder = new TextEncoder;
var decoder = new TextDecoder;
var MAX_INT32 = 2 ** 32;

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64 = (input) => {
  let unencoded = input;
  if (typeof unencoded === "string") {
    unencoded = encoder.encode(unencoded);
  }
  const CHUNK_SIZE = 32768;
  const arr = [];
  for (let i = 0;i < unencoded.length; i += CHUNK_SIZE) {
    arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
  }
  return btoa(arr.join(""));
};
var encode2 = (input) => {
  return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
var decodeBase64 = (encoded) => {
  const binary = atob(encoded);
  const bytes2 = new Uint8Array(binary.length);
  for (let i = 0;i < binary.length; i++) {
    bytes2[i] = binary.charCodeAt(i);
  }
  return bytes2;
};
var decode2 = (input) => {
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return decodeBase64(encoded);
  } catch (_a) {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};

// node_modules/jose/dist/browser/util/errors.js
class JOSEError extends Error {
  static get code() {
    return "ERR_JOSE_GENERIC";
  }
  constructor(message) {
    var _a;
    super(message);
    this.code = "ERR_JOSE_GENERIC";
    this.name = this.constructor.name;
    (_a = Error.captureStackTrace) === null || _a === undefined || _a.call(Error, this, this.constructor);
  }
}

class JWTClaimValidationFailed extends JOSEError {
  static get code() {
    return "ERR_JWT_CLAIM_VALIDATION_FAILED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JWTExpired extends JOSEError {
  static get code() {
    return "ERR_JWT_EXPIRED";
  }
  constructor(message, claim = "unspecified", reason = "unspecified") {
    super(message);
    this.code = "ERR_JWT_EXPIRED";
    this.claim = claim;
    this.reason = reason;
  }
}

class JOSEAlgNotAllowed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
  static get code() {
    return "ERR_JOSE_ALG_NOT_ALLOWED";
  }
}

class JOSENotSupported extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
  static get code() {
    return "ERR_JOSE_NOT_SUPPORTED";
  }
}
class JWSInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_INVALID";
  }
  static get code() {
    return "ERR_JWS_INVALID";
  }
}

class JWTInvalid extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWT_INVALID";
  }
  static get code() {
    return "ERR_JWT_INVALID";
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  constructor() {
    super(...arguments);
    this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
    this.message = "signature verification failed";
  }
  static get code() {
    return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
}

// node_modules/jose/dist/browser/lib/crypto_key.js
var unusable = function(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
};
var isAlgorithm = function(algorithm, name) {
  return algorithm.name === name;
};
var getHashLength = function(hash7) {
  return parseInt(hash7.name.slice(4), 10);
};
var getNamedCurve = function(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
};
var checkUsage = function(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
};
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}

// node_modules/jose/dist/browser/lib/invalid_key_input.js
var message = function(msg, actual, ...types4) {
  if (types4.length > 2) {
    const last = types4.pop();
    msg += `one of type ${types4.join(", ")}, or ${last}.`;
  } else if (types4.length === 2) {
    msg += `one of type ${types4[0]} or ${types4[1]}.`;
  } else {
    msg += `of type ${types4[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
};
function withAlg(alg, actual, ...types4) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types4);
}
var invalid_key_input_default = (actual, ...types4) => {
  return message("Key must be ", actual, ...types4);
};

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default = (key) => {
  return isCryptoKey(key);
};
var types4 = ["CryptoKey"];

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint = (...headers) => {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters4 = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters4);
      continue;
    }
    for (const parameter of parameters4) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
};
var is_disjoint_default = isDisjoint;

// node_modules/jose/dist/browser/lib/is_object.js
var isObjectLike = function(value15) {
  return typeof value15 === "object" && value15 !== null;
};
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default = (alg, key) => {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
};

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck = (alg, key) => {
  if (key instanceof Uint8Array)
    return;
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types4, "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${types4.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
  }
};
var asymmetricTypeCheck = (alg, key, usage) => {
  if (!is_key_like_default(key)) {
    throw new TypeError(withAlg(alg, key, ...types4));
  }
  if (key.type === "secret") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (usage === "sign" && key.type === "public") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
  }
  if (usage === "decrypt" && key.type === "public") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
  }
  if (key.algorithm && usage === "verify" && key.type === "private") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
  }
  if (key.algorithm && usage === "encrypt" && key.type === "private") {
    throw new TypeError(`${types4.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
  }
};
var checkKeyType = (alg, key, usage) => {
  const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
  if (symmetric) {
    symmetricTypeCheck(alg, key);
  } else {
    asymmetricTypeCheck(alg, key, usage);
  }
};
var check_key_type_default = checkKeyType;

// node_modules/jose/dist/browser/lib/validate_crit.js
var validateCrit = function(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== undefined && protectedHeader.crit === undefined) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === undefined) {
    return new Set;
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== undefined) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === undefined) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
};
var validate_crit_default = validateCrit;

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms = (option, algorithms) => {
  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some((s2) => typeof s2 !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return;
  }
  return new Set(algorithms);
};
var validate_algorithms_default = validateAlgorithms;

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash7 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash7, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash7, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash7, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash7, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types4));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types4, "Uint8Array"));
}

// node_modules/jose/dist/browser/runtime/verify.js
var verify = async (alg, key, signature, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "verify");
  check_key_length_default(alg, cryptoKey);
  const algorithm = subtleDsa(alg, cryptoKey.algorithm);
  try {
    return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch (_a) {
    return false;
  }
};
var verify_default = verify;

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === undefined && jws.header === undefined) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== undefined && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === undefined) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== undefined && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode2(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== undefined ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode2(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed;
  }
  let payload;
  if (b64) {
    try {
      payload = decode2(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result2 = { payload };
  if (jws.protected !== undefined) {
    result2.protectedHeader = parsedProt;
  }
  if (jws.header !== undefined) {
    result2.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result2, key };
  }
  return result2;
}

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result2 = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default = (date5) => Math.floor(date5.getTime() / 1000);

// node_modules/jose/dist/browser/lib/secs.js
var minute = 60;
var hour = minute * 60;
var day = hour * 24;
var week = day * 7;
var year = day * 365.25;
var REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
var secs_default = (str) => {
  const matched = REGEX.exec(str);
  if (!matched) {
    throw new TypeError("Invalid time period format");
  }
  const value15 = parseFloat(matched[1]);
  const unit = matched[2].toLowerCase();
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      return Math.round(value15);
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      return Math.round(value15 * minute);
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      return Math.round(value15 * hour);
    case "day":
    case "days":
    case "d":
      return Math.round(value15 * day);
    case "week":
    case "weeks":
    case "w":
      return Math.round(value15 * week);
    default:
      return Math.round(value15 * year);
  }
};

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp = (value15) => value15.toLowerCase().replace(/^application\//, "");
var checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
var jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
  }
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch (_a) {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  if (maxTokenAge !== undefined)
    requiredClaims.push("iat");
  if (audience !== undefined)
    requiredClaims.push("aud");
  if (subject !== undefined)
    requiredClaims.push("sub");
  if (issuer !== undefined)
    requiredClaims.push("iss");
  for (const claim of new Set(requiredClaims.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs_default(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch_default(currentDate || new Date);
  if ((payload.iat !== undefined || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
  }
  if (payload.nbf !== undefined) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
    }
  }
  if (payload.exp !== undefined) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
    }
  }
  return payload;
};

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === undefined ? undefined : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result2 = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result2, key: verified.key };
  }
  return result2;
}
// node_modules/jose/dist/browser/runtime/sign.js
var sign = async (alg, key, data) => {
  const cryptoKey = await getCryptoKey(alg, key, "sign");
  check_key_length_default(alg, cryptoKey);
  const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
  return new Uint8Array(signature);
};
var sign_default = sign;

// node_modules/jose/dist/browser/jws/flattened/sign.js
class FlattenedSign {
  constructor(payload) {
    if (!(payload instanceof Uint8Array)) {
      throw new TypeError("payload must be an instance of Uint8Array");
    }
    this._payload = payload;
  }
  setProtectedHeader(protectedHeader) {
    if (this._protectedHeader) {
      throw new TypeError("setProtectedHeader can only be called once");
    }
    this._protectedHeader = protectedHeader;
    return this;
  }
  setUnprotectedHeader(unprotectedHeader) {
    if (this._unprotectedHeader) {
      throw new TypeError("setUnprotectedHeader can only be called once");
    }
    this._unprotectedHeader = unprotectedHeader;
    return this;
  }
  async sign(key, options) {
    if (!this._protectedHeader && !this._unprotectedHeader) {
      throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
    }
    if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
      throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
    }
    const joseHeader = {
      ...this._protectedHeader,
      ...this._unprotectedHeader
    };
    const extensions = validate_crit_default(JWSInvalid, new Map([["b64", true]]), options === null || options === undefined ? undefined : options.crit, this._protectedHeader, joseHeader);
    let b64 = true;
    if (extensions.has("b64")) {
      b64 = this._protectedHeader.b64;
      if (typeof b64 !== "boolean") {
        throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
      }
    }
    const { alg } = joseHeader;
    if (typeof alg !== "string" || !alg) {
      throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
    }
    check_key_type_default(alg, key, "sign");
    let payload = this._payload;
    if (b64) {
      payload = encoder.encode(encode2(payload));
    }
    let protectedHeader;
    if (this._protectedHeader) {
      protectedHeader = encoder.encode(encode2(JSON.stringify(this._protectedHeader)));
    } else {
      protectedHeader = encoder.encode("");
    }
    const data = concat(protectedHeader, encoder.encode("."), payload);
    const signature = await sign_default(alg, key, data);
    const jws = {
      signature: encode2(signature),
      payload: ""
    };
    if (b64) {
      jws.payload = decoder.decode(payload);
    }
    if (this._unprotectedHeader) {
      jws.header = this._unprotectedHeader;
    }
    if (this._protectedHeader) {
      jws.protected = decoder.decode(protectedHeader);
    }
    return jws;
  }
}

// node_modules/jose/dist/browser/jws/compact/sign.js
class CompactSign {
  constructor(payload) {
    this._flattened = new FlattenedSign(payload);
  }
  setProtectedHeader(protectedHeader) {
    this._flattened.setProtectedHeader(protectedHeader);
    return this;
  }
  async sign(key, options) {
    const jws = await this._flattened.sign(key, options);
    if (jws.payload === undefined) {
      throw new TypeError("use the flattened module for creating JWS with b64: false");
    }
    return `${jws.protected}.${jws.payload}.${jws.signature}`;
  }
}

// node_modules/jose/dist/browser/jwt/produce.js
class ProduceJWT {
  constructor(payload) {
    if (!isObject(payload)) {
      throw new TypeError("JWT Claims Set MUST be an object");
    }
    this._payload = payload;
  }
  setIssuer(issuer) {
    this._payload = { ...this._payload, iss: issuer };
    return this;
  }
  setSubject(subject) {
    this._payload = { ...this._payload, sub: subject };
    return this;
  }
  setAudience(audience) {
    this._payload = { ...this._payload, aud: audience };
    return this;
  }
  setJti(jwtId) {
    this._payload = { ...this._payload, jti: jwtId };
    return this;
  }
  setNotBefore(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, nbf: input };
    } else {
      this._payload = { ...this._payload, nbf: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setExpirationTime(input) {
    if (typeof input === "number") {
      this._payload = { ...this._payload, exp: input };
    } else {
      this._payload = { ...this._payload, exp: epoch_default(new Date) + secs_default(input) };
    }
    return this;
  }
  setIssuedAt(input) {
    if (typeof input === "undefined") {
      this._payload = { ...this._payload, iat: epoch_default(new Date) };
    } else {
      this._payload = { ...this._payload, iat: input };
    }
    return this;
  }
}

// node_modules/jose/dist/browser/jwt/sign.js
class SignJWT extends ProduceJWT {
  setProtectedHeader(protectedHeader) {
    this._protectedHeader = protectedHeader;
    return this;
  }
  async sign(key, options) {
    var _a;
    const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
    sig.setProtectedHeader(this._protectedHeader);
    if (Array.isArray((_a = this._protectedHeader) === null || _a === undefined ? undefined : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
      throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
    }
    return sig.sign(key, options);
  }
}
// node_modules/@elysiajs/jwt/dist/index.js
var jwt = ({ name = "jwt", secret, alg = "HS256", crit, schema: schema6, nbf, exp, ...payload }) => {
  if (!secret)
    throw new Error("Secret can't be empty");
  const key = typeof secret === "string" ? new TextEncoder().encode(secret) : secret;
  const validator = schema6 ? p(Type.Intersect([
    schema6,
    Type.Object({
      iss: Type.Optional(Type.String()),
      sub: Type.Optional(Type.String()),
      aud: Type.Optional(Type.Union([Type.String(), Type.Array(Type.String())])),
      jti: Type.Optional(Type.String()),
      nbf: Type.Optional(Type.Union([Type.String(), Type.Number()])),
      exp: Type.Optional(Type.Union([Type.String(), Type.Number()])),
      iat: Type.Optional(Type.String())
    })
  ]), {}) : undefined;
  return new r({
    name: "@elysiajs/jwt",
    seed: {
      name,
      secret,
      alg,
      crit,
      schema: schema6,
      nbf,
      exp,
      ...payload
    }
  }).decorate(name, {
    sign: (morePayload) => {
      let jwt2 = new SignJWT({
        ...payload,
        ...morePayload,
        nbf: undefined,
        exp: undefined
      }).setProtectedHeader({
        alg,
        crit
      });
      if (nbf)
        jwt2 = jwt2.setNotBefore(nbf);
      if (exp)
        jwt2 = jwt2.setExpirationTime(exp);
      return jwt2.sign(key);
    },
    verify: async (jwt2) => {
      if (!jwt2)
        return false;
      try {
        const data = (await jwtVerify(jwt2, key)).payload;
        if (validator && !validator.Check(data))
          throw new q("JWT", validator, data);
        return data;
      } catch (_) {
        return false;
      }
    }
  });
};
var dist_default = jwt;

// node_modules/cookie/index.js
var parse5 = function(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode3;
  var index = 0;
  while (index < str.length) {
    var eqIdx = str.indexOf("=", index);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str.indexOf(";", index);
    if (endIdx === -1) {
      endIdx = str.length;
    } else if (endIdx < eqIdx) {
      index = str.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str.slice(index, eqIdx).trim();
    if (obj[key] === undefined) {
      var val = str.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index = endIdx + 1;
  }
  return obj;
};
var serialize = function(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode3;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name)) {
    throw new TypeError("argument name is invalid");
  }
  var value15 = enc(val);
  if (value15 && !fieldContentRegExp.test(value15)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name + "=" + value15;
  if (opt.maxAge != null) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str += "; Priority=Low";
        break;
      case "medium":
        str += "; Priority=Medium";
        break;
      case "high":
        str += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
var decode3 = function(str) {
  return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
};
var encode3 = function(val) {
  return encodeURIComponent(val);
};
var isDate = function(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
};
var tryDecode = function(str, decode4) {
  try {
    return decode4(str);
  } catch (e2) {
    return str;
  }
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var $parse = parse5;
var $serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

// node_modules/cookie-signature/index.js
var crypto3 = import.meta.require("crypto");
var $sign = function(val, secret) {
  if (typeof val != "string")
    throw new TypeError("Cookie value must be provided as a string.");
  if (secret == null)
    throw new TypeError("Secret key must be provided.");
  return val + "." + crypto3.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
};
var $unsign = function(input, secret) {
  if (typeof input != "string")
    throw new TypeError("Signed cookie string must be provided.");
  if (secret == null)
    throw new TypeError("Secret key must be provided.");
  var tentativeValue = input.slice(0, input.lastIndexOf(".")), expectedInput = $sign(tentativeValue, secret), expectedBuffer = Buffer.from(expectedInput), inputBuffer = Buffer.from(input);
  return expectedBuffer.length === inputBuffer.length && crypto3.timingSafeEqual(expectedBuffer, inputBuffer) ? tentativeValue : false;
};

// node_modules/@elysiajs/cookie/dist/index.js
var cookie = (options = {}) => {
  const { signed, secret: secretKey, ...defaultOptions } = options;
  const secret = !secretKey ? undefined : typeof secretKey === "string" ? secretKey : secretKey[0];
  const isStringKey = typeof secret === "string";
  return new r({
    name: "@elysiajs/cookie",
    seed: options
  }).decorate("unsignCookie", (value15) => {
    if (!secret)
      throw new Error("No secret is provided to cookie plugin");
    let unsigned = isStringKey ? $unsign(value15, secret) : false;
    if (isStringKey === false)
      for (let i = 0;i < secret.length; i++) {
        const temp = $unsign(value15, secret[i]);
        if (temp) {
          unsigned = temp;
          break;
        }
      }
    return {
      valid: unsigned !== false,
      value: unsigned || undefined
    };
  }).derive((context) => {
    let _cookie;
    const getCookie = () => {
      if (_cookie)
        return _cookie;
      try {
        const headerCookie = context.request.headers.get("cookie");
        _cookie = headerCookie ? $parse(headerCookie) : {};
      } catch (error22) {
        _cookie = {};
      }
      return _cookie;
    };
    return {
      get cookie() {
        return getCookie();
      },
      setCookie(name, value15, { signed: signed2 = false, ...options2 } = {}) {
        if (signed2) {
          if (!secret)
            throw new Error("No secret is provided to cookie plugin");
          value15 = $sign(value15, secret);
        }
        if (!Array.isArray(context.set.headers["Set-Cookie"]))
          context.set.headers["Set-Cookie"] = [];
        context.set.headers["Set-Cookie"].push($serialize(name, value15, {
          path: "/",
          ...defaultOptions,
          ...options2
        }));
        if (!_cookie)
          getCookie();
        _cookie[name] = value15;
      },
      removeCookie(name) {
        if (!getCookie()[name])
          return;
        context.set.headers["Set-Cookie"] = $serialize(name, "", {
          expires: new Date("Thu, Jan 01 1970 00:00:00 UTC")
        });
        delete _cookie[name];
      }
    };
  });
};
var dist_default2 = cookie;

// src/http/errors/unauthorized-error.ts
class UnauthorizadErro extends Error {
  constructor() {
    super("Unauthorizad.");
  }
}

// src/http/auth.ts
var jwtPayload = C.Object({
  sub: C.String(),
  restaurantId: C.Optional(C.String())
});
var auth = new r().error({
  UNAUTHORIZAD: UnauthorizadErro
}).onError(({ error: error22, code, set: set2 }) => {
  switch (code) {
    case "UNAUTHORIZAD": {
      set2.status = 401;
      return { code, message: error22.message };
    }
  }
}).use(dist_default({
  secret: env.JWT_SECRET_KEY,
  schema: jwtPayload
})).use(dist_default2()).derive(({ setCookie, jwt: jwt3, removeCookie, cookie: cookie3 }) => {
  return {
    signUser: async ({ sub, restaurantId }) => {
      const jwtToken = await jwt3.sign({
        sub,
        restaurantId
      });
      setCookie("auth", jwtToken, {
        httpOnly: true,
        maxAge: 604800,
        path: "/"
      });
    },
    signOut: () => {
      removeCookie("auth");
    },
    getCurrentUser: async () => {
      const authCookie = cookie3.auth;
      const payload = await jwt3.verify(authCookie);
      if (!payload) {
        throw new UnauthorizadErro;
      }
      return {
        userId: payload.sub,
        restaurantId: payload.restaurantId
      };
    }
  };
});

// src/use-cases/authenticate-from-code.ts
var import_dayjs = __toESM(require_dayjs_min(), 1);

// src/use-cases/errors/user-is-not-manage.ts
class UserIsNotManage extends Error {
  constructor() {
    super("User is not manager.");
  }
}

// src/use-cases/authenticate-from-code.ts
class AuthenticateFromCodeUseCase {
  authCodeRepository;
  restaurantRepository;
  constructor(authCodeRepository, restaurantRepository) {
    this.authCodeRepository = authCodeRepository;
    this.restaurantRepository = restaurantRepository;
  }
  async execute({
    code
  }) {
    const authCode = await this.authCodeRepository.findByCode(code);
    if (!authCode) {
      throw new Error("Auth link not Found.");
    }
    const minutesSinceAuthLinkWasCreated = import_dayjs.default().diff(authCode.createdAt, "minutes");
    await this.authCodeRepository.deleteById(authCode.id);
    if (minutesSinceAuthLinkWasCreated > 15) {
      throw new Error("Auth link expied, please generate a new one.");
    }
    const restaurant = await this.restaurantRepository.findByManagerId(authCode.userId);
    if (!restaurant) {
      throw new UserIsNotManage;
    }
    return {
      userId: authCode.userId,
      restaurantId: restaurant.id
    };
  }
}

// src/use-cases/factories/make-authenticate-from-code.ts
function makeAuthenticateFromCode() {
  const authCodesRepository = new DrizzleAuthCodesRepository;
  const restaurantRepository = new DrizzleRestaurantRepository;
  const useCase = new AuthenticateFromCodeUseCase(authCodesRepository, restaurantRepository);
  return useCase;
}

// src/http/routes/authenticate-from-link.ts
var authenticateFromLink = new r().use(auth).get("/auth-links/authenticate", async ({ query: query5, set: set2, signUser }) => {
  const { code, redirect } = query5;
  const authenticateFromCodeUseCase = makeAuthenticateFromCode();
  const { userId, restaurantId } = await authenticateFromCodeUseCase.execute({
    code
  });
  await signUser({
    sub: userId,
    restaurantId
  });
  set2.redirect = redirect;
}, {
  query: C.Object({
    code: C.String(),
    redirect: C.String()
  })
});

// src/http/routes/sign-out.ts
var signOut = new r().use(auth).get("/sign-out", async ({ signOut: internalSignOut }) => {
  internalSignOut();
});

// src/use-cases/get-user.ts
class GetUserUseCase {
  usersRepository;
  constructor(usersRepository) {
    this.usersRepository = usersRepository;
  }
  async execute({
    id
  }) {
    const user = await this.usersRepository.findById(id);
    if (!user) {
      throw new ResourceNotFoundError;
    }
    return { user };
  }
}

// src/use-cases/factories/make-get-user.ts
function makeGetUser() {
  const userRepository = new DrizzleUsersRepository;
  const useCase = new GetUserUseCase(userRepository);
  return useCase;
}

// src/http/routes/get-profile.ts
var getProfile = new r().use(auth).get("/me", async ({ getCurrentUser }) => {
  const { userId: id } = await getCurrentUser();
  const fetchProfile = makeGetUser();
  const { user } = await fetchProfile.execute({ id });
  return { user };
});

// src/use-cases/get-restaurant.ts
class GetRestaurant {
  restaurantRepository;
  constructor(restaurantRepository) {
    this.restaurantRepository = restaurantRepository;
  }
  async execute({
    restaurantId
  }) {
    const restaurant = await this.restaurantRepository.findById(restaurantId);
    if (!restaurant) {
      throw new ResourceNotFoundError;
    }
    return {
      restaurant
    };
  }
}

// src/use-cases/factories/make-get-restaurant.ts
function makeGetRestaurant() {
  const restaurantRepository = new DrizzleRestaurantRepository;
  const useCase = new GetRestaurant(restaurantRepository);
  return useCase;
}

// src/http/routes/get-managed-restaurant.ts
var getManagedRestaurant = new r().use(auth).get("/managed-restaurant", async ({ getCurrentUser }) => {
  const { restaurantId } = await getCurrentUser();
  if (!restaurantId) {
    throw new UserIsNotManage;
  }
  const getRestaurant = makeGetRestaurant();
  const managedRestaurant = await getRestaurant.execute({ restaurantId });
  return {
    managedRestaurant
  };
});

// node_modules/@elysiajs/swagger/dist/swagger/index.js
var SwaggerUIRender = (info, version3, theme, stringifiedSwaggerOptions, autoDarkMode) => `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>${info.title}</title>
    <meta
        name="description"
        content="${info.description}"
    />
    <meta
        name="og:description"
        content="${info.description}"
    />
    ${autoDarkMode && typeof theme === "string" ? `
    <style>
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #222;
                color: #faf9a;
            }
            .swagger-ui {
                filter: invert(92%) hue-rotate(180deg);
            }

            .swagger-ui .microlight {
                filter: invert(100%) hue-rotate(180deg);
            }
        }
    </style>` : ""}
    ${typeof theme === "string" ? `<link rel="stylesheet" href="${theme}" />` : `<link rel="stylesheet" media="(prefers-color-scheme: light)" href="${theme.light}" />
<link rel="stylesheet" media="(prefers-color-scheme: dark)" href="${theme.dark}" />`}
</head>
<body>
    <div id="swagger-ui"></div>
    <script src="https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui-bundle.js" crossorigin></script>
    <script>
        window.onload = () => {
            window.ui = SwaggerUIBundle(${stringifiedSwaggerOptions});
        };
    </script>
</body>
</html>`;

// node_modules/@elysiajs/swagger/dist/scalar/theme.js
var theme_default = `
/* basic theme */
.light-mode {
  --theme-color-1: #2a2f45;
  --theme-color-2: #757575;
  --theme-color-3: #8e8e8e;
  --theme-color-accent: #f06292;

  --theme-background-1: #fff;
  --theme-background-2: #f6f6f6;
  --theme-background-3: #e7e7e7;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(0, 0, 0, 0.1);
}
.dark-mode {
  --theme-color-1: rgba(255, 255, 255, 0.9);
  --theme-color-2: rgba(156, 163, 175, 1);
  --theme-color-3: rgba(255, 255, 255, 0.44);
  --theme-color-accent: #f06292;

  --theme-background-1: #111728;
  --theme-background-2: #1e293b;
  --theme-background-3: #334155;
  --theme-background-accent: #f062921f;

  --theme-border-color: rgba(255, 255, 255, 0.1);
}
/* Document Sidebar */
.light-mode .sidebar,
.dark-mode .sidebar {
  --sidebar-background-1: var(--theme-background-1);
  --sidebar-item-hover-color: currentColor;
  --sidebar-item-hover-background: var(--theme-background-2);
  --sidebar-item-active-background: var(--theme-background-accent);
  --sidebar-border-color: transparent;
  --sidebar-color-1: var(--theme-color-1);
  --sidebar-color-2: var(--theme-color-2);
  --sidebar-color-active: var(--theme-color-accent);
  --sidebar-search-background: transparent;
  --sidebar-search-border-color: var(--theme-border-color);
  --sidebar-search--color: var(--theme-color-3);
}
/* Document header only shows on mobile*/
.dark-mode .t-doc__header,
.light-mode .t-doc__header {
  --header-background-1: rgba(255, 255, 255, 0.85);
  --header-border-color: transparent;
  --header-color-1: var(--theme-color-1);
  --header-color-2: var(--theme-color-2);
  --header-background-toggle: var(--theme-color-3);
  --header-call-to-action-color: var(--theme-color-accent);
}

.dark-mode .t-doc__header {
  --header-background-1: rgba(17, 23, 40, 0.75);
}

/* advanced */
.light-mode {
  --theme-button-1: rgb(49 53 56);
  --theme-button-1-color: #fff;
  --theme-button-1-hover: rgb(28 31 33);

  --theme-color-green: #069061;
  --theme-color-red: #ef0006;
  --theme-color-yellow: #edbe20;
  --theme-color-blue: #0082d0;
  --theme-color-orange: #fb892c;
  --theme-color-purple: #5203d1;

  --theme-scrollbar-color: rgba(0, 0, 0, 0.18);
  --theme-scrollbar-color-active: rgba(0, 0, 0, 0.36);
}
.dark-mode {
  --theme-button-1: #f6f6f6;
  --theme-button-1-color: #000;
  --theme-button-1-hover: #e7e7e7;

  --theme-color-green: #a3ffa9;
  --theme-color-red: #ffa3a3;
  --theme-color-yellow: #fffca3;
  --theme-color-blue: #a5d6ff;
  --theme-color-orange: #e2ae83;
  --theme-color-purple: #d2a8ff;

  --theme-scrollbar-color: rgba(255, 255, 255, 0.24);
  --theme-scrollbar-color-active: rgba(255, 255, 255, 0.48);
}
/* Elysia Specific */
.scalar-api-client__send-request-button,
.show-api-client-button {
  background: #3c82f6 !important;
}
.show-api-client-button:before {
  display: none;
}

.sidebar-search:hover {
  transition: all 0.15s ease-in-out;
  --sidebar-search-border-color: var(--theme-color-accent) !important;
  color: var(--sidebar-color-1) !important;
}
.scalar-api-client__container .sidebar {
  --sidebar-border-color: var(--theme-border-color);
}
@media (min-width: 1150px) {
  .section-container:has( ~ .footer):before,
  .tag-section-container:before {
    content: "";
    position: absolute;
    top: -5px;
    left: 0;
    width: 100%;
    height: 10px;
    background: linear-gradient(90deg, var(--theme-background-1) 3%,transparent 10%);
  }
}
.section-flare {
  position: absolute;
  width: 100vw;
  height: 300px;
  --stripes: repeating-linear-gradient(
    100deg,
    #fff 0%,
    #fff 7%,
    transparent 10%,
    transparent 12%,
    #fff 16%
  );
  --stripesDark: repeating-linear-gradient(
    100deg,
    #000 0%,
    #000 7%,
    transparent 10%,
    transparent 12%,
    #000 16%
  );
  --rainbow: repeating-linear-gradient(
    100deg,
    #60a5fa 10%,
    #e879f9 16%,
    #5eead4 22%,
    #60a5fa 30%
  );
  background-image: var(--stripes), var(--rainbow);
  background-size: 300%, 200%;
  background-position: 50% 50%, 50% 50%;
  filter: invert(100%);
  -webkit-mask-image: radial-gradient(
    ellipse at 100% 0%,
    black 40%,
    transparent 70%
  );
  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);
  pointer-events: none;
  opacity: 0.15;
}
.dark-mode .section-flare {
  background-image: var(--stripesDark), var(--rainbow);
  filter: opacity(50%) saturate(200%);
  opacity: 0.25;
}
.section-flare:after {
  content: "";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  background-image: var(--stripes), var(--rainbow);
  background-size: 200%, 100%;
  background-attachment: fixed;
  mix-blend-mode: difference;
}
.dark-mode .section-flare:after {
  background-image: var(--stripesDark), var(--rainbow);
}
@keyframes headerbackground {
  from {
    background: transparent;
    backdrop-filter: none;
  }
  to {
    background: var(--header-background-1);
    backdrop-filter: blur(12px);
  }
}
.light-mode .t-doc__header,
.dark-mode .t-doc__header {
  animation: headerbackground forwards;
  animation-timeline: scroll();
  animation-range: 0px 200px;
  --header-border-color: transparent;
}
`;

// node_modules/@elysiajs/swagger/dist/scalar/index.js
var ScalarRender = (version3, config, cdn) => `<!doctype html>
<html>
  <head>
    <title>API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
      }
    </style>
    <style>
      ${config.customCss ?? theme_default}
    </style>
  </head>
  <body>
    <script
      id="api-reference"
      data-url="${config.spec?.url}"
      data-configuration='${JSON.stringify(config)}'
    >
    </script>
    <script src="${cdn ? cdn : `https://cdn.jsdelivr.net/npm/@scalar/api-reference@${version3}/dist/browser/standalone.min.js`}"></script>
  </body>
</html>`;

// node_modules/@elysiajs/swagger/dist/utils.js
var import_lodash = __toESM(require_lodash5(), 1);
var toOpenAPIPath = (path) => path.split("/").map((x) => x.startsWith(":") ? `{${x.slice(1, x.length)}}` : x).join("/");
var mapProperties = (name, schema6, models) => {
  if (schema6 === undefined)
    return [];
  if (typeof schema6 === "string")
    if (schema6 in models)
      schema6 = models[schema6];
    else
      throw new Error(`Can't find model ${schema6}`);
  return Object.entries(schema6?.properties ?? []).map(([key, value15]) => {
    const { type: valueType = undefined, ...rest4 } = value15;
    return {
      ...rest4,
      schema: { type: valueType },
      in: name,
      name: key,
      required: schema6.required?.includes(key) ?? false
    };
  });
};
var mapTypesResponse = (types5, schema6) => {
  if (typeof schema6 === "object" && ["void", "undefined", "null"].includes(schema6.type))
    return;
  const responses = {};
  for (const type75 of types5)
    responses[type75] = {
      schema: typeof schema6 === "string" ? {
        $ref: `#/components/schemas/${schema6}`
      } : { ...schema6 }
    };
  return responses;
};
var capitalize2 = (word) => word.charAt(0).toUpperCase() + word.slice(1);
var generateOperationId = (method, paths) => {
  let operationId = method.toLowerCase();
  if (paths === "/")
    return operationId + "Index";
  for (const path of paths.split("/")) {
    if (path.charCodeAt(0) === 123) {
      operationId += "By" + capitalize2(path.slice(1, -1));
    } else {
      operationId += capitalize2(path);
    }
  }
  return operationId;
};
var registerSchemaPath = ({ schema: schema6, path, method, hook, models }) => {
  if (hook)
    hook = import_lodash.default(hook);
  const contentType = hook?.type ?? [
    "application/json",
    "multipart/form-data",
    "text/plain"
  ];
  path = toOpenAPIPath(path);
  const contentTypes = typeof contentType === "string" ? [contentType] : contentType ?? ["application/json"];
  const bodySchema = hook?.body;
  const paramsSchema = hook?.params;
  const headerSchema = hook?.headers;
  const querySchema = hook?.query;
  let responseSchema = hook?.response;
  if (typeof responseSchema === "object") {
    if (Kind in responseSchema) {
      const { type: type75, properties, required: required5, additionalProperties, patternProperties, ...rest4 } = responseSchema;
      responseSchema = {
        "200": {
          ...rest4,
          description: rest4.description,
          content: mapTypesResponse(contentTypes, type75 === "object" || type75 === "array" ? {
            type: type75,
            properties,
            patternProperties,
            items: responseSchema.items,
            required: required5
          } : responseSchema)
        }
      };
    } else {
      Object.entries(responseSchema).forEach(([key, value15]) => {
        if (typeof value15 === "string") {
          if (!models[value15])
            return;
          const { type: type75, properties, required: required5, additionalProperties: _12, patternProperties: _2, ...rest4 } = models[value15];
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, value15)
          };
        } else {
          const { type: type75, properties, required: required5, additionalProperties, patternProperties, ...rest4 } = value15;
          responseSchema[key] = {
            ...rest4,
            description: rest4.description,
            content: mapTypesResponse(contentTypes, type75 === "object" || type75 === "array" ? {
              type: type75,
              properties,
              patternProperties,
              items: value15.items,
              required: required5
            } : value15)
          };
        }
      });
    }
  } else if (typeof responseSchema === "string") {
    if (!(responseSchema in models))
      return;
    const { type: type75, properties, required: required5, additionalProperties: _12, patternProperties: _2, ...rest4 } = models[responseSchema];
    responseSchema = {
      "200": {
        ...rest4,
        content: mapTypesResponse(contentTypes, responseSchema)
      }
    };
  }
  const parameters4 = [
    ...mapProperties("header", headerSchema, models),
    ...mapProperties("path", paramsSchema, models),
    ...mapProperties("query", querySchema, models)
  ];
  schema6[path] = {
    ...schema6[path] ? schema6[path] : {},
    [method.toLowerCase()]: {
      ...headerSchema || paramsSchema || querySchema || bodySchema ? { parameters: parameters4 } : {},
      ...responseSchema ? {
        responses: responseSchema
      } : {},
      operationId: hook?.detail?.operationId ?? generateOperationId(method, path),
      ...hook?.detail,
      ...bodySchema ? {
        requestBody: {
          content: mapTypesResponse(contentTypes, typeof bodySchema === "string" ? {
            $ref: `#/components/schemas/${bodySchema}`
          } : bodySchema)
        }
      } : null
    }
  };
};
var filterPaths = (paths, { excludeStaticFile = true, exclude: exclude6 = [] }) => {
  const newPaths = {};
  for (const [key, value15] of Object.entries(paths))
    if (!exclude6.some((x) => {
      if (typeof x === "string")
        return key === x;
      return x.test(key);
    }) && !key.includes("/swagger") && !key.includes("*") && (excludeStaticFile ? !key.includes(".") : true)) {
      Object.keys(value15).forEach((method) => {
        const schema6 = value15[method];
        if (key.includes("{")) {
          if (!schema6.parameters)
            schema6.parameters = [];
          schema6.parameters = [
            ...key.split("/").filter((x) => x.startsWith("{") && !schema6.parameters.find((params) => params.in === "path" && params.name === x.slice(1, x.length - 1))).map((x) => ({
              schema: { type: "string" },
              in: "path",
              name: x.slice(1, x.length - 1),
              required: true
            })),
            ...schema6.parameters
          ];
        }
        if (!schema6.responses)
          schema6.responses = {
            200: {}
          };
      });
      newPaths[key] = value15;
    }
  return newPaths;
};

// node_modules/@elysiajs/swagger/dist/index.js
var swagger2 = ({ provider = "scalar", scalarVersion = "latest", scalarCDN = "", scalarConfig = {}, documentation = {}, version: version3 = "5.9.0", excludeStaticFile = true, path = "/swagger", exclude: exclude6 = [], swaggerOptions = {}, theme: theme2 = `https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui.css`, autoDarkMode = true, excludeMethods = ["OPTIONS"] } = {
  provider: "scalar",
  scalarVersion: "latest",
  scalarCDN: "",
  scalarConfig: {},
  documentation: {},
  version: "5.9.0",
  excludeStaticFile: true,
  path: "/swagger",
  exclude: [],
  swaggerOptions: {},
  autoDarkMode: true,
  excludeMethods: ["OPTIONS"]
}) => (app) => {
  const schema6 = {};
  let totalRoutes = 0;
  if (!version3)
    version3 = `https://unpkg.com/swagger-ui-dist@${version3}/swagger-ui.css`;
  const info = {
    title: "Elysia Documentation",
    description: "Development documentation",
    version: "0.0.0",
    ...documentation.info
  };
  const relativePath = path.startsWith("/") ? path.slice(1) : path;
  app.get(path, () => {
    const combinedSwaggerOptions = {
      url: `${relativePath}/json`,
      dom_id: "#swagger-ui",
      ...swaggerOptions
    };
    const stringifiedSwaggerOptions = JSON.stringify(combinedSwaggerOptions, (key, value15) => {
      if (typeof value15 == "function")
        return;
      return value15;
    });
    const scalarConfiguration = {
      spec: {
        ...scalarConfig.spec,
        url: `${relativePath}/json`
      },
      ...scalarConfig
    };
    return new Response(provider === "swagger-ui" ? SwaggerUIRender(info, version3, theme2, stringifiedSwaggerOptions, autoDarkMode) : ScalarRender(scalarVersion, scalarConfiguration, scalarCDN), {
      headers: {
        "content-type": "text/html; charset=utf8"
      }
    });
  }).get(`${path}/json`, () => {
    const routes = app.routes;
    if (routes.length !== totalRoutes) {
      totalRoutes = routes.length;
      routes.forEach((route) => {
        if (excludeMethods.includes(route.method))
          return;
        registerSchemaPath({
          schema: schema6,
          hook: route.hooks,
          method: route.method,
          path: route.path,
          models: app.definitions?.type,
          contentType: route.hooks.type
        });
      });
    }
    return {
      openapi: "3.0.3",
      ...{
        ...documentation,
        info: {
          title: "Elysia Documentation",
          description: "Development documentation",
          version: "0.0.0",
          ...documentation.info
        }
      },
      paths: filterPaths(schema6, {
        excludeStaticFile,
        exclude: Array.isArray(exclude6) ? exclude6 : [exclude6]
      }),
      components: {
        ...documentation.components,
        schemas: {
          ...app.definitions?.type,
          ...documentation.components?.schemas
        }
      }
    };
  });
  return app;
};
var dist_default3 = swagger2;

// src/http/server.ts
var app = new r().use(dist_default3()).use(registerRestaurants).use(sendAuthLink).use(authenticateFromLink).use(signOut).use(getProfile).use(getManagedRestaurant).onError(({ error: error22, code, set: set2 }) => {
  switch (code) {
    case "VALIDATION": {
      set2.status = error22.status;
      return error22.toResponse();
    }
    default: {
      set2.status = 500;
      console.error(error22);
      return new Response(null, { status: 500 });
    }
  }
});
app.listen(3000, () => {
  console.log(`\uD83E\uDD8A Elysia is running at http://${app.server?.hostname}:${app.server?.port}`);
});
